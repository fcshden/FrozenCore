From 24bdf9e11725823d0281090e16132baf08143c55 Mon Sep 17 00:00:00 2001
From: Frozen <3097491@qqcom>
Date: Thu, 27 May 2021 11:20:14 +0900
Subject: =?UTF-8?q?ghost=E4=BB=A3=E7=A0=81=E5=A2=9E=E5=8A=A0?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit


diff --git a/src/common/Database/Implementation/CharacterDatabase.cpp b/src/common/Database/Implementation/CharacterDatabase.cpp
index 4fb95ab..a580b19 100644
--- a/src/common/Database/Implementation/CharacterDatabase.cpp
+++ b/src/common/Database/Implementation/CharacterDatabase.cpp
@@ -76,7 +76,7 @@ void CharacterDatabaseConnection::DoPrepareStatements()
     PrepareStatement(CHAR_INS_CHARACTER_SEASONALQUESTSTATUS, "INSERT INTO character_queststatus_seasonal (guid, quest, event) VALUES (?, ?, ?)", CONNECTION_ASYNC);
     PrepareStatement(CHAR_SEL_CHARACTER_REPUTATION, "SELECT faction, standing, flags FROM character_reputation WHERE guid = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_SEL_CHARACTER_INVENTORY, "SELECT creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text, bag, slot, "
-                     "item, itemEntry FROM character_inventory ci JOIN item_instance ii ON ci.item = ii.guid WHERE ci.guid = ? ORDER BY bag, slot", CONNECTION_ASYNC);
+                     "item, itemEntry, spells, stats, damages, name, leveldata, mapdata, delay, tempindex, unbind FROM character_inventory ci JOIN item_instance ii ON ci.item = ii.guid WHERE ci.guid = ? ORDER BY bag, slot", CONNECTION_ASYNC);
     PrepareStatement(CHAR_SEL_CHARACTER_ACTIONS, "SELECT a.button, a.action, a.type FROM character_action as a, characters as c WHERE a.guid = c.guid AND a.spec = c.activeTalentGroup AND a.guid = ? ORDER BY button", CONNECTION_ASYNC);
     PrepareStatement(CHAR_SEL_CHARACTER_MAILCOUNT, "SELECT COUNT(id) FROM mail WHERE receiver = ? AND deliver_time <= ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_SEL_CHARACTER_MAILCOUNT_UNREAD, "SELECT COUNT(id) FROM mail WHERE receiver = ? AND (checked & 1) = 0 AND deliver_time <= ?", CONNECTION_ASYNC);
@@ -104,8 +104,8 @@ void CharacterDatabaseConnection::DoPrepareStatements()
     // End LoginQueryHolder content
 
     PrepareStatement(CHAR_SEL_CHARACTER_ACTIONS_SPEC, "SELECT button, action, type FROM character_action WHERE guid = ? AND spec = ? ORDER BY button", CONNECTION_ASYNC);
-    PrepareStatement(CHAR_SEL_MAILITEMS, "SELECT creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text, item_guid, itemEntry, owner_guid FROM mail_items mi JOIN item_instance ii ON mi.item_guid = ii.guid WHERE mail_id = ?", CONNECTION_SYNCH);
-    PrepareStatement(CHAR_SEL_AUCTION_ITEMS, "SELECT creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text, itemguid, itemEntry FROM auctionhouse ah JOIN item_instance ii ON ah.itemguid = ii.guid", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_SEL_MAILITEMS, "SELECT creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text, item_guid, itemEntry, owner_guid, spells, stats, damages, name, leveldata, mapdata, delay, tempindex, unbind FROM mail_items mi JOIN item_instance ii ON mi.item_guid = ii.guid WHERE mail_id = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_SEL_AUCTION_ITEMS, "SELECT creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text, itemguid, itemEntry, spells, stats, damages, name, leveldata, mapdata, delay, tempindex, unbind FROM auctionhouse ah JOIN item_instance ii ON ah.itemguid = ii.guid", CONNECTION_SYNCH);
     PrepareStatement(CHAR_SEL_AUCTIONS, "SELECT id, auctioneerguid, itemguid, itemEntry, count, itemowner, buyoutprice, time, buyguid, lastbid, startbid, deposit FROM auctionhouse ah INNER JOIN item_instance ii ON ii.guid = ah.itemguid", CONNECTION_SYNCH);
     PrepareStatement(CHAR_INS_AUCTION, "INSERT INTO auctionhouse (id, auctioneerguid, itemguid, itemowner, buyoutprice, time, buyguid, lastbid, startbid, deposit) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
     PrepareStatement(CHAR_DEL_AUCTION, "DELETE FROM auctionhouse WHERE id = ?", CONNECTION_ASYNC);
@@ -126,8 +126,8 @@ void CharacterDatabaseConnection::DoPrepareStatements()
     PrepareStatement(CHAR_DEL_ITEM_BOP_TRADE, "DELETE FROM item_soulbound_trade_data WHERE itemGuid = ? LIMIT 1", CONNECTION_ASYNC);
     PrepareStatement(CHAR_INS_ITEM_BOP_TRADE, "INSERT INTO item_soulbound_trade_data VALUES (?, ?)", CONNECTION_ASYNC);
     PrepareStatement(CHAR_REP_INVENTORY_ITEM, "REPLACE INTO character_inventory (guid, bag, slot, item) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC);
-    PrepareStatement(CHAR_REP_ITEM_INSTANCE, "REPLACE INTO item_instance (itemEntry, owner_guid, creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text, guid) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
-    PrepareStatement(CHAR_UPD_ITEM_INSTANCE, "UPDATE item_instance SET itemEntry = ?, owner_guid = ?, creatorGuid = ?, giftCreatorGuid = ?, count = ?, duration = ?, charges = ?, flags = ?, enchantments = ?, randomPropertyId = ?, durability = ?, playedTime = ?, text = ? WHERE guid = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_REP_ITEM_INSTANCE, "REPLACE INTO item_instance (itemEntry, owner_guid, creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text, spells, stats, damages, name, leveldata, mapdata, delay, tempindex, unbind, guid) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_ITEM_INSTANCE, "UPDATE item_instance SET itemEntry = ?, owner_guid = ?, creatorGuid = ?, giftCreatorGuid = ?, count = ?, duration = ?, charges = ?, flags = ?, enchantments = ?, randomPropertyId = ?, durability = ?, playedTime = ?, text = ?, spells = ?, stats = ?, damages = ?, name = ?, leveldata = ?, mapdata = ?, delay = ?, tempindex = ?, unbind = ? WHERE guid = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_UPD_ITEM_INSTANCE_ON_LOAD, "UPDATE item_instance SET duration = ?, flags = ?, durability = ? WHERE guid = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_DEL_ITEM_INSTANCE, "DELETE FROM item_instance WHERE guid = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_DEL_ITEM_INSTANCE_BY_OWNER, "DELETE FROM item_instance WHERE owner_guid = ?", CONNECTION_ASYNC);
@@ -556,15 +556,6 @@ void CharacterDatabaseConnection::DoPrepareStatements()
     PrepareStatement(CHAR_DEL_CHAR_PET_BY_SLOT, "DELETE FROM character_pet WHERE owner = ? AND (slot = ? OR slot > ?)", CONNECTION_ASYNC);
     PrepareStatement(CHAR_REP_CHAR_PET, "REPLACE INTO character_pet (id, entry, owner, modelid, CreatedBySpell, PetType, level, exp, Reactstate, name, renamed, slot, curhealth, curmana, curhappiness, savetime, abdata) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
 
-
-    // NPCBOT
-    PrepareStatement(CHAR_SEL_NPCBOTS, "SELECT entry, race, class, roles, equipMhEx, equipOhEx, equipRhEx, "
-        "equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet, equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck FROM character_npcbot WHERE owner = ? AND active = 1", CONNECTION_SYNCH);
-    PrepareStatement(CHAR_DEL_NPCBOTS, "DELETE FROM character_npcbot WHERE owner = ?", CONNECTION_ASYNC);
-    PrepareStatement(CHAR_INS_NPCBOT, "REPLACE INTO character_npcbot (owner, entry, race, class, roles, equipMhEx, equipOhEx, equipRhEx, "
-        "equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet, equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck, active) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
-    // NPCBOT
-
     // PvPstats
     PrepareStatement(CHAR_SEL_PVPSTATS_MAXID, "SELECT MAX(id) FROM pvpstats_battlegrounds", CONNECTION_SYNCH);
     PrepareStatement(CHAR_INS_PVPSTATS_BATTLEGROUND, "INSERT INTO pvpstats_battlegrounds (id, winner_faction, bracket_id, type, date) VALUES (?, ?, ?, ?, NOW())", CONNECTION_ASYNC);
@@ -583,4 +574,38 @@ void CharacterDatabaseConnection::DoPrepareStatements()
     // Recovery Item
     PrepareStatement(CHAR_INS_RECOVERY_ITEM, "INSERT INTO recovery_item (Guid, ItemEntry, Count) VALUES (?, ?, ?)", CONNECTION_SYNCH);
     PrepareStatement(CHAR_DEL_RECOVERY_ITEM, "DELETE FROM recovery_item WHERE Guid = ? AND ItemEntry = ? AND Count = ? ORDER BY Id DESC LIMIT 1", CONNECTION_ASYNC);
+
+    PrepareStatement(CHAR_INS_AC, "INSERT INTO chatacters_anticheat (name,account,type,time) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_INS_CMD, "INSERT INTO chatacters_cmd_monitor (time, sender, sender_acc, receiver, receiver_acc, cmd, map, x, y, z) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+
+    PrepareStatement(CHAR_INS_ARMORY_TOKEN, "INSERT INTO armory_token (guid,account,amount) VALUES (?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_ARMORY_TOKEN, "UPDATE armory_token SET guid = ?, amount = ? WHERE account = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_DEL_ARMORY_TOKEN, "DELETE FROM armory_token WHERE account = ?", CONNECTION_ASYNC);
+
+    PrepareStatement(CHAR_INS_ARMORY_SIGIL, "INSERT INTO armory_sigil (guid,account,amount) VALUES (?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_ARMORY_SIGIL, "UPDATE armory_sigil SET guid = ?, amount = ? WHERE account = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_DEL_ARMORY_SIGIL, "DELETE FROM armory_sigil WHERE account = ?", CONNECTION_ASYNC);
+
+    PrepareStatement(CHAR_INS_ARMORY_PVP, "INSERT INTO armory_pvp (guid,account,amount) VALUES (?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_ARMORY_PVP, "UPDATE armory_pvp SET amount = ? WHERE guid = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_DEL_ARMORY_PVP, "DELETE FROM armory_pvp WHERE account = ?", CONNECTION_ASYNC);
+
+    PrepareStatement(CHAR_UPD_NAME_PREFIX, "UPDATE characters SET namePrefix = ? WHERE guid = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NAME_SUFFIX, "UPDATE characters SET nameSuffix = ? WHERE guid = ?", CONNECTION_ASYNC);
+
+    PrepareStatement(CHAR_INS_TOKEN, "INSERT INTO chatacters_token_monitor (time, name, guid, account, action,amount) VALUES (?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+
+    PrepareStatement(CHAR_REP_ARENA_DUEL, "REPLACE INTO characters_arena_duel (guid, selected, winnum) VALUES (?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_DEL_ARENA_DUEL, "TRUNCATE TABLE characters_arena_duel", CONNECTION_ASYNC);
+
+    PrepareStatement(CHAR_UPD_RANKVALUE, "REPLACE INTO character_rank (guid, level, value) VALUES (?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_SIGN_IN, "UPDATE characters SET signin_time = ?,signin_days = ? WHERE guid = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_CUSTOM_SKILL, "REPLACE INTO character_custom_skill (guid, skill) VALUES (?, ?)", CONNECTION_ASYNC);
+
+    PrepareStatement(CHAR_UPD_ITEM_DAY, "REPLACE INTO character_day_item (guid, entry, count) VALUES (?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_DEL_ITEM_DAY, "TRUNCATE character_day_item", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_REP_TALISMAN, "REPLACE INTO character_talisman (guid, ID_1, ID_2, ID_3, ID_4, ID_5, ID_6, ID_7) VALUES (?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+
+    PrepareStatement(CHAR_SEL_LOOTCHECK, "SELECT lootcheckcount,lootcheckbancount FROM characters WHERE guid = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_UPD_LOOTCHECK, "UPDATE characters SET lootcheckcount = ?,lootcheckbancount = ? WHERE guid = ?", CONNECTION_ASYNC);
 }
diff --git a/src/common/Database/Implementation/CharacterDatabase.h b/src/common/Database/Implementation/CharacterDatabase.h
index fb701b7..6a8825e 100644
--- a/src/common/Database/Implementation/CharacterDatabase.h
+++ b/src/common/Database/Implementation/CharacterDatabase.h
@@ -485,12 +485,6 @@ enum CharacterDatabaseStatements
     CHAR_DEL_CHAR_PET_BY_SLOT,
     CHAR_REP_CHAR_PET,
 
-        // NPCBOT
-        CHAR_SEL_NPCBOTS,
-        CHAR_DEL_NPCBOTS,
-        CHAR_INS_NPCBOT,
-        // NPCBOT
-
     CHAR_SEL_ITEMCONTAINER_ITEMS,
     CHAR_DEL_ITEMCONTAINER_SINGLE_ITEM,
     CHAR_INS_ITEMCONTAINER_SINGLE_ITEM,
@@ -511,6 +505,38 @@ enum CharacterDatabaseStatements
     CHAR_INS_RECOVERY_ITEM,
     CHAR_DEL_RECOVERY_ITEM,
 
+        CHAR_INS_AC,
+        CHAR_INS_CMD,
+
+        CHAR_UPD_ARMORY_TOKEN,
+        CHAR_DEL_ARMORY_TOKEN,
+        CHAR_INS_ARMORY_TOKEN,
+
+        CHAR_UPD_ARMORY_SIGIL,
+        CHAR_DEL_ARMORY_SIGIL,
+        CHAR_INS_ARMORY_SIGIL,
+
+        CHAR_UPD_ARMORY_PVP,
+        CHAR_DEL_ARMORY_PVP,
+        CHAR_INS_ARMORY_PVP,
+
+        CHAR_UPD_NAME_PREFIX,
+        CHAR_UPD_NAME_SUFFIX,
+
+        CHAR_INS_TOKEN,
+
+        CHAR_REP_ARENA_DUEL,
+        CHAR_DEL_ARENA_DUEL,
+
+        CHAR_UPD_RANKVALUE,
+        CHAR_UPD_SIGN_IN,
+        CHAR_UPD_CUSTOM_SKILL,
+        CHAR_UPD_ITEM_DAY,
+        CHAR_DEL_ITEM_DAY,
+        CHAR_REP_TALISMAN,
+        CHAR_SEL_LOOTCHECK,
+        CHAR_UPD_LOOTCHECK,
+
     MAX_CHARACTERDATABASE_STATEMENTS
 };
 
diff --git a/src/common/Database/Implementation/LoginDatabase.cpp b/src/common/Database/Implementation/LoginDatabase.cpp
index f69670b..302c073 100644
--- a/src/common/Database/Implementation/LoginDatabase.cpp
+++ b/src/common/Database/Implementation/LoginDatabase.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -45,7 +45,7 @@ void LoginDatabaseConnection::DoPrepareStatements()
     PrepareStatement(LOGIN_DEL_REALM_CHARACTERS, "DELETE FROM realmcharacters WHERE acctid = ?", CONNECTION_ASYNC);
     PrepareStatement(LOGIN_INS_REALM_CHARACTERS, "INSERT INTO realmcharacters (numchars, acctid, realmid) VALUES (?, ?, ?)", CONNECTION_ASYNC);
     PrepareStatement(LOGIN_SEL_SUM_REALM_CHARACTERS, "SELECT SUM(numchars) FROM realmcharacters WHERE acctid = ?", CONNECTION_ASYNC);
-    PrepareStatement(LOGIN_INS_ACCOUNT, "INSERT INTO account(username, sha_pass_hash, expansion, joindate) VALUES(?, ?, ?, NOW())", CONNECTION_ASYNC);
+    PrepareStatement(LOGIN_INS_ACCOUNT, "INSERT INTO account(username, sha_pass_hash, expansion, joindate, pcIDCode) VALUES(?, ?, ?, NOW(), ?)", CONNECTION_ASYNC);
     PrepareStatement(LOGIN_INS_REALM_CHARACTERS_INIT, "INSERT INTO realmcharacters (realmid, acctid, numchars) SELECT realmlist.id, account.id, 0 FROM realmlist, account LEFT JOIN realmcharacters ON acctid=account.id WHERE acctid IS NULL", CONNECTION_ASYNC);
     PrepareStatement(LOGIN_UPD_EXPANSION, "UPDATE account SET expansion = ? WHERE id = ?", CONNECTION_ASYNC);
     PrepareStatement(LOGIN_UPD_ACCOUNT_LOCK, "UPDATE account SET locked = ? WHERE id = ?", CONNECTION_ASYNC);
@@ -94,4 +94,11 @@ void LoginDatabaseConnection::DoPrepareStatements()
     PrepareStatement(LOGIN_INS_CHAR_IP_LOGGING, "INSERT INTO logs_ip_actions (account_id,character_guid,type,ip,systemnote,unixtime,time) VALUES (?, ?, ?, ?, ?, unix_timestamp(NOW()), NOW())", CONNECTION_ASYNC);
     // 0: string, 1: string, 2: string                      // Complete name: "Login_Insert_Failed_Account_Login_due_password_IP_Logging"
     PrepareStatement(LOGIN_INS_FALP_IP_LOGGING, "INSERT INTO logs_ip_actions (account_id,character_guid,type,ip,systemnote,unixtime,time) VALUES ((SELECT id FROM account WHERE username = ?), 0, 1, ?, ?, unix_timestamp(NOW()), NOW())", CONNECTION_ASYNC);
+
+    PrepareStatement(LOGIN_INS_PCCODE, "INSERT INTO pc_ban (account, pcIDCode) VALUES (?, ?)", CONNECTION_SYNCH);
+    PrepareStatement(LOGIN_DEL_PCCODE, "DELETE FROM pc_ban WHERE pcIDCode = ?", CONNECTION_SYNCH);
+    PrepareStatement(LOGIN_UPD_PWD, "UPDATE account SET pwd = ? WHERE username = ?", CONNECTION_ASYNC);
+    PrepareStatement(LOGIN_INS_ACCOUNT_SPELL, "INSERT INTO account_spells (account, spell) VALUES (?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(LOGIN_UPD_RANKVALUE, "REPLACE INTO account_rank (account, level, value) VALUES (?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(LOGIN_SEL_ACCOUNT_ID_BY_NAME_BUG, "SELECT * FROM `account_rank`", CONNECTION_SYNCH);
 }
diff --git a/src/common/Database/Implementation/LoginDatabase.h b/src/common/Database/Implementation/LoginDatabase.h
index 82e9a46..dd6d018 100644
--- a/src/common/Database/Implementation/LoginDatabase.h
+++ b/src/common/Database/Implementation/LoginDatabase.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -112,6 +112,13 @@ enum LoginDatabaseStatements
     LOGIN_SEL_ACCOUNT_MUTE_INFO,
     LOGIN_DEL_ACCOUNT_MUTEDEL,
 
+    LOGIN_INS_PCCODE,
+    LOGIN_DEL_PCCODE,
+    LOGIN_UPD_PWD,
+    LOGIN_INS_ACCOUNT_SPELL,
+    LOGIN_UPD_RANKVALUE,
+    LOGIN_SEL_ACCOUNT_ID_BY_NAME_BUG,
+
     MAX_LOGINDATABASE_STATEMENTS
 };
 
diff --git a/src/common/Database/Implementation/WorldDatabase.cpp b/src/common/Database/Implementation/WorldDatabase.cpp
index d59552b..25b2060 100644
--- a/src/common/Database/Implementation/WorldDatabase.cpp
+++ b/src/common/Database/Implementation/WorldDatabase.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -23,9 +23,9 @@ void WorldDatabaseConnection::DoPrepareStatements()
     PrepareStatement(WORLD_DEL_GRAVEYARD_ZONE, "DELETE FROM graveyard_zone WHERE ID = ? AND GhostZone = ? AND Faction = ?", CONNECTION_ASYNC);
     PrepareStatement(WORLD_INS_GAME_TELE, "INSERT INTO game_tele (id, position_x, position_y, position_z, orientation, map, name) VALUES (?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
     PrepareStatement(WORLD_DEL_GAME_TELE, "DELETE FROM game_tele WHERE name = ?", CONNECTION_ASYNC);
-    PrepareStatement(WORLD_INS_NPC_VENDOR, "INSERT INTO npc_vendor (entry, item, maxcount, incrtime, extendedcost, needid) VALUES(?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(WORLD_INS_NPC_VENDOR, "INSERT INTO npc_vendor (entry, item, maxcount, incrtime, extendedcost) VALUES(?, ?, ?, ?, ?)", CONNECTION_ASYNC);
     PrepareStatement(WORLD_DEL_NPC_VENDOR, "DELETE FROM npc_vendor WHERE entry = ? AND item = ?", CONNECTION_ASYNC);
-    PrepareStatement(WORLD_SEL_NPC_VENDOR_REF, "SELECT item, maxcount, incrtime, ExtendedCost, Needid FROM npc_vendor WHERE entry = ? ORDER BY slot ASC", CONNECTION_SYNCH);
+    PrepareStatement(WORLD_SEL_NPC_VENDOR_REF, "SELECT item, maxcount, incrtime, ExtendedCost FROM npc_vendor WHERE entry = ? ORDER BY slot ASC", CONNECTION_SYNCH);
     PrepareStatement(WORLD_UPD_CREATURE_MOVEMENT_TYPE, "UPDATE creature SET MovementType = ? WHERE guid = ?", CONNECTION_ASYNC);
     PrepareStatement(WORLD_UPD_CREATURE_FACTION, "UPDATE creature_template SET faction = ? WHERE entry = ?", CONNECTION_ASYNC);
     PrepareStatement(WORLD_UPD_CREATURE_NPCFLAG, "UPDATE creature_template SET npcflag = ? WHERE entry = ?", CONNECTION_ASYNC);
@@ -83,6 +83,55 @@ void WorldDatabaseConnection::DoPrepareStatements()
     // 0: uint8
     PrepareStatement(WORLD_SEL_REQ_XP, "SELECT Experience FROM player_xp_for_level WHERE Level = ?", CONNECTION_SYNCH);
 
-    // NPCBOT
-    PrepareStatement(WORLD_SEL_NPCBOT_PET_LEVELSTATS, "SELECT hp, mana, armor, str, agi, sta, inte, spi FROM pet_levelstats WHERE creature_entry = ? AND level = ?", CONNECTION_SYNCH);
+    PrepareStatement(WORLD_INS_SPELL_DBC, "INSERT INTO _dbc_spell (Id, Category, Dispel, Mechanic, Attributes, AttributesEx, AttributesEx2, AttributesEx3, AttributesEx4, AttributesEx5, AttributesEx6, AttributesEx7, "
+        "Stances, unk_320_2, StancesNot, unk_320_3, Targets, TargetCreatureType, RequiresSpellFocus, FacingCasterFlags, CasterAuraState, "
+        "TargetAuraState, CasterAuraStateNot, TargetAuraStateNot, casterAuraSpell, targetAuraSpell, excludeCasterAuraSpell, excludeTargetAuraSpell, "
+        "CastingTimeIndex, RecoveryTime, CategoryRecoveryTime, InterruptFlags, AuraInterruptFlags, ChannelInterruptFlags, ProcFlags, "
+        "ProcChance, ProcCharges, MaxLevel, BaseLevel, SpellLevel, DurationIndex, powerType, manaCost, manaCostPerlevel, manaPerSecond, manaPerSecondPerLevel, "
+        "rangeIndex, speed, modalNextSpell, StackAmount, Totem1, Totem2, Reagent1, Reagent2, Reagent3, Reagent4, Reagent5, Reagent6, Reagent7, Reagent8, "
+        "ReagentCount1, ReagentCount2, ReagentCount3, ReagentCount4, ReagentCount5, ReagentCount6, ReagentCount7, ReagentCount8, "
+        "EquippedItemClass, EquippedItemSubClassMask, EquippedItemInventoryTypeMask, Effect1, Effect2, Effect3, EffectDieSides1, EffectDieSides2, EffectDieSides3, "
+        "EffectRealPointsPerLevel1, EffectRealPointsPerLevel2, EffectRealPointsPerLevel3, EffectBasePoints1, EffectBasePoints2, EffectBasePoints3, "
+        "EffectMechanic1, EffectMechanic2, EffectMechanic3, EffectImplicitTargetA1, EffectImplicitTargetA2, EffectImplicitTargetA3, "
+        "EffectImplicitTargetB1, EffectImplicitTargetB2, EffectImplicitTargetB3, EffectRadiusIndex1, EffectRadiusIndex2, EffectRadiusIndex3, "
+        "EffectApplyAuraName1, EffectApplyAuraName2, EffectApplyAuraName3, EffectAmplitude1, EffectAmplitude2, EffectAmplitude3, "
+        "EffectValueMultiplier1, EffectValueMultiplier2, EffectValueMultiplier3, EffectChainTarget1, EffectChainTarget2, EffectChainTarget3, "
+        "EffectItemType1, EffectItemType2, EffectItemType3, EffectMiscValueA1, EffectMiscValueA2, EffectMiscValueA3, "
+        "EffectMiscValueB1, EffectMiscValueB2, EffectMiscValueB3, EffectTriggerSpell1, EffectTriggerSpell2, EffectTriggerSpell3, "
+        "EffectPointsPerComboPoint1, EffectPointsPerComboPoint2, EffectPointsPerComboPoint3, "
+        "EffectSpellClassMaskA1, EffectSpellClassMaskA2, EffectSpellClassMaskA3, EffectSpellClassMaskB1, EffectSpellClassMaskB2, EffectSpellClassMaskB3, EffectSpellClassMaskC1, EffectSpellClassMaskC2, EffectSpellClassMaskC3, "
+        "SpellVisual1, SpellVisual2, SpellIconID, activeIconID, spellPriority, SpellName, SpellNameFlag, Rank, RankFlags, Description, DescriptionFlags, ToolTip, ToolTipFlags, "
+        "ManaCostPercentage, StartRecoveryCategory, StartRecoveryTime, MaxTargetLevel, SpellFamilyName, SpellFamilyFlags1, SpellFamilyFlags2, SpellFamilyFlags3, "
+        "MaxAffectedTargets, DmgClass, PreventionType, StanceBarOrder, EffectDamageMultiplier1, EffectDamageMultiplier2, EffectDamageMultiplier3, "
+        "MinFactionId, MinReputation, RequiredAuraVision, TotemCategory1, TotemCategory2, AreaGroupId, SchoolMask, runeCostID, spellMissileID, PowerDisplayId, "
+        "EffectBonusMultiplier1, EffectBonusMultiplier2, EffectBonusMultiplier3, spellDescriptionVariableID, SpellDifficultyId) "
+        "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?, ?,?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?, ?, ?, ?,?)", CONNECTION_ASYNC);
+
+
+    PrepareStatement(WORLD_SEL_SPELL_DBC, "SELECT Id, Category, Dispel, Mechanic, Attributes, AttributesEx, AttributesEx2, AttributesEx3, AttributesEx4, AttributesEx5, AttributesEx6, AttributesEx7, "
+        "Stances, unk_320_2, StancesNot, unk_320_3, Targets, TargetCreatureType, RequiresSpellFocus, FacingCasterFlags, CasterAuraState, "
+        "TargetAuraState, CasterAuraStateNot, TargetAuraStateNot, casterAuraSpell, targetAuraSpell, excludeCasterAuraSpell, excludeTargetAuraSpell, "
+        "CastingTimeIndex, RecoveryTime, CategoryRecoveryTime, InterruptFlags, AuraInterruptFlags, ChannelInterruptFlags, ProcFlags, "
+        "ProcChance, ProcCharges, MaxLevel, BaseLevel, SpellLevel, DurationIndex, powerType, manaCost, manaCostPerlevel, manaPerSecond, manaPerSecondPerLevel, "
+        "rangeIndex, speed, modalNextSpell, StackAmount, Totem1, Totem2, Reagent1, Reagent2, Reagent3, Reagent4, Reagent5, Reagent6, Reagent7, Reagent8, "
+        "ReagentCount1, ReagentCount2, ReagentCount3, ReagentCount4, ReagentCount5, ReagentCount6, ReagentCount7, ReagentCount8, "
+        "EquippedItemClass, EquippedItemSubClassMask, EquippedItemInventoryTypeMask, Effect1, Effect2, Effect3, EffectDieSides1, EffectDieSides2, EffectDieSides3, "
+        "EffectRealPointsPerLevel1, EffectRealPointsPerLevel2, EffectRealPointsPerLevel3, EffectBasePoints1, EffectBasePoints2, EffectBasePoints3, "
+        "EffectMechanic1, EffectMechanic2, EffectMechanic3, EffectImplicitTargetA1, EffectImplicitTargetA2, EffectImplicitTargetA3, "
+        "EffectImplicitTargetB1, EffectImplicitTargetB2, EffectImplicitTargetB3, EffectRadiusIndex1, EffectRadiusIndex2, EffectRadiusIndex3, "
+        "EffectApplyAuraName1, EffectApplyAuraName2, EffectApplyAuraName3, EffectAmplitude1, EffectAmplitude2, EffectAmplitude3, "
+        "EffectValueMultiplier1, EffectValueMultiplier2, EffectValueMultiplier3, EffectChainTarget1, EffectChainTarget2, EffectChainTarget3, "
+        "EffectItemType1, EffectItemType2, EffectItemType3, EffectMiscValueA1, EffectMiscValueA2, EffectMiscValueA3, "
+        "EffectMiscValueB1, EffectMiscValueB2, EffectMiscValueB3, EffectTriggerSpell1, EffectTriggerSpell2, EffectTriggerSpell3, "
+        "EffectPointsPerComboPoint1, EffectPointsPerComboPoint2, EffectPointsPerComboPoint3, "
+        "EffectSpellClassMaskA1, EffectSpellClassMaskA2, EffectSpellClassMaskA3, EffectSpellClassMaskB1, EffectSpellClassMaskB2, EffectSpellClassMaskB3, EffectSpellClassMaskC1, EffectSpellClassMaskC2, EffectSpellClassMaskC3, "
+        "SpellVisual1, SpellVisual2, SpellIconID, activeIconID, spellPriority, SpellName, SpellNameFlag, Rank, RankFlags, Description, DescriptionFlags, ToolTip, ToolTipFlags, "
+        "ManaCostPercentage, StartRecoveryCategory, StartRecoveryTime, MaxTargetLevel, SpellFamilyName, SpellFamilyFlags1, SpellFamilyFlags2, SpellFamilyFlags3, "
+        "MaxAffectedTargets, DmgClass, PreventionType, StanceBarOrder, EffectDamageMultiplier1, EffectDamageMultiplier2, EffectDamageMultiplier3, "
+        "MinFactionId, MinReputation, RequiredAuraVision, TotemCategory1, TotemCategory2, AreaGroupId, SchoolMask, runeCostID, spellMissileID, PowerDisplayId, "
+        "EffectBonusMultiplier1, EffectBonusMultiplier2, EffectBonusMultiplier3, spellDescriptionVariableID, SpellDifficultyId FROM _dbc_spell  ORDER BY Id ASC"
+        , CONNECTION_SYNCH);
+
+    PrepareStatement(WORLD_INS_SPELL_ICON_DBC, "INSERT INTO _dbc_spellicon (ID, Icon) VALUES (?, ?)", CONNECTION_ASYNC);
+
 }
diff --git a/src/common/Database/Implementation/WorldDatabase.h b/src/common/Database/Implementation/WorldDatabase.h
index 737bf74..c2ab03f 100644
--- a/src/common/Database/Implementation/WorldDatabase.h
+++ b/src/common/Database/Implementation/WorldDatabase.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -102,11 +102,9 @@ enum WorldDatabaseStatements
     WORLD_UPD_CREATURE_ZONE_AREA_DATA,
     WORLD_UPD_GAMEOBJECT_ZONE_AREA_DATA,
     WORLD_SEL_REQ_XP,
-
-    // NPCBOT
-    WORLD_SEL_NPCBOT_PET_LEVELSTATS,
-    // NPCBOT
-
+    WORLD_INS_SPELL_ICON_DBC,
+    WORLD_INS_SPELL_DBC,
+    WORLD_SEL_SPELL_DBC,
     MAX_WORLDDATABASE_STATEMENTS
 };
 
diff --git a/src/common/Utilities/Util.h b/src/common/Utilities/Util.h
index 1c8417b..7874280 100644
--- a/src/common/Utilities/Util.h
+++ b/src/common/Utilities/Util.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -726,6 +726,11 @@ public:
         _eventMap.insert(EventStore::value_type(_time + time, _lastEvent));
     }
 
+    void PopEvent()
+    {
+        if (!Empty())
+            _eventMap.erase(_eventMap.begin());
+    }
     /**
     * @name ExecuteEvent
     * @brief Returns the next event to execute and removes it from map.
@@ -757,6 +762,22 @@ public:
         return 0;
     }
 
+    uint32 GetEvent()
+    {
+        while (!Empty())
+        {
+            EventStore::iterator itr = _eventMap.begin();
+
+            if (itr->first > _time)
+                return 0;
+            else if (_phase && (itr->second & 0xFF000000) && !(itr->second & (_phase << 24)))
+                _eventMap.erase(itr);
+            else
+                return (itr->second & 0x0000FFFF);
+        }
+
+        return 0;
+    }
     /**
     * @name DelayEvents
     * @brief Delays all events in the map. If delay is greater than or equal internal timer, delay will be 0.
diff --git a/src/server/game/AI/NpcBots/BotSys/BotSystem.cpp b/src/server/game/AI/NpcBots/BotSys/BotSystem.cpp
deleted file mode 100644
index e647412..0000000
--- a/src/server/game/AI/NpcBots/BotSys/BotSystem.cpp
+++ /dev/null
@@ -1,91 +0,0 @@
-#include "AccountMgr.h"
-#include "AchievementMgr.h"
-#include "ArenaTeam.h"
-#include "ArenaTeamMgr.h"
-#include "Chat.h"
-#include "Common.h"
-#include "DatabaseEnv.h"
-#include "DisableMgr.h"
-#include "GameEventMgr.h"
-#include "GossipDef.h"
-#include "GroupMgr.h"
-#include "GuildMgr.h"
-#include "InstanceSaveMgr.h"
-#include "Language.h"
-#include "LFGMgr.h"
-#include "Log.h"
-#include "MapManager.h"
-#include "ObjectMgr.h"
-#include "Pet.h"
-#include "PoolMgr.h"
-#include "ReputationMgr.h"
-#include "SpellAuras.h"
-#include "Spell.h"
-#include "SpellMgr.h"
-#include "SpellScript.h"
-#include "Transport.h"
-#include "UpdateMask.h"
-#include "Util.h"
-#include "Vehicle.h"
-#include "WaypointManager.h"
-#include "World.h"
-#include "BotSystem.h"
-#include "Player.h"
-#pragma execution_character_set("utf-8")
-
-NPCBotTemplate::NPCBotTemplate()
-{
-
-}
-
-NPCBotTemplate::~NPCBotTemplate()
-{
-
-}
-
-void NPCBotTemplate::LoadData()
-{
-    m_sunBot.clear();
-    uint32 count = 0;
-    QueryResult result = WorldDatabase.Query("SELECT entry, trainer_class, trainer_race, ScriptName FROM creature_template WHERE entry > 80000 and entry < 80248");
-    if (result)
-    {
-        do
-        {
-            Field *fields = result->Fetch();
-
-            BotTemplate itr;
-            itr.entry = fields[0].GetUInt32();
-            itr.trainer_class = fields[1].GetUInt8();
-            itr.trainer_race = fields[2].GetUInt8();
-            itr.scriptname = fields[3].GetString();
-            ++count;
-            m_sunBot[itr.entry] = itr;
-        } while (result->NextRow());
-    }
-    sLog->outString(">> ¶ÁÈ¡¹¦ÄÜÊý¾Ý±í[_NPCBOT_],¹²%uÌõÊý¾Ý¶ÁÈ¡¼ÓÔØ...", count);
-}
-
-NpcBotsDataTemplate  NPCBotTemplate::GetNPCBotTemplate(uint32 bclass, std::string scriptname, uint32 brace1, uint32 brace2, uint32 brace3, uint32 brace4, uint32 brace5)
-{
-	NpcBotsDataTemplate npcBotsData;
-	for (NPCBotTemplateMap::const_iterator itr = m_sunBot.begin(); itr != m_sunBot.end(); ++itr)
-	{
-        BotTemplate bb = itr->second;
-		if (bb.trainer_class == bclass && bb.scriptname == scriptname && (bb.trainer_race == brace1 || bb.trainer_race == brace2 || bb.trainer_race == brace3 ||	bb.trainer_race == brace4 || bb.trainer_race == brace5))
-			npcBotsData.push_back(std::pair<uint32, uint8>(bb.entry, bb.trainer_race));
-	}
-	return npcBotsData;
-}
-
-uint32 NPCBotTemplate::GetNPCBotTemplateCount(uint32 bclass, std::string scriptname, uint32 brace1, uint32 brace2, uint32 brace3, uint32 brace4, uint32 brace5)
-{
-	uint32 count = 0;
-	for (NPCBotTemplateMap::const_iterator itr = m_sunBot.begin(); itr != m_sunBot.end(); ++itr)
-	{
-        BotTemplate bb = itr->second;
-		if (bb.trainer_class == bclass && bb.scriptname == scriptname && (bb.trainer_race == brace1 || bb.trainer_race == brace2 || bb.trainer_race == brace3 || bb.trainer_race == brace4 || bb.trainer_race == brace5))
-			count = count + 1;
-	}
-	return count;
-}
diff --git a/src/server/game/AI/NpcBots/BotSys/BotSystem.h b/src/server/game/AI/NpcBots/BotSys/BotSystem.h
deleted file mode 100644
index 5733b59..0000000
--- a/src/server/game/AI/NpcBots/BotSys/BotSystem.h
+++ /dev/null
@@ -1,58 +0,0 @@
-#ifndef _SUNMGR_H
-#define _SUNMGR_H
-
-#include "Log.h"
-#include "Object.h"
-#include "Bag.h"
-#include "Creature.h"
-#include "DynamicObject.h"
-#include "GameObject.h"
-#include "TemporarySummon.h"
-#include "Corpse.h"
-#include "QuestDef.h"
-#include "NPCHandler.h"
-#include "DatabaseEnv.h"
-#include "Mail.h"
-#include "Map.h"
-#include "ObjectAccessor.h"
-#include "ObjectDefines.h"
-#include <ace/Singleton.h>
-#include "VehicleDefines.h"
-#include <string>
-#include <map>
-#include <limits>
-#include "ConditionMgr.h"
-#include <functional>
-
-struct BotTemplate
-{
-	uint32 entry;
-	uint32 trainer_race;
-	uint32 trainer_class;
-	std::string scriptname;
-};
-
-typedef std::unordered_map<uint32, BotTemplate>NPCBotTemplateMap;
-typedef std::list< std::pair<uint32, uint8> > NpcBotsDataTemplate;
-
-class NPCBotTemplate
-{
-	friend class PlayerDumpReader;
-	friend class ACE_Singleton<NPCBotTemplate, ACE_Null_Mutex>;
-private:
-    NPCBotTemplate();
-	~NPCBotTemplate();
-public:
-
-	void LoadData();
-	NpcBotsDataTemplate  GetNPCBotTemplate(uint32 bclass, std::string scriptname, uint32 brace1, uint32 brace2, uint32 brace3, uint32 brace4, uint32 brace5);
-	uint32 GetNPCBotTemplateCount(uint32 bclass, std::string scriptname, uint32 brace1, uint32 brace2, uint32 brace3, uint32 brace4, uint32 brace5);
-
-private:
-
-    NPCBotTemplateMap		m_sunBot;
-	NpcBotsDataTemplate npcBotsData;
-};
-
-#define sBotTemplate		ACE_Singleton<NPCBotTemplate,ACE_Null_Mutex>::instance()
-#endif
diff --git a/src/server/game/AI/NpcBots/CBots/botCreature.cpp b/src/server/game/AI/NpcBots/CBots/botCreature.cpp
deleted file mode 100644
index 2daed09..0000000
--- a/src/server/game/AI/NpcBots/CBots/botCreature.cpp
+++ /dev/null
@@ -1,179 +0,0 @@
-#include "Creature.h"
-#include "Player.h"
-#include "../game/AI/NpcBots/bot_ai.h"
-
-uint8 Creature::GetBotClass() const
-{
-    switch (m_bot_class)
-    {
-    case DRUID_BEAR_FORM:
-    case DRUID_CAT_FORM:
-        //case TRAVEL:
-        //case FLY:
-        return CLASS_DRUID;
-    default:
-        return m_bot_class;
-    }
-}
-
-void Creature::SetIAmABot(bool bot)
-{
-    if (!bot)
-    {
-        bot_AI->UnsummonAll();
-        IsAIEnabled = false;
-        bot_AI = NULL;
-        SetUInt64Value(UNIT_FIELD_CREATEDBY, 0);
-    }
-}
-
-void Creature::SetBotsPetDied()
-{
-    if (!m_bots_pet)
-        return;
-
-    m_bots_pet->SetCharmerGUID(0);
-    m_bots_pet->SetCreatureOwner(NULL);
-    //m_bots_pet->GetBotPetAI()->SetCreatureOwner(NULL);
-    m_bots_pet->SetIAmABot(false);
-    m_bot_owner->SetMinion((Minion*)m_bots_pet, false);
-    m_bots_pet->CleanupsBeforeDelete();
-    m_bots_pet->AddObjectToRemoveList();
-    m_bots_pet = NULL;
-}
-
-uint8 Creature::GetBotRoles() const
-{
-    return bot_AI ? bot_AI->GetBotRoles() : 0;
-}
-
-void Creature::SetBotCommandState(CommandStates st, bool force)
-{
-    if (bot_AI && IsAIEnabled)
-        bot_AI->SetBotCommandState(st, force);
-}
-CommandStates Creature::GetBotCommandState() const
-{
-    return bot_AI ? bot_AI->GetBotCommandState() : COMMAND_ABANDON;
-}
-//Bot damage mods
-void Creature::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
-{
-    if (bot_AI)
-        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo);
-}
-void Creature::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
-{
-    if (bot_AI)
-        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
-}
-void Creature::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
-{
-    if (bot_AI)
-        bot_AI->ApplyBotDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
-}
-
-void Creature::ApplyBotDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float &value) const
-{
-    if (bot_AI)
-        bot_AI->ApplyBotDamageMultiplierEffect(spellInfo, effect_index, value);
-}
-
-bool Creature::GetIAmABot() const
-{
-    return bot_AI && bot_AI->IsMinionAI();
-}
-
-bool Creature::GetIAmABotsPet() const
-{
-    return bot_AI && bot_AI->IsPetAI();
-}
-
-bot_minion_ai* Creature::GetBotMinionAI() const
-{
-    return IsAIEnabled && bot_AI && bot_AI->IsMinionAI() ? const_cast<bot_minion_ai*>(bot_AI->GetMinionAI()) : NULL;
-}
-
-bot_pet_ai* Creature::GetBotPetAI() const
-{
-    return IsAIEnabled && bot_AI && bot_AI->IsPetAI() ? const_cast<bot_pet_ai*>(bot_AI->GetPetAI()) : NULL;
-}
-
-void Creature::InitBotAI(bool asPet)
-{
-    ASSERT(!bot_AI);
-
-    if (asPet)
-        bot_AI = (bot_pet_ai*)AI();
-    else
-        bot_AI = (bot_minion_ai*)AI();
-}
-
-void Creature::SetBotShouldUpdateStats()
-{
-    if (bot_AI)
-        bot_AI->SetShouldUpdateStats();
-}
-
-void Creature::OnBotSummon(Creature* summon)
-{
-    if (bot_AI)
-        bot_AI->OnBotSummon(summon);
-}
-
-void Creature::OnBotDespawn(Creature* summon)
-{
-    if (bot_AI)
-        bot_AI->OnBotDespawn(summon);
-}
-
-void Creature::RemoveBotItemBonuses(uint8 slot)
-{
-    if (bot_AI)
-        bot_AI->RemoveItemBonuses(slot);
-}
-void Creature::ApplyBotItemBonuses(uint8 slot)
-{
-    if (bot_AI)
-        bot_AI->ApplyItemBonuses(slot);
-}
-bool Creature::CanUseOffHand() const
-{
-    return bot_AI && bot_AI->CanUseOffHand();
-}
-bool Creature::CanUseRanged() const
-{
-    return bot_AI && bot_AI->CanUseRanged();
-}
-bool Creature::CanEquip(ItemTemplate const* item, uint8 slot) const
-{
-    return bot_AI && bot_AI->CanEquip(item, slot);
-}
-bool Creature::Unequip(uint8 slot) const
-{
-    return bot_AI && bot_AI->Unequip(slot);
-}
-bool Creature::Equip(uint32 itemId, uint8 slot) const
-{
-    return bot_AI && bot_AI->Equip(itemId, slot);
-}
-bool Creature::ResetEquipment(uint8 slot) const
-{
-    return bot_AI && bot_AI->ResetEquipment(slot);
-}
-
-bool Creature::IsQuestBot() const
-{
-    return
-        m_creatureInfo->Entry >= 71000 && m_creatureInfo->Entry < 72000 &&
-        (m_creatureInfo->unit_flags2 & UNIT_FLAG2_ALLOW_ENEMY_INTERACT);
-}
-
-
-uint32 Creature::GetShieldBlockValue() const
-{
-    if (bot_AI)
-        return bot_AI->GetShieldBlockValue();
-
-    return (getLevel() / 2 + uint32(GetStat(STAT_STRENGTH) / 20));
-}
diff --git a/src/server/game/AI/NpcBots/PBots/botPlayer.cpp b/src/server/game/AI/NpcBots/PBots/botPlayer.cpp
deleted file mode 100644
index b73a178..0000000
--- a/src/server/game/AI/NpcBots/PBots/botPlayer.cpp
+++ /dev/null
@@ -1,1214 +0,0 @@
-ï»¿#include "Player.h"
-#include "AccountMgr.h"
-#include "AchievementMgr.h"
-#include "ArenaTeam.h"
-#include "ArenaTeamMgr.h"
-#include "Battlefield.h"
-#include "BattlefieldMgr.h"
-#include "BattlefieldWG.h"
-#include "Battleground.h"
-#include "BattlegroundAV.h"
-#include "BattlegroundMgr.h"
-#include "CellImpl.h"
-#include "Channel.h"
-#include "ChannelMgr.h"
-#include "CharacterDatabaseCleaner.h"
-#include "Chat.h"
-#include "Common.h"
-#include "ConditionMgr.h"
-#include "CreatureAI.h"
-#include "DatabaseEnv.h"
-#include "DisableMgr.h"
-#include "Formulas.h"
-#include "GameEventMgr.h"
-#include "GossipDef.h"
-#include "GridNotifiers.h"
-#include "GridNotifiersImpl.h"
-#include "Group.h"
-#include "GroupMgr.h"
-#include "Guild.h"
-#include "GuildMgr.h"
-#include "GitRevision.h"
-#include "revision.h"
-#include "InstanceSaveMgr.h"
-#include "InstanceScript.h"
-#include "Language.h"
-#include "LFGMgr.h"
-#include "Log.h"
-#include "LootItemStorage.h"
-#include "MapInstanced.h"
-#include "MapManager.h"
-#include "ObjectAccessor.h"
-#include "ObjectMgr.h"
-#include "Opcodes.h"
-#include "OutdoorPvP.h"
-#include "OutdoorPvPMgr.h"
-#include "Pet.h"
-#include "PetitionMgr.h"
-#include "QuestDef.h"
-#include "ReputationMgr.h"
-#include "SkillDiscovery.h"
-#include "SocialMgr.h"
-#include "Spell.h"
-#include "SpellAuraEffects.h"
-#include "SpellAuras.h"
-#include "SpellMgr.h"
-#include "Transport.h"
-#include "UpdateData.h"
-#include "UpdateFieldFlags.h"
-#include "UpdateMask.h"
-#include "Util.h"
-#include "Vehicle.h"
-#include "Weather.h"
-#include "WeatherMgr.h"
-#include "World.h"
-#include "WorldPacket.h"
-#include "WorldSession.h"
-#include "ArenaSpectator.h"
-#include "GameObjectAI.h"
-#include "PoolMgr.h"
-#include "SavingSystem.h"
-#include "TicketMgr.h"
-#include "ScriptMgr.h"
-#include "GameGraveyard.h"
-
-#include "Config.h"
-// NPCBOT
-#include "bothelper.h"
-#include "BotSystem.h"
-// NPCBOT
-
-
-void Player::UpdateNpcBot(uint32 p_time)
-{
-    if (m_botTimer > 0)
-    {
-        if (p_time >= m_botTimer)
-            m_botTimer = 0;
-        else
-            m_botTimer -= p_time;
-    }
-    else
-        RefreshBot(p_time);
-}
-
-void Player::LoadBotInfo()
-{
-    if (sConfigMgr->GetBoolDefault("Bot.EnableNpcBots", true))
-    {
-        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOTS);
-        stmt->setUInt32(0, GetGUIDLow());
-        PreparedQueryResult result = CharacterDatabase.Query(stmt);
-        if (result)
-        {
-            uint32 m_bot_entry = 0;
-            uint8 m_bot_race = 0;
-            uint8 m_bot_class = 0;
-            uint32 equips[18];
-            do
-            {
-                Field* fields = result->Fetch();
-                m_bot_entry = fields[0].GetUInt32();
-                m_bot_race = fields[1].GetUInt8();
-                m_bot_class = fields[2].GetInt8();
-                for (uint8 i = 0; i != 18; ++i)
-                    equips[i] = fields[i + 4].GetUInt32();
-
-                if (m_bot_entry && m_bot_race && m_bot_class)
-                    SetBotMustBeCreated(m_bot_entry, m_bot_race, m_bot_class, equips);
-
-            } while (result->NextRow());
-        }
-    }
-}
-
-void Player::SaveBotInfo()
-{
-    CharacterDatabase.DirectPExecute("DELETE FROM character_npcbot WHERE owner = %u", GetGUIDLow());
-
-    for (BotInfoMap::const_iterator itr = m_botInfo.begin(); itr != m_botInfo.end(); ++itr)
-    {
-        BotInfo mb = itr->second;
-        //entry is unique for each master's bot so clean it up just in case
-        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_NPCBOT);
-        uint8 i = 0;
-        stmt->setUInt32(i++, GetGUIDLow());
-        stmt->setUInt32(i++, mb.entry);
-        stmt->setUInt8(i++, mb.race);
-        stmt->setUInt8(i++, mb.bclass);
-        stmt->setUInt8(i++, uint8(mb.roles));
-
-        for (uint8 j = 0; j != 18; ++j)
-            stmt->setUInt32(i++, mb.equips[j]);
-
-        stmt->setUInt8(i++, uint8(1)); //active
-        CharacterDatabase.Execute(stmt);
-    }
-}
-
-BotInfo const* Player::GetBotInfo(uint32 entry) const
-{
-    BotInfoMap::const_iterator itr = m_botInfo.find(entry);
-    if (itr != m_botInfo.end())
-        return &itr->second;
-    return NULL;
-}
-
-uint32 Player::GetPlayerBotRoles(uint32 entry)
-{
-    BotInfoMap::const_iterator itr = m_botInfo.find(entry);
-    if (itr != m_botInfo.end())
-        return itr->second.roles;
-    return 0;
-}
-
-void Player::SetBotInfo(uint32 entry, uint32 race, uint32 pclass, uint32 roles, uint32 * equips, uint32 active)
-{
-    BotInfo info;
-    info.entry = entry;
-    info.race = race;
-    info.bclass = pclass;
-    info.roles = roles;
-    for (uint8 i = 0; i != 18; ++i)
-        info.equips[i] = equips[i];
-    info.active = active;
-    m_botInfo[info.entry] = info;
-}
-
-void Player::SetBotActive(uint32 entry, uint32 active)
-{
-    BotInfoMap::const_iterator itr = m_botInfo.find(entry);
-    if (itr != m_botInfo.end())
-    {
-        m_botInfo[entry].active = active;
-    }
-}
-
-void Player::SetBotQquips(uint32 entry, uint32 * equips)
-{
-    BotInfoMap::const_iterator itr = m_botInfo.find(entry);
-    if (itr != m_botInfo.end())
-    {
-        for (int i = 0; i != 18; ++i)
-            m_botInfo[entry].equips[i] = equips[i];
-    }
-}
-
-void Player::SetBotRoles(uint32 entry, uint32 roles)
-{
-    BotInfoMap::const_iterator itr = m_botInfo.find(entry);
-    if (itr != m_botInfo.end())
-    {
-        m_botInfo[entry].roles = roles;
-    }
-}
-
-void Player::SetBotRace(uint32 pos, uint32 race)
-{
-    NpcBotMap const* m_tmp = GetBotMap(pos);
-    if (!m_tmp)
-        return;
-    m_botmap[pos]->m_race = race;
-}
-
-void Player::UpdateBotModelid(Creature* bot)
-{
-    /*	CreatureOutfit co;
-
-        co.race = 1;
-        co.gender = bot->getGender();
-        //co.displayId = bot->GetNativeDisplayId();
-        co.skin = 0;
-        co.face = 0;
-        co.hair = 0;
-        co.haircolor = 0;
-        co.facialhair = 0;
-
-        for (uint8 i = 0; i != MAX_CREATURE_OUTFIT_DISPLAYS; ++i)
-            co.outfit[i] = 0;
-
-        if (uint32 itemId = GetBotEquip(bot, 3))
-            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
-                co.outfit[0] = proto->DisplayInfoID;
-
-        if (uint32 itemId = GetBotEquip(bot, 4))
-            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
-                co.outfit[1] = proto->DisplayInfoID;
-
-        if (uint32 itemId = GetBotEquip(bot, 12))
-            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
-                co.outfit[2] = proto->DisplayInfoID;
-
-
-        if (uint32 itemId = GetBotEquip(bot, 5))
-            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
-                co.outfit[3] = proto->DisplayInfoID;
-
-        if (uint32 itemId = GetBotEquip(bot, 6))
-            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
-                co.outfit[4] = proto->DisplayInfoID;
-
-        if (uint32 itemId = GetBotEquip(bot, 7))
-            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
-                co.outfit[5] = proto->DisplayInfoID;
-
-        if (uint32 itemId = GetBotEquip(bot, 8))
-            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
-                co.outfit[6] = proto->DisplayInfoID;
-
-        if (uint32 itemId = GetBotEquip(bot, 9))
-            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
-                co.outfit[7] = proto->DisplayInfoID;
-
-        if (uint32 itemId = GetBotEquip(bot, 10))
-            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
-                co.outfit[8] = proto->DisplayInfoID;
-
-        WorldPacket data(SMSG_MIRRORIMAGE_DATA, 68);
-        data << uint64(bot->ToUnit()->GetGUID());
-        data << uint32(bot->GetNativeDisplayId()); // displayId
-        data << uint8(co.race);             // race
-        data << uint8(co.gender);           // gender
-        data << uint8(bot->getClass());            // class
-        data << uint8(co.skin);             // skin
-        data << uint8(co.face);             // face
-        data << uint8(co.hair);             // hair
-        data << uint8(co.haircolor);        // haircolor
-        data << uint8(co.facialhair);       // facialhair
-        data << uint32(0);                          // guildId
-
-        // item displays
-        for (uint8 i = 0; i != MAX_CREATURE_OUTFIT_DISPLAYS; ++i)
-            data << uint32(co.outfit[i]);
-
-        GetSession()->SendPacket(&data);*/
-    return;
-}
-
-void Player::RefreshBot(uint32 diff)
-{
-    if (m_botTimer > 0)
-        return;
-
-    if (IsInFlight())
-        m_botTimer = 3000;
-
-    if (!HaveBot())
-        return;
-
-    //BOT REVIVE SUPPORT part 2
-    //Revive timer condition (maybe we should check whole party?)
-    bool partyInCombat = IsInCombat();
-    if (!partyInCombat)
-    {
-        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
-        {
-            if (Creature* bot = m_botmap[i]->m_creature)
-            {
-                if (bot->IsInCombat())
-                {
-                    partyInCombat = true;
-                    break;
-                }
-                else if (Creature* pet = bot->GetBotsPet())
-                {
-                    if (pet->IsInCombat())
-                    {
-                        partyInCombat = true;
-                        break;
-                    }
-                }
-            }
-        }
-    }
-
-    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
-    {
-        uint64 guid = m_botmap[i]->m_guid;
-        m_bot = m_botmap[i]->m_creature;
-
-        //BOT REVIVE SUPPORT part 2
-        //Do not allow bot to be revived if master is in battle
-        if (!partyInCombat)
-        {
-            if (m_botmap[i]->m_reviveTimer > diff)
-            {
-                if (!IsInCombat())
-                    m_botmap[i]->m_reviveTimer -= diff;
-            }
-            else if (m_botmap[i]->m_reviveTimer > 0)
-                m_botmap[i]->m_reviveTimer = 0;
-        }
-
-        if (!m_bot || !m_bot->IsInWorld())
-            continue;
-
-        //!!!BOT UPDATE HELPER!!!
-        m_bot->SetCanUpdate(true);
-        m_bot->IsAIEnabled = true;
-
-        //BOT REVIVE SUPPORT part 3
-        //Revive bot if possible
-        if (m_botmap[i]->m_reviveTimer == 0)
-        {
-            if (m_bot->isDead() && IsAlive() && !IsInCombat() && !InArena() && !IsInFlight() &&
-                !HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FEIGN_DEATH) &&
-                !HasInvisibilityAura() && !HasStealthAura())
-            {
-                CreateBot(0, 0, 0, true); //revive
-                continue;
-            }
-
-            //delay next attempt
-            m_botmap[i]->m_reviveTimer = 500;
-        }
-
-        //BOT MUST DIE SUPPORT
-        if (IsInFlight() || !GetGroup() || !GetGroup()->IsMember(m_bot->GetGUID()))//even if bot is dead
-        {
-            RemoveBot(guid, !IsInFlight(), false);
-            continue;
-        }
-
-        //TELEPORT SUPPORT
-        if (!IsInFlight() && IsAlive() && (m_bot->IsAlive() || m_bot->GetMapId() != GetMapId() || RestrictBots()))
-        {
-            if (m_bot->GetMapId() != GetMapId() || RestrictBots())
-            {
-                RemoveBot(guid);
-                continue;
-            }
-            else if (m_bot->GetBotCommandState() != COMMAND_STAY)
-            {
-                if (GetDistance(m_bot) > SIZE_OF_GRIDS)
-                {
-                    ////This thing is not confirmed to be stable
-                    //m_bot->SetOwnerGUID(0);
-                    //m_bot->RemoveFromWorld();
-                    //m_bot->Relocate(this);
-                    ////Creature::AddToWorld(): Skip AIM_Initialize();
-                    //if (m_bot->GetZoneScript())
-                    //    m_bot->GetZoneScript()->OnCreatureCreate(m_bot);
-                    //sObjectAccessor->AddObject(m_bot);
-                    //m_bot->ToUnit()->AddToWorld();
-                    //m_bot->SetOwnerGUID(GetGUID());
-
-                    //This thing is unsafe
-                    m_bot->SetBotsPetDied();
-                    m_bot->OnBotDespawn(NULL);
-                    m_bot->InterruptNonMeleeSpells(true);
-                    m_bot->AttackStop();
-                    m_bot->RemoveAllAttackers();
-                    m_bot->DeleteThreatList();
-                    m_bot->ClearInCombat();
-
-                    m_bot->RemoveNotOwnSingleTargetAuras();
-                    //m_bot->RemoveAllGameObjects();
-                    //m_bot->RemoveAllDynObjects();
-                    //m_bot->ExitVehicle();
-                    //m_bot->UnsummonAllTotems();
-                    //m_bot->RemoveAllControlled();
-                    m_bot->RemoveAreaAurasDueToLeaveWorld();
-                    m_bot->DestroyForNearbyPlayers();
-                    m_bot->ClearUpdateMask(true);
-                    //sObjectAccessor->RemoveObject(m_bot);
-                    m_bot->Relocate(this);
-                    //sObjectAccessor->AddObject(m_bot);
-                    m_bot->ToUnit()->AddToWorld();
-                }
-            }
-        }
-
-        //Update bots manually and prevent from normal updates
-        //This will update bot's AI
-        m_bot->Update(diff);
-        m_bot->SetCanUpdate(false);
-
-        //Update bot's pet manually and prevent from normal updates
-        //This will update pet's AI
-        if (Creature* pet = m_bot->GetBotsPet())
-        {
-            pet->SetCanUpdate(true);
-            pet->IsAIEnabled = true;
-            pet->Update(diff);
-            pet->SetCanUpdate(false);
-        }
-
-        m_bot = NULL;
-    }//end for botmap
-
-    //BOT CREATION/RECREATION SUPPORT
-
-    if (m_botCreateTimer > diff)
-        m_botCreateTimer -= diff;
-    else
-    {
-        m_botCreateTimer = 250;
-
-        if (!IsInFlight() && IsAlive() && !IsInCombat() && GetBotMustBeCreated() && !RestrictBots())
-            for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
-                if (m_botmap[pos]->m_entry != 0 && m_botmap[pos]->m_guid == 0)
-                    CreateBot(m_botmap[pos]->m_entry, m_botmap[pos]->m_race, m_botmap[pos]->m_class);
-    }
-}
-
-void Player::SetBotMustBeCreated(uint32 m_entry, uint8 m_race, uint8 m_class, uint32 *equips)
-{
-    if (m_enableNpcBots == false)
-    {
-        ChatHandler ch(GetSession());
-        ch.SendSysMessage("NpcBot system currently disabled. Please contact your administration.");
-        ClearBotMustBeCreated(0, 0, true);
-        return;
-    }
-    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
-    {
-        if (m_botmap[pos]->m_entry == 0)
-        {
-            m_botmap[pos]->m_guid = 0;//we need it to make sure Player::CreateBot will find this slot
-            m_botmap[pos]->m_entry = m_entry;
-            m_botmap[pos]->m_race = m_race;
-            m_botmap[pos]->m_class = m_class;
-
-            for (uint8 i = 0; i != 18; ++i)
-                m_botmap[pos]->equips[i] = equips[i];
-
-            break;
-        }
-    }
-}
-
-bool Player::GetBotMustBeCreated()
-{
-    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
-    {
-        if (m_botmap[pos]->m_entry != 0 &&
-            (m_botmap[pos]->m_guid == 0 || !sObjectAccessor->FindUnit(m_botmap[pos]->m_guid)))
-        {
-            m_botmap[pos]->m_guid = 0;
-            return true;
-        }
-    }
-    return false;
-}
-
-void Player::ClearBotMustBeCreated(uint64 guidOrSlot, bool guid, bool fully)
-{
-    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
-    {
-        if ((guid == true && m_botmap[pos]->m_guid == guidOrSlot) ||
-            (guid == false && pos == guidOrSlot) ||
-            fully)
-        {
-            m_botmap[pos]->m_guid = 0;
-            m_botmap[pos]->m_entry = 0;
-            m_botmap[pos]->m_race = 0;
-            m_botmap[pos]->m_class = 0;
-            m_botmap[pos]->m_creature = NULL;
-
-            for (uint8 i = 0; i != 18; ++i)
-                m_botmap[pos]->equips[i] = 0;
-
-            if (!fully)
-                break;
-        }
-    }
-}
-
-void Player::RemoveBot(uint64 guid, bool final, bool eraseFromDB)
-{
-    if (guid == 0) return;
-    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
-    {
-        if (m_botmap[i]->m_guid == guid)
-        {
-            m_bot = m_botmap[i]->m_creature;
-            break;
-        }
-    }
-    if (!m_bot)
-        m_bot = sObjectAccessor->GetObjectInWorld(guid, (Creature*)NULL);
-    if (m_bot)
-    {
-        //do not disband group unless not in dungeon or forced or on logout (Check WorldSession::LogoutPlayer())
-        Group* gr = GetGroup();
-        if (gr && gr->IsMember(guid))
-        {
-            if (gr->GetMembersCount() > 2 || /*!GetMap()->Instanceable() || */(final && eraseFromDB))
-                gr->RemoveMember(guid);
-            else //just cleanup
-            {
-                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GROUP_MEMBER);
-                stmt->setUInt32(0, GUID_LOPART(guid));
-                stmt->setUInt32(1, GetGUIDLow());
-                CharacterDatabase.Execute(stmt);
-            }
-        }
-
-        m_bot->SetBotsPetDied();
-        m_bot->OnBotDespawn(NULL);
-        m_bot->SetCharmerGUID(0);
-        //m_bot->SetBotOwner(NULL);
-        m_bot->SetIAmABot(false);
-        SetMinion((Minion*)m_bot, false);
-        m_bot->CleanupsBeforeDelete();
-        m_bot->AddObjectToRemoveList();
-
-        if (final)//on logout or by command
-        {
-            ClearBotMustBeCreated(guid);
-            if (eraseFromDB)//by command
-                SetBotActive(m_bot->GetEntry(), 0);
-
-            if (eraseFromDB)//å é¤æ°æ®åº
-            {
-                m_botInfo.erase(m_bot->GetEntry());
-                CharacterDatabase.DirectPExecute("DELETE FROM character_npcbot WHERE owner = %u and entry = %u", GetGUIDLow(), m_bot->GetEntry());
-            }
-        }
-        else
-        {
-            ModifyMoney(int64(GetNpcBotCost())); //temp restore money before retake
-
-            for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
-            {
-                if (m_botmap[pos]->m_guid == guid)
-                {
-                    m_botmap[pos]->m_guid = 0;//reset guid so it can be set during recreation
-                    m_botmap[pos]->m_creature = NULL;
-                }
-            }
-        }
-        m_bot = NULL;
-    }
-}
-
-void Player::CreateBot(uint32 botentry, uint8 botrace, uint8 botclass, bool revive)
-{
-
-    if (IsBeingTeleported() || IsInFlight()) return; //don't create bot yet
-    if (isDead() && !revive) return; //not to revive by command so abort
-    if (IsInCombat()) return;
-
-    if (m_bot != NULL && revive)
-    {
-        m_bot->SetHealth(m_bot->GetCreateHealth() / 6);//~15% of base health
-        if (m_bot->getPowerType() == POWER_MANA)
-            m_bot->SetPower(POWER_MANA, m_bot->GetCreateMana());
-        SetUInt32Value(UNIT_NPC_FLAGS, m_bot->GetCreatureTemplate()->npcflag);
-        ClearUnitState(uint32(UNIT_STATE_ALL_STATE));
-        m_bot->setDeathState(ALIVE);
-        m_bot->SetBotCommandState(COMMAND_FOLLOW, true);
-        return;
-    }
-    if (m_enableNpcBots == false && revive == false)
-    {
-        ChatHandler ch(GetSession());
-        ch.SendSysMessage("NpcBot system currently disabled. Please contact administration.");
-        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
-            if (m_botmap[pos]->m_entry == botentry)
-                ClearBotMustBeCreated(pos, false);
-        return;
-    }
-    if (!botentry || !botrace || !botclass)
-    {
-        ////TC_LOG_ERROR("entities.player", "ERROR! CreateBot(): player %s (%u) trying to create bot with entry = %u, race = %u, class = %u, ignored", GetName().c_str(), GetGUIDLow(), botentry, botrace, botclass);
-        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
-            if (m_botmap[pos]->m_entry == botentry)
-                ClearBotMustBeCreated(pos, false);
-        return;
-    }
-
-    if (GetNpcBotsCount() > GetMaxNpcBots())
-    {
-        ChatHandler ch(GetSession());
-        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
-            if (m_botmap[pos]->m_entry == botentry)
-                ClearBotMustBeCreated(pos, false);
-        ch.PSendSysMessage("Youre exceed max npcbots");
-        ch.SetSentErrorMessage(true);
-        return;
-    }
-    //instance limit check
-    if ((m_limitNpcBotsDungeons && GetMap()->IsNonRaidDungeon()) || (m_limitNpcBotsRaids && GetMap()->IsRaid()))
-    {
-        InstanceMap* map = (InstanceMap*)GetMap();
-        uint32 count = 0;
-        Map::PlayerList const& plMap = map->GetPlayers();
-        for (Map::PlayerList::const_iterator itr = plMap.begin(); itr != plMap.end(); ++itr)
-            if (Player* player = itr->GetSource())
-                count += (1 + player->GetNpcBotsCount());
-
-        //check "more" cuz current bot is queued and we are to choose to remove it or not
-        if (count > map->GetMaxPlayers())
-        {
-            ChatHandler ch(GetSession());
-            for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
-                if (m_botmap[pos]->m_entry == botentry)
-                    ClearBotMustBeCreated(pos, false);
-            ch.PSendSysMessage("Instance players limit exceed");
-            ch.SetSentErrorMessage(true);
-            return;
-        }
-    }
-    if (GetGroup() && GetGroup()->isRaidGroup() && GetGroup()->IsFull())
-    {
-        ChatHandler ch(GetSession());
-        ch.PSendSysMessage("Your group is Full!");
-        ch.SetSentErrorMessage(true);
-        return;
-    }
-    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
-        if (m_botmap[pos]->m_entry == botentry)
-            if (m_botmap[pos]->m_reviveTimer != 0)
-                return;
-
-    m_bot = SummonCreature(botentry, *this);
-
-    //check if we have free slot
-    bool _set = false;
-    uint8 slot = 0;
-    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
-    {
-        if (m_botmap[pos]->m_entry == botentry && m_botmap[pos]->m_guid == 0)
-        {
-            m_botmap[pos]->m_guid = m_bot->GetGUID();
-            m_botmap[pos]->m_creature = m_bot;//this will save some time but we need guid as well
-            slot = pos;
-            _set = true;
-            break;
-        }
-    }
-    if (!_set)
-    {
-        ////TC_LOG_ERROR("entities.player", "character %s (%u) is failed to create npcbot! Removing all bots", GetName().c_str(), GetGUIDLow());
-
-        m_bot->CombatStop();
-        m_bot->CleanupsBeforeDelete();
-        m_bot->AddObjectToRemoveList();
-        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
-            RemoveBot(m_botmap[pos]->m_guid, true);
-        ClearBotMustBeCreated(0, false, true);
-        return;
-    }
-
-    m_bot->SetBotOwner(this);
-
-    m_bot->SetUInt64Value(UNIT_FIELD_CREATEDBY, GetGUID());
-    SetMinion((Minion*)m_bot, true);
-    m_bot->CombatStop();
-    m_bot->DeleteThreatList();
-    m_bot->AddUnitTypeMask(UNIT_MASK_MINION);
-
-    m_bot->SetByteValue(UNIT_FIELD_BYTES_0, 0, botrace);
-    m_bot->setFaction(getFaction());
-    m_bot->SetLevel(getLevel());
-    m_bot->SetBotClass(botclass);
-    m_bot->AIM_Initialize();
-    m_bot->InitBotAI();
-    m_bot->SetBotCommandState(COMMAND_FOLLOW, true);
-
-    InitBotEquips(m_bot);
-
-    SetBotInfo(botentry, botrace, botclass, m_bot->GetBotRoles(), m_botmap[slot]->equips, uint8(1));
-
-    //If we have a group, just add bot
-    if (Group* gr = GetGroup())
-    {
-        if (!gr->IsFull())
-        {
-            if (!gr->AddMember((Player*)m_bot))
-                RemoveBot(m_bot->GetGUID(), true);
-        }
-        else if (!gr->isRaidGroup()) //non-raid group is full
-        {
-            gr->ConvertToRaid();
-            if (!gr->AddMember((Player*)m_bot))
-                RemoveBot(m_bot->GetGUID(), true);
-        }
-        else //raid group is full
-            RemoveBot(m_bot->GetGUID(), true);
-    }
-    else
-    {
-        gr = new Group;
-        if (!gr->Create(this))
-        {
-            delete gr;
-            return;
-        }
-        sGroupMgr->AddGroup(gr);
-        if (!gr->AddMember((Player*)m_bot))
-            RemoveBot(m_bot->GetGUID(), true);
-    }
-
-    if (uint32 cost = GetNpcBotCost())
-        ModifyMoney(-(int32(cost)));
-
-    UpdateBotModelid(m_bot);
-
-    if (Group* gr = GetGroup())
-    {
-        Group::MemberSlotList const a = gr->GetMemberSlots();
-        //try to remove 'absent' bots
-        for (Group::member_citerator itr = a.begin(); itr != a.end(); ++itr)
-        {
-            if (itr->guid == 0)
-                continue;
-            if (IS_PLAYER_GUID(itr->guid))
-                continue;
-            if (!sObjectAccessor->FindUnit(itr->guid))
-                gr->RemoveMember(itr->guid);
-        }
-    }
-
-    // NPCBOT
-    m_bot->SetBotShouldUpdateStats();
-    // NPCBOT
-} //end Player::CreateBot
-
-uint8 Player::GetNpcBotsCount() const
-{
-    uint8 bots = 0;
-    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
-        if (m_botmap[pos]->m_entry != 0)
-            ++bots;
-    return bots;
-}
-
-uint8 Player::GetMaxNpcBots() const
-{
-    uint8 botcount = (GetSession()->GetSecurity() == SEC_PLAYER) ? m_maxNpcBots : MAX_NPCBOTS;
-    if (botcount > 20)
-        return 20;
-    return botcount;
-}
-
-bool Player::HaveBot() const
-{
-    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
-        if (m_botmap[i]->m_entry != 0)
-            return true;
-    return false;
-}
-
-void Player::SendBotCommandState(Creature* cre, CommandStates state)
-{
-    if (!cre) return;
-    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
-        if (m_botmap[i]->m_creature == cre)
-            cre->SetBotCommandState(state, true);
-}
-//finds bot's slot into master's botmap
-int8 Player::GetNpcBotSlot(uint64 guid) const
-{
-    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
-        if (m_botmap[pos]->m_guid == guid)
-            return pos;
-
-    return -1;
-}
-
-void Player::SetNpcBotDied(uint64 guid)
-{
-    if (!guid) return;
-    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
-        if (m_botmap[pos]->m_guid == guid)
-        {
-            m_botmap[pos]->m_reviveTimer = 15000;
-            break;
-        }
-}
-
-bool Player::RestrictBots() const
-{
-    return
-        (!m_enableNpcBotsBGs && GetMap()->IsBattleground()) ||
-        (!m_enableNpcBotsArenas && GetMap()->IsBattleArena()) ||
-        (!m_enableNpcBotsDungeons && GetMap()->IsNonRaidDungeon()) ||
-        (!m_enableNpcBotsRaids && GetMap()->IsRaid());
-}
-
-uint32 Player::GetNpcBotCost() const
-{
-    return m_NpcBotsCost ? uint32((m_NpcBotsCost / 80.f) * getLevel()) : 0;
-}
-
-std::string Player::GetNpcBotCostStr() const
-{
-    std::ostringstream money;
-
-    if (uint32 cost = GetNpcBotCost())
-    {
-        uint32 gold = uint32(cost / 10000);
-        cost -= (gold * 10000);
-        uint32 silver = uint32(cost / 100);
-        cost -= (silver * 100);
-
-        if (gold != 0)
-            money << gold << " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
-        if (silver != 0)
-            money << silver << " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
-        if (cost)
-            money << cost << " |TInterface\\Icons\\INV_Misc_Coin_05:8|t";
-    }
-    return money.str();
-}
-
-void Player::CreateEntryBot(uint32 BotId)
-{
-    CreatureTemplate const* Info = sObjectMgr->GetCreatureTemplate(BotId);
-    if (!Info)
-        return;
-
-    if (BotId < 80001 || BotId > 80248)
-        return;
-
-    //check if we have too many bots of that class
-    if (HaveBot())
-    {
-        uint8 count = 0;
-        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
-            if (m_botmap[i]->m_class == Info->trainer_class)
-                ++count;
-
-        if (count >= m_maxClassNpcBots)
-        {
-            //SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
-            ChatHandler ch(GetSession());
-            ch.PSendSysMessage("You cannot have more bots of that class! %u of %u", count, m_maxClassNpcBots);
-            ch.SetSentErrorMessage(true);
-            return;
-        }
-    }
-
-    //check if player cannot afford a bot
-    if (GetMoney() < GetNpcBotCost())
-    {
-        ChatHandler ch(GetSession());
-        ch.SetSentErrorMessage(true);
-        return;
-    }
-
-    uint32 equips[18];
-    for (uint8 i = 0; i != 18; ++i)
-        equips[i] = 0;
-
-    BotInfo const* m_equips = GetBotInfo(BotId);
-    if (m_equips)
-    {
-        for (uint8 i = 0; i != 18; ++i)
-            equips[i] = m_equips->equips[i];
-    }
-
-    SetBotMustBeCreated(BotId, Info->trainer_race, Info->trainer_class, equips);
-}
-
-//NPCbot base setup
-void Player::CreateNPCBot(uint8 bot_class)
-{
-    //check if we have too many bots of that class
-    if (HaveBot())
-    {
-        uint8 count = 0;
-        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
-            if (m_botmap[i]->m_class == bot_class)
-                ++count;
-        if (count >= m_maxClassNpcBots)
-        {
-            //SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
-            ChatHandler ch(GetSession());
-            ch.PSendSysMessage("You cannot have more bots of that class! %u of %u", count, m_maxClassNpcBots);
-            ch.SetSentErrorMessage(true);
-            return;
-        }
-    }
-
-    //check if player cannot afford a bot
-    if (GetMoney() < GetNpcBotCost())
-    {
-        ChatHandler ch(GetSession());
-        std::string str = "You don't have enough money (";
-        str += GetNpcBotCostStr();
-        str += ")!";
-        ch.SendSysMessage(str.c_str());
-        ch.SetSentErrorMessage(true);
-        return;
-    }
-
-
-    NpcBotsDataTemplate npcBotsData;
-    uint32 npcBotsDataCount;
-    std::ostringstream classStr;
-    switch (bot_class)
-    {
-    case CLASS_ROGUE:
-        classStr << "rogue_bot";        break;
-    case CLASS_PRIEST:
-        classStr << "priest_bot";       break;
-    case CLASS_DRUID:
-        classStr << "druid_bot";        break;
-    case CLASS_SHAMAN:
-        classStr << "shaman_bot";       break;
-    case CLASS_MAGE:
-        classStr << "mage_bot";         break;
-    case CLASS_WARLOCK:
-        classStr << "warlock_bot";      break;
-    case CLASS_WARRIOR:
-        classStr << "warrior_bot";      break;
-    case CLASS_PALADIN:
-        classStr << "paladin_bot";      break;
-    case CLASS_HUNTER:
-        classStr << "hunter_bot";       break;
-    case CLASS_DEATH_KNIGHT:
-        classStr << "death_knight_bot"; break;
-    default:
-        ChatHandler ch(GetSession());
-        ch.PSendSysMessage("ERROR! unknown bot_class %u", bot_class);
-        ch.SetSentErrorMessage(true);
-        //TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::CreateNPCBot() player %u(%s) tried to create bot of unknown/unsupported class %u!", GetGUIDLow(), GetName().c_str(), bot_class);
-        return;
-    }
-
-    switch (getRace())
-    {
-    case RACE_NONE:
-    case RACE_HUMAN:
-    case RACE_DWARF:
-    case RACE_NIGHTELF:
-    case RACE_GNOME:
-    case RACE_DRAENEI:
-        npcBotsData = sBotTemplate->GetNPCBotTemplate(bot_class, classStr.str(), 1, 3, 4, 7, 11);
-        npcBotsDataCount = sBotTemplate->GetNPCBotTemplateCount(bot_class, classStr.str(), 1, 3, 4, 7, 11);
-        break;
-
-    case RACE_ORC:
-    case RACE_UNDEAD_PLAYER:
-    case RACE_TAUREN:
-    case RACE_TROLL:
-    case RACE_BLOODELF:
-        npcBotsData = sBotTemplate->GetNPCBotTemplate(bot_class, classStr.str(), 2, 5, 6, 8, 10);
-        npcBotsDataCount = sBotTemplate->GetNPCBotTemplateCount(bot_class, classStr.str(), 2, 5, 6, 8, 10);
-        break;
-    }
-
-    if (npcBotsDataCount < 1)
-    {
-        sLog->outString("Player::CreateNPCBot() CANNOT create bot of class %u, not found in DB!", bot_class);
-        return;
-    }
-
-    uint32 entry = 0;
-    uint32 bot_race = 0;
-
-    uint32 m_rand = urand(1, npcBotsDataCount);
-    uint32 tmp_rand = 1;
-    std::list< std::pair<uint32, uint8> >::const_iterator itr = npcBotsData.begin();
-    bool haveSameBot = false;
-    bool moveback = false;
-    bool forcedCheck = false;
-    bool secondCheck = false;
-    while (true)
-    {
-        if (itr == npcBotsData.end()) //end of list is reached (selected bot is checked)
-        {
-            moveback = true;
-            --itr; //tmp_rand is not needed anymore
-            continue;
-        }
-        if (moveback && itr == npcBotsData.begin()) //search is finished, nothing found
-            break;
-        if (tmp_rand == m_rand || haveSameBot)
-        {
-            bool canAdd = true;
-            for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
-            {
-                if (m_botmap[i]->m_entry == itr->first)
-                {
-                    haveSameBot = true;
-                    canAdd = false;
-                    if (!secondCheck)
-                        forcedCheck = true;
-                    secondCheck = true;
-                    break;
-                }
-            }
-            if (canAdd)
-            {
-                entry = itr->first;
-                bot_race = itr->second;
-                break;
-            }
-            if (forcedCheck)
-            {
-                itr = npcBotsData.begin(); //reset searcher pos
-                forcedCheck = false;
-                continue;
-            }
-        }
-        //move through
-        if (moveback)
-            --itr;
-        else
-        {
-            ++itr;
-            ++tmp_rand;
-        }
-    }
-
-    if (!entry || !bot_race)
-    {
-        ChatHandler ch(GetSession());
-        ch.SendSysMessage("No more bots of this class available");
-        ch.SetSentErrorMessage(true);
-        return;
-    }
-
-    uint32 equips[18];
-    for (uint8 i = 0; i != 18; ++i)
-        equips[i] = 0;
-
-    BotInfo const* m_equips = GetBotInfo(entry);
-    if (m_equips)
-    {
-        for (uint8 i = 0; i != 18; ++i)
-            equips[i] = m_equips->equips[i];
-    }
-
-    SetBotMustBeCreated(entry, bot_race, bot_class, equips);
-}
-
-void Player::InitBotEquips(Creature* bot)
-{
-    int8 id = 1;
-    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(bot->GetEntry(), id);
-
-    uint8 slot = 0;
-    //Load stored equipment if any
-    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
-    {
-        if (m_botmap[pos]->m_creature == bot)
-        {
-            slot = pos;
-
-            bot->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0, m_botmap[pos]->equips[0]);
-            bot->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1, m_botmap[pos]->equips[1]);
-            bot->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2, m_botmap[pos]->equips[2]);
-
-            if (uint32 mh = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0))
-            {
-                if (!einfo || einfo->ItemEntry[0] != mh)
-                {
-                    if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(mh))
-                    {
-                        bot->SetAttackTime(BASE_ATTACK, proto->Delay);
-                        bot->ApplyBotItemBonuses(0);
-                    }
-                }
-            }
-            else
-                bot->SetAttackTime(BASE_ATTACK, bot->GetCreatureTemplate()->BaseAttackTime);
-
-            if (uint32 oh = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1))
-            {
-                if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(oh))
-                {
-                    if (!einfo || einfo->ItemEntry[1] != oh)
-                        bot->ApplyBotItemBonuses(1);
-
-                    if (proto->Class == ITEM_CLASS_WEAPON)
-                    {
-                        bot->SetAttackTime(OFF_ATTACK, proto->Delay);
-                        bot->SetCanDualWield(true);
-                    }
-                    else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
-                    {
-                        if (bot->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
-                            const_cast<CreatureTemplate*>(bot->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
-                    }
-                }
-            }
-            else
-                bot->SetAttackTime(OFF_ATTACK, bot->GetCreatureTemplate()->BaseAttackTime);
-
-            if (uint32 rh = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2))
-            {
-                if (!einfo || einfo->ItemEntry[2] != rh)
-                {
-                    if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(rh))
-                    {
-                        bot->SetAttackTime(RANGED_ATTACK, proto->Delay);
-                        bot->ApplyBotItemBonuses(2);
-                    }
-                }
-            }
-            else
-                bot->SetAttackTime(OFF_ATTACK, bot->GetCreatureTemplate()->RangeAttackTime);
-
-            for (uint8 i = 3; i != 18; ++i)
-                bot->ApplyBotItemBonuses(i);
-
-            break;
-        }
-    }
-
-
-    //Load remaining items as defaults
-    if (einfo)
-    {
-        for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
-        {
-            if (bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i) == 0 && einfo->ItemEntry[i] != 0)
-            {
-                bot->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, einfo->ItemEntry[i]);
-                if (i == 1) //off-hand
-                {
-                    if (einfo->ItemEntry[i] != 0 && bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i) == einfo->ItemEntry[i])
-                    {
-                        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(einfo->ItemEntry[i]))
-                        {
-                            if (proto->Class == ITEM_CLASS_WEAPON)
-                            {
-                                bot->SetAttackTime(OFF_ATTACK, bot->GetBotClass() == CLASS_ROGUE ? 1400 : 1800);
-                                bot->SetCanDualWield(true);
-                            }
-                            else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
-                            {
-                                if (bot->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
-                                    const_cast<CreatureTemplate*>(bot->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        //while creating new bot he has no equips but equip template so write these to bot map
-        m_botmap[slot]->equips[0] = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0);
-        m_botmap[slot]->equips[1] = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1);
-        m_botmap[slot]->equips[2] = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2);
-    }
-}
-
-uint32 Player::GetBotEquip(Creature* bot, uint8 slot) const
-{
-    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
-        if (m_botmap[pos]->m_creature == bot)
-            return m_botmap[pos]->equips[slot];
-
-    return 0;
-}
-
-void Player::UpdateBotEquips(Creature* bot, uint8 slot, uint32 itemId)
-{
-    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
-    {
-        if (m_botmap[pos]->m_creature == bot)
-        {
-            m_botmap[pos]->equips[slot] = itemId;
-
-            SetBotQquips(m_botmap[pos]->m_entry, m_botmap[pos]->equips);
-            break;
-        }
-    }
-}
diff --git a/src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp b/src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp
deleted file mode 100644
index 8863ecf..0000000
--- a/src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp
+++ /dev/null
@@ -1,121 +0,0 @@
-#include "bot_ai.h"
-#include "Group.h"
-#include "Player.h"
-#include "ScriptedGossip.h"
-#include "ScriptMgr.h"
-#include "SpellAuras.h"
-#include "WorldSession.h"
-/*
-Bot Quest npc Airen by Graff onlysuffering@gmail.com
-Complete - 0%
-TODO:
-*/
-#define ACT                 GOSSIP_ACTION_INFO_DEF
-
-class Airen_chapter1 : public CreatureScript
-{
-public:
-    Airen_chapter1() : CreatureScript("npc_Airen_qI") { }
-
-    CreatureAI* GetAI(Creature* creature) const override
-    {
-        return new Airen_AI(creature);
-    }
-
-    bool OnGossipHello(Player* player, Creature* creature)
-    {
-        player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_CHAT, "nothing here", 6000, ACT + 1, "nothing here either", 0 * COPPER, true);
-        player->PlayerTalkClass->SendGossipMenu(creature->GetEntry(), creature->GetGUID());
-
-        std::ostringstream msg;
-        msg << "..." << player->GetName() << ", huh?";
-        bot_ai::BotSpeak(msg.str(), CHAT_MSG_WHISPER, LANG_UNIVERSAL, creature->GetGUID(), player->GetGUID());
-
-        return true;
-    }
-
-    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
-    {
-        player->PlayerTalkClass->ClearMenus();
-
-        switch (sender)
-        {
-            case 6000:
-            {
-                if (action == ACT + 1)
-                {
-                    if (!player->HasEnoughMoney(1 * COPPER))
-                    {
-                        player->SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, creature, 0, 0);
-                        break;
-                    }
-                    player->ModifyMoney(-(1 * COPPER));
-                }
-
-                break;
-            }
-            default:
-                break;
-        }
-
-        player->CLOSE_GOSSIP_MENU();
-        return true;
-    }
-
-    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
-    {
-        player->PlayerTalkClass->ClearMenus();
-        std::string answer = "asd";
-
-        switch (sender)
-        {
-            case 6000:
-            {
-                if (action == ACT + 1 && code == answer)
-                    bot_ai::BotSpeak("hehe", CHAT_MSG_YELL, LANG_UNIVERSAL, creature->GetGUID(), player->GetGUID());
-                break;
-            }
-        }
-
-        player->CLOSE_GOSSIP_MENU();
-        return true;
-    }
-
-    struct Airen_AI : public ScriptedAI
-    {
-        Airen_AI(Creature* creature) : ScriptedAI(creature) { }
-
-        void EnterCombat(Unit*) { }
-        void Aggro(Unit*) { }
-        void AttackStart(Unit*) { }
-        void KilledUnit(Unit*) { }
-        void EnterEvadeMode() { }
-        void MoveInLineOfSight(Unit*) { }
-        void JustDied(Unit*) { me->DisappearAndDie(); }
-
-        void UpdateAI(uint32 /*diff*/)
-        {
-        }
-
-        void Reset()
-        {
-            me->SetCreateHealth(213000213);
-            me->SetMaxHealth(me->GetCreateHealth());
-            me->SetFullHealth();
-
-            me->setPowerType(POWER_RAGE);
-            me->SetMaxPower(POWER_RAGE, 10000);
-            me->SetPower(POWER_RAGE, me->GetMaxPower(POWER_RAGE));
-        }
-
-		void DamageTaken(Unit* /*u*/, uint32& damage, DamageEffectType, SpellSchoolMask)
-        {
-            damage = me->GetHealth() > 1 ? 1 : 0;
-        }
-    };
-};
-
-void AddSC_BotQuests_chapter1()
-{
-    new Airen_chapter1();
-}
diff --git a/src/server/game/AI/NpcBots/bot_GridNotifiers.h b/src/server/game/AI/NpcBots/bot_GridNotifiers.h
deleted file mode 100644
index 284a744..0000000
--- a/src/server/game/AI/NpcBots/bot_GridNotifiers.h
+++ /dev/null
@@ -1,596 +0,0 @@
-/*
-Name: bot_GridNotifiers
-%Complete: 95+
-Comment: Custom grid notifiers for Bot system by Graff (onlysuffering@gmail.com)
-Category: creature_cripts/custom/bots/grids
-*/
-
-#ifndef _BOT_GRIDNOTIFIERS_H
-#define _BOT_GRIDNOTIFIERS_H
-
-#include "Group.h"
-#include "Player.h"
-#include "bot_ai.h"
-#include "SpellAuras.h"
-#include "SpellAuraEffects.h"
-#include "SpellInfo.h"
-
-uint8 PvP = 1;
-
-class NearestHostileUnitCheck
-{
-    public:
-        explicit NearestHostileUnitCheck(Unit const* unit, float dist, bool magic, bot_ai const* m_ai, bool targetCCed = false) :
-        me(unit), m_range(dist), byspell(magic), ai(m_ai), AttackCCed(targetCCed) { }
-        bool operator()(Unit* u)
-        {
-            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
-                return false;
-            if (!me->IsWithinDistInMap(u, m_range))
-                return false;
-            if (!u->IsInCombat())
-                return false;
-            if (!u->InSamePhase(me))
-                return false;
-            if (!ai->CanBotAttack(u, byspell))
-                return false;
-            if (ai->InDuel(u))
-                return false;
-            if (!AttackCCed && (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE)))
-                return false;//do not allow CCed units if checked
-            //if (u->HasUnitState(UNIT_STATE_CASTING) && (u->GetTypeId() == TYPEID_PLAYER || u->IsPet()))
-            //    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
-            //        if (Spell* spell = u->GetCurrentSpell(i))
-            //            if (ai->IsInBotParty(spell->m_targets.GetUnitTarget()))
-            //                return true;
-            if (!ai->IsInBotParty(u->GetVictim()))
-                return false;
-
-            m_range = me->GetDistance(u);   // use found unit range as new range limit for next check
-            return true;
-        }
-    private:
-        Unit const* me;
-        float m_range;
-        bool byspell;
-        bot_ai const* ai;
-        bool AttackCCed;
-        NearestHostileUnitCheck(NearestHostileUnitCheck const&);
-};
-
-class HostileDispelTargetCheck
-{
-    public:
-        explicit HostileDispelTargetCheck(Unit const* unit, float dist = 30, bool stealable = false, bot_ai const* m_ai = NULL) :
-        me(unit), m_range(dist), checksteal(stealable), ai(m_ai) { }
-        bool operator()(Unit* u)
-        {
-            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
-                return false;
-            if (u->IsWithinDistInMap(me, m_range) &&
-                u->IsAlive() &&
-                u->InSamePhase(me) &&
-                u->IsInCombat() &&
-                u->isTargetableForAttack() &&
-                u->IsVisible() &&
-                u->GetReactionTo(me) < REP_NEUTRAL &&
-                ai->IsInBotParty(u->GetVictim()))
-            {
-                if (checksteal && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(30449))) return false;//immune to steal
-                if (!checksteal)
-                {
-                    if (me->getLevel() >= 70 && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(32375))) return false;//immune to mass dispel
-                    if (me->getLevel() < 70 && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(527))) return false;//immune to direct dispel
-                }
-                Unit::AuraMap const &Auras = u->GetOwnedAuras();
-                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
-                {
-                    Aura* aura = itr->second;
-                    SpellInfo const* Info = aura->GetSpellInfo();
-                    if (Info->Dispel != DISPEL_MAGIC) continue;
-                    if (Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
-                    if (checksteal && (Info->AttributesEx4 & SPELL_ATTR4_NOT_STEALABLE)) continue;
-                    AuraApplication const* aurApp = aura->GetApplicationOfTarget(u->GetGUID());
-                    if (aurApp && aurApp->IsPositive())
-                    {
-                        const std::string name = Info->SpellName[0];
-                        if (name == "Vengeance" || name == "Bloody Vengeance")
-                            continue;
-                        return true;
-                    }
-                }
-            }
-            return false;
-        }
-    private:
-        Unit const* me;
-        float m_range;
-        bool checksteal;
-        bot_ai const* ai;
-        HostileDispelTargetCheck(HostileDispelTargetCheck const&);
-};
-
-class AffectedTargetCheck
-{
-    public:
-        explicit AffectedTargetCheck(uint64 casterguid, float dist, uint32 spellId, Player const* groupCheck = 0, uint8 hostileCheckType = 0) :
-        caster(casterguid), m_range(dist), spell(spellId), checker(groupCheck), needhostile(hostileCheckType)
-        { if (checker->GetTypeId() != TYPEID_PLAYER) return; gr = checker->GetGroup(); }
-        bool operator()(Unit* u)
-        {
-            if (caster && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
-                return false;
-            if (needhostile == 0 && !u->IsHostileTo(checker)) return false;
-            if (needhostile == 1 && !(gr && gr->IsMember(u->GetGUID()) && u->GetTypeId() == TYPEID_PLAYER)) return false;
-            if (needhostile == 2 && !(gr && gr->IsMember(u->GetGUID()))) return false;
-            if (needhostile == 3 && !u->IsFriendlyTo(checker)) return false;
-
-            if (u->IsAlive() && checker->IsWithinDistInMap(u, m_range))
-            {
-                Unit::AuraMap const &Auras = u->GetOwnedAuras();
-                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
-                {
-                    Aura* aura = itr->second;
-                    if (aura->GetId() == spell)
-                        if (caster == 0 || aura->GetCasterGUID() == caster)
-                            return true;
-                }
-            }
-            return false;
-        }
-    private:
-        uint64 const caster;
-        float m_range;
-        uint32 const spell;
-        Player const* checker;
-        uint8 needhostile;
-        Group const* gr;
-        AffectedTargetCheck(AffectedTargetCheck const&);
-};
-
-class PolyUnitCheck
-{
-    public:
-        explicit PolyUnitCheck(Unit const* unit, float dist, Unit const* currTarget) : me(unit), m_range(dist), mytar(currTarget) {}
-        bool operator()(Unit* u)
-        {
-            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
-                return false;
-            if (u == mytar)
-                return false;
-            if (!me->IsWithinDistInMap(u, m_range))
-                return false;
-            if (!u->IsInCombat() || !u->IsAlive() || !u->GetVictim())
-                return false;
-            if (u->GetCreatureType() != CREATURE_TYPE_HUMANOID &&
-                u->GetCreatureType() != CREATURE_TYPE_BEAST)
-                return false;
-            if (me->GetDistance(u) < 6 || mytar->GetDistance(u) < 5 ||
-                (me->ToCreature()->GetBotClass() == CLASS_MAGE && u->GetHealthPct() < 70))
-                return false;
-            if (!u->InSamePhase(me))
-                return false;
-            if (!u->isTargetableForAttack())
-                return false;
-            if (!u->IsVisible())
-                return false;
-            if (me->ToCreature()->GetBotClass() == CLASS_MAGE ? !u->getAttackers().empty() : u->getAttackers().size() > 1)
-                return false;
-            if (!u->IsHostileTo(me))
-                return false;
-            if (u->IsPolymorphed() ||
-                u->isFrozen() ||
-                u->isInRoots() ||
-                u->HasAura(51514)/*hex*/ ||
-                u->HasAura(20066)/*repentance*/ ||
-                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(339)) || //entangling roots
-                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(16914)) || //hurricane
-                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(10)) || //blizzard
-                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(2121)) || //flamestrike
-                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(20116)) || //consecration
-                u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
-                return false;
-
-            if (me->ToCreature()->GetBotClass() == CLASS_MAGE && !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(118)))//Polymorph
-                return true;
-            if (me->ToCreature()->GetBotClass() == CLASS_SHAMAN && !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(51514)))//Hex
-                return true;
-
-            return false;
-        }
-    private:
-        Unit const* me;
-        float m_range;
-        Unit const* mytar;
-        PolyUnitCheck(PolyUnitCheck const&);
-};
-
-class FearUnitCheck
-{
-    public:
-        explicit FearUnitCheck(Unit const* unit, float dist = 30) : me(unit), m_range(dist) {}
-        bool operator()(Unit* u)
-        {
-            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
-                return false;
-            if (!me->IsWithinDistInMap(u, m_range))
-                return false;
-            if (!u->InSamePhase(me))
-                return false;
-            if (!u->IsInCombat())
-                return false;
-            if (u->GetCreatureType() == CREATURE_TYPE_UNDEAD)
-                return false;
-            if (u->GetCreatureType() != CREATURE_TYPE_BEAST &&
-                me->ToCreature()->GetBotClass() == CLASS_HUNTER)
-                return false;
-            if (!u->IsAlive())
-                return false;
-            if (!u->isTargetableForAttack())
-                return false;
-            if (!u->IsVisible())
-                return false;
-            if (u->getAttackers().size() > 1 && u->GetVictim() != me)
-                return false;
-            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
-                return false;
-            if (u->isFeared())
-                return false;
-            if (u->GetReactionTo(me) > REP_NEUTRAL)
-                return false;
-
-            if (me->ToCreature()->GetBotClass() == CLASS_WARLOCK &&
-                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(5782)))//fear rank1
-                return true;
-            if (me->ToCreature()->GetBotClass() == CLASS_HUNTER &&
-                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(1513)))//scare beast rank1
-                return true;
-
-            return false;
-        }
-    private:
-        Unit const* me;
-        float m_range;
-        FearUnitCheck(FearUnitCheck const&);
-};
-
-class StunUnitCheck
-{
-    public:
-        explicit StunUnitCheck(Unit const* unit, float dist = 20) : me(unit), m_range(dist) {}
-        bool operator()(Unit* u)
-        {
-            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
-                return false;
-            if (!me->IsWithinDistInMap(u, m_range))
-                return false;
-            if (!u->IsInCombat())
-                return false;
-            if (me->GetVictim() == u)
-                return false;
-            if (me->GetTypeId() == TYPEID_UNIT)
-                if (Player* mymaster = me->ToCreature()->GetBotOwner())
-                    if (mymaster->GetVictim() == u)
-                        return false;
-            if (!u->InSamePhase(me))
-                return false;
-            if (u->GetReactionTo(me) > REP_NEUTRAL)
-                return false;
-            if (!u->IsAlive())
-                return false;
-            if (!u->IsVisible())
-                return false;
-            if (!u->isTargetableForAttack())
-                return false;
-            if (!u->getAttackers().empty())
-                return false;
-            if (u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
-                return false;
-            if (me->ToCreature()->GetBotClass() == CLASS_PALADIN &&
-                !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID ||
-                u->GetCreatureType() == CREATURE_TYPE_DEMON ||
-                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN ||
-                u->GetCreatureType() == CREATURE_TYPE_GIANT ||
-                u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
-                return false;
-            if (me->ToCreature()->GetBotClass() == CLASS_HUNTER && u->isFeared())
-                return false;
-            if (me->GetDistance(u) < 10)//do not allow close cast to prevent break due to AOE damage
-                return false;
-            if (u->IsPolymorphed() ||
-                u->HasAura(51514)/*hex*/ ||
-                u->HasAura(20066)/*repentance*/ ||
-                u->HasAuraWithMechanic((1<<MECHANIC_SHACKLE)|(1<<MECHANIC_SLEEP)|(1<<MECHANIC_DISORIENTED)))
-                return false;
-            if (me->ToCreature()->GetBotClass() == CLASS_PALADIN &&
-                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(20066)))//repentance
-                return true;
-            if (me->ToCreature()->GetBotClass() == CLASS_HUNTER &&
-                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(60210)))//freezing arrow effect
-                return true;
-            if (me->ToCreature()->GetBotClass() == CLASS_HUNTER &&
-                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(19386)))//wyvern sting rank 1
-                return true;
-            if (me->ToCreature()->GetBotClass() == CLASS_HUNTER &&
-                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(1991)))//scatter shot
-                return true;
-
-            return false;
-        }
-    private:
-        Unit const* me;
-        float m_range;
-        StunUnitCheck(StunUnitCheck const&);
-};
-
-class UndeadCCUnitCheck
-{
-    public:
-        explicit UndeadCCUnitCheck(Unit const* unit, float dist = 30, uint32 spell = 0) : me(unit), m_range(dist), m_spellId(spell) { if (!spell) return; }
-        bool operator()(Unit* u)
-        {
-            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
-                return false;
-            if (!me->IsWithinDistInMap(u, m_range))
-                return false;
-            if (!u->InSamePhase(me))
-                return false;
-            if (!u->IsInCombat())
-                return false;
-            if (u->GetReactionTo(me) > REP_NEUTRAL)
-                return false;
-            if (!u->IsAlive())
-                return false;
-            if (!u->isTargetableForAttack())
-                return false;
-            if (!u->IsVisible())
-                return false;
-            if (me->GetVictim() == u && u->GetVictim() == me)
-                return false;
-            if (!u->getAttackers().empty())
-                return false;
-            if (u->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
-                (m_spellId == 9484 || m_spellId == 9485 || m_spellId == 10955))//shackle undead
-                return false;
-            //most horrible hacks
-            if (u->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
-                u->GetCreatureType() != CREATURE_TYPE_DEMON &&
-                (m_spellId == 2812 || m_spellId == 10318 || //holy
-                m_spellId == 27139 || m_spellId == 48816 || //wra
-                m_spellId == 48817 ||                       //th or
-                m_spellId == 10326))                        //turn evil
-                return false;
-            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
-                return false;
-            if (u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) &&
-                (m_spellId == 9484 || m_spellId == 9485 || m_spellId == 10955))//shackle undead
-                return false;
-            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId)))
-                return true;
-
-            return false;
-        }
-    private:
-        Unit const* me;
-        float m_range;
-        uint32 m_spellId;
-        UndeadCCUnitCheck(UndeadCCUnitCheck const&);
-};
-
-class RootUnitCheck
-{
-    public:
-        explicit RootUnitCheck(Unit const* unit, Unit const* mytarget, float dist = 30, uint32 spell = 0) : me(unit), curtar(mytarget), m_range(dist), m_spellId(spell)
-        { if (!spell) return; }
-        bool operator()(Unit* u)
-        {
-            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
-                return false;
-            if (u == curtar)
-                return false;
-            if (!me->IsWithinDistInMap(u, m_range))
-                return false;
-            if (!u->IsAlive())
-                return false;
-            if (!u->IsInCombat())
-                return false;
-            if (me->GetDistance(u) < 8)
-                return false;
-            if (!u->InSamePhase(me))
-                return false;
-            if (!u->IsVisible())
-                return false;
-            if (!u->isTargetableForAttack())
-                return false;
-            if (u->GetReactionTo(me) > REP_NEUTRAL)
-                return false;
-            if (u->isFrozen() || u->isInRoots())
-                return false;
-            if (!u->getAttackers().empty())
-                return false;
-            if (u->IsPolymorphed() ||
-                u->HasAura(51514)/*hex*/ ||
-                u->HasAura(20066)/*repentance*/ ||
-                u->HasAuraWithMechanic(1<<MECHANIC_SHACKLE)/*shackle undead*/)
-                return false;
-            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId)))
-                return true;
-
-            return false;
-        }
-    private:
-        Unit const* me;
-        Unit const* curtar;
-        float m_range;
-        uint32 m_spellId;
-        RootUnitCheck(RootUnitCheck const&);
-};
-
-class CastingUnitCheck
-{
-    public:
-        explicit CastingUnitCheck(Unit const* unit, float mindist = 0.f, float maxdist = 30, bool friendly = false, uint32 spell = 0) :
-        me(unit), min_range(mindist), max_range(maxdist), m_friend(friendly), m_spell(spell) {}
-        bool operator()(Unit* u)
-        {
-            if (!m_friend && !PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
-                return false;
-            if (min_range > 0.1f && me->GetDistance(u) < min_range)
-                return false;
-            if (!me->IsWithinDistInMap(u, max_range))
-                return false;
-            if (!u->IsAlive())
-                return false;
-            if (!u->InSamePhase(me))
-                return false;
-            if (!u->IsVisible())
-                return false;
-            if (!m_friend && !u->isTargetableForAttack())
-                return false;
-            //if (!m_friend && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SILENCED))//prevent double silence
-            //    return false;
-            if (!u->IsNonMeleeSpellCast(false))
-                return false;
-            if (m_friend == (u->GetReactionTo(me) < REP_FRIENDLY))
-                return false;
-            if (m_spell == 10326 && //turn evil
-                u->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
-                u->GetCreatureType() != CREATURE_TYPE_DEMON)
-                return false;
-            if (m_spell == 20066 && //repentance
-                !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID ||
-                u->GetCreatureType() == CREATURE_TYPE_DEMON ||
-                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN ||
-                u->GetCreatureType() == CREATURE_TYPE_GIANT ||
-                u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
-                return false;
-            if (!m_spell || !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spell)))
-                return true;
-
-            return false;
-        }
-    private:
-        Unit const* me;
-        float min_range, max_range;
-        bool m_friend;
-        uint32 m_spell;
-        CastingUnitCheck(CastingUnitCheck const&);
-};
-
-class SecondEnemyCheck
-{
-    public:
-        explicit SecondEnemyCheck(Unit const* unit, float dist, float splashdist, Unit const* currtarget, bot_ai const* m_ai) :
-        me(unit), m_range(dist), m_splashrange(splashdist), mytar(currtarget), ai(m_ai) {}
-        bool operator()(Unit* u)
-        {
-            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
-                return false;
-            if (u == mytar)
-                return false;//We need to find SECONDARY target
-            if (!u->IsInCombat())
-                return false;
-            if (u->isMoving() != mytar->isMoving())//only when both targets idle or both moving
-                return false;
-            if (!me->IsWithinDistInMap(u, m_range + 1.f))//distance check
-                return false;
-            if (mytar->GetDistance(u) > m_splashrange)//not close enough to each other
-                return false;
-
-            if (ai->CanBotAttack(u))
-                return true;
-
-            return false;
-        }
-    private:
-        Unit const* me;
-        float m_range, m_splashrange;
-        Unit const* mytar;
-        bot_ai const* ai;
-        SecondEnemyCheck(SecondEnemyCheck const&);
-};
-
-class TranquilTargetCheck
-{
-    public:
-        explicit TranquilTargetCheck(Unit const* unit, float mindist, float maxdist, bot_ai const* m_ai) :
-        me(unit), min_range(mindist), max_range(maxdist), ai(m_ai) { }
-        bool operator()(Unit* u)
-        {
-            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
-                return false;
-            if (u != me->GetVictim() &&//check hunter_bot::hunter_botAI::CheckTranquil(uint32)
-                u->IsWithinDistInMap(me, max_range) &&
-                u->GetDistance(me) > min_range &&
-                u->IsAlive() &&
-                u->InSamePhase(me) &&
-                u->IsInCombat() &&
-                u->isTargetableForAttack() &&
-                u->IsVisible() &&
-                u->GetReactionTo(me) < REP_NEUTRAL &&
-                ai->IsInBotParty(u->GetVictim()))
-            {
-                if (u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(19801))) return false;//immune to tranquilizing shot
-                Unit::AuraMap const &Auras = u->GetOwnedAuras();
-                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
-                {
-                    SpellInfo const* Info = itr->second->GetSpellInfo();
-                    if (Info->Dispel != DISPEL_MAGIC && Info->Dispel != DISPEL_ENRAGE) continue;
-                    if (Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
-                    AuraApplication const* aurApp = itr->second->GetApplicationOfTarget(u->GetGUID());
-                    if (aurApp && aurApp->IsPositive())
-                    {
-                        return true;
-                    }
-                }
-            }
-
-            return false;
-        }
-    private:
-        Unit const* me;
-        float min_range, max_range;
-        bot_ai const* ai;
-        TranquilTargetCheck(TranquilTargetCheck const&);
-};
-
-class NearbyHostileUnitCheck
-{
-    public:
-        explicit NearbyHostileUnitCheck(Unit const* unit, float maxdist, float mindist, bot_ai const* m_ai, bool forCC) :
-        me(unit), max_range(maxdist), min_range(mindist), ai(m_ai), m_forCC(forCC) { }
-        bool operator()(Unit* u)
-        {
-            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
-                return false;
-            if (!me->IsWithinDistInMap(u, max_range))
-                return false;
-            if (min_range > 0.1f && me->GetDistance(u) < min_range)
-                return false;
-            if (!u->IsInCombat())
-                return false;
-            if (!u->InSamePhase(me))
-                return false;
-            if (!ai->CanBotAttack(u))
-                return false;
-            if (ai->InDuel(u))
-                return false;
-            if (u->HasUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_STUNNED|UNIT_STATE_FLEEING|UNIT_STATE_DISTRACTED|UNIT_STATE_CONFUSED_MOVE))
-                return false;
-            if (m_forCC && u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
-                return false;
-
-            if (ai->IsInBotParty(u->GetVictim()))
-                return true;
-
-            return false;
-        }
-    private:
-        Unit const* me;
-        float max_range, min_range;
-        bot_ai const* ai;
-        bool m_forCC;
-        NearbyHostileUnitCheck(NearbyHostileUnitCheck const&);
-};
-
-#endif
diff --git a/src/server/game/AI/NpcBots/bot_ai.cpp b/src/server/game/AI/NpcBots/bot_ai.cpp
deleted file mode 100644
index c993380..0000000
--- a/src/server/game/AI/NpcBots/bot_ai.cpp
+++ /dev/null
@@ -1,5162 +0,0 @@
-ï»¿#include "bot_ai.h"
-#include "bot_GridNotifiers.h"
-#include "CellImpl.h"
-#include "Chat.h"
-#include "Config.h"
-#include "GameEventMgr.h"
-#include "GridNotifiers.h"
-#include "GridNotifiersImpl.h"
-#include "ScriptedGossip.h"
-#include "SpellAuraEffects.h"
-#include "BYcustom.h"
-#pragma execution_character_set("utf-8")
-/*
-
-NpcBot System by Graff (onlysuffering@gmail.com)
-Original patch from: LordPsyan https://bitbucket.org/lordpsyan/trinitycore-patches/src/3b8b9072280e/Individual/11185-BOTS-NPCBots.patch
-TODO:
-Implement virtual inventory for bots
-Better equipment implementation
-Convert doCast events (CD etc.) into SpellHit()- and SpellHitTarget()-based
-Implement Racial Abilities
-Quests
-I NEED MORE
-*/
-const uint8 GroupIconsFlags[TARGETICONCOUNT] =
-{
-    /*STAR        = */0x001,
-    /*CIRCLE      = */0x002,
-    /*DIAMOND     = */0x004,
-    /*TRIANGLE    = */0x008,
-    /*MOON        = */0x010,
-    /*SQUARE      = */0x020,
-    /*CROSS       = */0x040,
-    /*SKULL       = */0x080
-};
-
-bot_minion_ai::bot_minion_ai(Creature* creature) : bot_ai(creature)
-{
-    Potion_cd = 0;
-    pvpTrinket_cd = 30000;
-    rezz_cd = 0;
-    evade_cd = 0;
-    myangle = 0.f;
-    mana_cd = uint32(-1);
-    health_cd = uint32(-1);
-    _classinfo = new PlayerClassLevelInfo();
-    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
-        for (uint8 j = 0; j != MAX_BOT_ITEM_MOD; ++j)
-            _stats[i][j] = 0;
-    for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
-    {
-        _ctc[i].first = 0;
-        _ctc[i].second = 0;
-    }
-}
-bot_minion_ai::~bot_minion_ai()
-{
-    delete _classinfo;
-}
-
-bot_pet_ai::bot_pet_ai(Creature* creature) : bot_ai(creature)
-{
-    m_creatureOwner = me->GetCreatureOwner();
-    basearmor = 0;
-}
-bot_pet_ai::~bot_pet_ai() { }
-
-bot_ai::bot_ai(Creature* creature) : ScriptedAI(creature)
-{
-    master = me->GetBotOwner();
-    _roleMask = 0;
-    m_spellpower = 0;
-    m_block = 1;
-    m_expertise = 0;
-    m_spellpen = 0;
-    haste = 0;
-    hit = 0.f;
-    regen_mp5 = 0.f;
-    m_botSpellInfo = NULL;
-    clear_cd = 2;
-    temptimer = 0;
-    wait = 15;
-    GC_Timer = 0;
-    checkAurasTimer = 20;
-    roleTimer = 0;
-    cost = 0;
-    doHealth = false;
-    doMana = false;
-    //shouldUpdateStats = true;
-    pos.m_positionX = 0.f;
-    pos.m_positionY = 0.f;
-    pos.m_positionZ = 0.f;
-    aftercastTargetGuid = 0;
-    currentSpell = 0;
-    tempMana = 0;
-    dmgmult_melee = sConfigMgr->GetFloatDefault("Bot.DamageMult.Melee", 1.0);
-    dmgmult_spell = sConfigMgr->GetFloatDefault("Bot.DamageMult.Spell", 1.0);
-    dmgmult_melee = std::max(dmgmult_melee, 0.01f);
-    dmgmult_spell = std::max(dmgmult_spell, 0.01f);
-    dmgmult_melee = std::min(dmgmult_melee, 10.f);
-    dmgmult_spell = std::min(dmgmult_spell, 10.f);
-    dmgmod_melee = Creature::_GetDamageMod(me->GetCreatureTemplate()->rank);
-    dmgmod_spell = me->GetSpellDamageMod(me->GetCreatureTemplate()->rank);
-    healTargetIconFlags = sConfigMgr->GetIntDefault("Bot.HealTargetIconsMask", 8);
-    PvP = sConfigMgr->GetIntDefault("Bot.PvP", 1);
-}
-bot_ai::~bot_ai() { }
-
-SpellCastResult bot_ai::CheckBotCast(Unit* victim, uint32 spellId, uint8 botclass) const
-{
-    if (spellId == 0)
-        return SPELL_FAILED_DONT_REPORT;
-
-    if (InDuel(victim))
-        return SPELL_FAILED_DONT_REPORT;
-
-    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
-    if (!spellInfo)
-        return SPELL_FAILED_DONT_REPORT;
-
-    if (!CheckImmunities(spellId, victim))
-        return SPELL_FAILED_DONT_REPORT;
-
-    if (Powers(spellInfo->PowerType) == me->getPowerType() &&
-        (int32)me->GetPower(me->getPowerType()) < spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()))
-        return SPELL_FAILED_DONT_REPORT;
-
-    switch (botclass)
-    {
-        case CLASS_PALADIN:
-        case CLASS_MAGE:
-        case CLASS_PRIEST:
-        case CLASS_DRUID:
-        case CLASS_WARLOCK:
-        case CLASS_SHAMAN:
-            if (Feasting() && !master->IsInCombat() && !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
-                return SPELL_FAILED_DONT_REPORT;
-            break;
-        case CLASS_WARRIOR:
-            //BladeStorm
-            if (me->HasAura(46924/*67541*/))
-                return SPELL_FAILED_DONT_REPORT;
-            break;
-        case CLASS_ROGUE:
-        case CLASS_HUNTER:
-        case CLASS_DEATH_KNIGHT:
-        default:
-            break;
-    }
-
-    return SPELL_CAST_OK;
-}
-
-bool bot_ai::doCast(Unit* victim, uint32 spellId, bool triggered, uint64 originalCaster)
-{
-    if (spellId == 0) return false;
-    if (me->IsMounted()) return false;
-    if (IsCasting()) return false;
-    if (!victim || !victim->IsInWorld() || me->GetMap() != victim->FindMap()) return false;
-
-    m_botSpellInfo = sSpellMgr->GetSpellInfo(spellId);
-    if (!m_botSpellInfo)
-        return false;
-
-    if (spellId == MANAPOTION)
-    {
-        value = urand(me->GetMaxPower(POWER_MANA)/4, me->GetMaxPower(POWER_MANA)/2);
-        me->CastCustomSpell(victim, spellId, &value, 0, 0, true);
-        return true;
-    }
-
-    //remove shapeshifts manually to restore powers/stats
-    if (me->GetShapeshiftForm() != FORM_NONE)
-    {
-        if (m_botSpellInfo->CheckShapeshift(me->GetShapeshiftForm()) != SPELL_CAST_OK)
-            removeFeralForm(true);
-    }
-
-    if (spellId != HEALINGPOTION && spellId != MANAPOTION)
-        me->SetStandState(UNIT_STAND_STATE_STAND);
-
-    if (!victim->IsWithinLOSInMap(me) && IsInBotParty(victim))
-    {
-        //std::ostringstream msg;
-        //msg << "casting " << spellInfo->SpellName[0] << " on " << victim->GetName();
-        //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
-        me->Relocate(victim);
-    }
-
-    TriggerCastFlags flags = triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE;
-    SpellCastTargets targets;
-    targets.SetUnitTarget(victim);
-    Spell* spell = new Spell(me, m_botSpellInfo, flags, originalCaster);
-    spell->prepare(&targets); //sets current spell if succeed
-
-    bool casted = triggered; //triggered casts are casted immediately
-    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
-    {
-        if (me->GetCurrentSpell(i) == spell)
-        {
-            casted = true;
-            break;
-        }
-    }
-
-    if (!casted)
-    {
-        //failed to cast
-        //delete spell; //crash due to invalid event added to master's eventmap
-        return false;
-    }
-
-    currentSpell = spellId;
-
-    if (me->GetBotClass() == CLASS_ROGUE || GetBotStance() == DRUID_CAT_FORM || GetBotStance() == DEATH_KNIGHT_UNHOLY_PRESENCE)
-        value = int32(1000.f - 1000.f*(float(haste) / 100.f));
-    else
-        value = int32(1500.f - 1500.f*(float(haste) / 100.f));
-
-    GC_Timer = std::max<uint32>(value, 500);
-
-    return true;
-}
-//Follow point calculation
-void bot_minion_ai::_calculatePos(Position& pos)
-{
-    uint8 followdist = master->GetBotFollowDist();
-    float mydist, angle;
-
-    if (IsTank())
-    {
-        mydist = frand(3.5f, 6.5f); //stand a bit farther
-        angle = (float(M_PI)/2.f) / 16.f * frand(-3.f, 3.f); //in front +-pi/5
-    }
-    else if (IsMelee())
-    {
-        mydist = frand(0.2f, 1.f);
-        angle = (float(M_PI)/2.f) / 8.f * RAND(frand(5.f, 10.f), frand(-10.f, -5.f)); //to the sides +-(pi/3 to pi/1.6)
-    }
-    else
-    {
-        mydist = frand(0.15f, 0.8f);
-        angle = (float(M_PI)/2.f) / 6.f * frand(10.5f, 13.5f); //behind pi+-pi/4.5
-    }
-    //myangle = angle used last time
-    //if difference between last angle and cur angle is too big, use new angle
-    //else use last angle (prevent constant struggling)
-    if (abs(abs(myangle) - abs(angle)) > float(M_PI)/3.f)
-        myangle = angle;
-    else
-        angle = myangle;
-    mydist += followdist > 10 ? float(followdist - 10)/4.f : 0.f; //distance from 10+ is reduced
-    mydist = std::min<float>(mydist, 35.f); //do not spread bots too much
-    angle += master->GetOrientation();
-    float x(0),y(0),z(0);
-    float size = me->GetObjectSize()/3.f;
-    bool over = false;
-    for (uint8 i = 0; i != 5 + over; ++i)
-    {
-        if (over)
-        {
-            mydist *= 0.2f;
-            break;
-        }
-        master->GetNearPoint(me, x, y, z, size, mydist, angle);
-        if (!master->IsWithinLOS(x,y,z)) //try to get much closer to master
-        {
-            mydist *= 0.4f - float(i*0.07f);
-            size *= 0.1f;
-            if (size < 0.1)
-                size = 0.f;
-            if (size == 0.f && me->GetPositionZ() < master->GetPositionZ())
-                z += 0.25f; //prevent going underground
-        }
-        else
-            over = true;
-    }
-    pos.m_positionX = x;
-    pos.m_positionY = y;
-    pos.m_positionZ = z;
-}
-
-// Movement set
-void bot_minion_ai::SetBotCommandState(CommandStates st, bool force, Position* newpos)
-{
-    if (me->isDead() || IAmDead())
-        return;
-    if (st == COMMAND_FOLLOW && ((!me->isMoving() && !IsCasting() && master->IsAlive()) || force))
-    {
-        if (CCed(me, true)/* || master->HasUnitState(UNIT_STATE_FLEEING)*/) return;
-        if (me->isMoving() && Rand() > 25) return;
-        if (!newpos)
-            _calculatePos(pos);
-        else
-        {
-            pos.m_positionX = newpos->m_positionX;
-            pos.m_positionY = newpos->m_positionY;
-            pos.m_positionZ = newpos->m_positionZ;
-        }
-        if (me->getStandState() == UNIT_STAND_STATE_SIT && !Feasting())
-            me->SetStandState(UNIT_STAND_STATE_STAND);
-        me->GetMotionMaster()->MovePoint(master->GetMapId(), pos);
-        //me->GetMotionMaster()->MoveFollow(master, mydist, angle);
-    }
-    else if (st == COMMAND_STAY)
-    {
-        me->StopMoving();
-        me->GetMotionMaster()->Clear();
-        me->GetMotionMaster()->MoveIdle();
-    }
-    else if (st == COMMAND_ATTACK)
-    { }
-    m_botCommandState = st;
-    if (Creature* m_botsPet = me->GetBotsPet())
-        m_botsPet->SetBotCommandState(st, force);
-}
-
-void bot_pet_ai::SetBotCommandState(CommandStates st, bool force, Position* /*newpos*/)
-{
-    if (me->isDead() || IAmDead())
-        return;
-    if (st == COMMAND_FOLLOW && ((!me->isMoving() && !IsCasting() && master->IsAlive()) || force))
-    {
-        if (CCed(me, true)) return;
-        if (me->isMoving() && Rand() > 25) return;
-        Unit* followtarget = m_creatureOwner;
-        if (CCed(m_creatureOwner))
-            followtarget = master;
-        if (followtarget == m_creatureOwner)
-        {
-            if (!me->HasUnitState(UNIT_STATE_FOLLOW) || me->GetDistance(master)*0.75f < me->GetDistance(m_creatureOwner))
-                me->GetMotionMaster()->MoveFollow(m_creatureOwner, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);
-        }
-        else
-            if (!me->HasUnitState(UNIT_STATE_FOLLOW) || me->GetDistance(m_creatureOwner)*0.75f < me->GetDistance(master))
-                me->GetMotionMaster()->MoveFollow(master, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);
-    }
-    else if (st == COMMAND_STAY)//NUY
-    {
-        me->StopMoving();
-        me->GetMotionMaster()->Clear();
-        me->GetMotionMaster()->MoveIdle();
-    }
-    else if (st == COMMAND_ATTACK)
-    { }
-    m_botCommandState = st;
-}
-// Buffs And Heal (really)
-void bot_minion_ai::BuffAndHealGroup(Player* gPlayer, uint32 diff)
-{
-    if (GC_Timer > diff) return;
-    if (me->IsMounted()) return;
-    if (IsCasting() || Feasting()) return;
-
-    Group* pGroup = gPlayer->GetGroup();
-    if (!pGroup)
-    {
-        if (!master->IsInWorld() || master->IsBeingTeleported())
-            return;
-        if (HasRole(BOT_ROLE_HEAL) && HealTarget(master, GetHealthPCT(master), diff))
-            return;
-        if (BuffTarget(master, diff))
-            return;
-		for (Unit::ControlSet::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
-        {
-            Unit* u = *itr;
-            if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
-            if (HasRole(BOT_ROLE_HEAL) && HealTarget(u, GetHealthPCT(u), diff))
-                return;
-            if (Creature* cre = u->ToCreature())
-                if (cre->GetIAmABot() || cre->IsPet())
-                    if (BuffTarget(u, diff))
-                        return;
-        }
-        return;
-    }
-    bool Bots = false;
-    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-    {
-        Player* tPlayer = itr->GetSource();
-        if (tPlayer == NULL) continue;
-        if (me->GetMap() != tPlayer->FindMap()) continue;
-        if (!tPlayer->m_Controlled.empty())
-            Bots = true;
-        if (!tPlayer->IsAlive()) continue;
-        if (HasRole(BOT_ROLE_HEAL) && HealTarget(tPlayer, GetHealthPCT(tPlayer), diff))
-            return;
-        if (BuffTarget(tPlayer, diff))
-            return;
-    }
-    if (Bots)
-    {
-        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-        {
-            Player* tPlayer = itr->GetSource();
-            if (tPlayer == NULL || tPlayer->m_Controlled.empty()) continue;
-            if (me->GetMap() != tPlayer->FindMap()) continue;
-			for (Unit::ControlSet::const_iterator itr = tPlayer->m_Controlled.begin(); itr != tPlayer->m_Controlled.end(); ++itr)
-            {
-                Unit* u = *itr;
-                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
-                if (HasRole(BOT_ROLE_HEAL) && HealTarget(u, GetHealthPCT(u), diff))
-                    return;
-                if (Creature* cre = u->ToCreature())
-                    if (cre->GetIAmABot() || cre->IsPet())
-                        if (BuffTarget(u, diff))
-                            return;
-            }
-        }
-    }
-    //check if we have pointed heal target
-    if (HasRole(BOT_ROLE_HEAL))
-    {
-        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
-        {
-            if (healTargetIconFlags & GroupIconsFlags[i])
-            {
-                if (uint64 guid = pGroup->GetTargetIcons()[i])//check this one
-                {
-                    if (Unit* unit = sObjectAccessor->FindUnit(guid))
-                    {
-                        if (unit->IsAlive() && me->GetMap() == unit->FindMap() &&
-                            master->GetVictim() != unit && unit->GetVictim() != master &&
-                            unit->GetReactionTo(master) >= REP_NEUTRAL)
-                        {
-                            HealTarget(unit, GetHealthPCT(unit), diff);
-                            //CureTarget(unit, getCureSpell(), diff);
-                        }
-                    }
-                }
-            }
-        }
-    }
-}
-// Attempt to resurrect dead players using class spells
-// Target is either player or its corpse
-void bot_minion_ai::RezGroup(uint32 REZZ, Player* gPlayer)
-{
-    if (!REZZ || !gPlayer || me->IsMounted()) return;
-    if (IsCasting()) return;
-    if (rezz_cd > 0) return;
-
-    //sLog->outBasic("RezGroup by %s", me->GetName().c_str());
-    Group* pGroup = gPlayer->GetGroup();
-    if (!pGroup)
-    {
-        Unit* target = master;
-        if (master->IsAlive()) return;
-        if (master->isResurrectRequested()) return; //resurrected
-        if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
-            target = (Unit*)master->GetCorpse();
-        if (!target || !target->IsInWorld()) return;
-        if (me->GetMap() != target->FindMap()) return;
-        if (me->GetDistance(target) > 30)
-        {
-            me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
-            rezz_cd = 3;//6-9 sec reset
-            return;
-        }
-        else if (!target->IsWithinLOSInMap(me))
-            me->Relocate(*target);
-
-        if (doCast(target, REZZ))//rezzing it
-        {
-            me->MonsterWhisper(("æ­£å¨å¤æ´»ä½ ã"), master);
-            rezz_cd = 60;
-        }
-        return;
-    }
-    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-    {
-        Player* tPlayer = itr->GetSource();
-        Unit* target = tPlayer;
-        if (!tPlayer || tPlayer->IsAlive()) continue;
-        if (tPlayer->isResurrectRequested()) continue; //resurrected
-        if (Rand() > 5) continue;
-        if (tPlayer->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
-            target = (Unit*)tPlayer->GetCorpse();
-        if (!target || !target->IsInWorld()) continue;
-        if (master->GetMap() != target->FindMap()) continue;
-        if (me->GetDistance(target) > 30)
-        {
-            me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
-            rezz_cd = 3;//6-9 sec reset
-            return;
-        }
-        else if (!target->IsWithinLOSInMap(me))
-            me->Relocate(*target);
-
-        if (doCast(target, REZZ))//rezzing it
-        {
-            me->MonsterWhisper(("æ­£å¨å¤æ´»ä½ ã"), tPlayer);
-            if (tPlayer != master)
-            {
-                std::string rezstr = ("å¤æ´»ã");
-                rezstr += tPlayer->GetName();
-                me->MonsterWhisper(rezstr.c_str(), master);
-            }
-            rezz_cd = 60;
-            return;
-        }
-    }
-}
-// CURES
-//cycle through the group sending members for cure
-void bot_minion_ai::CureGroup(Player* pTarget, uint32 cureSpell, uint32 diff)
-{
-    if (!cureSpell || GC_Timer > diff) return;
-    if (me->getLevel() < 10 || pTarget->getLevel() < 10) return;
-    if (me->IsMounted()) return;
-    if (IsCasting() || Feasting()) return;
-    if (!master->GetMap()->IsRaid() && Rand() > 75) return;
-    //sLog->outBasic("%s: CureGroup() on %s", me->GetName().c_str(), pTarget->GetName().c_str());
-    Group* pGroup = pTarget->GetGroup();
-    if (!pGroup)
-    {
-        if (CureTarget(master, cureSpell, diff))
-            return;
-        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
-        {
-            Creature* cre = master->GetBotMap(i)->_Cre();
-            if (!cre || !cre->IsInWorld() || me->GetDistance(cre) > 30) continue;
-            if (CureTarget(cre, cureSpell, diff))
-                return;
-        }
-    }
-    else
-    {
-        bool Bots = false;
-        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-        {
-            Player* tPlayer = itr->GetSource();
-            if (!tPlayer || (tPlayer->isDead() && !tPlayer->HaveBot())) continue;
-            if (!Bots && tPlayer->HaveBot())
-                Bots = true;
-            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
-            if (me->GetMap() != tPlayer->FindMap()) continue;
-            if (me->GetDistance(tPlayer) > 30) continue;
-            if (CureTarget(tPlayer, cureSpell, diff))
-                return;
-        }
-        if (!Bots) return;
-        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-        {
-            Player* tPlayer = itr->GetSource();
-            if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
-            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
-            if (me->GetMap() != tPlayer->FindMap()) continue;
-            for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
-            {
-                Creature* cre = tPlayer->GetBotMap(i)->_Cre();
-                if (!cre || !cre->IsInWorld() || me->GetDistance(cre) > 30) continue;
-                if (CureTarget(cre, cureSpell, diff))
-                    return;
-            }
-        }
-    }
-}
-
-bool bot_minion_ai::CureTarget(Unit* target, uint32 cureSpell, uint32 diff)
-{
-    return _canCureTarget(target, cureSpell, diff) ? doCast(target, cureSpell) : false;
-}
-// determines if unit has something to cure
-bool bot_minion_ai::_canCureTarget(Unit* target, uint32 cureSpell, uint32 diff) const
-{
-    if (!cureSpell || GC_Timer > diff) return false;
-    if (!target || !target->IsAlive()) return false;
-    if (me->getLevel() < 10 || target->getLevel() < 10) return false;
-    if (me->IsMounted()) return false;
-    if (IsCasting() || Feasting()) return false;
-    if (me->GetDistance(target) > 30) return false;
-    if (!IsInBotParty(target)) return false;
-
-    SpellInfo const* info = sSpellMgr->GetSpellInfo(cureSpell);
-    if (!info)
-        return false;
-
-    uint32 dispelMask = 0;
-    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
-        if (info->Effects[i].Effect == SPELL_EFFECT_DISPEL)
-            dispelMask |= SpellInfo::GetDispelMask(DispelType(info->Effects[i].MiscValue));
-
-    if (dispelMask == 0)
-        return false;
-
-    DispelChargesList dispel_list;
-    _getBotDispellableAuraList(target, me, dispelMask, dispel_list);
-
-    return !(dispel_list.empty());
-}
-
-void bot_minion_ai::_getBotDispellableAuraList(Unit* target, Unit* caster, uint32 dispelMask, DispelChargesList& dispelList) const
-{
-    if (dispelMask & (1 << DISPEL_DISEASE) && target->HasAura(50536))
-        dispelMask &= ~(1 << DISPEL_DISEASE);
-
-    Unit::AuraMap const& auras = target->GetOwnedAuras();
-    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
-    {
-        Aura* aura = itr->second;
-
-        if (aura->IsPassive())
-            continue;
-
-        AuraApplication* aurApp = aura->GetApplicationOfTarget(target->GetGUID());
-        if (!aurApp)
-            continue;
-
-        if (aura->GetSpellInfo()->GetDispelMask() & dispelMask)
-        {
-            //do not dispel positive auras from enemies and negative ones from friends
-            if (aurApp->IsPositive() == target->IsFriendlyTo(caster))
-                continue;
-
-            //skip Vampiric Touch to prevent being CCed just heal it out
-            if (aura->GetSpellInfo()->IsRankOf(sSpellMgr->GetSpellInfo(34914)))
-                continue;
-
-            uint8 charges = (aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES) ? aura->GetCharges() : aura->GetStackAmount();
-            if (charges > 0)
-                dispelList.push_back(std::make_pair(aura, charges));
-        }
-    }
-}
-//protected
-bool bot_ai::HasAuraName(Unit* unit, uint32 spellId, uint64 casterGuid, bool exclude) const
-{
-    ASSERT(spellId);
-
-    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
-    if (!spellInfo)
-    {
-		//slog
-        //TC_LOG_FATAL("entities.player", "bot_ai::HasAuraName(uint32): no spellInfo found for spell %u!", spellId);
-        ASSERT(false);
-    }
-
-    uint8 loc = master->GetSession()->GetSessionDbcLocale();
-    std::string const name = spellInfo->SpellName[loc];
-
-    return _hasAuraName(unit, name, casterGuid, exclude);
-}
-//private
-bool bot_ai::_hasAuraName(Unit* unit, std::string const spell, uint64 casterGuid, bool exclude) const
-{
-/*
-    ASSERT(unit);
-    ASSERT(spell.length() != 0);
-*/
-
-    uint8 loc = master->GetSession()->GetSessionDbcLocale();
-
-    Unit::AuraMap const& vAuras = unit->GetOwnedAuras();
-    SpellInfo const* spellInfo;
-    std::string name;
-
-    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
-    {
-        spellInfo = itr->second->GetSpellInfo();
-        name = spellInfo->SpellName[loc];
-        if (spell == name)
-            if (casterGuid == 0 || (exclude == (casterGuid != itr->second->GetCasterGUID())))
-                return true;
-    }
-
-    return false;
-}
-//LIST AURAS
-// Debug: Returns bot's info to called player
-void bot_ai::_listAuras(Player* player, Unit* unit) const
-{
-    if (!IsInBotParty(player)) 
-		return;
-    if (!IsInBotParty(unit)) 
-		return;
-    ChatHandler ch(player->GetSession());
-    std::ostringstream botstring;
-    if (unit->GetTypeId() == TYPEID_PLAYER)
-        botstring << ("ç©å®¶ã");
-    else if (unit->GetTypeId() == TYPEID_UNIT)
-    {
-        if (unit->ToCreature()->GetIAmABot())
-        {
-            botstring << ("å°ä¼ä¼´ã, ä¸»äººã: ");
-            std::string const& ownername = unit->ToCreature()->GetBotOwner()->GetName();
-            botstring << ownername;
-        }
-        else if (unit->ToCreature()->GetIAmABotsPet())
-        {
-            Player* owner = unit->ToCreature()->GetBotOwner();
-            Creature* creowner = unit->ToCreature()->GetBotPetAI()->GetCreatureOwner();
-            std::string const& ownername = owner ? owner->GetName() : ("æ ã");
-            std::string const& creownername = creowner ? creowner->GetName() : ("æ ã");
-            botstring << ("å°ä¼ä¼´çå® ç©ã, ä¸»äººã: ");
-            botstring << ownername;
-            botstring << (", å°ä¼ä¼´çä¸»äººã: ");
-            botstring << creownername;
-            if (creowner)
-                botstring << " (" << creowner->GetGUIDLow() << ')';
-        }
-    }
-	ch.PSendSysMessage(sCustomMgr->Format(("%sçå±æ§åè¡¨ã, %s"), unit->GetName().c_str(), botstring.str().c_str()).c_str());
-
-	if (unit == me)
-    {
-		for (uint8 i = STAT_STRENGTH; i != MAX_STATS; ++i)
-		{
-			std::string mystat;
-			switch (i)
-			{
-			case STAT_STRENGTH:	 mystat = ("åé"); break;
-			case STAT_AGILITY:	 mystat = ("ææ·"); break;
-			case STAT_STAMINA:	 mystat = ("èå"); break;
-			case STAT_INTELLECT: mystat = ("æºå"); break;
-			case STAT_SPIRIT:	 mystat = ("ç²¾ç¥"); break;
-			default: mystat = ("æªç¥å±æ§ã"); break;
-			}
-			ch.PSendSysMessage("%s: %.1f", mystat.c_str(), unit->GetTotalStatValue(Stats(i)));
-		}
-		ch.PSendSysMessage(sCustomMgr->Format(("æ¤ç²: %u"), unit->GetArmor()).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("æ´å»: %0.1f"), unit->GetUnitCriticalChance(BASE_ATTACK, me)).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("èº²éª: %0.1f"), unit->GetUnitDodgeChance()).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("ææ¶: %0.1f"), unit->GetUnitParryChance()).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("æ ¼æ¡: %0.1f"), unit->GetUnitBlockChance()).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("æ ¼æ¡å¼: %u"), unit->GetShieldBlockValue()).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("è¿ææ»å»å¼ºåº¦: %0.1f"), unit->GetTotalAttackPowerValue(BASE_ATTACK)).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("è¿ç¨æ»å»å¼ºåº¦: %0.1f"), unit->GetTotalAttackPowerValue(RANGED_ATTACK)).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("æ®éä¼¤å®³å æ: %0.3f"), unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL)).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("æ³æ¯ä¼¤å®³å æ: %0.3f"), unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_MAGIC)).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("ä¸»æä¼¤å®³èå´: æå°: %0.1f, æå¤§: %0.1f"), unit->GetFloatValue(UNIT_FIELD_MINDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXDAMAGE)).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("å¯æä¼¤å®³èå´: æå°: %0.1f, æå¤§: %0.1f"), unit->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE)).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("è¿ç¨ä¼¤å®³èå´: æå°: %0.1f, æå¤§: %0.1f"), unit->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE)).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("ä¸»æä¼¤å®³å æ: %0.3f"), unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT)).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("å¯æä¼¤å®³å æ: %0.3f"), unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT)).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("è¿ç¨ä¼¤å®³å æ: %0.3f"), unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT)).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("ä¸»ææ»å»éåº¦: %0.2f"), float(unit->GetAttackTime(BASE_ATTACK)) / 1000.f).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("å¯ææ»å»éåº¦: %0.2f"), float(unit->GetAttackTime(OFF_ATTACK)) / 1000.f).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("è¿ç¨æ»å»éåº¦: %0.2f"), float(unit->GetAttackTime(RANGED_ATTACK)) / 1000.f).c_str());
-		if (unit == me)
-			ch.PSendSysMessage(sCustomMgr->Format(("è¿æä¼¤å®³åç: %0.3f"), dmgmult_melee).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("åºç¡çå½å¼: %u"), unit->GetCreateHealth()).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("å½åçå½å¼: %u"), unit->GetMaxHealth()).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("åºç¡æ³åå¼: %u"), unit->GetCreateMana()).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("å½åæ³åå¼: %u"), unit->GetMaxPower(POWER_MANA)).c_str());
-
-        for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
-        {
-            const char* resist = NULL;
-            switch (i)
-            {
-			case 1: resist = ("ç¥å£");   break;
-			case 2: resist = ("ç«ç°");   break;
-			case 3: resist = ("èªç¶"); break;
-			case 4: resist = ("å°é");  break;
-			case 5: resist = ("æå½±"); break;
-			case 6: resist = ("å¥¥æ¯"); break;
-            }
-            ch.PSendSysMessage("%sææ§: %u", resist, me->GetResistance(SpellSchools(i)));
-        }
-		//ch.PSendSysMessage(Format(("å°ä¼ä¼´æ§å¶ç¶æã: %s", m_botCommandState == COMMAND_FOLLOW ? "è·éã" : m_botCommandState == COMMAND_ATTACK ? "æ»å»ã" : m_botCommandState == COMMAND_STAY ? "åçã" : m_botCommandState == COMMAND_ABANDON ? "éç½®ã" : "æ ã")).c_str());
-		ch.PSendSysMessage(sCustomMgr->Format(("è·éè·ç¦»ã: %u"), master->GetBotFollowDist()).c_str());
-    }
-}
-//SetStats
-// Health, Armor, Powers, Combat Ratings, and global update setup
-void bot_minion_ai::SetStats(bool force, bool shapeshift)
-{
-    uint8 myclass = me->GetBotClass();
-    uint8 mylevel = master->getLevel();
-    if (myclass == CLASS_DRUID)
-        myclass = GetBotStance();
-    if (myclass != DRUID_BEAR_FORM && myclass != DRUID_CAT_FORM && (master->isDead() || (!shouldUpdateStats && !force))) return;
-    /*sLog->outBasic("SetStats(): Updating bot %s, class: %u, race: %u, level %u, master: %s",
-        me->GetName().c_str(), myclass, myrace, mylevel, master->GetName().c_str());*/
-
-    mylevel = std::min<uint8>(mylevel, 80);
-
-    //Do not remove this code under any circumstances! You've been warned.
-    if (myclass == CLASS_DEATH_KNIGHT)
-        mylevel = std::max<uint8>(mylevel, 55);
-
-    //LEVEL
-    if (me->getLevel() != mylevel)
-    {
-        me->SetLevel(mylevel);
-        force = true; //restore powers on lvl update
-    }
-    if (force)
-    {
-        InitPowers();
-        InitSpells();
-        //ApplyPassives(me->GetBotClass());
-
-        //need to find a way to remove all passives before reapply (except levelups)
-        //!!!this is only for gm's (players are not supposed to lower their level)
-        ApplyClassPassives();
-    }
-
-    //PHASE
-    if (master->GetPhaseMask() != me->GetPhaseMask())
-        me->SetPhaseMask(master->GetPhaseMask(), true);
-    //INIT STATS
-    //partially receive master's stats and get base class stats, we'll need all this later
-    uint8 tempclass = myclass == DRUID_BEAR_FORM || myclass == DRUID_CAT_FORM ? CLASS_DRUID : myclass;
-    sObjectMgr->GetPlayerClassLevelInfo(tempclass, mylevel, _classinfo);
-    const CreatureBaseStats* const classstats = sObjectMgr->GetCreatureBaseStats(mylevel, me->getClass());//use creature class
-    float value;
-    if (force)
-        for (uint8 i = STAT_STAMINA; i < MAX_STATS; i++)
-            me->SetCreateStat(Stats(i), master->GetCreateStat(Stats(i)));
-
-    //MAXSTAT
-    for (uint8 i = 0; i < MAX_STATS; ++i)
-    {
-        value = master->GetTotalStatValue(Stats(i));
-        if (i == 0 || value > stat)
-            stat = value; //Get Hightest stat (on first cycle just set base value)
-    }
-    stat = std::max(stat - 18.f, 0.f); //base value for all stats is 18 (isn't counted in any way)
-
-    //INIT CLASS MODIFIERS
-    switch (myclass)
-    {
-        case CLASS_WARRIOR:      ap_mod = 1.3f; spp_mod = 0.0f; armor_mod = 1.4f;  crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 0.75f; parry_mod = 1.75f; break;
-        case CLASS_DEATH_KNIGHT: ap_mod = 1.2f; spp_mod = 0.0f; armor_mod = 1.05f; crit_mod = 1.1f; haste_mod = 1.05f; dodge_mod = 0.6f;  parry_mod = 1.95f;  break;
-        case CLASS_PALADIN:      ap_mod = 1.0f; spp_mod = 0.8f; armor_mod = 1.2f;  crit_mod = 0.8f; haste_mod = 0.85f; dodge_mod = 0.7f;  parry_mod = 1.5f;  break;
-        case CLASS_ROGUE:        ap_mod = 1.5f; spp_mod = 0.0f; armor_mod = 0.7f;  crit_mod = 1.5f; haste_mod = 1.35f; dodge_mod = 1.5f;  parry_mod = 0.8f;  break;
-        case CLASS_HUNTER:       ap_mod = 1.7f; spp_mod = 0.2f; armor_mod = 1.0f;  crit_mod = 1.2f; haste_mod = 1.85f; dodge_mod = 1.3f;  parry_mod = 1.2f;  break;
-        case CLASS_SHAMAN:       ap_mod = 1.1f; spp_mod = 0.5f; armor_mod = 1.1f;  crit_mod = 1.1f; haste_mod = 1.45f; dodge_mod = 1.1f;  parry_mod = 1.4f;  break;
-        case CLASS_DRUID:        ap_mod = 0.0f; spp_mod = 1.3f; armor_mod = 0.7f;  crit_mod = 0.7f; haste_mod = 1.95f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
-        case CLASS_MAGE:         ap_mod = 0.0f; spp_mod = 0.8f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
-        case CLASS_PRIEST:       ap_mod = 0.0f; spp_mod = 1.2f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
-        case CLASS_WARLOCK:      ap_mod = 0.0f; spp_mod = 1.0f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
-        case DRUID_BEAR_FORM:    ap_mod = 2.0f; spp_mod = 1.3f; armor_mod = 2.25f; crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 2.5f;  parry_mod = 0.0f;  break;
-        case DRUID_CAT_FORM:     ap_mod = 1.5f; spp_mod = 1.3f; armor_mod = 1.1f;  crit_mod = 1.5f; haste_mod = 2.25f; dodge_mod = 1.35f; parry_mod = 0.0f;  break;
-        default:                 ap_mod = 0.0f; spp_mod = 0.0f; armor_mod = 0.0f;  crit_mod = 0.0f; haste_mod = 0.00f; dodge_mod = 0.0f;  parry_mod = 0.0f;  break;
-    }
-    if (spp_mod != 0.f && mylevel > 39)
-        spp_mod *= (float(mylevel - 39))/41.f;// gain spell power slowly
-
-    //DAMAGE
-    _OnMeleeDamageUpdate(myclass);
-
-    //ARMOR
-    //sLog->outBasic("Unpdating %s's ARMOR: ", me->GetName().c_str());
-    //sLog->outBasic("armor mod: %f", armor_mod);
-    armor_mod *= (master->GetModifierValue(UNIT_MOD_ARMOR, BASE_PCT) + master->GetModifierValue(UNIT_MOD_ARMOR, TOTAL_PCT))/2.f;
-    //sLog->outBasic("armor mod * master's modifier: %f", armor_mod);
-    value = float(classstats->BaseArmor / 2);
-    //sLog->outBasic("base armor: %f", value);
-    value += float(master->GetArmor())/5.f;
-    //sLog->outBasic("base armor + 1/5 of master's armor: %f", value);
-
-    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
-        value += _stats[i][BOT_ITEM_MOD_ARMOR];
-
-    if (IsTank())
-        armor_mod += 0.5f;
-    if (GetBotStance() == DEATH_KNIGHT_FROST_PRESENCE)
-        armor_mod += 0.6f;
-
-    value *= armor_mod;
-    //sLog->outBasic("multiplied by armor mod (total base armor): %f", value);
-    me->SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, value);
-    me->UpdateArmor();//buffs will be took in consideration here
-
-    //RESISTANCES
-    //sLog->outBasic("Unpdating %s's RESISTANCES: ", me->GetName().c_str());
-    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
-    {
-        value = float(master->GetResistance(SpellSchools(i)));
-
-        for (uint8 j = 0; j != BOT_INVENTORY_SIZE; ++j)
-            value += 2.5f * (_stats[j][BOT_ITEM_MOD_RESIST_HOLY + (i - 1)]);
-
-        //sLog->outBasic("master's resistance %u: %f, setting %f (triple) to bot", uint32(UNIT_MOD_RESISTANCE_START + i), value, value*3);
-        me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_VALUE, value * 2.f + float(mylevel * 2));
-        //me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_PCT, 1.f);
-        me->UpdateResistances(i);
-    }
-    //DAMAGE TAKEN
-    float directReduction = master->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL);
-    float magicReduction = master->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_MAGIC);
-    value = (directReduction + magicReduction)/2.f; // average
-    if (value > 1.f)
-        value -= 1.f;
-    else
-        value = 1.f - value; //get reduction even if master's is 1.0+
-    value = std::min(0.42f, value);
-    value/= 0.01f; //here we get percent like 0.42/0.01 = 42% (value * 100.f)
-    if (mylevel > 77)
-        value += float(mylevel - 78)*6.f;// + 2 stacks for high level
-    RefreshAura(DMG_TAKEN, int8(value/6.f));//so max aura count = 10
-
-    //HEALTH
-    _OnHealthUpdate();
-
-    //HASTE
-    value = 0.f;
-    for (uint8 i = CR_HASTE_MELEE; i != CR_HASTE_SPELL + 1; ++i)
-        if (float rating = std::min<float>(master->GetRatingBonusValue(CombatRating(i)), 30.f))
-            if (rating > value) //master got some haste
-                value = rating; //get hightest pct
-    for (uint8 i = EQUIPMENT_SLOT_BACK; i < EQUIPMENT_SLOT_END; ++i)
-        if (Item* item = master->GetItemByPos(0, i)) //inventory weapons
-            if (item->GetTemplate()->ItemLevel >= 277) //bears ICC 25H LK items or Wrathful items
-                value += 9.f; //only weapons so we can add 1 to 3 stacks (rogue, warr, sham...)
-
-    if (mylevel >= 70)
-    {
-        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
-        {
-            //25.5 HR = 1% haste at 80 (12.75 for bot)
-            float tempval = _stats[i][ITEM_MOD_HASTE_MELEE_RATING] + _stats[i][ITEM_MOD_HASTE_RANGED_RATING] + _stats[i][ITEM_MOD_HASTE_SPELL_RATING] + _stats[i][ITEM_MOD_HASTE_RATING];
-            value += 3.f * (tempval / (25.5f * (float(mylevel - 40) / 40.f)));
-        }
-    }
-
-    value *= haste_mod;
-    if (IsMeleeClass(myclass))
-        value *= 0.67f; //nerf melee haste by 1/3
-    value = value/10.f + float(mylevel/39);//get bonus at 39 and 78
-    if (myclass == DRUID_CAT_FORM) //give cat lots of haste
-        value += float(mylevel/16); //or 20 (+ 4-5 stacks);
-    RefreshAura(HASTE,  uint8(value) + uint8(myclass == CLASS_SHAMAN) * 2); //spell haste
-    RefreshAura(HASTE2, uint8(value) + uint8(myclass == CLASS_ROGUE)); //melee haste
-    if (myclass == CLASS_ROGUE || myclass == CLASS_HUNTER)
-        RefreshAura(HASTE3, uint8(value) + uint8(myclass == CLASS_HUNTER) * 2); //ranged haste
-    haste = uint8(value); //for show only
-
-    //HIT
-    int32 melee_hit = master->GetTotalAuraModifier(SPELL_AURA_MOD_HIT_CHANCE) + master->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE) + master->GetRatingBonusValue(CR_HIT_MELEE);
-    int32 spell_hit = master->GetTotalAuraModifier(SPELL_AURA_MOD_SPELL_HIT_CHANCE) + master->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_INCREASES_SPELL_PCT_TO_HIT, SPELL_SCHOOL_MASK_SPELL) + master->GetRatingBonusValue(CR_HIT_SPELL);
-    value = std::min<float>(25.0f, float(melee_hit > spell_hit ? melee_hit : spell_hit) * 1.5f); //hightest, buff hit chance for bots
-
-    if (mylevel >= 20)
-    {
-        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
-        {
-            //32.5 HR = 1% hit at 80
-            float tempval = _stats[i][ITEM_MOD_HIT_MELEE_RATING] + _stats[i][ITEM_MOD_HIT_RANGED_RATING] + _stats[i][ITEM_MOD_HIT_SPELL_RATING] + _stats[i][ITEM_MOD_HIT_RATING];
-            value += 5.f * (tempval / (32.5f * (float(mylevel - 10) / 70.f)));
-        }
-    }
-
-    hit = value;
-    RefreshAura(PRECISION,  int8(hit) + mylevel / 39); //melee
-    RefreshAura(PRECISION2, int8(hit) + mylevel / 39); //spell
-
-    //EXPERTISE
-    if (ap_mod > 0.f) //don't bother casters
-    {
-        m_expertise = std::min<int32>(80, (master->GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) + master->GetRatingBonusValue(CR_EXPERTISE)) * 2); //lots of expertise for bots
-
-        if (mylevel >= 20)
-        {
-            for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
-            {
-                //~8.0 ER = 1 expertise at 80
-                float tempval = _stats[i][ITEM_MOD_EXPERTISE_RATING];
-                m_expertise += int32(2.f * (tempval / (8.0f * (float(mylevel - 10) / 70.f))));
-            }
-        }
-
-        if (m_expertise < 20)
-            RefreshAura(EXPERTISE,  int8(m_expertise / 5)  + mylevel / 39); //5  expertise + 10
-        else
-            RefreshAura(EXPERTISE2, int8(m_expertise / 10) + mylevel / 39); //10 expertise + 20
-    }
-    else
-        m_expertise = 0;
-
-    //CRIT
-    //chose melee or ranged cuz crit rating increases melee/spell, and hunter benefits from agility
-    value = std::min<float>(50.0f, master->GetUnitCriticalChance((master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK), me));
-    value = value > 5.f ? value - 5.f : 0.f; //remove base chance if can
-
-    if (mylevel >= 10)
-    {
-        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
-        {
-            //45 CR = 1% crit at 80
-            float tempval = _stats[i][ITEM_MOD_CRIT_MELEE_RATING] + _stats[i][ITEM_MOD_CRIT_RANGED_RATING] + _stats[i][ITEM_MOD_CRIT_SPELL_RATING] + _stats[i][ITEM_MOD_CRIT_RATING];
-            value += 1.5f * (tempval / (45.f * (float(mylevel - 5) / 75.f)));
-        }
-    }
-
-    value *= crit_mod;
-    RefreshAura(CRITS, int8(value / 5.f) + 1);
-    if (myclass == CLASS_PRIEST)
-        RefreshAura(HOLYCRIT, int8(value / 7.f)); //add holy crit to healers
-
-    //PARRY
-    value = 0.5f * master->GetFloatValue(PLAYER_PARRY_PERCENTAGE);
-    value = value > 5.f ? value - 5.f : 0.f; //remove base chance if possible
-
-    if (mylevel >= 30)
-    {
-        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
-        {
-            //67 PR = 1% parry at 80
-            float tempval = _stats[i][ITEM_MOD_PARRY_RATING];
-            value += 1.5f * (tempval / (67.f * (float(mylevel - 20) / 60.f)));
-            //125 DR = 1% block/parry/dodge at 80
-            tempval = _stats[i][ITEM_MOD_DEFENSE_SKILL_RATING];
-            value += 1.5f * (tempval / (125.f * (float(mylevel - 20) / 60.f)));
-        }
-    }
-
-    value *= parry_mod;
-    if (IsTank() && myclass != DRUID_CAT_FORM && myclass != DRUID_BEAR_FORM) //feral cannot parry so let it be base 5%
-        value += 10.f;
-    //Forceful Deflection: 12.5% (half of base 25%) of strength (use max stat) goes to parry rating (~1% parry per 67 rating at 80)
-    if (myclass == CLASS_DEATH_KNIGHT/* && mylevel >= 55*/)
-        value += (stat / 8.f) / (float(mylevel) - (13.f / (float(mylevel - 40) / 40.f))); //~20 at 55, ~34 at 60 and 67 at 80
-    if (value > 35.f)
-        value = 35.f;
-    float parryAndDodge = value; //set temp value, this is needed to keep total avoidance within 40%
-    RefreshAura(PARRY, int8(value/5.f)); //5% per stack aplied
-
-    //DODGE
-    value = 0.5f * master->GetUnitDodgeChance();
-    value = value > 5.f ? value - 5.f : 0.f; //remove base chance if possible
-
-    if (mylevel >= 20)
-    {
-        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
-        {
-            //53 DR = 1% dodge at 80
-            float tempval = _stats[i][ITEM_MOD_DODGE_RATING];
-            value += 1.5f * (tempval / (53.f * (float(mylevel - 10) / 70.f)));
-            //125 DR = 1% block/parry/dodge at 80
-            tempval = _stats[i][ITEM_MOD_DEFENSE_SKILL_RATING];
-            value += 1.5f * (tempval / (125.f * (float(mylevel - 10) / 70.f)));
-        }
-    }
-
-    value *= dodge_mod;
-    if (IsTank())
-        value += 10.f;
-    if (value > 35.f)
-        value = 35.f;
-    if (parryAndDodge + value > 35.f)
-        value = 35.f - parryAndDodge; //do not allow avoidance to be more than 40% (base 5+5)
-    RefreshAura(DODGE, int8(value / 5.f));
-
-    //BLOCK
-    if (!(me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK))
-    {
-        value = master->GetFloatValue(PLAYER_BLOCK_PERCENTAGE);
-        if (mylevel >= 10)
-        {
-            for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
-            {
-                //16.5 BR = 1% block at 80
-                float tempval = _stats[i][ITEM_MOD_BLOCK_RATING];
-                value += 1.5f * (tempval / (16.5f * (float(mylevel - 5) / 75.f)));
-                //125 DR = 1% block/parry/dodge at 80
-                tempval = _stats[i][ITEM_MOD_DEFENSE_SKILL_RATING];
-                value += 2.5f * (tempval / (125.f * (float(mylevel - 5) / 75.f)));
-            }
-        }
-
-        if (IsTank())
-            value += 15.f;
-        value = std::min<float>(value, 75.0f);
-        RefreshAura(BLOCK, int8(value / 5.f));
-
-        //BLOCK VALUE
-        float tempval = float(mylevel + mylevel / 4);
-        //tempval += master->GetShieldBlockValue();
-        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
-        {
-            tempval += 0.75f * (_stats[i][ITEM_MOD_STRENGTH]);
-            tempval += 1.25f * (_stats[i][ITEM_MOD_BLOCK_VALUE]);
-        }
-
-        //Shield Mastery
-        if (mylevel >= 20 && myclass == CLASS_WARRIOR)
-            tempval *= 1.3f;
-
-        tempval = std::max<float>(tempval - 10.f, 1.f);
-
-        m_block = uint32(tempval);
-    }
-    else
-        m_block = 1;
-
-    //MANA
-    _OnManaUpdate(shapeshift);
-
-    //MANA REGEN
-    if (mylevel >= 40 && (me->getPowerType() == POWER_MANA || me->getPowerType() == POWER_RUNIC_POWER))
-    {
-        regen_mp5 = 0.5f * master->GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER);
-        //TOO COMPLICATED
-        //regen_mp5 = (master->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, POWER_MANA) + sqrt(master->GetStat(STAT_INTELLECT)) * master->OCTRegenMPPerSpirit()) / 5.f;
-        //Unit::AuraEffectList const& regenAura = master->GetAuraEffectsByType(SPELL_AURA_MOD_MANA_REGEN_FROM_STAT);
-        //for (Unit::AuraEffectList::const_iterator i = regenAura.begin(); i != regenAura.end(); ++i)
-        //    regen_mp5 += master->GetStat(Stats((*i)->GetMiscValue())) * (*i)->GetAmount() / 500.f;
-        //regen_mp5 *= 0.8f;//custom modifier
-        float regen_mp5_a = stat * 0.2f;
-        //regen_mp5 += master->GetTotalStatValue(STAT_SPIRIT) * 0.1f;
-        regen_mp5 = regen_mp5 > regen_mp5_a ? regen_mp5 : regen_mp5_a;
-
-        //unknown values
-        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
-        {
-            regen_mp5 += 2.f * (_stats[i][ITEM_MOD_MANA_REGENERATION]);
-            regen_mp5 += 1.f * (_stats[i][ITEM_MOD_SPIRIT]);
-        }
-
-        if (myclass == CLASS_HUNTER && mylevel > 20)
-            regen_mp5 += 45.f * ((mylevel - 20) / 15 + 1);
-        if (regen_mp5 >= 45.f)
-        {
-            me->RemoveAurasDueToSpell(MANAREGEN100);
-            me->RemoveAurasDueToSpell(MANAREGEN45);
-            if      (regen_mp5 > 200.f)   RefreshAura(MANAREGEN100,int8(regen_mp5/100.f) + mylevel / 20);
-            else/*if (regen_mp5 > 150.f)*/RefreshAura(MANAREGEN45, int8(regen_mp5/45.f)  + mylevel / 20);
-        }
-    }
-
-    //SPELL PENETRATION
-    if (mylevel >= 30 && spp_mod > 0.f)
-    {
-        m_spellpen = std::min<int32>(200, master->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, SPELL_SCHOOL_MASK_SPELL) / 2);
-
-        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
-        {
-            //~1 SPPR = 1 spell penetration
-            m_spellpen += 5 * _stats[i][ITEM_MOD_SPELL_PENETRATION];
-        }
-
-        if (m_spellpen < 25)
-            RefreshAura(SPELL_PEN_5,  int8(m_spellpen / 5)  + mylevel / 20); //5  sppen + 20
-        else
-            RefreshAura(SPELL_PEN_20, int8(m_spellpen / 20) + mylevel / 40); //20 sppen + 40
-    }
-    else
-        m_spellpen = 0;
-
-    //SPELL POWER
-    if (mylevel >= 40 && spp_mod > 0.f)
-    {
-        //sLog->outBasic("Updating spellpower for %s:", me->GetName().c_str());
-        //sLog->outBasic("spp_mod: %f", spp_mod);
-        for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
-        {
-            int32 power = master->SpellBaseDamageBonusDone(SpellSchoolMask(1 << i));
-            if (power > sppower || i == SPELL_SCHOOL_HOLY)
-                sppower = power;
-        }
-        //sLog->outBasic("Master's spell power: %i", sppower);
-        atpower = master->GetTotalAttackPowerValue(master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK);
-        atpower *= 0.67f;
-        //sLog->outBasic("Master's 2/3 of attack power: %f", atpower);
-        m_spellpower = sppower > atpower ? sppower : atpower;
-        //sLog->outBasic("Chosen stat value: %i", m_spellpower);
-
-        m_spellpower /= 3; //reduce spellpower since we have items
-
-        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
-            m_spellpower += 2 * (_stats[i][ITEM_MOD_SPELL_POWER]);
-
-        m_spellpower = int32(float(m_spellpower) * spp_mod);
-        //sLog->outBasic("spellpower * mod: %i", m_spellpower);
-
-        if (myclass == CLASS_MAGE)
-            RefreshAura(FIREDAM_86, (m_spellpower / 4) / 86 + (mylevel >= 78) * 2); //(86,172,258,344,430,516,602,688...) // fire spp, do not touch this
-        me->RemoveAurasDueToSpell(SPELL_BONUS_250);
-        me->RemoveAurasDueToSpell(SPELL_BONUS_150);
-        me->RemoveAurasDueToSpell(SPELL_BONUS_50);
-        if      (mylevel < 60) RefreshAura(SPELL_BONUS_50,  m_spellpower / 50);
-        else if (mylevel < 80) RefreshAura(SPELL_BONUS_150, m_spellpower / 150 + 1);
-        else                   RefreshAura(SPELL_BONUS_250, m_spellpower / 250 + 2);
-    }
-
-    if (force)
-    {
-        me->SetFullHealth();
-        me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
-    }
-
-    //SetStats for pet
-    if (Creature* pet = me->GetBotsPet())
-        if (bot_pet_ai* petai = pet->GetBotPetAI())
-            petai->SetStats(force);
-
-    shouldUpdateStats = false;
-}
-void bot_pet_ai::SetStats(bool force)
-{
-    uint8 mylevel = master->getLevel();
-    uint8 petType = GetPetType(me);
-    if (petType == PET_TYPE_NONE || petType >= MAX_PET_TYPES) return;
-    if (!shouldUpdateStats && !force) return;
-    //////TC_LOG_ERROR("entities.player", "SetStats(): Updating pet bot %s, type: %u, level %u, owner: %s, master: %s", me->GetName().c_str(), petType, mylevel, m_creatureOwner->GetName().c_str(), master->GetName().c_str());
-
-    //LEVEL
-    if (me->getLevel() != mylevel)
-    {
-        me->SetLevel(mylevel);
-        force = true; //restore powers on lvl update
-    }
-    if (force)
-    {
-        InitPowers();
-        InitSpells();
-        //ApplyPassives(me->GetBotClass());
-
-        //need to find a way to remove all passives before reapply (except levelups)
-        //!!!this is only for gm's (players are not supposed to lower their level)
-        ApplyClassPassives();
-    }
-
-    //PHASE
-    if (master->GetPhaseMask() != me->GetPhaseMask())
-        me->SetPhaseMask(master->GetPhaseMask(), true);
-
-    ////INIT STATS
-    //uint8 botclass = m_creatureOwner->GetBotClass();
-    //sObjectMgr->GetPlayerClassLevelInfo(botclass, m_creatureOwner->getLevel(), _classinfo);
-    //const CreatureBaseStats* const classstats = sObjectMgr->GetCreatureBaseStats(mylevel, me->GetBotClass());//use creature class
-    //if (force)
-    //    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; i++)
-    //        me->SetCreateStat(Stats(i), master->GetCreateStat(Stats(i))*0.5f);
-
-    //MAXSTAT
-    float value;
-    for (uint8 i = 0; i < MAX_STATS; ++i)
-    {
-        value = master->GetTotalStatValue(Stats(i));
-        if (i == 0 || value > stat)
-            stat = value;//Get Hightest stat (on first cycle just set base value)
-    }
-    stat = std::max(stat - 18.f, 0.f);//remove base
-
-    //INIT CLASS MODIFIERS
-    //STAT -- 'mod' -- used stat values to apply
-    //WARLOCK
-    //Stamina x0.3  -- health
-    //Armor   x0.35 -- armor
-    //Int     x0.3  -- crit/mana
-    //Spd     x0.15 -- spd (if has mana)
-    //AP      x0.57 -- attack power (if melee pet)
-    //Resist  x0.4  -- resistances
-    //MAGE
-    //
-    //SHAMAN
-    //
-    //HUNTER
-    //Other   x1.0  -- use as default
-    switch (petType)
-    {
-        case PET_TYPE_VOIDWALKER:       ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;
-        //case PET_TYPE_FELHUNTER:        ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
-        //case PET_TYPE_FELGUARD:         ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
-        //case PET_TYPE_SUCCUBUS:         ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
-        //case PET_TYPE_IMP:              ap_mod = 0.f;   spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
-
-        //case PET_TYPE_WATER_ELEMENTAL:  ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
-
-        //case PET_TYPE_FIRE_ELEMENTAL:   ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
-        //case PET_TYPE_EARTH_ELEMENTAL:  ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
-
-        //case PET_TYPE_VULTURE:          ap_mod = 0.9f;  spp_mod = 1.0f; crit_mod = 1.2f; break;//NYI
-        default:                        ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;
-    }
-    //case CLASS_WARRIOR:      ap_mod = 1.3f;  spp_mod = 0.0f; armor_mod = 1.4f;  crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 0.75f; parry_mod = 1.75f; break;
-    //case CLASS_DEATH_KNIGHT: ap_mod = 1.2f;  spp_mod = 1.0f; armor_mod = 1.15f; crit_mod = 0.9f; haste_mod = 0.65f; dodge_mod = 0.8f;  parry_mod = 2.0f;  break;//NYI
-    //case CLASS_PALADIN:      ap_mod = 1.0f;  spp_mod = 0.8f; armor_mod = 1.2f;  crit_mod = 0.8f; haste_mod = 0.85f; dodge_mod = 0.7f;  parry_mod = 1.5f;  break;
-    //case CLASS_ROGUE:        ap_mod = 1.5f;  spp_mod = 0.0f; armor_mod = 0.7f;  crit_mod = 1.5f; haste_mod = 1.35f; dodge_mod = 1.5f;  parry_mod = 0.8f;  break;//NYI
-    //case CLASS_HUNTER:       ap_mod = 1.15f; spp_mod = 0.0f; armor_mod = 0.85f; crit_mod = 1.2f; haste_mod = 1.25f; dodge_mod = 1.2f;  parry_mod = 1.2f;  break;//NYI
-    //case CLASS_SHAMAN:       ap_mod = 0.9f;  spp_mod = 1.0f; armor_mod = 0.9f;  crit_mod = 1.2f; haste_mod = 1.65f; dodge_mod = 0.8f;  parry_mod = 0.5f;  break;//NYI
-    //case CLASS_DRUID:        ap_mod = 0.0f;  spp_mod = 1.3f; armor_mod = 0.7f;  crit_mod = 0.7f; haste_mod = 1.95f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
-    //case CLASS_MAGE:         ap_mod = 0.0f;  spp_mod = 0.8f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
-    //case CLASS_PRIEST:       ap_mod = 0.0f;  spp_mod = 1.2f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
-    //case CLASS_WARLOCK:      ap_mod = 0.0f;  spp_mod = 1.0f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
-    //case BEAR:               ap_mod = 2.0f;  spp_mod = 1.3f; armor_mod = 2.25f; crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 2.5f;  parry_mod = 0.0f;  break;
-    //case CAT:                ap_mod = 1.5f;  spp_mod = 1.3f; armor_mod = 1.1f;  crit_mod = 1.5f; haste_mod = 2.25f; dodge_mod = 1.35f; parry_mod = 0.0f;  break;
-
-    if (spp_mod != 0.f && mylevel > 39)
-        spp_mod *= (float(mylevel - 39)) / 41.f;// gain spell power slowly
-
-    //DAMAGE
-    if (ap_mod > 0.f)//do not bother casters
-    {
-        switch (m_creatureOwner->GetBotClass())
-        {
-            case CLASS_WARLOCK:
-                value = float(m_creatureOwner->GetBotAI()->GetSpellPower());
-                break;
-            case CLASS_DEATH_KNIGHT:
-                value = m_creatureOwner->GetTotalAttackPowerValue(BASE_ATTACK);
-                break;
-            case CLASS_HUNTER:
-                value = m_creatureOwner->GetTotalAttackPowerValue(RANGED_ATTACK);
-                break;
-            default: //some weird class or NYI
-                value = 0.f;
-                break;
-        }
-        //Calculate ap
-        //set base strength
-        me->SetModifierValue(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, me->GetCreateStat(STAT_STRENGTH) - 9.f);
-        //calc attack power (strength and minion's spd)
-        atpower = me->GetTotalAuraModValue(UNIT_MOD_STAT_STRENGTH) * 2.f + value * ap_mod;
-        //set value
-        me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
-        me->UpdateAttackPowerAndDamage();
-    }
-
-    //ARMOR
-    value = float(basearmor);
-    //get minion's armor and give 35% to pet (just as for real pets)
-    value += m_creatureOwner->GetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE) * 0.35f;
-    me->SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, value);
-    me->UpdateArmor();//buffs will be took in consideration here
-
-    //RESISTANCES
-    //based on minion's resistances gain x0.4
-    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
-    {
-        value = float(master->GetResistance(SpellSchools(i)));
-        me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_VALUE, 0.4f * (value * 2.5f + float(mylevel * 2)));
-        me->UpdateResistances(i);
-    }
-
-    //DAMAGE TAKEN
-    //just get minion's reduction and apply to pet
-    value = m_creatureOwner->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL);
-    if (value > 1.f)
-        value -= 1.f;
-    else
-        value = 1.f - value; //get reduction even if owner's is 1.0+
-    value = std::min(0.42f, value);
-    value/= 0.01f; //here we get percent like 0.42/0.01 = 42% (value * 100.f)
-    RefreshAura(DMG_TAKEN, int8(value/6.f));//so max aura count = 10
-
-    //HEALTH
-    _OnHealthUpdate();
-
-//////RATINGS//////
-    //ok now, pet receives 100% of its master's ratings
-
-    //HASTE
-    haste = m_creatureOwner->GetBotAI()->GetHaste();
-    RefreshAura(HASTE,  haste);//spell haste
-    RefreshAura(HASTE2, haste);//melee haste
-
-    //HIT
-    hit = m_creatureOwner->GetBotAI()->GetHitRating();
-    RefreshAura(PRECISION,  int8(hit) + mylevel / 39);//melee
-    RefreshAura(PRECISION2, int8(hit) + mylevel / 39);//spell
-
-    //CRIT
-    //chose melee or ranged cuz crit rating increases melee/spell, and hunter benefits from agility
-    value = master->GetUnitCriticalChance((master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK), me);
-    if (crit_mod != 1.0f)
-        value *= crit_mod;
-    RefreshAura(CRITS, int8(value / 5.f) + mylevel / 39);
-
-    //PARRY
-    value = master->GetFloatValue(PLAYER_PARRY_PERCENTAGE);
-    if (IsTank())
-        value += 10.f;
-    if (value > 65.f)
-        value = 65.f;
-    float parryAndDodge = value; //set temp value, this is needed to keep total avoidance within 75%
-    RefreshAura(PARRY, int8(value / 5.f));
-
-    //DODGE
-    value = master->GetUnitDodgeChance();
-    value = value > 5.f ? value - 5.f : 0.f; //remove base chance if possible
-    if (IsTank())
-        value += 10.f;
-    if (value > 65.f)
-        value = 65.f;
-    if (parryAndDodge + value > 65.f)
-        value = 65.f - parryAndDodge; //do not allow avoidance to be more than 75% (base 5+5)
-    RefreshAura(DODGE, int8(value / 5.f));
-
-    //MANA
-    _OnManaUpdate(false);
-
-    //MANA REGEN
-    if (mylevel >= 40 && me->getPowerType() == POWER_MANA)
-    {
-        //let regen rate be same as stats rate x0.3
-        regen_mp5 = m_creatureOwner->GetBotAI()->GetManaRegen() * 0.3f;
-        if (regen_mp5 >= 45.f)
-        {
-            me->RemoveAurasDueToSpell(MANAREGEN100);
-            me->RemoveAurasDueToSpell(MANAREGEN45);
-            if      (regen_mp5 > 200.f)   RefreshAura(MANAREGEN100,int8(regen_mp5 / 100.f) + mylevel / 20);
-            else/*if (regen_mp5 > 150.f)*/RefreshAura(MANAREGEN45, int8(regen_mp5 / 45.f)  + mylevel / 20);
-        }
-    }
-
-    //SPELL POWER
-    if (mylevel >= 40 && spp_mod != 0.f)
-    {
-        switch (m_creatureOwner->GetBotClass())
-        {
-            case CLASS_WARLOCK:
-                value = float(m_creatureOwner->GetBotAI()->GetSpellPower());
-                break;
-            case CLASS_DEATH_KNIGHT:
-                value = m_creatureOwner->GetTotalAttackPowerValue(BASE_ATTACK);
-                break;
-            case CLASS_HUNTER:
-                value = m_creatureOwner->GetTotalAttackPowerValue(RANGED_ATTACK);
-                break;
-            default: //some weird class or NYI
-                value = 0.f;
-                break;
-        }
-        m_spellpower = int32(value * spp_mod);
-        me->RemoveAurasDueToSpell(SPELL_BONUS_250);
-        me->RemoveAurasDueToSpell(SPELL_BONUS_150);
-        me->RemoveAurasDueToSpell(SPELL_BONUS_50);
-        if      (mylevel < 60) RefreshAura(SPELL_BONUS_50,  m_spellpower / 50);
-        else if (mylevel < 80) RefreshAura(SPELL_BONUS_150, m_spellpower / 150 + 1);
-        else                   RefreshAura(SPELL_BONUS_250, m_spellpower / 250 + 2);
-    }
-
-    if (force)
-    {
-        me->SetFullHealth();
-        me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
-    }
-
-    shouldUpdateStats = false;
-}
-//Emotion-based action
-void bot_ai::ReceiveEmote(Player* player, uint32 emote)
-{
-    switch (emote)
-    {
-        case TEXT_EMOTE_BONK:
-            _listAuras(player, me);
-            break;
-        case TEXT_EMOTE_SALUTE:
-            _listAuras(player, player);
-            break;
-        case TEXT_EMOTE_STAND:
-            if (!IsMinionAI())
-                return;
-            if (master != player)
-            {
-                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
-                return;
-            }
-            SetBotCommandState(COMMAND_STAY);
-            me->MonsterWhisper(("åå°å¾å½ï¼ã"), player);
-            break;
-        case TEXT_EMOTE_WAVE:
-            if (!IsMinionAI())
-                return;
-            if (master != player)
-            {
-                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
-                return;
-            }
-            SetBotCommandState(COMMAND_FOLLOW, true);
-            me->MonsterWhisper(("è·ä¸ï¼ã"), player);
-            break;
-        default:
-            break;
-    }
-}
-
-//ISINBOTPARTY
-//Returns group members (and their npcbots too)
-//For now all your puppets are in your group automatically
-bool bot_ai::IsInBotParty(Unit* unit) const
-{
-    if (!unit || !unit->IsInWorld()) return false;
-    if (unit == me || unit == master) return true;
-
-    //cheap check
-    if (Group* gr = master->GetGroup())
-    {
-        //group member case
-        if (gr->IsMember(unit->GetGUID()))
-            return true;
-        //pointed target case
-        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
-            if (healTargetIconFlags & GroupIconsFlags[i])
-                if (uint64 guid = gr->GetTargetIcons()[i])//check this one
-                    if (guid == unit->GetGUID())
-                        if (unit->GetReactionTo(master) >= REP_NEUTRAL &&
-                            master->GetVictim() != unit &&
-                            unit->GetVictim() != master)
-                            return true;
-    }
-
-    //Player-controlled creature case
-    if (Creature* cre = unit->ToCreature())
-    {
-        if (Player* owner = cre->GetBotOwner())
-        {
-            if (owner == master)
-                return true;
-        }
-        //pets, minions, guardians etc.
-        else
-        {
-            uint64 ownerGuid = unit->GetOwnerGUID();
-            //controlled by group member
-            if (Group* gr = master->GetGroup())
-                if (gr->IsMember(ownerGuid))
-                    return true;
-        }
-    }
-
-    return false;
-}
-
-//REFRESHAURA
-//Applies/reapplies aura stacks
-bool bot_ai::RefreshAura(uint32 spell, int8 count) const
-{
-    if (!spell)
-        return false;
-    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell);
-    if (!spellInfo)
-        return false;
-    //if (!spellInfo->IsPassive())
-    //{
-    //    ////TC_LOG_ERROR("entities.player", "bot_ai::RefreshAura(): %s received spell %u (%s) which is not a passive spell!", target->GetName().c_str(), spell, spellInfo->SpellName[0]);
-    //    //return false;
-    //}
-    if (me->HasAura(spell))
-        me->RemoveAurasDueToSpell(spell);
-
-    //if (count > 15)
-    //    ////TC_LOG_ERROR("entities.player", "bot_ai::RefreshAura(): %s's aura count for spell %u (%s) is greater than 15... (%i)", target->GetName().c_str(), spell, spellInfo->SpellName, count);
-
-    for (uint8 i = 0; i < count; ++i)
-        me->AddAura(spellInfo, MAX_EFFECT_MASK, me);
-    return true;
-}
-//CHECKAURAS
-//Updates bot's condition once a while
-void bot_minion_ai::CheckAuras(bool force)
-{
-    opponent = me->GetVictim(); //safe
-
-    if (!force)
-        _updateRations(); //safe
-
-    if (checkAurasTimer == 0)
-    {
-        checkAurasTimer = 10 + master->GetNpcBotsCount()/2;
-
-        if (m_botCommandState != COMMAND_FOLLOW && m_botCommandState != COMMAND_STAY && opponent && !CCed(me, true))
-        {
-            if (IsMelee())
-            {
-                if (me->GetDistance(opponent) > 1.5f)
-                    GetInPosition(true);
-            }
-            else
-            {
-                CalculateAttackPos(opponent, attackpos);
-                if (me->GetDistance(attackpos) > 8)
-                    GetInPosition(true, opponent, &attackpos);
-            }
-        }
-        if (shouldUpdateStats)
-            SetStats(false);
-        else
-        {
-            UpdateHealth();
-            UpdateMana();
-        }
-        if (rezz_cd > 0)
-            --rezz_cd;
-        if (clear_cd > 0)
-            --clear_cd;
-        else
-            clear_cd = 15;
-        return;
-    }
-    else if (force)
-    {
-        if (!opponent)
-        {
-            if (master->isDead())
-            {
-                //If ghost move to corpse, else move to dead player
-                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
-                {
-                    Corpse* corpse = master->GetCorpse();
-                    if (corpse && me->GetMap() == corpse->FindMap() && !me->IsInCombat() && !me->HasUnitState(UNIT_STATE_MOVING) && !IsCasting() && !CCed(me) && me->GetDistance(corpse) > 5)
-                        me->GetMotionMaster()->MovePoint(corpse->GetMapId(), *corpse);
-                }
-                else
-                {
-                    if (m_botCommandState != COMMAND_FOLLOW || me->GetDistance(master) > 30 - 20 * (!me->IsWithinLOSInMap(master)))
-                        Follow(true);
-                }
-            }
-            else if (m_botCommandState != COMMAND_STAY && !IsCasting())
-            {
-                _calculatePos(pos);
-                uint8 followdist = master->GetBotFollowDist();
-                if (me->GetExactDist(&pos) > (followdist > 8 ? 4 + followdist/2*(!master->isMoving()) : 8))
-                    Follow(true, &pos); //check if doing nothing
-            }
-        }
-        if (!IsCasting())
-        {
-            if (me->IsInCombat())
-            {
-                if (me->GetBotClass() == CLASS_HUNTER)
-                {
-                    if (me->GetSheath() != SHEATH_STATE_RANGED)
-                        me->SetSheath(SHEATH_STATE_RANGED);
-                }
-                else if (me->GetSheath() != SHEATH_STATE_MELEE)
-                    me->SetSheath(SHEATH_STATE_MELEE);
-            }
-            else if (me->IsStandState() && me->GetSheath() != SHEATH_STATE_UNARMED && Rand() < 50)
-                me->SetSheath(SHEATH_STATE_UNARMED);
-        }
-        _updateMountedState();
-        _updateStandState();
-    }
-}
-void bot_pet_ai::CheckAuras(bool /*force*/)
-{
-    if (checkAurasTimer > 0) return;
-    checkAurasTimer = 10 + master->GetNpcBotsCount()/2;
-    if (m_botCommandState != COMMAND_FOLLOW && m_botCommandState != COMMAND_STAY)
-    {
-        opponent = me->GetVictim();
-        if (opponent)
-        {
-            switch (GetPetType(me))
-            {
-                case PET_TYPE_IMP:
-                    CalculateAttackPos(opponent, attackpos);
-                    if (me->GetDistance(attackpos) > 8)
-                        GetInPosition(true, opponent, &attackpos);
-                    break;
-                default:
-                    if (me->GetDistance(opponent) > 1.5f)
-                        GetInPosition(true);
-                    break;
-            }
-        }
-    }
-    if (clear_cd > 0)
-        --clear_cd;
-    else
-        clear_cd = 15;
-
-    return;
-}
-
-bool bot_ai::CanBotAttack(Unit* target, int8 byspell) const
-{
-    if (!target)
-        return false;
-    if (!PvP && (target->ToPlayer() || (target->ToCreature() && target->ToCreature()->GetBotAI())))
-        return false;
-    if (target->ToCreature() &&
-        (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE) ||
-         target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_ATTACKABLE_1) ||
-         target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC) ||
-         target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_NPC) ||
-         target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE)))
-        return false;
-    uint8 followdist = master->GetBotFollowDist();
-    float foldist = _getAttackDistance(float(followdist));
-    return
-       (target->IsAlive() &&
-       target->IsVisible() &&
-       (master->isDead() || target->GetTypeId() == TYPEID_PLAYER || target->IsPet() ||
-       (target->GetDistance(master) < foldist && me->GetDistance(master) < followdist)) &&//if master is killed pursue to the end
-        target->isTargetableForAttack() &&
-        !IsInBotParty(target) &&
-        (target->IsHostileTo(master) ||
-        (target->GetReactionTo(master) < REP_FRIENDLY && master->GetVictim() == target && (master->IsInCombat() || target->IsInCombat())) ||//master has pointed this target
-        target->IsHostileTo(me)) &&//if master is controlled
-        //target->IsWithinLOSInMap(me) &&
-        (byspell == -1 || !target->IsImmunedToDamage(byspell ? SPELL_SCHOOL_MASK_MAGIC : SPELL_SCHOOL_MASK_NORMAL)));
-}
-//GETTARGET
-//Returns attack target or 'no target'
-//uses follow distance if range isn't set
-Unit* bot_ai::_getTarget(bool byspell, bool ranged, bool &reset) const
-{
-    //check if no need to change target
-    Unit* u = master->GetVictim();
-    if (master->GetTypeId() == TYPEID_PLAYER &&
-        master->ToPlayer()->GetSelectedUnit() &&
-        (master->ToPlayer()->GetSelectedUnit()->IsHostileTo(master) ||
-         (master->ToPlayer()->GetSelectedUnit()->GetReactionTo(master) < REP_FRIENDLY && master->ToPlayer()->GetSelectedUnit()->GetVictim() && (master->ToPlayer()->GetSelectedUnit()->GetVictim()->GetTypeId() == TYPEID_PLAYER || (master->ToPlayer()->GetSelectedUnit()->GetVictim()->GetTypeId() == TYPEID_UNIT && (master->ToPlayer()->GetSelectedUnit()->GetVictim()->ToCreature()->GetIAmABot() || master->ToPlayer()->GetSelectedUnit()->GetVictim()->ToCreature()->GetIAmABotsPet()))))) &&
-        !master->ToPlayer()->GetSelectedUnit()->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE) &&
-        !master->ToPlayer()->GetSelectedUnit()->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_ATTACKABLE_1) &&
-        !master->ToPlayer()->GetSelectedUnit()->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC) &&
-        !master->ToPlayer()->GetSelectedUnit()->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
-        u = master->ToPlayer()->GetSelectedUnit();
-    Unit* mytar = me->GetVictim();
-    if (!mytar && IsMinionAI())
-        if (Creature* pet = me->GetBotsPet())
-            mytar = pet->GetVictim();
-
-    //////TC_LOG_ERROR("entities.player", "bot_ai::getTarget(): bot: %s, PvP = %u", me->GetName().c_str(), PvP);
-
-    if (u && u == mytar)
-    {
-        //////TC_LOG_ERROR("entities.player", "bot %s continues attack common target %s", me->GetName().c_str(), u->GetName().c_str());
-        return u;//forced
-    }
-    //Follow if...
-    uint8 followdist = master->GetBotFollowDist();
-    float foldist = _getAttackDistance(float(followdist));
-    if (!u && master->IsAlive() && (me->GetDistance(master) > foldist || (mytar && master->GetDistance(mytar) > foldist && me->GetDistance(master) > foldist)))
-    {
-        //////TC_LOG_ERROR("entities.player", "bot %s cannot attack target %s, too far away", me->GetName().c_str(), mytar ? mytar->GetName().c_str() : "");
-        return NULL;
-    }
-
-    if (u && (master->IsInCombat() || u->IsInCombat()) && !InDuel(u) && !IsInBotParty(u) && !(!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI()))))
-    {
-        //////TC_LOG_ERROR("entities.player", "bot %s starts attack master's target %s", me->GetName().c_str(), u->GetName().c_str());
-        return u;
-    }
-
-    if (CanBotAttack(mytar, byspell) && !InDuel(mytar))
-    {
-        //////TC_LOG_ERROR("entities.player", "bot %s continues attack its target %s", me->GetName().c_str(), mytar->GetName().c_str());
-        if (me->GetDistance(mytar) > (ranged ? 20.f : 5.f) && m_botCommandState != COMMAND_STAY && m_botCommandState != COMMAND_FOLLOW)
-            reset = true;
-        return mytar;
-    }
-
-    if (followdist == 0 && master->IsAlive())
-        return NULL; //do not bother
-
-    //check group
-    Group* gr = master->GetGroup();
-    if (!gr)
-    {
-        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
-        {
-            Creature* bot = master->GetBotMap(i)->_Cre();
-            if (!bot || !bot->InSamePhase(me) || bot == me) continue;
-            u = bot->GetVictim();
-            if (u && CanBotAttack(u, byspell) &&
-                (bot->IsInCombat() || u->IsInCombat()) &&
-                (master->isDead() || master->GetDistance(u) < foldist))
-            {
-                //////TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
-                return u;
-            }
-            Creature* pet = bot->GetIAmABot() ? bot->GetBotsPet() : NULL;
-            if (!pet || !pet->InSamePhase(me)) continue;
-            u = pet->GetVictim();
-            if (u && CanBotAttack(u, byspell) &&
-                (pet->IsInCombat() || u->IsInCombat()) &&
-                (master->isDead() || master->GetDistance(u) < foldist))
-            {
-                //////TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), pet->GetName().c_str(), u->GetName().c_str());
-                return u;
-            }
-        }
-    }
-    else
-    {
-        for (GroupReference* ref = gr->GetFirstMember(); ref != NULL; ref = ref->next())
-        {
-            Player* pl = ref->GetSource();
-            if (!pl || !pl->IsInWorld() || pl->IsBeingTeleported()) continue;
-            if (me->GetMap() != pl->FindMap() || !pl->InSamePhase(me)) continue;
-            u = pl->GetVictim();
-            if (u && pl != master && CanBotAttack(u, byspell) &&
-                (pl->IsInCombat() || u->IsInCombat()) &&
-                (master->isDead() || master->GetDistance(u) < foldist))
-            {
-                //////TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), pl->GetName().c_str(), u->GetName().c_str());
-                return u;
-            }
-            if (!pl->HaveBot()) continue;
-            for (uint8 i = 0; i != pl->GetMaxNpcBots(); ++i)
-            {
-                Creature* bot = pl->GetBotMap(i)->_Cre();
-                if (!bot || !bot->InSamePhase(me) || bot == me) continue;
-                if (!bot->IsInWorld()) continue;
-                if (me->GetMap() != bot->FindMap()) continue;
-                u = bot->GetVictim();
-                if (u && CanBotAttack(u, byspell) &&
-                    (bot->IsInCombat() || u->IsInCombat()) &&
-                    (master->isDead() || master->GetDistance(u) < foldist))
-                {
-                    //////TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
-                    return u;
-                }
-                Creature* pet = bot->GetIAmABot() ? bot->GetBotsPet() : NULL;
-                if (!pet || !pet->InSamePhase(me)) continue;
-                if (!pet->IsInWorld()) continue;
-                if (me->GetMap() != pet->FindMap()) continue;
-                u = pet->GetVictim();
-                if (u && CanBotAttack(u, byspell) &&
-                    (pet->IsInCombat() || u->IsInCombat()) &&
-                    (master->isDead() || master->GetDistance(u) < foldist))
-                {
-                    //////TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), pet->GetName().c_str(), u->GetName().c_str());
-                    return u;
-                }
-            }
-        }
-    }
-
-    //check targets around
-    Unit* t = NULL;
-    float maxdist = InitAttackRange(float(followdist), ranged);
-    //first cycle we search non-cced target, then, if not found, check all
-    for (uint8 i = 0; i != 2; ++i)
-    {
-        if (!t)
-        {
-            bool attackCC = false;
-            if (i = 1)
-                attackCC = true;
-            else
-                attackCC = false;
-
-            CellCoord p(acore::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
-            Cell cell(p);
-            cell.SetNoCreate();
-
-            NearestHostileUnitCheck check(me, maxdist, byspell, this, attackCC);
-            acore::UnitLastSearcher <NearestHostileUnitCheck> searcher(master, t, check);
-            me->VisitNearbyObject(maxdist, searcher);
-        }
-    }
-
-    if (t && opponent && t != opponent)
-    {
-        //////TC_LOG_ERROR("entities.player", "bot %s has Found new target %s", me->GetName().c_str(), t->GetName().c_str());
-        reset = true;
-    }
-    return t;
-}
-//'CanAttack' function
-bool bot_ai::CheckAttackTarget(uint8 botOrPetType)
-{
-    bool byspell = false, ranged = !IsMelee(), reset = false;
-
-    if (IsMinionAI())
-    {
-        switch (botOrPetType)
-        {
-            case CLASS_DRUID:
-                byspell = me->GetShapeshiftForm() == FORM_NONE ||
-                    me->GetShapeshiftForm() == FORM_TREE ||
-                    me->GetShapeshiftForm() == FORM_MOONKIN;
-                ranged = byspell;
-                break;
-            case CLASS_PRIEST:
-            case CLASS_MAGE:
-            case CLASS_WARLOCK:
-            case CLASS_SHAMAN:
-                byspell = true;
-            default:
-                break;
-        }
-    }
-    else
-    {
-        switch (botOrPetType)
-        {
-            case PET_TYPE_IMP:
-                byspell = true;
-                ranged = true;
-                break;
-            default:
-                break;
-        }
-    }
-
-    opponent = _getTarget(byspell, ranged, reset);
-    if (!opponent)
-    {
-        me->AttackStop();
-        return false;
-    }
-
-    if (reset)
-        m_botCommandState = COMMAND_ABANDON;//reset AttackStart()
-
-    if (opponent != me->GetVictim())
-        me->Attack(opponent, !ranged);
-
-    return true;
-}
-//POSITION
-void bot_ai::CalculateAttackPos(Unit* target, Position& pos) const
-{
-    uint8 followdist = master->GetBotFollowDist();
-    float x(0),y(0),z(0),
-        dist = float(6 + urand(followdist/4, followdist/3)),
-        angle = target->GetAngle(me);
-    dist = std::min(dist, 20.f);
-    if (me->GetIAmABotsPet())
-        dist *= 0.5f;
-    float clockwise = RAND(1.f,-1.f);
-    for (uint8 i = 0; i != 5; ++i)
-    {
-        target->GetNearPoint(me, x, y, z, me->GetObjectSize()/2.f, dist, angle);
-        bool toofaraway = master->GetDistance(x,y,z) > (followdist > 28 ? 28.f : followdist < 20 ? 20.f : float(followdist));
-        bool outoflos = !target->IsWithinLOS(x,y,z);
-        if (toofaraway || outoflos)
-        {
-            if (toofaraway)
-                angle = target->GetAngle(master) + frand(0.f, float(M_PI)*0.5f) * clockwise;
-            if (outoflos)
-                dist *= 0.5f;
-        }
-        else
-        {
-            dist *= 0.75f;
-            break;
-        }
-    }
-    pos.m_positionX = x;
-    pos.m_positionY = y;
-    pos.m_positionZ = z;
-}
-// Forces bot to chase opponent (if ranged then distance depends on follow distance)
-void bot_ai::GetInPosition(bool force, Unit* newtarget, Position* mypos)
-{
-    if (me->HasUnitState(UNIT_STATE_ROOT)) return;
-    if (!newtarget)
-        newtarget = me->GetVictim();
-    if (!newtarget)
-        return;
-    if ((!newtarget->IsInCombat() || m_botCommandState == COMMAND_STAY) && !force)
-        return;
-    if (IsCasting())
-        return;
-    uint8 followdist = master->GetBotFollowDist();
-    bool ranged = !IsMelee();
-    if (ranged)
-    {
-        if (newtarget->GetTypeId() == TYPEID_PLAYER &&
-            me->GetDistance(newtarget) < 6 + urand(followdist/4, followdist/3)) return;//do not allow constant runaway from player
-        if (!mypos)
-            CalculateAttackPos(newtarget, attackpos);
-        else
-        {
-            attackpos.m_positionX = mypos->m_positionX;
-            attackpos.m_positionY = mypos->m_positionY;
-            attackpos.m_positionZ = mypos->m_positionZ;
-        }
-        if (me->GetDistance(attackpos) > (me->GetBotClass() == CLASS_HUNTER ? 4 : 8))
-            me->GetMotionMaster()->MovePoint(newtarget->GetMapId(), attackpos);
-    }
-    else if (!me->HasUnitState(UNIT_STATE_CHASE) || !me->HasUnitState(UNIT_STATE_CHASE_MOVE))
-        me->GetMotionMaster()->MoveChase(newtarget);
-
-    if (newtarget != me->GetVictim())
-        me->Attack(newtarget, !ranged);
-}
-
-void bot_ai::CheckAttackState()
-{
-    if (me->GetVictim())
-    {
-        if (HasRole(BOT_ROLE_DPS))
-            DoMeleeAttackIfReady();
-    }
-    else
-        Evade();
-}
-
-bool bot_ai::MoveBehind(Unit &target) const
-{
-    if (me->HasUnitState(UNIT_STATE_ROOT)) return false;
-    if (target.IsWithinCombatRange(me, ATTACK_DISTANCE) &&
-        target.HasInArc(float(M_PI), me)                &&
-        !IsTank()                                       &&
-        (me->GetBotClass() == CLASS_ROGUE ? target.GetVictim() != me || CCed(&target) : target.GetVictim() != me && !CCed(&target)))
-    {
-        float x(0),y(0),z(0);
-        target.GetNearPoint(me, x, y, z, me->GetObjectSize()/3, 0.1f, me->GetAngle(&target));
-        me->GetMotionMaster()->MovePoint(target.GetMapId(), x, y, z);
-        return true;
-    }
-    return false;
-}
-//MOUNT SUPPORT
-void bot_minion_ai::_updateMountedState()
-{
-    if (GetBotCommandState() != COMMAND_FOLLOW)
-        return;
-
-    bool aura = me->HasAuraType(SPELL_AURA_MOUNTED);
-    bool mounted = me->IsMounted();
-    if ((!master->IsMounted() || aura != mounted || (me->IsInCombat() && opponent)) && (aura || mounted))
-    {
-        //const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->InhabitType &= ~INHABIT_AIR;
-        me->RemoveAurasByType(SPELL_AURA_MOUNTED);
-        //me->RemoveUnitMovementFlag(MOVEMENTFLAG_HOVER);
-        me->SetCanFly(false);
-        me->SetDisableGravity(false);
-        me->SetSpeed(MOVE_FLIGHT, master->GetSpeedRate(MOVE_FLIGHT) * 1.37f);
-        me->SetSpeed(MOVE_RUN, master->GetSpeedRate(MOVE_RUN) * 1.25f);
-        me->RemoveUnitMovementFlag(MOVEMENTFLAG_FALLING);
-        me->Dismount();
-        return;
-    }
-    if (me->IsInCombat() || IsCasting() || me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING)) //IsInWater() is too much calculations
-        return;
-    //fly
-    //if ((master->IsMounted() && master->HasAuraType(SPELL_AURA_FLY))/* || master->HasUnitMovementFlag(MOVEMENTFLAG_CAN_FLY) || master->HasUnitMovementFlag(MOVEMENTFLAG_FLYING)*/)
-    //{
-    //    if (!me->IsMounted() || !me->HasAuraType(SPELL_AURA_FLY))
-    //    {
-    //        //if (me->GetBotClass() == CLASS_DRUID && InitSpell(FLY_FORM))//TODO
-    //        //{
-    //        //}
-    //        //else
-    //        {
-    //            uint32 mount = 0;
-    //            Unit::AuraEffectList const &mounts = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
-    //            if (!mounts.empty())
-    //                mount = mounts.front()->GetId();
-    //            if (mount)
-    //            {
-    //                if (me->HasAuraType(SPELL_AURA_MOUNTED))
-    //                        me->RemoveAurasByType(SPELL_AURA_MOUNTED);
-    //                if (doCast(me, mount))
-    //                {
-    //                    if (Feasting())
-    //                    {
-    //                        me->RemoveAurasDueToSpell(DRINK);
-    //                        me->RemoveAurasDueToSpell(EAT);
-    //                    }
-    //                }
-    //            }
-    //        }
-    //    }
-    //}
-    ////ground
-    /*else */
-    if (master->IsMounted() && !me->IsMounted() && !master->IsInCombat() && !me->IsInCombat() && !me->GetVictim())
-    {
-        uint32 mount = 0;
-        Unit::AuraEffectList const &mounts = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
-        if (!mounts.empty())
-        {
-            //Winter Veil addition
-            if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
-                mount = master->CanFly() ? REINDEER_FLY : REINDEER;
-            else
-                mount = mounts.front()->GetId();
-        }
-        if (mount)
-        {
-            if (me->HasAuraType(SPELL_AURA_MOUNTED))
-                me->RemoveAurasByType(SPELL_AURA_MOUNTED);
-            if (Feasting())
-            {
-                me->RemoveAurasDueToSpell(DRINK);
-                me->RemoveAurasDueToSpell(EAT);
-            }
-            if (doCast(me, mount))
-            {
-                return;
-            }
-        }
-    }
-}
-//STANDSTATE
-void bot_minion_ai::_updateStandState() const
-{
-    if (master->getStandState() == UNIT_STAND_STATE_STAND &&
-        me->getStandState() == UNIT_STAND_STATE_SIT &&
-        !(me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED))
-        me->SetStandState(UNIT_STAND_STATE_STAND);
-    if ((master->getStandState() == UNIT_STAND_STATE_SIT || Feasting()) && !me->IsInCombat() && !me->isMoving() &&
-        me->getStandState() == UNIT_STAND_STATE_STAND)
-        me->SetStandState(UNIT_STAND_STATE_SIT);
-
-}
-//RATIONS
-void bot_minion_ai::_updateRations()
-{
-    if (mana_cd > RATIONS_CD)
-        mana_cd = uint32(-1);
-    if (health_cd > RATIONS_CD)
-        health_cd = uint32(-1);
-
-    if (me->IsInCombat() || CCed(me))
-    {
-        if (health_cd <= RATIONS_CD && me->HasAura(EAT))
-        {
-            health_cd = uint32(-1);
-            me->RemoveAurasDueToSpell(EAT);
-        }
-        if (mana_cd <= RATIONS_CD && me->HasAura(DRINK))
-        {
-            mana_cd = uint32(-1);
-            me->RemoveAurasDueToSpell(DRINK);
-        }
-
-        return;
-    }
-
-    //drink
-    if (me->getPowerType() == POWER_MANA && !me->IsMounted() && !me->isMoving() &&
-        !me->IsInCombat() && !IsCasting() && urand(0, 100) < 20 && GetManaPCT(me) < 80 &&
-        !me->HasAura(DRINK))
-    {
-        mana_cd = RATIONS_CD;
-        me->CastSpell(me, DRINK);
-        me->SetStandState(UNIT_STAND_STATE_SIT);
-    }
-    if (mana_cd == 0 && me->getPowerType() == POWER_MANA && me->GetPower(POWER_MANA) < me->GetMaxPower(POWER_MANA))
-    {
-        mana_cd = RATIONS_CD;
-        me->ModifyPower(POWER_MANA, me->GetMaxPower(POWER_MANA) / (RATIONS_CD / 40)/*1000/40=25*/); //4% per second
-    }
-
-    //eat
-    if (!me->IsMounted() && !me->isMoving() && !me->IsInCombat() && !IsCasting() &&
-        urand(0, 100) < 20 && GetHealthPCT(me) < 80 &&
-        !me->HasAura(EAT))
-    {
-        health_cd = RATIONS_CD;
-        me->CastSpell(me, EAT);
-        me->SetStandState(UNIT_STAND_STATE_SIT);
-    }
-    if (health_cd == 0 && me->GetHealth() < me->GetMaxHealth() && me->HasAura(EAT))
-    {
-        health_cd = RATIONS_CD;
-        me->SetHealth(me->GetHealth() + me->GetMaxHealth() / (RATIONS_CD / 50)/*1000/50=20*/); //5% per second
-    }
-
-    //check
-    if (health_cd <= RATIONS_CD && me->GetHealth() >= me->GetMaxHealth() && me->HasAura(EAT))
-    {
-        health_cd = uint32(-1);
-        me->RemoveAurasDueToSpell(EAT);
-    }
-
-    if (mana_cd <= RATIONS_CD && me->getPowerType() == POWER_MANA &&
-        me->GetPower(POWER_MANA) >= me->GetMaxPower(POWER_MANA) &&
-        me->HasAura(DRINK))
-    {
-        mana_cd = uint32(-1);
-        me->RemoveAurasDueToSpell(DRINK);
-    }
-}
-//PASSIVES
-// Used to apply common passives (run once)
-void bot_ai::ApplyPassives(uint8 botOrPetType) const
-{
-    //me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
-    //me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
-
-    //movement speed
-    if (master->HasAuraType(SPELL_AURA_MOD_SPEED_ALWAYS) ||
-        master->HasAuraType(SPELL_AURA_MOD_SPEED_NOT_STACK) ||
-        master->HasAuraType(SPELL_AURA_MOD_INCREASE_SPEED))
-        RefreshAura(BOAR);
-
-    //apply +healing taken
-    if (master->getLevel() >= 40)
-        RefreshAura(BOR);//+40%
-
-    if (IsMinionAI())
-    {
-        //apply -threat mod
-        switch (botOrPetType)
-        {
-            case CLASS_WARRIOR:
-            case CLASS_DEATH_KNIGHT:
-                RefreshAura(RCP, 1 * !IsTank()); //-27%
-                break;
-            case CLASS_PRIEST:
-            case CLASS_MAGE:
-            case CLASS_ROGUE:
-            case CLASS_HUNTER:
-            case CLASS_SHAMAN:
-                RefreshAura(RCP, 3 * !IsTank()); //-87%
-                break;
-            default:
-                RefreshAura(RCP, 2 * !IsTank()); //-54%
-                break;
-        }
-        //apply +threat mod
-        RefreshAura(DEFENSIVE_STANCE_PASSIVE, 1 * IsTank()); //+43%
-    }
-    else
-    {
-        switch (botOrPetType)
-        {
-            case PET_TYPE_VOIDWALKER:
-                RefreshAura(DEFENSIVE_STANCE_PASSIVE, 2 * IsTank());
-                break;
-            default:
-                break;
-        }
-    }
-}
-//check if our party players are in duel. if so - ignore them, their opponents and any bots they have
-bool bot_ai::InDuel(Unit* target) const
-{
-    if (!target) return false;
-    bool isbot = target->GetTypeId() == TYPEID_UNIT && (target->ToCreature()->GetIAmABot() || target->ToCreature()->GetIAmABotsPet());
-    Player* player = target->GetTypeId() == TYPEID_PLAYER ? target->ToPlayer() : isbot ? target->ToCreature()->GetBotOwner() : NULL;
-    if (!player)
-    {
-        if (!target->IsControlledByPlayer())
-            return false;
-        player = target->GetCharmerOrOwnerPlayerOrPlayerItself();
-    }
-
-    return (player && player->duel && (IsInBotParty(player) || IsInBotParty(player->duel->opponent)));
-}
-//Used to find target for priest's dispels and mage's spellsteal (also shaman's purge in future)
-//Returns dispellable/stealable 'Any Hostile Unit Attacking BotParty'
-Unit* bot_minion_ai::FindHostileDispelTarget(float dist, bool stealable) const
-{
-    CellCoord p(acore::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
-    Cell cell(p);
-    cell.SetNoCreate();
-
-    Unit* unit = NULL;
-
-    HostileDispelTargetCheck check(me, dist, stealable, this);
-    acore::UnitLastSearcher <HostileDispelTargetCheck> searcher(me, unit, check);
-
-    TypeContainerVisitor<acore::UnitLastSearcher <HostileDispelTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
-    TypeContainerVisitor<acore::UnitLastSearcher <HostileDispelTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
-
-    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
-    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
-
-    return unit;
-}
-//Finds single target affected by given spell (and given caster if is)
-//Can check:
-//    hostile targets  (hostile = 0) <default>
-//    our party players (hostile = 1)
-//    our party members  (hostile = 2)
-//    any friendly target (hostile = 3)
-//    any target in range  (hostile = any other value)
-Unit* bot_minion_ai::FindAffectedTarget(uint32 spellId, uint64 caster, float dist, uint8 hostile) const
-{
-    if (!spellId)
-        return NULL;
-    if (master->GetMap()->Instanceable())
-        dist = DEFAULT_VISIBILITY_INSTANCE;
-
-    CellCoord p(acore::ComputeCellCoord(master->GetPositionX(), master->GetPositionY()));
-    Cell cell(p);
-    cell.SetNoCreate();
-
-    Unit* unit = NULL;
-
-    AffectedTargetCheck check(caster, dist, spellId, master, hostile);
-    acore::UnitLastSearcher <AffectedTargetCheck> searcher(master, unit, check);
-
-    TypeContainerVisitor<acore::UnitLastSearcher <AffectedTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
-    TypeContainerVisitor<acore::UnitLastSearcher <AffectedTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
-
-    cell.Visit(p, world_unit_searcher, *master->GetMap(), *master, dist);
-    cell.Visit(p, grid_unit_searcher, *master->GetMap(), *master, dist);
-
-    return unit;
-}
-//Finds target for mage's polymorph or shaman's hex
-Unit* bot_minion_ai::FindPolyTarget(float dist, Unit* currTarget) const
-{
-    if (!currTarget)
-        return NULL;
-
-    CellCoord p(acore::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
-    Cell cell(p);
-    cell.SetNoCreate();
-
-    Unit* unit = NULL;
-
-    PolyUnitCheck check(me, dist, currTarget);
-    acore::UnitLastSearcher <PolyUnitCheck> searcher(me, unit, check);
-
-    TypeContainerVisitor<acore::UnitLastSearcher <PolyUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
-    TypeContainerVisitor<acore::UnitLastSearcher <PolyUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
-
-    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
-    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
-
-    return unit;
-}
-//Finds target for direct fear (warlock)
-Unit* bot_minion_ai::FindFearTarget(float dist) const
-{
-    CellCoord p(acore::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
-    Cell cell(p);
-    cell.SetNoCreate();
-
-    Unit* unit = NULL;
-
-    FearUnitCheck check(me, dist);
-    acore::UnitLastSearcher <FearUnitCheck> searcher(me, unit, check);
-
-    TypeContainerVisitor<acore::UnitLastSearcher <FearUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
-    TypeContainerVisitor<acore::UnitLastSearcher <FearUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
-
-    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
-    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
-
-    return unit;
-}
-//Finds target for paladin's repentance
-Unit* bot_minion_ai::FindStunTarget(float dist) const
-{
-    CellCoord p(acore::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
-    Cell cell(p);
-    cell.SetNoCreate();
-
-    Unit* unit = NULL;
-
-    StunUnitCheck check(me, dist);
-    acore::UnitLastSearcher <StunUnitCheck> searcher(me, unit, check);
-
-    TypeContainerVisitor<acore::UnitLastSearcher <StunUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
-    TypeContainerVisitor<acore::UnitLastSearcher <StunUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
-
-    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
-    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
-
-    return unit;
-}
-//Finds target for priest's shackles
-Unit* bot_minion_ai::FindUndeadCCTarget(float dist, uint32 spellId/* = 0*/) const
-{
-    CellCoord p(acore::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
-    Cell cell(p);
-    cell.SetNoCreate();
-
-    Unit* unit = NULL;
-
-    UndeadCCUnitCheck check(me, dist, spellId);
-    acore::UnitLastSearcher <UndeadCCUnitCheck> searcher(me, unit, check);
-
-    TypeContainerVisitor<acore::UnitLastSearcher <UndeadCCUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
-    TypeContainerVisitor<acore::UnitLastSearcher <UndeadCCUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
-
-    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
-    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
-
-    return unit;
-}
-//Finds target for druid's Entangling Roots
-Unit* bot_minion_ai::FindRootTarget(float dist, uint32 spellId) const
-{
-    CellCoord p(acore::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
-    Cell cell(p);
-    cell.SetNoCreate();
-
-    Unit* unit = NULL;
-
-    RootUnitCheck check(me, me->GetVictim(), dist, spellId);
-    acore::UnitLastSearcher <RootUnitCheck> searcher(me, unit, check);
-
-    TypeContainerVisitor<acore::UnitLastSearcher <RootUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
-    TypeContainerVisitor<acore::UnitLastSearcher <RootUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
-
-    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
-    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
-
-    return unit;
-}
-//Finds casting target (friend or enemy)
-Unit* bot_minion_ai::FindCastingTarget(float maxdist, float mindist, bool isFriend, uint32 spellId) const
-{
-    CellCoord p(acore::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
-    Cell cell(p);
-    cell.SetNoCreate();
-
-    Unit* unit = NULL;
-
-    CastingUnitCheck check(me, mindist, maxdist, isFriend, spellId);
-    acore::UnitLastSearcher <CastingUnitCheck> searcher(me, unit, check);
-
-    TypeContainerVisitor<acore::UnitLastSearcher <CastingUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
-    TypeContainerVisitor<acore::UnitLastSearcher <CastingUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
-
-    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, maxdist);
-    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, maxdist);
-
-    return unit;
-}
-// Returns target for AOE spell (blizzard, hurricane etc.) based on attackers count
-// Cycles through BotParty, first checks player and, if checked, npcbots
-// If checked, can return friendly target as target for AOE spell
-Unit* bot_minion_ai::FindAOETarget(float dist, bool checkbots, bool targetfriend) const
-{
-    if (IsCasting())
-        return NULL;
-
-    Unit* unit = NULL;
-    Group* pGroup = master->GetGroup();
-    if (!pGroup)
-    {
-		Unit::AttackerSet m_attackers = master->getAttackers();
-        if (m_attackers.size() > 1)
-        {
-            uint32 mCount = 0;
-			for (Unit::AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
-            {
-                if (!(*iter) || !(*iter)->IsAlive()) continue;
-                if ((*iter)->isMoving()) continue;
-                if ((*iter)->HasBreakableByDamageCrowdControlAura())
-                    continue;
-                if (me->GetDistance(*iter) < dist)
-                    ++mCount;
-            }
-            if (mCount > 1)
-            {
-                Unit* u = master->GetVictim();
-                if (mCount > 3 && targetfriend == true)
-                    unit = master;
-                else if (u && FindSplashTarget(dist + 8, u))
-                    unit = u;
-            }//end if
-        }//end if
-        if (!checkbots)
-            return unit;
-        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
-        {
-            Creature* bot = master->GetBotMap(i)->_Cre();
-            if (!bot || !bot->IsAlive() || !bot->IsInWorld() || me->GetDistance(bot) > dist) continue;
-
-			Unit::AttackerSet b_attackers = bot->getAttackers();
-            if (b_attackers.size() > 1)
-            {
-                uint32 mCount = 0;
-				for (Unit::AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
-                {
-                    if (!(*iter) || !(*iter)->IsAlive()) continue;
-                    if ((*iter)->isMoving()) continue;
-                    if ((*iter)->HasBreakableByDamageCrowdControlAura())
-                        continue;
-                    if (me->GetDistance(*iter) < dist)
-                        ++mCount;
-                }
-                if (mCount > 1)
-                {
-                    Unit* u = bot->GetVictim();
-                    if (mCount > 3 && targetfriend == true)
-                        unit = bot;
-                    else if (u && FindSplashTarget(dist + 8, u))
-                        unit = u;
-                }//end if
-            }//end if
-            if (unit) return unit;
-        }//end for
-        return unit;
-    }
-    bool Bots = false;
-    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-    {
-        Player* tPlayer = itr->GetSource();
-        if (!tPlayer) continue;
-        if (checkbots && tPlayer->HaveBot())
-            Bots = true;
-        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
-        if (!tPlayer->IsAlive() || me->GetMap() != tPlayer->FindMap()) continue;
-        if (me->GetDistance(tPlayer) > 40) continue;
-
-		Unit::AttackerSet m_attackers = tPlayer->getAttackers();
-        if (m_attackers.size() > 1)
-        {
-            uint32 mCount = 0;
-			for (Unit::AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
-            {
-                if (!(*iter) || !(*iter)->IsAlive()) continue;
-                if ((*iter)->isMoving()) continue;
-                if (me->GetDistance(*iter) < dist)
-                    ++mCount;
-            }
-            if (mCount > 1)
-            {
-                Unit* u = tPlayer->GetVictim();
-                if (mCount > 3 && targetfriend == true)
-                    unit = tPlayer;
-                else if (u && FindSplashTarget(dist + 8, u))
-                    unit = u;
-            }//end if
-        }//end if
-        if (unit) return unit;
-    }//end for
-    if (!Bots) return NULL;
-    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-    {
-        Player* tPlayer = itr->GetSource();
-        if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
-        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
-        if (me->GetMap() != tPlayer->FindMap()) continue;
-        for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
-        {
-            Creature* bot = tPlayer->GetBotMap(i)->_Cre();
-            if (!bot || !bot->IsAlive() || me->GetMap() != bot->FindMap()) continue;
-            if (!bot->IsInWorld()) continue;
-            if (me->GetDistance(bot) > 40) continue;
-
-			Unit::AttackerSet b_attackers = bot->getAttackers();
-            if (b_attackers.size() > 1)
-            {
-                uint32 mCount = 0;
-				for (Unit::AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
-                {
-                    if (!(*iter) || !(*iter)->IsAlive()) continue;
-                    if ((*iter)->isMoving()) continue;
-                    if (me->GetDistance(*iter) < dist)
-                        ++mCount;
-                }
-                if (mCount > 1)
-                {
-                    Unit* u = bot->GetVictim();
-                    if (mCount > 3 && targetfriend == true)
-                        unit = bot;
-                    else if (u && FindSplashTarget(dist + 8, u))
-                        unit = u;
-                }//end if
-            }//end if
-        }//end for
-        if (unit) return unit;
-    }//end for
-    return unit;
-}
-// Finds secondary target for spells like Cleave, Swipe, Mind Sear etc.
-Unit* bot_minion_ai::FindSplashTarget(float dist, Unit* To, float splashdist) const
-{
-    if (!To)
-        To = me->GetVictim();
-    if (!To)
-        return NULL;
-
-    if (me->GetDistance(To) > dist)
-        return NULL;
-
-    CellCoord p(acore::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
-    Cell cell(p);
-    cell.SetNoCreate();
-
-    Unit* unit = NULL;
-
-    SecondEnemyCheck check(me, dist, splashdist, To, this);
-    acore::UnitLastSearcher <SecondEnemyCheck> searcher(me, unit, check);
-
-    TypeContainerVisitor<acore::UnitLastSearcher <SecondEnemyCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
-    TypeContainerVisitor<acore::UnitLastSearcher <SecondEnemyCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
-
-    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
-    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
-
-    return unit;
-}
-
-Unit* bot_minion_ai::FindTranquilTarget(float mindist, float maxdist) const
-{
-    CellCoord p(acore::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
-    Cell cell(p);
-    cell.SetNoCreate();
-
-    Unit* unit = NULL;
-
-    TranquilTargetCheck check(me, mindist, maxdist, this);
-    acore::UnitLastSearcher <TranquilTargetCheck> searcher(me, unit, check);
-
-    TypeContainerVisitor<acore::UnitLastSearcher <TranquilTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
-    TypeContainerVisitor<acore::UnitLastSearcher <TranquilTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
-
-    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, maxdist);
-    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, maxdist);
-
-    return unit;
-}
-
-void bot_minion_ai::GetNearbyTargetsList(std::list<Unit*> &targets, float maxdist, float mindist, bool forCC) const
-{
-    CellCoord p(acore::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
-    Cell cell(p);
-    cell.SetNoCreate();
-
-    NearbyHostileUnitCheck check(me, maxdist, mindist, this, forCC);
-    acore::UnitListSearcher <NearbyHostileUnitCheck> searcher(me, targets, check);
-
-    TypeContainerVisitor<acore::UnitListSearcher <NearbyHostileUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
-    TypeContainerVisitor<acore::UnitListSearcher <NearbyHostileUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
-
-    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, maxdist);
-    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, maxdist);
-}
-
-//////////
-//Internal
-//////////
-//Using rist-rank spell as source, returns spell of max rank allowed for given caster
-uint32 bot_ai::InitSpell(Unit const* caster, uint32 spell)
-{
-    SpellInfo const* info = sSpellMgr->GetSpellInfo(spell);
-    if (!info)
-    {
-        //TC_LOG_FATAL("entities.player", "InitSpell(): No SpellInfo found for spell %u", spell);
-        return 0; //weird spell with no info, disable it
-    }
-
-    uint8 lvl = caster->getLevel();
-    if (lvl < info->BaseLevel) //only 1st rank spells check
-        return 0; //cannot use this spell
-
-    if (SpellInfo const* spInfo = info->GetNextRankSpell())
-    {
-        if (lvl < spInfo->BaseLevel)
-            return spell; //cannot use next rank, use this one
-        else
-            return InitSpell(caster, spInfo->Id); //can use next rank, forward check
-    }
-
-    return spell; //max rank, use this
-}
-//Using rist-rank spell as source, returns spell of max rank allowed for given caster in given spellmap
-void bot_ai::InitSpellMap(uint32 basespell, bool forceadd)
-{
-    SpellInfo const* info = sSpellMgr->GetSpellInfo(basespell);
-    if (!info)
-    {
-        //TC_LOG_FATAL("entities.player", "InitSpellMap(): No SpellInfo found for base spell %u", basespell);
-        return; //invalid spell id
-    }
-
-    uint8 lvl = me->getLevel();
-    uint32 spellId = 0;
-
-    while (info != NULL && (forceadd || lvl >= info->BaseLevel))
-    {
-        spellId = info->Id; //can use this spell
-        info = info->GetNextRankSpell(); //check next rank
-    }
-
-    //if (spellId != 0)
-    //{
-        BotSpell newSpell;
-        newSpell.first = spellId;
-        newSpell.second = GetSpellCooldown(basespell);
-        spells[basespell] = newSpell;
-    //}
-}
-//Using rist-rank spell as source, return current spell id
-uint32 bot_ai::GetSpell(uint32 basespell) const
-{
-    BotSpellMap::const_iterator itr = spells.find(basespell);
-    return itr != spells.end() ? itr->second.first : 0;
-}
-//Using rist-rank spell as source, returns cooldown on current spell
-uint32 bot_ai::GetSpellCooldown(uint32 basespell) const
-{
-    BotSpellMap::const_iterator itr = spells.find(basespell);
-    return itr != spells.end() ? itr->second.second : 0;
-}
-bool bot_ai::IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD, uint32 forcedTime) const
-{
-    BotSpellMap::const_iterator itr = spells.find(basespell);
-
-    if (itr != spells.end())
-    {
-        return
-        ((*itr).second.first != 0 &&
-        (!checkGCD || GC_Timer <= diff) &&
-        (*itr).second.second <= (forcedTime ? forcedTime : diff));
-    }
-
-    return false;
-}
-//Using rist-rank spell as source, sets cooldown for current spell
-void bot_ai::SetSpellCooldown(uint32 basespell, uint32 msCooldown)
-{
-    BotSpellMap::iterator itr = spells.find(basespell);
-
-    if (itr != spells.end())
-        (*itr).second.second = msCooldown;
-}
-//Using rist-rank spell as source, disables certain spell for this bot
-void bot_ai::RemoveSpell(uint32 basespell)
-{
-    BotSpellMap::iterator itr = spells.find(basespell);
-
-    if (itr != spells.end())
-    {
-        //spells.erase(itr); //usafe possible
-        (*itr).second.first = 0;
-        //(*itr).second.second = 0; //unneeded
-    }
-}
-void bot_ai::SpellTimers(uint32 diff)
-{
-    // spell must be initialized!!!
-    for (BotSpellMap::iterator itr = spells.begin(); itr != spells.end(); ++itr)
-        if ((*itr).second.second > diff)
-            (*itr).second.second -= diff;
-}
-//Health magement for minions
-//Including health calcs, set and regeneration
-void bot_minion_ai::_OnHealthUpdate() const
-{
-    uint8 myclass = me->GetBotClass();
-    uint8 mylevel = master->getLevel();
-    if (myclass == CLASS_DRUID)
-        myclass = GetBotStance();
-    //////TC_LOG_ERROR("entities.player", "_OnHealthUpdate(): updating bot %s", me->GetName().c_str());
-    float pct = me->GetHealthPct();// needs for regeneration
-    uint32 m_basehp = _classinfo->basehealth;
-    //////TC_LOG_ERROR("entities.player", "class base health: %u", m_basehp);
-    me->SetCreateHealth(m_basehp);
-    float stammod;
-    switch (myclass)
-    {
-        case CLASS_WARRIOR: case CLASS_DEATH_KNIGHT: case DRUID_BEAR_FORM:
-            switch (master->getClass())
-            {
-                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
-                    stammod = 16.f;
-                    break;
-                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
-                    stammod = 13.f;
-                    break;
-                default: stammod = 9.8f; break;
-            }
-            break;
-        case CLASS_PALADIN:
-            switch (master->getClass())
-            {
-                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
-                    stammod = 15.5f;
-                    break;
-                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
-                    stammod = 12.5f;
-                    break;
-                case CLASS_PALADIN:
-                    stammod = 9.8f;
-                    break;
-                default: stammod = 9.f; break;
-            }
-            break;
-        case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
-            switch (master->getClass())
-            {
-                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
-                    stammod = 9.8f;
-                    break;
-                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
-                    stammod = 8.f;
-                    break;
-                default: stammod = 5.f; break;
-            }
-            break;
-        case CLASS_DRUID: case DRUID_CAT_FORM: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
-            switch (master->getClass())
-            {
-                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
-                    stammod = 12.f;
-                    break;
-                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
-                    stammod = 9.8f;
-                    break;
-                default: stammod = 8.f; break;
-            }
-            break;
-        default:
-            //TC_LOG_FATAL("entities.player", "bmai::_OnHealthUpdate(): unknown 'myclass' value (%u)", myclass);
-            stammod = 10.f;
-            break;
-    }
-    stammod -= 0.3f;
-    stammod *= 0.75f;
-    //////TC_LOG_ERROR("entities.player", "stammod: %f", stammod);
-
-    //manually pick up stamina from bot's buffs
-    float stamValue = me->GetTotalStatValue(STAT_STAMINA);
-    stamValue = std::max(stamValue - 18.f, 1.f); //remove base stamina (not calculated into health)
-
-    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
-        stamValue += 1.f * (static_cast<BotStat>(_stats[i])[ITEM_MOD_STAMINA]);
-
-    //////TC_LOG_ERROR("entities.player", "bot's stats to health add: Stamina (%f), value: %f", stamValue, stamValue * 10.f);
-    int32 hp_add = int32(stamValue * 10.f);
-
-    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
-        hp_add += 3.f * (static_cast<BotStat>(_stats[i])[ITEM_MOD_HEALTH]);
-
-    //pick up master's stamina from items
-    float total_pct = std::max((master->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_PCT) - 0.1f), 1.f);
-    float base_stam = master->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_VALUE);
-    base_stam = std::max(base_stam - 18.f, 0.f); //remove base stamina (not calculated into health)
-    stamValue = base_stam * master->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_PCT) * total_pct;
-    //////TC_LOG_ERROR("entities.player", "stat to health add: Stamina (%f), value: %f", stamValue, stamValue*stammod);
-    hp_add += int32(stamValue * stammod);
-    //float stamstat = stat * 0.5f;
-    //if (stamValue > stamstat)
-    //{
-    //    //sLog->outBasic("selected stat to health add: Stamina (%f), value: %f", stamValue, stamValue*stammod);
-    //    hp_add += int32(stamValue * stammod);
-    //}
-    //else
-    //{
-    //    //sLog->outBasic("selected stat to health add: stamStat (%f), value: %f", stamstat, stamstat*stammod);
-    //    hp_add += int32(stamstat * stammod);
-    //}
-    //sLog->outBasic("health to add after master's stat mod: %i", hp_add);
-    int32 miscVal = me->getGender() * mylevel;
-    //////TC_LOG_ERROR("entities.player", "health to remove from gender mod: %i", -miscVal);
-    hp_add -= miscVal;//less hp for females lol
-    //////TC_LOG_ERROR("entities.player", "health to add after gender mod: %i", hp_add);
-    //miscVal = myrace*(mylevel/5);
-    //////TC_LOG_ERROR("entities.player", "health to add from race mod: %i", miscVal);
-    //hp_add += miscVal;//draenei tanks lol
-    //////TC_LOG_ERROR("entities.player", "health to add after race mod: %i", hp_add);
-    miscVal = master->GetNpcBotSlot(me->GetGUID()) * (mylevel / 5);
-    //////TC_LOG_ERROR("entities.player", "health to remove from slot mod: %i", -miscVal);
-    hp_add -= miscVal;
-    //////TC_LOG_ERROR("entities.player", "health to add after slot mod: %i", hp_add);
-    uint32 m_totalhp = m_basehp + hp_add; //m_totalhp = uint32(float(m_basehp + hp_add) * stammod);
-    //////TC_LOG_ERROR("entities.player", "total base health: %u", m_totalhp);
-    uint32 bonuspct = 0;
-    bonuspct += 35 * IsTank();
-    bonuspct += 8 * (GetBotStance() == DEATH_KNIGHT_FROST_PRESENCE);
-    if (bonuspct)
-        m_totalhp = (m_totalhp * (100 + bonuspct)) / 100;
-    me->SetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE, float(m_totalhp)); //replaces base hp at max lvl
-    me->UpdateMaxHealth();//will use our values we just set (update base health and buffs)
-    //////TC_LOG_ERROR("entities.player", "overall hp: %u", me->GetMaxHealth());
-    me->SetHealth(uint32(0.5f + float(me->GetMaxHealth()) * pct / 100.f)); //restore pct
-    if (!me->IsInCombat())
-        me->SetHealth(me->GetHealth() + m_basehp / 100 + me->getLevel() / 2); //regenerate
-}
-//Mana management for minions
-//Including calcs and set
-void bot_minion_ai::_OnManaUpdate(bool shapeshift)
-{
-    if (me->getPowerType() != POWER_MANA)
-        return;
-    uint8 myclass = me->GetBotClass();
-    uint8 mylevel = master->getLevel();
-    //////TC_LOG_ERROR("entities.player", "_OnManaUpdate(): updating bot %s", me->GetName().c_str());
-    float pct = (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
-    float m_basemana = _classinfo->basemana > 0 ? _classinfo->basemana : me->GetCreateMana();
-    //////TC_LOG_ERROR("entities.player", "classinfo base mana = %f", m_basemana);
-    me->SetCreateMana(m_basemana); //set base mana, critical
-    float manamod = 15.f; //here we set mana multiplier from intellect as we gain mana from MASTER's stats mostly
-    switch (myclass)
-    {
-        case CLASS_HUNTER:                     manamod =  8.5f; break;
-        case CLASS_PALADIN:                    manamod =  4.5f; break;
-        case CLASS_SHAMAN:                     manamod = 13.5f; break;
-        case CLASS_DRUID:                      manamod = 12.5f; break;
-        case CLASS_PRIEST:                     manamod = 16.5f; break;
-        case CLASS_MAGE: case CLASS_WARLOCK:   manamod = 10.5f; break;
-        default:                                                break;
-    }
-
-    manamod *= 0.75f; //custom
-
-    //////TC_LOG_ERROR("entities.player", "Manamod: %f", manamod);
-    float intValue = me->GetTotalStatValue(STAT_INTELLECT);
-    intValue = std::max(intValue - 18.f, 1.f); //remove base int (not calculated into mana)
-
-    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
-    {
-        intValue += 1.f * (static_cast<BotStat>(_stats[i])[ITEM_MOD_INTELLECT]);
-        m_basemana += 3.f * (static_cast<BotStat>(_stats[i])[ITEM_MOD_MANA]);
-    }
-
-    //////TC_LOG_ERROR("entities.player", "bot's stats to mana add: Int (%f), value: %f", intValue, intValue * manamod);
-    m_basemana += intValue * 15.f;
-    //pick up master's intellect from items if master has mana
-    if (master->getPowerType() == POWER_MANA)
-    {
-        float total_pct = std::max((master->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_PCT) - 0.1f), 1.f);
-        intValue = std::max(master->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_VALUE) - 18.f, 1.f); //remove base int (not calculated into mana)
-        intValue = intValue * master->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_PCT) * total_pct;
-    }
-    else // pick up maxstat
-        intValue = stat * 0.5f;
-    //////TC_LOG_ERROR("entities.player", "mana add from master's stat: %f", intValue * manamod);
-    m_basemana += intValue * manamod;
-    //////TC_LOG_ERROR("entities.player", "base mana + mana from master's intellect or stat: %f", m_basemana);
-    //intValue = me->GetTotalAuraModValue(UNIT_MOD_STAT_INTELLECT);
-    //sLog->outBasic("Intellect from buffs: %f", intValue);
-    //m_basemana += uint32(intValue) * manamod;
-    //sLog->outBasic("base mana + mana from intellect + mana from buffs: %u", m_basemana);
-    uint8 otherVal = me->getGender() * 3 * mylevel;
-    //////TC_LOG_ERROR("entities.player", "mana to add from gender mod: %u", otherVal);
-    m_basemana += float(otherVal); //more mana for females lol
-    //////TC_LOG_ERROR("entities.player", "base mana after gender mod: %f", m_basemana);
-    otherVal = master->GetNpcBotSlot(me->GetGUID()) * (mylevel / 5); //only to make mana unique
-    //////TC_LOG_ERROR("entities.player", "mana to remove from slot mod: %i", -int8(otherVal));
-    m_basemana -= otherVal;
-    //////TC_LOG_ERROR("entities.player", "base mana after slot mod: %f", m_basemana);
-    float m_totalmana = m_basemana;
-    //////TC_LOG_ERROR("entities.player", "total mana to set: %f", m_totalmana);
-    me->SetModifierValue(UNIT_MOD_MANA, BASE_VALUE, m_totalmana);
-    me->UpdateMaxPower(POWER_MANA);
-    //////TC_LOG_ERROR("entities.player", "Overall mana to set: %u", me->GetMaxPower(POWER_MANA));
-    if (tempMana)
-    {
-        me->SetPower(POWER_MANA, tempMana);
-        if (shapeshift == false)
-            tempMana = 0;
-    }
-    else
-        me->SetPower(POWER_MANA, uint32(0.5f + float(me->GetMaxPower(POWER_MANA)) * pct / 100.f)); //restore pct
-    //No Regen
-}
-//Melee damage for minions (melee classes only)
-//Calculation is based on master's attack power if melee/hunter or spellpower
-void bot_minion_ai::_OnMeleeDamageUpdate(uint8 myclass) const
-{
-    if (ap_mod < 0.1f) return; //do not bother casters
-    //sLog->outBasic("_OnMeleeDamageUpdate: Updating bot %s", me->GetName().c_str());
-    float my_ap_mod = ap_mod;
-    float mod = master->getClass() == CLASS_HUNTER ? (master->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT) + master->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT))/2.f :
-        (master->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT) + master->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT))/2.f;
-    mod = std::max(mod, 1.f); // x1 is Minimum
-    mod = std::min(mod, 2.5f); // x2.5 is Maximum
-    //sLog->outBasic("got base damage modifier: %f", mod);
-    mod -= (mod - 1.f)*0.33f;//reduce bonus by 33%
-    //sLog->outBasic("damage modifier truencated to %f, applying", mod);
-
-    for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
-        me->SetModifierValue(UnitMods(UNIT_MOD_DAMAGE_MAINHAND + i), BASE_VALUE, static_cast<BotStat>(_stats[i])[BOT_ITEM_MOD_DAMAGE]);
-
-    me->SetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT, mod);
-    me->SetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT, mod);
-    me->SetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT, mod);
-    //me->SetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT, mod);//NUY
-    mod = (mod - 1.f)*0.5f;
-    //sLog->outBasic("reduced damage modifier to gain bonus: %f", mod);
-    //sLog->outBasic("base ap modifier is %f", my_ap_mod);
-    my_ap_mod *= 0.5f;
-    //sLog->outBasic("ap modifier multiplied to %f", my_ap_mod);
-    my_ap_mod += my_ap_mod > 0.f ? mod : 0.f; //add reduced master's multiplier if can have damage
-    //sLog->outBasic("ap modifier + mod = %f", my_ap_mod);
-    me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_PCT, my_ap_mod);
-    me->SetModifierValue(UNIT_MOD_ATTACK_POWER_RANGED, BASE_PCT, my_ap_mod);
-
-    int32 sppower = 0;
-    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
-    {
-        int32 power = master->SpellBaseDamageBonusDone(SpellSchoolMask(1 << i));
-        if (power > sppower)
-            sppower = power;
-    }
-    //sLog->outBasic("master's spellpower is %i, multiplying...", sppower);
-    sppower *= 1.5f;
-    //sLog->outBasic("got spellpower of %i", sppower);
-    //atpower = float(master->GetInt32Value(master->getClass() == CLASS_HUNTER ? UNIT_FIELD_RANGED_ATTACK_POWER : UNIT_FIELD_ATTACK_POWER));
-    float atpower = master->GetTotalAttackPowerValue(master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK);
-    //sLog->outBasic("master's base attack power is %f", atpower);
-    atpower = sppower > atpower ? sppower : atpower; //highest stat is used (either 1.5x spellpower or attack power)
-    //sLog->outBasic("chosen attack power stat value: %f", atpower);
-    //sLog->outBasic("expected attack power: %f", atpower*ap_mod);
-    atpower *= 0.333f; //reduce damage since we can have weapons
-
-    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
-    {
-        atpower += static_cast<BotStat>(_stats[i])[ITEM_MOD_ATTACK_POWER] + static_cast<BotStat>(_stats[i])[ITEM_MOD_RANGED_ATTACK_POWER] +
-            static_cast<BotStat>(_stats[i])[ITEM_MOD_STRENGTH] * 2 + static_cast<BotStat>(_stats[i])[ITEM_MOD_AGILITY] * 2;
-    }
-
-    me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
-    if (myclass == CLASS_HUNTER || myclass == CLASS_ROGUE)
-    {
-        me->SetModifierValue(UNIT_MOD_ATTACK_POWER_RANGED, BASE_VALUE, atpower);
-        me->UpdateAttackPowerAndDamage(true);
-    }
-    me->UpdateAttackPowerAndDamage();
-    //sLog->outBasic("listing stats: ");
-    //sLog->outBasic("attack power main hand: %f", me->GetTotalAttackPowerValue(BASE_ATTACK));
-    //sLog->outBasic("attack power off hand: %f", me->GetTotalAttackPowerValue(OFF_ATTACK));
-    //sLog->outBasic("attack power ranged: %f", me->GetTotalAttackPowerValue(RANGED_ATTACK));
-    //sLog->outBasic("damage multiplier main hand: %f", me->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT) * me->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT));
-    //sLog->outBasic("damage multiplier off hand: %f", me->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT) * me->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT));
-    //sLog->outBasic("damage multiplier ranged: %f", me->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT) * me->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT));
-    //sLog->outBasic("Damage range main hand: min: %f, max: %f", me->GetFloatValue(UNIT_FIELD_MINDAMAGE), me->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
-    //sLog->outBasic("Damage range off hand: min: %f, max: %f", me->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE), me->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE));
-    //sLog->outBasic("Damage range ranged: min: %f, max: %f", me->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE), me->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE));
-}
-//Health for pets
-//Same as for minions just simplified (modified to match real pets' values)
-void bot_pet_ai::_OnHealthUpdate() const
-{
-    uint8 mylevel = master->getLevel();
-    float hp_mult = 10.f;
-    switch (GetPetType(me))
-    {
-        case PET_TYPE_VOIDWALKER:
-            hp_mult = 11.f;
-            break;
-        default:
-            break;
-    }
-    float pct = me->GetHealthPct();// needs for regeneration
-    //Use simple checks and calcs
-    //0.3 hp for bots (inaccurate but cheap)
-    uint32 m_basehp = me->GetCreateHealth() / 2;
-    //pick up stamina from buffs
-    float stamValue = me->GetTotalStatValue(STAT_STAMINA);
-    stamValue = std::max(stamValue - 18.f, 1.f); //remove base stamina (not calculated into health)
-    uint32 hp_add = uint32(stamValue * hp_mult);
-    hp_add += (m_creatureOwner->GetMaxHealth() - m_creatureOwner->GetCreateHealth()) * 0.3f;
-    uint8 miscVal = GetPetType(me)*mylevel;
-    hp_add -= miscVal;
-    uint32 m_totalhp = m_basehp + hp_add;
-    if (IsTank())
-        m_totalhp = (m_totalhp * 135) / 100; //35% hp bonus for tanks
-    me->SetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE, float(m_totalhp));
-    me->UpdateMaxHealth(); //will use values set (update base health and buffs)
-    me->SetHealth(uint32(0.5f + float(me->GetMaxHealth()) * pct / 100.f)); //restore pct
-    if (!me->IsInCombat())
-        me->SetHealth(me->GetHealth() + m_basehp / 100 + me->getLevel() / 2); //regenerate
-}
-//Mana for pets
-//Same as for minions just simplified (modified to match real pets' values)
-void bot_pet_ai::_OnManaUpdate(bool /*shapeshift*/)
-{
-    if (me->getPowerType() != POWER_MANA)
-        return;
-
-    uint8 mylevel = master->getLevel();
-
-    float mana_mult = 15.f;
-    switch (GetPetType(me))
-    {
-        case PET_TYPE_VOIDWALKER:
-            mana_mult = 11.5f;
-            break;
-        default:
-            break;
-    }
-    float pct = (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
-    //Use simple checks and calcs
-    //0.3 mana for bots (inaccurate but cheap)
-    float m_basemana = float(me->GetCreateMana());
-    m_basemana += (std::max<float>(me->GetTotalStatValue(STAT_INTELLECT) - 18.f, 1.f))*mana_mult; //remove base stamina (not calculated into mana)
-    m_basemana += float(m_creatureOwner->GetMaxPower(POWER_MANA) - m_creatureOwner->GetCreateMana())*0.3f;
-    m_basemana -= float(GetPetType(me)*mylevel);
-    me->SetModifierValue(UNIT_MOD_MANA, BASE_VALUE, m_basemana);
-    me->UpdateMaxPower(POWER_MANA);
-    me->SetPower(POWER_MANA, uint32(0.5f + float(me->GetMaxPower(POWER_MANA))*pct / 100.f));//restore pct
-}
-//Sends all master's bots a message to not try to evade for a certain period of time
-void bot_ai::SendPartyEvadeAbort() const
-{
-    for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
-        if (Creature* bot = master->GetBotMap(i)->_Cre())
-            if (bot_minion_ai* ai = bot->GetBotMinionAI())
-                ai->SetEvadeTimer(50);
-}
-//Removes buggy bots' threat from party, so no 'stuck in combat' bugs form bot mod
-//optionally interrupts casted spell if target is dead for bot and it's pet
-void bot_minion_ai::_evade()
-{
-    if (me->HasUnitState(UNIT_STATE_CASTING))
-        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
-            if (Spell* spell = me->GetCurrentSpell(CurrentSpellTypes(i)))
-                if (!spell->GetSpellInfo()->IsChanneled())
-                    if (Unit* u = spell->m_targets.GetUnitTarget())
-                        if (!u->IsAlive() && !IsInBotParty(u))
-                            me->InterruptSpell(CurrentSpellTypes(i), false, false);
-
-    Creature* m_botsPet = me->GetBotsPet();
-    if (m_botsPet && m_botsPet->HasUnitState(UNIT_STATE_CASTING))
-        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
-            if (Spell* spell = m_botsPet->GetCurrentSpell(CurrentSpellTypes(i)))
-                if (!spell->GetSpellInfo()->IsChanneled())
-                    if (Unit* u = spell->m_targets.GetUnitTarget())
-                        if (!u->IsAlive() && !IsInBotParty(u))
-                            m_botsPet->InterruptSpell(CurrentSpellTypes(i), false, false);
-
-    if (Rand() > 10) return;
-    if (!master->IsInCombat() && !me->IsInCombat() && (!m_botsPet || !m_botsPet->IsInCombat())) return;
-    if (CheckAttackTarget(me->GetBotClass()))
-        return;
-    //ChatHandler ch(master);
-    //ch.PSendSysMessage("_evade() by bot %s", me->GetName().c_str());
-    if (master->IsInCombat())
-    {
-        HostileRefManager& mgr = master->getHostileRefManager();
-        if (!mgr.isEmpty())
-        {
-            std::set<Unit*> Set;
-            HostileReference* ref = mgr.getFirst();
-            while (ref)
-            {
-                if (ref->GetSource() && ref->GetSource()->GetOwner())
-                    Set.insert(ref->GetSource()->GetOwner());
-                ref = ref->next();
-            }
-            for (std::set<Unit*>::const_iterator i = Set.begin(); i != Set.end(); ++i)
-            {
-                Unit* unit = (*i);
-                if (/*unit->IsFriendlyTo(master)*/IsInBotParty(unit) || !unit->IsInCombat())
-                {
-                    //ch.PSendSysMessage("_evade(): %s's hostile reference is removed from %s!", unit->GetName().c_str(), master->GetName().c_str());
-                    mgr.deleteReference(unit);
-                }
-            }
-        }
-    }
-    else
-    {
-        SendPartyEvadeAbort();
-        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
-        {
-            Creature* cre = master->GetBotMap(i)->_Cre();
-            if (!cre) continue;
-            if (cre->IsInCombat())
-            {
-                cre->DeleteThreatList();
-                HostileRefManager& mgr = cre->getHostileRefManager();
-                if (!mgr.isEmpty())
-                {
-                    std::set<Unit*> Set;
-                    HostileReference* ref = mgr.getFirst();
-                    while (ref)
-                    {
-                        if (ref->GetSource() && ref->GetSource()->GetOwner())
-                            Set.insert(ref->GetSource()->GetOwner());
-                        ref = ref->next();
-                    }
-                    for (std::set<Unit*>::const_iterator i = Set.begin(); i != Set.end(); ++i)
-                    {
-                        Unit* unit = (*i);
-                        if (!unit->InSamePhase(me)) continue;
-                        if (/*unit->IsFriendlyTo(master)*/IsInBotParty(unit) || !unit->IsInCombat())
-                        {
-                            //ch.PSendSysMessage("_evade(): %s's hostile reference is removed from %s!", unit->GetName().c_str(), cre->GetName().c_str());
-                            mgr.deleteReference(unit);
-                        }
-                    }
-                }
-                //if (mgr.isEmpty())// has empty threat list and no hostile refs - we have all rights to stop combat
-                //{
-                //    if (cre->IsInCombat())
-                //    {
-                //        //ch.PSendSysMessage("_evade(): %s's HostileRef is empty! Combatstop!", cre->GetName().c_str());
-                //        cre->ClearInCombat();
-                //    }
-                //}
-            }
-
-            Creature* m_botsPet = cre->GetBotsPet();
-            if (!m_botsPet || !m_botsPet->IsInCombat()) continue;
-            m_botsPet->DeleteThreatList();
-            HostileRefManager& mgr = m_botsPet->getHostileRefManager();
-            if (!mgr.isEmpty())
-            {
-                std::set<Unit*> Set;
-                HostileReference* ref = mgr.getFirst();
-                while (ref)
-                {
-                    if (ref->GetSource() && ref->GetSource()->GetOwner())
-                        Set.insert(ref->GetSource()->GetOwner());
-                    ref = ref->next();
-                }
-                for (std::set<Unit*>::const_iterator i = Set.begin(); i != Set.end(); ++i)
-                {
-                    Unit* unit = (*i);
-                    if (!unit->InSamePhase(me)) continue;
-                    if (/*unit->IsFriendlyTo(master)*/IsInBotParty(unit) || !unit->IsInCombat())
-                    {
-                        //ch.PSendSysMessage("_evade(): %s's hostile reference is removed from %s!", unit->GetName().c_str(), m_botsPet->GetName().c_str());
-                        mgr.deleteReference(unit);
-                    }
-                }
-            }
-            //if (mgr.isEmpty())// has empty threat list and no hostile refs - we have all rights to stop combat
-            //{
-            //    if (m_botsPet->IsInCombat())
-            //    {
-            //        //ch.PSendSysMessage("_evade(): %s's HostileRef is empty! Combatstop!", pet->GetName().c_str());
-            //        m_botsPet->ClearInCombat();
-            //    }
-            //}
-        }
-    }
-}
-//SpellHit()... OnSpellHit()
-void bot_ai::OnSpellHit(Unit* /*caster*/, SpellInfo const* spell)
-{
-    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
-    {
-        uint32 auraname = spell->Effects[i].ApplyAuraName;
-        //remove pet on mount
-        if (auraname == SPELL_AURA_MOUNTED)
-        {
-            me->SetBotsPetDied();
-            if (master->HasAuraType(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED) ||
-                master->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
-            {
-                //const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->InhabitType |= INHABIT_AIR;
-                //me->AddUnitMovementFlag(MOVEMENTFLAG_HOVER);
-                me->SetCanFly(true);
-                me->SetDisableGravity(true);
-                if (master->GetSpeedRate(MOVE_RUN) >= 6.0f && master->GetSpeedRate(MOVE_RUN) <= 30.0f)
-                {
-                    me->SetSpeed(MOVE_FLIGHT, master->GetSpeedRate(MOVE_RUN) * 1.37f);
-                    me->SetSpeed(MOVE_RUN, master->GetSpeedRate(MOVE_RUN) * 1.37f);
-                }
-                else
-                {
-                    me->SetSpeed(MOVE_WALK, 12.1f);
-                    me->SetSpeed(MOVE_RUN, 12.1f);
-                    me->SetSpeed(MOVE_SWIM, 12.1f); // using 1.0 rate
-                    me->SetSpeed(MOVE_FLIGHT, 12.1f); // using 1.0 rate	
-
-                }
-            }
-            else
-            {
-                if (master->GetSpeedRate(MOVE_RUN) >= 6.0f && master->GetSpeedRate(MOVE_RUN) <= 20.0f)
-                    me->SetSpeed(MOVE_RUN, master->GetSpeedRate(MOVE_RUN) * 1.25f);
-                else
-                    me->SetSpeed(MOVE_RUN, 12.1f);
-            }
-                
-        }
-
-        //update stats
-        if (auraname == SPELL_AURA_MOD_STAT)
-        {
-            shouldUpdateStats = true;
-        }
-        else
-        {
-            if (auraname == SPELL_AURA_MOD_INCREASE_HEALTH ||
-                auraname == SPELL_AURA_MOD_INCREASE_HEALTH_2 ||
-                auraname == SPELL_AURA_230 ||//SPELL_AURA_MOD_INCREASE_HEALTH_2
-                auraname == SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT)
-                doHealth = true;
-            else if (auraname == SPELL_AURA_MOD_INCREASE_ENERGY ||
-                auraname == SPELL_AURA_MOD_INCREASE_ENERGY_PERCENT)
-                doMana = true;
-        }
-    }
-}
-//Messed up
-//Hp + Mana update
-//target update
-//returns fake wait time between overall AI updates (if it is even understandable)
-uint8 bot_ai::GetWait()
-{
-    if (doHealth)
-    {
-        doHealth = false;
-        _OnHealthUpdate();
-    }
-    if (doMana)
-    {
-        doMana = false;
-        _OnManaUpdate();
-    }
-    CheckAuras(true);
-    //0 to 2 plus 1 for every 3 bots except first one
-    return (1 + (master->GetNpcBotsCount() - 1)/3 + (irand(0,100) <= 50)*int8(RAND(-1,1)));
-}
-//Damage Mods
-//1) Apply class-specified damage/crit chance/crit damage bonuses
-//2) Apply bot damage multiplier
-//3) Remove Creature damage multiplier (make independent from original config)
-//Bug with config reload (creatures do not update their damage on reload) is not bot-related but still annoying
-void bot_ai::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& /*damageinfo*/) const
-{
-    //ApplyClassDamageMultiplierMelee(damage, damageinfo);
-    damage = int32(float(damage)*dmgmult_melee/dmgmod_melee);
-
-    	uint8 mylevel = std::min<uint8>(master->getLevel(), 90);
-	if (mylevel >= 10 && mylevel <= 100)
-	{
-		damage = damage + (mylevel * 10);
-	}
-}
-void bot_ai::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
-{
-    ApplyClassDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
-    damage = int32(float(damage)*dmgmult_melee/dmgmod_melee);
-
-    uint8 mylevel = std::min<uint8>(master->getLevel(), 90);
-    if (mylevel >= 10 && mylevel <= 100)
-    {
-        damage = damage + (mylevel * 10);
-    }
-}
-void bot_ai::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
-{
-    ApplyClassDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
-    damage = int32(float(damage)*dmgmult_spell/dmgmod_spell);
-
-    uint8 mylevel = std::min<uint8>(master->getLevel(), 90);
-    if (mylevel >= 10 && mylevel <= 100)
-    {
-        damage = damage + (mylevel * 10);
-
-        if (mylevel >= 60)
-            damage = damage + (mylevel * 10);
-    }
-}
-void bot_ai::ApplyBotDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float &value) const
-{
-    //Only for damage effects which can scale (TC check)
-    bool canEffectScale = false;
-    switch (spellInfo->Effects[effect_index].Effect)
-    {
-        case SPELL_EFFECT_SCHOOL_DAMAGE:
-        //case SPELL_EFFECT_DUMMY:
-        //case SPELL_EFFECT_POWER_DRAIN:
-        //case SPELL_EFFECT_HEALTH_LEECH:
-        case SPELL_EFFECT_HEAL:
-        case SPELL_EFFECT_WEAPON_DAMAGE:
-        //case SPELL_EFFECT_POWER_BURN:
-        //case SPELL_EFFECT_SCRIPT_EFFECT:
-        case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
-        //case SPELL_EFFECT_FORCE_CAST_WITH_VALUE:
-        //case SPELL_EFFECT_TRIGGER_SPELL_WITH_VALUE:
-        //case SPELL_EFFECT_TRIGGER_MISSILE_SPELL_WITH_VALUE:
-            canEffectScale = true;
-            break;
-        default:
-            break;
-    }
-    switch (spellInfo->Effects[effect_index].ApplyAuraName)
-    {
-        case SPELL_AURA_PERIODIC_DAMAGE:
-        //case SPELL_AURA_DUMMY:
-        //case SPELL_AURA_PERIODIC_HEAL:
-        //case SPELL_AURA_DAMAGE_SHIELD:
-        case SPELL_AURA_PROC_TRIGGER_DAMAGE:
-        //case SPELL_AURA_PERIODIC_LEECH:
-        //case SPELL_AURA_PERIODIC_MANA_LEECH:
-        //case SPELL_AURA_SCHOOL_ABSORB:
-        //case SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE:
-            canEffectScale = true;
-            break;
-        default:
-            break;
-    }
-
-    if (!canEffectScale)
-        return;
-
-    ApplyClassDamageMultiplierEffect(spellInfo, effect_index, value);
-
-    if (spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MELEE || spellInfo->DmgClass == SPELL_DAMAGE_CLASS_RANGED)
-        value = value*dmgmult_melee/dmgmod_melee;
-    else if (spellInfo->DmgClass == SPELL_DAMAGE_CLASS_NONE || spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MAGIC)
-        value = value*dmgmult_spell/dmgmod_spell;
-}
-////////// 
-//GOSSIP//
-//////////
-//GossipHello
-bool bot_minion_ai::OnGossipHello(Player* player, Creature* creature)
-{
-    if (creature->IsInCombat() || creature->GetBotMinionAI()->IAmDead())
-    {
-        player->CLOSE_GOSSIP_MENU();
-        return true;
-    }
-
-    if (player == creature->GetBotOwner())
-    {
-		//player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, ("|cFFFF0000(ç©åå­å¨åºç°BUG,ä¿®å¤åè¯·å¿å°å¼ºåè¿æèæ¾ç½®å®ç³çè£å¤ç»BBä½©æ´-ç´§æ¥ä¿®å¤ä¸­)|rã"), GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 1);
-        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, ("è£å¤ç®¡çã"), GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 1);
-        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, ("èè´£ç®¡çã"), GOSSIP_SENDER_ROLES, GOSSIP_ACTION_INFO_DEF + 1);
-        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, ("ä½¿ç¨æè½ã"), GOSSIP_SENDER_ABILITIES, GOSSIP_ACTION_INFO_DEF + 1);
-    }
-
-    switch (creature->GetBotClass())
-    {
-        case CLASS_MAGE:
-            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, ("æéè¦é£ç©ã"), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
-            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, ("æéè¦åæ°´ã"), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 2);
-            break;
-        default:
-            break;
-    }
-
-    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, ("å±æ§æ¥çã"), 7000, GOSSIP_ACTION_INFO_DEF + 1);
-    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, ("æ²¡ä»ä¹äºã"), 0, GOSSIP_ACTION_INFO_DEF + 1);
-    player->PlayerTalkClass->SendGossipMenu(GOSSIP_SERVE_MASTER, creature->GetGUID());
-    return true;
-}
-
-//GossipSelect
-bool bot_minion_ai::OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
-{
-    if (!IsInBotParty(player))
-    {
-        player->CLOSE_GOSSIP_MENU();
-        return true;
-    }
-
-    player->PlayerTalkClass->ClearMenus();
-    bool subMenu = false;
-
-    switch (sender)
-    {
-    case 7000: //stat
-    {
-        ReceiveEmote(player, 13);
-        break;
-    }
-        case 0: //any kind of fail
-        {
-            me->MonsterSay("...", LANG_UNIVERSAL, player);
-            break;
-        }
-        case 1: //return to main menu
-        {
-            return bot_minion_ai::OnGossipHello(player, creature);
-        }
-        case GOSSIP_SENDER_CLASS: //food/drink (classes: MAGE)
-        {
-            //Prevent high-leveled consumables for low-level characters
-            Unit* checker;
-            if (player->getLevel() < me->getLevel())
-                checker = player;
-            else
-                checker = me;
-
-            // Conjure Refreshment rank 1
-            uint32 food = InitSpell(checker, 42955);
-            bool iswater = (action == GOSSIP_ACTION_INFO_DEF + 2);
-            if (!food)
-            {
-                if (!iswater)// Conjure Food rank 1
-                    food = InitSpell(checker, 587);
-                else// Conjure Water rank 1
-                    food = InitSpell(checker, 5504);
-            }
-            if (!food)
-            {
-                std::string errorstr = ("æè¿ä¸è½å¶é ã");
-				errorstr += iswater ? ("æ°´ã" ): ("é£ç©ã");
-                errorstr += ("å¦ãã");
-				me->MonsterWhisper(errorstr.c_str(), player);
-                //player->PlayerTalkClass->ClearMenus();
-                //return OnGossipHello(player, me);
-                break;
-            }
-            SpellInfo const* Info = sSpellMgr->GetSpellInfo(food);
-            Spell* foodspell = new Spell(me, Info, TRIGGERED_NONE, player->GetGUID());
-            SpellCastTargets targets;
-            targets.SetUnitTarget(player);
-            //TODO implement checkcast for bots
-            SpellCastResult result = me->IsMounted() || CCed(me) ? SPELL_FAILED_CUSTOM_ERROR : foodspell->CheckPetCast(player);
-            if (result != SPELL_CAST_OK)
-            {
-                foodspell->finish(false);
-                delete foodspell;
-                me->MonsterWhisper(("æç°å¨ä¸è½è¿ä¹åãã"), player);
-            }
-            else
-            {
-                aftercastTargetGuid = player->GetGUID();
-                foodspell->prepare(&targets);
-                me->MonsterWhisper(("ç»ä½ çãã"), player);
-            }
-            break;
-        }
-        case GOSSIP_SENDER_EQUIPMENT: //equips change s1: send what slots we can use
-        {
-            subMenu = true;
-
-            //general
-			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, ("æ¥çä½ çè£å¤ã"), GOSSIP_SENDER_EQUIPMENT_LIST, GOSSIP_ACTION_INFO_DEF + 1);
-            for (uint8 i = 0; i < 18; ++i)
-            {
-                if (i + 1 == BOT_SLOT_OFFHAND && !CanUseOffHand())
-                    continue;
-                if (i + 1 == BOT_SLOT_RANGED && !CanUseRanged())
-                    continue;
-                std::ostringstream Str;
-                if (i + 1 == BOT_SLOT_RANGED && CanUseRanged())
-                {
-                    if (me->GetBotClass() == CLASS_PALADIN || me->GetBotClass() == CLASS_DRUID || me->GetBotClass() == CLASS_SHAMAN || me->GetBotClass() == CLASS_DEATH_KNIGHT)
-                        Str << sObjectMgr->GetAcoreStringForDBCLocale(30133);
-                    else
-                        Str << sObjectMgr->GetAcoreStringForDBCLocale(30115 + i);
-                }
-                else
-                    Str << sObjectMgr->GetAcoreStringForDBCLocale(30115 + i);
-                if (uint32 itemId = master->GetBotEquip(me, i))
-                {
-                    ItemTemplate const* EquipObject = sObjectMgr->GetItemTemplate(itemId);
-                    Str << sObjectMgr->GetAcoreStringForDBCLocale(30134) << "(|cFF800000" << EquipObject->ItemLevel << "|r)|r\n" << GetItemIcon(itemId, 30, 30, -3, -2);
-                    _AddItemTemplateLink(master, EquipObject, Str);
-                }
-                else
-                {
-                    if (i + 1 == BOT_SLOT_MAINHAND)
-                        Str << "\n" << GetSlotIcon(EQUIPMENT_SLOT_MAINHAND, 30, 30, -3, -2) << sObjectMgr->GetAcoreStringForDBCLocale(30135);
-                    else
-                    if (i + 1 == BOT_SLOT_OFFHAND)
-                        Str << "\n" << GetSlotIcon(EQUIPMENT_SLOT_OFFHAND, 30, 30, -3, -2) << sObjectMgr->GetAcoreStringForDBCLocale(30135);
-                    else
-                    if (i + 1 == BOT_SLOT_RANGED)
-                        Str << "\n" << GetSlotIcon(EQUIPMENT_SLOT_RANGED, 30, 30, -3, -2) << sObjectMgr->GetAcoreStringForDBCLocale(30135);
-                    else
-                    if (i + 1 == BOT_SLOT_HEAD)
-                        Str << "\n" << GetSlotIcon(EQUIPMENT_SLOT_HEAD, 30, 30, -3, -2) << sObjectMgr->GetAcoreStringForDBCLocale(30135);
-                    else
-                    if (i + 1 == BOT_SLOT_SHOULDERS)
-                        Str << "\n" << GetSlotIcon(EQUIPMENT_SLOT_SHOULDERS, 30, 30, -3, -2) << sObjectMgr->GetAcoreStringForDBCLocale(30135);
-                    else
-                    if (i + 1 == BOT_SLOT_CHEST)
-                        Str << "\n" << GetSlotIcon(EQUIPMENT_SLOT_CHEST, 30, 30, -3, -2) << sObjectMgr->GetAcoreStringForDBCLocale(30135);
-                    else
-                    if (i + 1 == BOT_SLOT_WAIST)
-                        Str << "\n" << GetSlotIcon(EQUIPMENT_SLOT_WAIST, 30, 30, -3, -2) << sObjectMgr->GetAcoreStringForDBCLocale(30135);
-                    else
-                    if (i + 1 == BOT_SLOT_LEGS)
-                        Str << "\n" << GetSlotIcon(EQUIPMENT_SLOT_LEGS, 30, 30, -3, -2) << sObjectMgr->GetAcoreStringForDBCLocale(30135);
-                    else
-                    if (i + 1 == BOT_SLOT_FEET)
-                        Str << "\n" << GetSlotIcon(EQUIPMENT_SLOT_FEET, 30, 30, -3, -2) << sObjectMgr->GetAcoreStringForDBCLocale(30135);
-                    else
-                    if (i + 1 == BOT_SLOT_WRIST)
-                        Str << "\n" << GetSlotIcon(EQUIPMENT_SLOT_WRISTS, 30, 30, -3, -2) << sObjectMgr->GetAcoreStringForDBCLocale(30135);
-                    else
-                    if (i + 1 == BOT_SLOT_HANDS)
-                        Str << "\n" << GetSlotIcon(EQUIPMENT_SLOT_HANDS, 30, 30, -3, -2) << sObjectMgr->GetAcoreStringForDBCLocale(30135);
-                    else
-                    if (i + 1 == BOT_SLOT_BACK)
-                        Str << "\n" << GetSlotIcon(EQUIPMENT_SLOT_BACK, 30, 30, -3, -2) << sObjectMgr->GetAcoreStringForDBCLocale(30135);
-                    else
-                    if (i + 1 == BOT_SLOT_BODY)
-                        Str << "\n" << GetSlotIcon(EQUIPMENT_SLOT_BODY, 30, 30, -3, -2) << sObjectMgr->GetAcoreStringForDBCLocale(30135);
-                    else
-                    if (i + 1 == BOT_SLOT_FINGER1)
-                        Str << "\n" << GetSlotIcon(EQUIPMENT_SLOT_FINGER1, 30, 30, -3, -2) << sObjectMgr->GetAcoreStringForDBCLocale(30135);
-                    else
-                    if (i + 1 == BOT_SLOT_FINGER2)
-                        Str << "\n" << GetSlotIcon(EQUIPMENT_SLOT_FINGER2, 30, 30, -3, -2) << sObjectMgr->GetAcoreStringForDBCLocale(30135);
-                    else
-                    if (i + 1 == BOT_SLOT_TRINKET1)
-                        Str << "\n" << GetSlotIcon(EQUIPMENT_SLOT_TRINKET1, 30, 30, -3, -2) << sObjectMgr->GetAcoreStringForDBCLocale(30135);
-                    else
-                    if (i + 1 == BOT_SLOT_TRINKET2)
-                        Str << "\n" << GetSlotIcon(EQUIPMENT_SLOT_TRINKET2, 30, 30, -3, -2) << sObjectMgr->GetAcoreStringForDBCLocale(30135);
-                    else
-                    if (i + 1 == BOT_SLOT_NECK)
-                        Str << "\n" << GetSlotIcon(EQUIPMENT_SLOT_NECK, 30, 30, -3, -2) << sObjectMgr->GetAcoreStringForDBCLocale(30135);
-                }
-                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, Str.str().c_str(), GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + i + 1);
-            }
-			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, ("è¿åã"), 1, GOSSIP_ACTION_INFO_DEF + 1);
-
-            break;
-        }
-        case GOSSIP_SENDER_EQUIPMENT_LIST: //list inventory
-        {
-            //if (action - GOSSIP_ACTION_INFO_DEF != BOT_SLOT_NONE)
-            //    break;
-
-            int8 id = 1;
-            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
-
-            for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
-            {
-                if (uint32 itemId = master->GetBotEquip(me, i))
-                {
-                    std::ostringstream msg;
-                    if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
-                        _AddItemTemplateLink(master, proto, msg);
-                    else
-                        msg << ("æªç¥ç©åã");
-                    msg << ("å¨æ ä½ã") << uint32(i) << " (" << _getNameForSlot(i + 1) << ')';
-                    if (i < BOT_SLOT_RANGED && einfo && einfo->ItemEntry[i] == itemId)
-                        msg << ("æ¯ã|cffe6cc80|h[ãåå§è£å¤ã]|h|r");
-                    me->MonsterWhisper(msg.str().c_str(), master);
-                }
-            }
-
-            break;
-        }
-        case GOSSIP_SENDER_EQUIPMENT_INFO: //request equip item info
-        {
-            //GOSSIP ITEMS RESTRICTED
-            //subMenu = true; //needed for return
-
-            uint8 slot = action - (GOSSIP_ACTION_INFO_DEF + 1);
-            if (uint32 itemId = master->GetBotEquip(me, slot))
-            {
-                std::ostringstream msg;
-                if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
-                    _AddItemTemplateLink(master, proto, msg);
-                else
-                    msg << ("æªç¥ã");
-
-                int8 id = 1;
-                EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
-                if (slot < BOT_SLOT_RANGED && einfo && einfo->ItemEntry[slot] == itemId)
-                    msg << ("æ¯ã|cffe6cc80|h[ãåå§è£å¤ã]|h|r");
-
-                me->MonsterWhisper(msg.str().c_str(), master);
-            }
-
-            //break; //no break here - return to menu
-        }
-        case GOSSIP_SENDER_EQUIPMENT_SHOW: //equips change s2: send list of equippable items
-        {
-            subMenu = true;
-
-            std::set<uint32> itemList;
-
-            //s2.1: build list
-            //s2.1.1: backpack
-            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
-                if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
-                    if (CanEquip(pItem->GetTemplate(), action - GOSSIP_ACTION_INFO_DEF) && itemList.find(pItem->GetEntry()) == itemList.end())
-                        itemList.insert(pItem->GetEntry());
-
-            //s2.1.2: other bags
-            for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
-                if (Bag* pBag = player->GetBagByPos(i))
-                    for (uint32 j = 0; j != pBag->GetBagSize(); j++)
-                        if (Item* pItem = player->GetItemByPos(i, j))
-                            if (CanEquip(pItem->GetTemplate(), action - GOSSIP_ACTION_INFO_DEF) && itemList.find(pItem->GetEntry()) == itemList.end())
-                                itemList.insert(pItem->GetEntry());
-
-            //s2.2: add gossips
-
-            //s2.2.0 add current item (with return)
-            uint8 slot = action - (GOSSIP_ACTION_INFO_DEF + 1);
-            std::ostringstream str;
-            str << ("å·²è£å¤ï¼ã");
-            if (uint32 itemId = master->GetBotEquip(me, slot))
-            {
-                if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
-                    _AddItemTemplateLink(master, proto, str);
-                else
-                    str << ("æªç¥ç©åã");
-
-                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, str.str().c_str(), GOSSIP_SENDER_EQUIPMENT_INFO, action);
-            }
-            else
-            {
-                str << ("æ²¡æä»»ä½ç©åã");
-                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, str.str().c_str(), GOSSIP_SENDER_EQUIPMENT_SHOW, action);
-            }
-
-            //s2.2.1 add unequip option if have weapon
-            if (action - GOSSIP_ACTION_INFO_DEF <= BOT_SLOT_RANGED)
-                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, ("è¿ååå§è£å¤ã"), GOSSIP_SENDER_EQUIP_RESET, action);
-
-            //s2.2.2 add unequip option if have weapon
-            if (master->GetBotEquip(me, action - (GOSSIP_ACTION_INFO_DEF + 1)))
-                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, ("å¸ä¸è£å¤ã"), GOSSIP_SENDER_UNEQUIP, action);
-
-            //s2.2.3a: add an empty submenu with info if no items are found
-            if (itemList.empty())
-            {
-                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, ("é£ä¸ªâ¦â¦ææ²¡æä»»ä½ä¸è¥¿å¯ä»¥ç»ä½ ã"), 0, GOSSIP_ACTION_INFO_DEF + 1);
-            }
-            else
-            {
-                ItemTemplate const* weap;
-                uint32 counter = 0;
-                uint32 maxcounter = GOSSIP_MAX_MENU_ITEMS - 4; //unequip, reset, current, back
-                uint32 slot = action - GOSSIP_ACTION_INFO_DEF;
-                //s2.2.3b: add items as gossip options
-                for (std::set<uint32>::const_iterator itr = itemList.begin(); itr != itemList.end() && counter < maxcounter; ++itr)
-                {
-                    weap = sObjectMgr->GetItemTemplate(*itr);
-                    if (weap)
-                    {
-                        std::ostringstream name;
-                        _AddItemTemplateLink(master, weap, name);
-                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP + (slot - 1), GOSSIP_ACTION_INFO_DEF + weap->ItemId);
-                        ++counter;
-                    }
-                }
-            }
-
-            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, ("è¿åã"), GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 2);
-
-            //////TC_LOG_ERROR("entities.player", "OnGossipSelect(bot): added %u item(s) to list of %s (requester: %s)",
-            //    counter, me->GetName().c_str(), player->GetName().c_str());
-
-            break;
-        }
-        case GOSSIP_SENDER_UNEQUIP: //equips change s3: Unequip
-        {
-            if (action - GOSSIP_ACTION_INFO_DEF == BOT_SLOT_MAINHAND)
-            {
-                if (me->GetBotClass() == CLASS_WARRIOR || me->GetBotClass() == CLASS_DEATH_KNIGHT ||
-                    me->GetBotClass() == CLASS_ROGUE || (me->GetBotClass() == CLASS_SHAMAN && IsMelee()) ||
-                    me->GetBotClass() == CLASS_PALADIN || me->GetBotClass() == CLASS_HUNTER)
-                {
-                    me->MonsterSay(("ä»ä¹ï¼ä½ è®©æèµ¤æç©ºæ³ï¼æ²¡é¨ï¼ã"), LANG_UNIVERSAL, player);
-                    break;
-                }
-            }
-            else if (action - GOSSIP_ACTION_INFO_DEF == BOT_SLOT_OFFHAND)
-            {
-                if (me->GetBotClass() == CLASS_ROGUE)
-                {
-                    me->MonsterSay(("ä¸ä¼å§ãã"), LANG_UNIVERSAL, player);
-                    break;
-                }
-            }
-            else if (action - GOSSIP_ACTION_INFO_DEF == BOT_SLOT_RANGED)
-            {
-                if (me->GetBotClass() == CLASS_HUNTER)
-                {
-                    me->MonsterSay(("è¶ï¼éå¸¸æè¶£ãã"), LANG_UNIVERSAL, player);
-                    break;
-                }
-            }
-            if (action - (GOSSIP_ACTION_INFO_DEF + 1) < BOT_SLOT_RANGED)
-            {
-                int8 id = 1;
-                uint8 slot = action - (GOSSIP_ACTION_INFO_DEF + 1);
-                EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
-                uint32 itemId = me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot);
-                if (einfo && einfo->ItemEntry[slot] == itemId)
-                {
-					me->MonsterSay(("è¯·é®å¨ä½ å¿éæçæ­¦å¨åæç¸æ¯æ¯ä¸æ¯æ´å·é­åå¢ï¼ã"), LANG_UNIVERSAL, player);
-                    break;
-                }
-            }
-
-            if (Unequip(action - (GOSSIP_ACTION_INFO_DEF + 1)))
-                me->MonsterSay(("åâ¦â¦ã"), LANG_UNIVERSAL, player);
-            break;
-        }
-        case GOSSIP_SENDER_EQUIP_RESET: //equips change s4a: reset equipment
-        {
-            if (ResetEquipment(action - (GOSSIP_ACTION_INFO_DEF + 1)))
-                me->MonsterSay(RANDCHAR<const char*>("Fine", "Very well", "Alright", "Yeah"), LANG_UNIVERSAL, player);
-            break;
-        }
-        //equips change s4b: Equip item
-        case GOSSIP_SENDER_EQUIP_BEGIN:     //1 - 1 main hand
-        case GOSSIP_SENDER_EQUIP_OHAND:     //2 - 1 off hand
-        case GOSSIP_SENDER_EQUIP_RANGED:    //3 - 1 ranged
-        case GOSSIP_SENDER_EQUIP_HEAD:      //4 - 1 head
-        case GOSSIP_SENDER_EQUIP_SHOULDERS: //5 - 1 shoulders
-        case GOSSIP_SENDER_EQUIP_CHEST:     //6 - 1 chest
-        case GOSSIP_SENDER_EQUIP_WAIST:     //7 - 1 waist
-        case GOSSIP_SENDER_EQUIP_LEGS:      //8 - 1 legs
-        case GOSSIP_SENDER_EQUIP_FEET:      //9 - 1 feet
-        case GOSSIP_SENDER_EQUIP_WRIST:     //10 - 1 wrist
-        case GOSSIP_SENDER_EQUIP_HANDS:     //11 - 1 hands
-        case GOSSIP_SENDER_EQUIP_BACK:      //12 - 1 back
-        case GOSSIP_SENDER_EQUIP_BODY:      //13 - 1 body
-        case GOSSIP_SENDER_EQUIP_FINGER1:   //14 - 1 finger
-        case GOSSIP_SENDER_EQUIP_FINGER2:   //15 - 1 finger
-        case GOSSIP_SENDER_EQUIP_TRINKET1:  //16 - 1 trinket
-        case GOSSIP_SENDER_EQUIP_TRINKET2:  //17 - 1 trinket
-        case GOSSIP_SENDER_EQUIP_NECK:      //18 - 1 neck
-        {
-            if (Equip(action - GOSSIP_ACTION_INFO_DEF, sender - GOSSIP_SENDER_EQUIP))
-                me->MonsterSay(RANDCHAR<const char*>("Fine", "Very well", "Alright", "Yeah", "Good", "Okay"), LANG_UNIVERSAL, player);
-            break;
-        }
-        case GOSSIP_SENDER_ROLES_TOGGLE: //ROLES 2: set/unset
-        {
-            ToggleRole(action - GOSSIP_ACTION_INFO_DEF);
-
-            //break;
-        }
-        case GOSSIP_SENDER_ROLES: //ROLES 1: list
-        {
-            subMenu = true;
-
-            uint8 role = BOT_ROLE_TANK;
-
-            for (; role != BOT_MAX_ROLE; role <<= 1)
-                player->ADD_GOSSIP_ITEM(_onOffIcon(role), GetRoleString(role), GOSSIP_SENDER_ROLES_TOGGLE, GOSSIP_ACTION_INFO_DEF + role);
-
-            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, ("è¿åã"), 1, GOSSIP_ACTION_INFO_DEF + role + 1);
-
-            break;
-        }
-        case GOSSIP_SENDER_ABILITIES_USE:
-        {
-            if (uint32 basespell = action - GOSSIP_ACTION_INFO_DEF)
-            {
-                uint32 spellId = GetSpell(basespell);
-                if (doCast(player, spellId))
-                {
-                    uint32 rec = sSpellMgr->GetSpellInfo(spellId)->GetRecoveryTime();
-                    rec = !rec ? 15000 : std::min<uint32>(rec, 90000);
-                    SetSpellCooldown(basespell, rec);
-                }
-            }
-
-            //break;
-        }
-        case GOSSIP_SENDER_ABILITIES:
-        {
-            subMenu = true;
-
-            uint32 basespell;
-            SpellInfo const* spellInfo;
-            BotSpellMap const& myspells = GetSpellMap();
-            for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
-            {
-                basespell = (*itr).first; //always valid
-                if (!CanUseManually(basespell)) continue;
-                if (!IsSpellReady(basespell, 0, false, 5000)) continue;
-                spellInfo = sSpellMgr->GetSpellInfo(basespell); //always valid
-
-                std::ostringstream name;
-                _AddSpellLink(player, spellInfo, name);
-                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, name.str().c_str(), GOSSIP_SENDER_ABILITIES_USE, GOSSIP_ACTION_INFO_DEF + basespell);
-            }
-
-            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, ("å·æ°ã"), GOSSIP_SENDER_ABILITIES_USE, GOSSIP_ACTION_INFO_DEF);
-            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, ("è¿åã"), 1, GOSSIP_ACTION_INFO_DEF + 2);
-
-            break;
-        }
-        default:
-            break;
-    }
-
-    //if we add submenus send them else we should return
-    if (subMenu)
-        player->PlayerTalkClass->SendGossipMenu(GOSSIP_SERVE_MASTER, me->GetGUID());
-    else
-        player->CLOSE_GOSSIP_MENU();
-
-    return true;
-}
-//Summons pet for bot
-void bot_minion_ai::SummonBotsPet(uint32 entry)
-{
-    Creature* m_botsPet = me->GetBotsPet();
-    if (m_botsPet)
-        me->SetBotsPetDied();
-
-    uint8 mylevel = std::min<uint8>(master->getLevel(), 80);
-    uint32 originalentry = bot_pet_ai::GetPetOriginalEntry(entry);
-    if (!originalentry)
-    {
-        //annoy master
-        me->MonsterWhisper(("ä¸ºä»ä¹æè¦å°è¯çå¬å¤ä¸åªæªç¥çå® ç©ï¼ï¼ã"), master);
-        return;
-    }
-    uint32 armor = 0;
-    float x(0),y(0),z(0);
-    me->GetClosePoint(x, y, z, me->GetObjectSize());
-    m_botsPet = me->SummonCreature(entry, x, y, z, 0, TEMPSUMMON_DEAD_DESPAWN);
-
-    if (!m_botsPet)
-    {
-        me->MonsterWhisper(("å¬å¤å® ç©å¤±è´¥ï¼ã"), master);
-        return;
-    }
-
-    //std::string name = sObjectMgr->GeneratePetName(originalentry);//voidwalker
-    //if (!name.empty())
-    //    m_botsPet->SetName(name);
-
-    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_NPCBOT_PET_LEVELSTATS);
-    stmt->setUInt32(0, originalentry);
-    stmt->setUInt8(1, mylevel);
-    PreparedQueryResult result = WorldDatabase.Query(stmt);
-    //QueryResult result = WorldDatabase.PQuery("SELECT hp, mana, armor, str, agi, sta, inte, spi FROM `pet_levelstats` WHERE `creature_entry` = '%u' AND `level` = '%u'", originalentry, mylevel);
-
-    if (result)
-    {
-        Field* fields = result->Fetch();
-        uint32 hp = fields[0].GetUInt16();
-        uint32 mana = fields[1].GetUInt16();
-        armor = fields[2].GetUInt32();
-        uint32 str = fields[3].GetUInt16();
-        uint32 agi = fields[4].GetUInt16();
-        uint32 sta = fields[5].GetUInt16();
-        uint32 inte = fields[6].GetUInt16();
-        uint32 spi = fields[7].GetUInt16();
-
-        m_botsPet->SetCreateHealth(hp);
-        m_botsPet->SetMaxHealth(hp);
-        m_botsPet->SetCreateMana(mana);
-        m_botsPet->SetMaxPower(POWER_MANA, mana);
-
-        m_botsPet->SetCreateStat(STAT_STRENGTH, str);
-        m_botsPet->SetCreateStat(STAT_AGILITY, agi);
-        m_botsPet->SetCreateStat(STAT_STAMINA, sta);
-        m_botsPet->SetCreateStat(STAT_INTELLECT, inte);
-        m_botsPet->SetCreateStat(STAT_SPIRIT, spi);
-    }
-
-    m_botsPet->SetBotOwner(master);
-    m_botsPet->SetCreatureOwner(me);
-    m_botsPet->SetBotClass(bot_pet_ai::GetPetClass(m_botsPet));
-    master->SetMinion((Minion*)m_botsPet, true);
-    m_botsPet->SetUInt64Value(UNIT_FIELD_CREATEDBY, me->GetGUID());
-    m_botsPet->DeleteThreatList();
-    m_botsPet->AddUnitTypeMask(UNIT_MASK_MINION);
-    //m_botsPet->SetLevel(master->getLevel());
-    m_botsPet->AIM_Initialize();
-    m_botsPet->InitBotAI(true);
-    m_botsPet->setFaction(master->getFaction());
-    //bot_pet_ai* petai = m_botsPet->GetBotPetAI();
-    //petai->SetCreatureOwner(me);
-    //petai->SetBaseArmor(armor);
-    //petai->SetStats(mylevel, bot_pet_ai::GetPetType(m_botsPet), true);
-    m_botsPet->SetBotCommandState(COMMAND_FOLLOW, true);
-
-    me->SetBotsPet(m_botsPet);
-
-    m_botsPet->SendUpdateToPlayer(master);
-}
-
-uint16 bot_ai::Rand() const
-{
-    return urand(0, 100 + (master->GetNpcBotsCount() - 1) * 10);
-}
-//Returns pet type (maybe unneeded)
-uint8 bot_pet_ai::GetPetType(Creature* pet)
-{
-    switch (pet->GetEntry())
-    {
-        case PET_VOIDWALKER:
-            return PET_TYPE_VOIDWALKER;
-    }
-    return PET_TYPE_NONE;
-}
-//Returns pet's class
-uint8 bot_pet_ai::GetPetClass(Creature* pet)
-{
-    switch (GetPetType(pet))
-    {
-        case PET_TYPE_IMP:
-            return CLASS_MAGE;
-        default:
-            return CLASS_PALADIN;
-    }
-}
-//Return entry used to summon real pets
-uint32 bot_pet_ai::GetPetOriginalEntry(uint32 entry)
-{
-    switch (entry)
-    {
-        case PET_VOIDWALKER:
-            return ORIGINAL_ENTRY_VOIDWALKER;
-        default:
-            return 0;
-    }
-}
-//PvP trinket for minions
-void bot_minion_ai::BreakCC(uint32 diff)
-{
-    if (pvpTrinket_cd <= diff && CCed(me, true) && (me->GetVictim() || !me->getAttackers().empty()))
-    {
-        temptimer = GC_Timer;
-        if (doCast(me, PVPTRINKET))
-        {
-            pvpTrinket_cd = 120000; //2 minutes default pvp trinket CD
-            GC_Timer = temptimer;
-            return;
-        }
-    }
-}
-//Returns attack range based on given range
-//If mounted: 20%
-//If ranged: 125%
-//If master is dead: max range
-float bot_ai::InitAttackRange(float origRange, bool ranged) const
-{
-    if (me->IsMounted())
-        origRange *= 0.2f;
-    else
-    {
-        if (ranged)
-            origRange *= 1.25f;
-        if (master->isDead())
-            origRange += sWorld->GetMaxVisibleDistanceOnContinents();
-    }
-    return origRange;
-}
-//Force bots to start attack anyone who tries to DAMAGE me or master
-//This means that anyone who attacks party will be attacked by whole bot party (see GetTarget())
-void bot_minion_ai::OnOwnerDamagedBy(Unit* attacker)
-{
-    if (IAmDead())
-        return;
-    if (me->GetVictim())
-        return;
-    if (InDuel(attacker))
-        return;
-    bool byspell = false;
-    bool ranged = !IsMelee();
-    switch (me->GetBotClass())
-    {
-        case CLASS_DRUID:
-            byspell = GetBotStance() == CLASS_DRUID || GetBotStance() == DRUID_MOONKIN_FORM;
-            break;
-        case CLASS_PRIEST:
-        case CLASS_MAGE:
-        case CLASS_WARLOCK:
-        case CLASS_SHAMAN:
-            byspell = true;
-            break;
-        default:
-            break;
-    }
-    float maxdist = InitAttackRange(float(master->GetBotFollowDist()), ranged); //use increased range
-    if (!attacker->IsWithinDist(me, maxdist))
-        return;
-    if (!CanBotAttack(attacker, byspell))
-        return;
-
-    m_botCommandState = COMMAND_ABANDON; //reset AttackStart()
-    me->Attack(attacker, !ranged);
-}
-
-bool bot_minion_ai::CanUseOffHand() const
-{
-    //warriot can wield any offhand with titan's grip
-    if (me->GetBotClass() == CLASS_WARRIOR && me->getLevel() >= 60)
-        return true;
-
-    if (me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0))
-    {
-        if (ItemTemplate const* item = sObjectMgr->GetItemTemplate(me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0)))
-        {
-            if (item->Class == ITEM_CLASS_WEAPON && item->InventoryType == INVTYPE_2HWEAPON)
-            return false;
-        }
-    }
-    //no offhand: check we are using one-handed weapon in main hand
-    if (!me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1))
-    {
-        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0)))
-        {
-            if (proto->Class == ITEM_CLASS_WEAPON && proto->InventoryType != INVTYPE_2HWEAPON &&
-                (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE ||
-                proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
-                proto->SubClass == ITEM_SUBCLASS_WEAPON_FIST ||
-                proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE ||
-                proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD))
-                return true;
-        }
-    }
-    else if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1)))
-    {
-        //Now we have something in off-hand
-        //1 check if it is one-handed weapon
-        if (proto->Class == ITEM_CLASS_WEAPON && proto->InventoryType != INVTYPE_2HWEAPON &&
-            (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE ||
-            proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
-            proto->SubClass == ITEM_SUBCLASS_WEAPON_FIST ||
-            proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE ||
-            proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD))
-            return true;
-        //2 check of it is a shield
-        if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
-            return true;
-        //3 check of it is a 'held in off-hand' item
-        if (proto->InventoryType == INVTYPE_HOLDABLE)
-            return true;
-    }
-
-    //NO
-    return false;
-}
-
-bool bot_minion_ai::CanUseRanged() const
-{
-    return (me->GetBotClass() == CLASS_HUNTER/* || me->GetBotClass() == CLASS_ROGUE*/);
-    //return (me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2) != 0);
-}
-
-bool bot_minion_ai::CanEquip(ItemTemplate const* item, uint8 slot) const
-{
-    //prevent reequipping same items
-    if (item->ItemId == master->GetBotEquip(me, slot - 1))
-        return false;
-
-    //prevent equipping items with random properties (temp)
-    //if (item->RandomProperty > 0 || item->RandomSuffix > 0)
-        //if (item->Quality >= ITEM_QUALITY_RARE)
-            //return false;
-
-    //level requirements
-    if (me->getLevel() < item->RequiredLevel)
-        return false;
-
-    //class requirements
-    if (!(item->AllowableClass & (1<<(me->GetBotClass()-1))))
-        return false;
-
-    //skip race requirements
-
-    if (item->Class == ITEM_CLASS_WEAPON)
-    {
-        if (slot > BOT_SLOT_RANGED)
-            return false;
-
-        if (slot == BOT_SLOT_MAINHAND && item->SubClass == INVTYPE_WEAPONOFFHAND)
-            return false;
-        if (slot == BOT_SLOT_OFFHAND && item->SubClass == INVTYPE_WEAPONMAINHAND)
-            return false;
-        if (slot == BOT_SLOT_OFFHAND && item->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
-            return false;
-
-        if (slot == BOT_SLOT_OFFHAND && me->GetBotClass() != CLASS_WARRIOR &&
-            me->GetBotClass() != CLASS_ROGUE && me->GetBotClass() != CLASS_HUNTER &&
-            me->GetBotClass() != CLASS_SHAMAN && me->GetBotClass() != CLASS_DEATH_KNIGHT)
-            return false;
-
-        /*if (slot == BOT_SLOT_MAINHAND && item->SubClass != ITEM_SUBCLASS_WEAPON_DAGGER &&
-            me->GetBotClass() == CLASS_ROGUE)
-            return false;*/
-
-        if ((item->InventoryType == INVTYPE_THROWN || item->InventoryType == INVTYPE_RANGED || item->InventoryType == INVTYPE_RANGEDRIGHT) && CanUseRanged())
-        {
-            if (item->SubClass == ITEM_SUBCLASS_WEAPON_BOW)
-                return (me->GetBotClass() == CLASS_WARRIOR || me->GetBotClass() == CLASS_ROGUE || me->GetBotClass() == CLASS_HUNTER) && slot == BOT_SLOT_RANGED;
-            else if (item->SubClass == ITEM_SUBCLASS_WEAPON_GUN)
-                return (me->GetBotClass() == CLASS_WARRIOR || me->GetBotClass() == CLASS_ROGUE || me->GetBotClass() == CLASS_HUNTER) && slot == BOT_SLOT_RANGED;
-            else if (item->SubClass == ITEM_SUBCLASS_WEAPON_THROWN)
-                return (me->GetBotClass() == CLASS_WARRIOR || me->GetBotClass() == CLASS_ROGUE || me->GetBotClass() == CLASS_HUNTER) && slot == BOT_SLOT_RANGED;
-            else if (item->SubClass == ITEM_SUBCLASS_WEAPON_CROSSBOW)
-                return (me->GetBotClass() == CLASS_WARRIOR || me->GetBotClass() == CLASS_ROGUE || me->GetBotClass() == CLASS_HUNTER) && slot == BOT_SLOT_RANGED;
-            else if (item->SubClass == ITEM_SUBCLASS_WEAPON_WAND)
-                return (me->GetBotClass() == CLASS_MAGE || me->GetBotClass() == CLASS_PRIEST || me->GetBotClass() == CLASS_WARLOCK) && slot == BOT_SLOT_RANGED;
-        }
-        else if (item->InventoryType == INVTYPE_2HWEAPON)
-        {
-            if (me->GetBotClass() == CLASS_WARRIOR && me->getLevel() >= 60 && (slot == BOT_SLOT_MAINHAND || slot == BOT_SLOT_OFFHAND))
-                return true;
-
-            if (item->SubClass == ITEM_SUBCLASS_WEAPON_EXOTIC || item->SubClass == ITEM_SUBCLASS_WEAPON_EXOTIC2)
-                return false;
-
-            if (item->SubClass == ITEM_SUBCLASS_WEAPON_MISC)
-                return false;
-
-            if (me->GetBotClass() == CLASS_ROGUE)
-                return false;
-
-            if ((me->GetBotClass() == CLASS_MAGE || me->GetBotClass() == CLASS_PRIEST || me->GetBotClass() == CLASS_WARLOCK) && item->SubClass != ITEM_SUBCLASS_WEAPON_STAFF)
-                return false;
-
-            if (me->GetBotClass() == CLASS_PALADIN && item->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
-                return false;
-
-            if (me->GetBotClass() == CLASS_HUNTER && (item->SubClass == ITEM_SUBCLASS_WEAPON_MACE || item->SubClass == ITEM_SUBCLASS_WEAPON_MACE2))
-                return false;
-
-            if (me->GetBotClass() == CLASS_DRUID && (item->SubClass == ITEM_SUBCLASS_WEAPON_AXE || item->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 || item->SubClass == ITEM_SUBCLASS_WEAPON_SWORD || item->SubClass == ITEM_SUBCLASS_WEAPON_SWORD2))
-                return false;
-
-            if (me->GetBotClass() == CLASS_SHAMAN && (item->SubClass == ITEM_SUBCLASS_WEAPON_SWORD || item->SubClass == ITEM_SUBCLASS_WEAPON_SWORD2 || item->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM))
-                return false;
-
-            if (me->GetBotClass() == CLASS_DEATH_KNIGHT && (item->SubClass == ITEM_SUBCLASS_WEAPON_MACE || item->SubClass == ITEM_SUBCLASS_WEAPON_MACE2 || item->SubClass == ITEM_SUBCLASS_WEAPON_STAFF))
-                return false;
-
-            return (slot == BOT_SLOT_MAINHAND);
-        }
-        else if (item->InventoryType == INVTYPE_WEAPON ||
-            item->InventoryType == INVTYPE_WEAPONMAINHAND ||
-            item->InventoryType == INVTYPE_WEAPONOFFHAND)
-        {
-            if (item->SubClass == ITEM_SUBCLASS_WEAPON_EXOTIC || item->SubClass == ITEM_SUBCLASS_WEAPON_EXOTIC2)
-                return false;
-
-            if (item->SubClass == ITEM_SUBCLASS_WEAPON_MISC)
-                return false;
-
-            if ((me->GetBotClass() == CLASS_MAGE || me->GetBotClass() == CLASS_WARLOCK) && (item->SubClass == ITEM_SUBCLASS_WEAPON_AXE || item->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 || item->SubClass == ITEM_SUBCLASS_WEAPON_MACE || item->SubClass == ITEM_SUBCLASS_WEAPON_MACE2 || item->SubClass == ITEM_SUBCLASS_WEAPON_FIST))
-                return false;
-
-            if (me->GetBotClass() == CLASS_PRIEST && (item->SubClass == ITEM_SUBCLASS_WEAPON_SWORD || item->SubClass == ITEM_SUBCLASS_WEAPON_SWORD2 || item->SubClass == ITEM_SUBCLASS_WEAPON_AXE || item->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 || item->SubClass == ITEM_SUBCLASS_WEAPON_FIST))
-                return false;
-
-            if (me->GetBotClass() == CLASS_PALADIN && (item->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER || item->SubClass == ITEM_SUBCLASS_WEAPON_FIST))
-                return false;
-
-            if (me->GetBotClass() == CLASS_HUNTER && (item->SubClass == ITEM_SUBCLASS_WEAPON_MACE || item->SubClass == ITEM_SUBCLASS_WEAPON_MACE2))
-                return false;
-
-            if (me->GetBotClass() == CLASS_DRUID && (item->SubClass == ITEM_SUBCLASS_WEAPON_AXE || item->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 || item->SubClass == ITEM_SUBCLASS_WEAPON_SWORD || item->SubClass == ITEM_SUBCLASS_WEAPON_SWORD2))
-                return false;
-
-            if (me->GetBotClass() == CLASS_SHAMAN && (item->SubClass == ITEM_SUBCLASS_WEAPON_SWORD || item->SubClass == ITEM_SUBCLASS_WEAPON_SWORD2))
-                return false;
-
-            if (me->GetBotClass() == CLASS_DEATH_KNIGHT && (item->SubClass == ITEM_SUBCLASS_WEAPON_MACE || item->SubClass == ITEM_SUBCLASS_WEAPON_MACE2 || item->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER || item->SubClass == ITEM_SUBCLASS_WEAPON_FIST))
-                return false;
-
-            return (slot == BOT_SLOT_MAINHAND ||
-                (slot == BOT_SLOT_OFFHAND && me->GetBotClass() != CLASS_PALADIN && CanUseOffHand()));
-        }
-    }
-    else if (item->Class == ITEM_CLASS_ARMOR)
-    {
-        switch (item->InventoryType)
-        {
-            case INVTYPE_HEAD:
-                if (slot != BOT_SLOT_HEAD)
-                    return false;
-                break;
-            case INVTYPE_SHOULDERS:
-                if (slot != BOT_SLOT_SHOULDERS)
-                    return false;
-                break;
-            case INVTYPE_BODY:
-                if (slot != BOT_SLOT_BODY)
-                    return false;
-                break;
-            case INVTYPE_CHEST:
-            case INVTYPE_ROBE:
-                if (slot != BOT_SLOT_CHEST)
-                    return false;
-                break;
-            case INVTYPE_WAIST:
-                if (slot != BOT_SLOT_WAIST)
-                    return false;
-                break;
-            case INVTYPE_LEGS:
-                if (slot != BOT_SLOT_LEGS)
-                    return false;
-                break;
-            case INVTYPE_FEET:
-                if (slot != BOT_SLOT_FEET)
-                    return false;
-                break;
-            case INVTYPE_WRISTS:
-                if (slot != BOT_SLOT_WRIST)
-                    return false;
-                break;
-            case INVTYPE_HANDS:
-                if (slot != BOT_SLOT_HANDS)
-                    return false;
-                break;
-            case INVTYPE_FINGER:
-                if (slot != BOT_SLOT_FINGER1 && slot != BOT_SLOT_FINGER2)
-                    return false;
-                break;
-            case INVTYPE_TRINKET:
-                if (slot != BOT_SLOT_TRINKET1 && slot != BOT_SLOT_TRINKET2)
-                    return false;
-                break;
-            case INVTYPE_NECK:
-                if (slot != BOT_SLOT_NECK)
-                    return false;
-                break;
-            case INVTYPE_CLOAK:
-                if (slot != BOT_SLOT_BACK)
-                    return false;
-                break;
-            case INVTYPE_HOLDABLE:
-            case INVTYPE_SHIELD:
-                if (slot != BOT_SLOT_OFFHAND)
-                    return false;
-                break;
-            case INVTYPE_RELIC:
-                if (slot != BOT_SLOT_RANGED)
-                    return false;
-                break;
-            default:
-                break;
-        }
-
-        if (item->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
-        {
-            if (slot == BOT_SLOT_OFFHAND)
-            {
-                return CanUseOffHand() &&
-                    (me->GetBotClass() == CLASS_WARRIOR ||
-                    me->GetBotClass() == CLASS_PALADIN ||
-                    me->GetBotClass() == CLASS_SHAMAN);
-            }
-        }
-        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_PLATE)
-        {
-            return (me->getLevel() >= 40 &&
-                (me->GetBotClass() == CLASS_WARRIOR ||
-                me->GetBotClass() == CLASS_DEATH_KNIGHT ||
-                me->GetBotClass() == CLASS_PALADIN));
-        }
-        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_MAIL)
-        {
-            if (me->GetBotClass() == CLASS_WARRIOR ||
-                me->GetBotClass() == CLASS_DEATH_KNIGHT ||
-                me->GetBotClass() == CLASS_PALADIN)
-                return true;
-
-            return (me->getLevel() >= 40 &&
-                (me->GetBotClass() == CLASS_SHAMAN ||
-                me->GetBotClass() == CLASS_HUNTER));
-        }
-        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_LEATHER)
-        {
-            return (me->GetBotClass() != CLASS_WARLOCK &&
-                me->GetBotClass() != CLASS_MAGE &&
-                me->GetBotClass() != CLASS_PRIEST);
-        }
-        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_CLOTH)
-        {
-            return true;
-        }
-        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_MISC)
-        {
-            if (item->InventoryType == INVTYPE_FEET && slot == BOT_SLOT_FEET)
-                return true;
-            if (item->InventoryType == INVTYPE_BODY && slot == BOT_SLOT_BODY)
-                return true;
-            if (item->InventoryType == INVTYPE_FINGER &&
-                (slot == BOT_SLOT_FINGER1 || slot == BOT_SLOT_FINGER2))
-                return true;
-            if (item->InventoryType == INVTYPE_TRINKET &&
-                (slot == BOT_SLOT_TRINKET1 || slot == BOT_SLOT_TRINKET2))
-                return true;
-            if (item->InventoryType == INVTYPE_NECK && slot == BOT_SLOT_NECK)
-                return true;
-            if (item->InventoryType == INVTYPE_HOLDABLE && slot == BOT_SLOT_OFFHAND)
-                return true;
-        }
-        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_LIBRAM)
-            return me->GetBotClass() == CLASS_PALADIN && slot == BOT_SLOT_RANGED;
-        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_IDOL)
-            return me->GetBotClass() == CLASS_DRUID && slot == BOT_SLOT_RANGED;
-        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_TOTEM)
-            return me->GetBotClass() == CLASS_SHAMAN && slot == BOT_SLOT_RANGED;
-        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_SIGIL)
-            return me->GetBotClass() == CLASS_DEATH_KNIGHT && slot == BOT_SLOT_RANGED;
-    }
-
-    return false;
-}
-
-bool bot_minion_ai::Unequip(uint8 slot)
-{
-    if (slot < BOT_SLOT_RANGED)
-    {
-        int8 id = 1;
-        EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
-        uint32 itemId = me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot);
-        if (!einfo || einfo->ItemEntry[slot] != me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot))
-        {
-            ItemPosCountVec dest;
-            uint32 no_space = 0;
-            InventoryResult msg = master->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, 1, &no_space);
-            if (msg != EQUIP_ERR_OK)
-            {
-                master->SendEquipError(msg, NULL, NULL, itemId);
-                return false;
-            }
-            Item* pItem = master->StoreNewItem(dest, itemId, true, 0);
-            if (!pItem)
-            {
-                master->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
-                return false;
-            }
-            master->SendNewItem(pItem, 1, true, false, false);
-        }
-
-        //only for non-standard items
-        if (!(einfo && einfo->ItemEntry[slot] == itemId))
-            RemoveItemBonuses(slot);
-
-        me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot, 0);
-        me->SetAttackTime(WeaponAttackType(slot), 2000); //without weapon
-
-        if (slot + 1 == BOT_SLOT_OFFHAND)
-        {
-            if (me->CanDualWield())
-                me->SetCanDualWield(false);
-            //if (!(me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK))
-                //const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra |= CREATURE_FLAG_EXTRA_NO_BLOCK;
-        }
-		master->UpdateBotEquips(me, slot, 0);
-		master->UpdateBotModelid(me);
-    }
-    else
-    {
-        uint32 itemId = master->GetBotEquip(me, slot);
-        if (itemId == 0)
-            return true; //nothing to unequip
-
-        ItemPosCountVec dest;
-        uint32 no_space = 0;
-        InventoryResult msg = master->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, 1, &no_space);
-        if (msg != EQUIP_ERR_OK)
-        {
-            master->SendEquipError(msg, NULL, NULL, itemId);
-            return false;
-        }
-        Item* pItem = master->StoreNewItem(dest, itemId, true, 0);
-        if (!pItem)
-        {
-            master->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
-            return false;
-        }
-        master->SendNewItem(pItem, 1, true, false, false);
-
-        RemoveItemBonuses(slot);
-
-        master->UpdateBotEquips(me, slot, 0);
-		master->UpdateBotModelid(me);
-    }
-
-    return true;
-}
-
-bool bot_minion_ai::Equip(uint32 itemId, uint8 slot)
-{
-    if (master->GetBotEquip(me, slot) == itemId)
-        return false;
-
-    if (!itemId)
-        return false;
-
-    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
-    if (!proto)
-        return false;
-
-    if (slot < BOT_SLOT_RANGED)
-    {
-        int8 id = 1;
-        EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
-
-        if (me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot))
-        {
-            if (!Unequip(slot))
-            {
-                me->MonsterSay("ä½ æ²¡æè¶³å¤çèåç©ºé´æ¥å­æ¾æçè£å¤ãã", LANG_UNIVERSAL, master);
-                return false;
-            }
-        }
-
-        if (!einfo || einfo->ItemEntry[slot] != itemId)
-        {
-            if (!master->HasItemCount(itemId, 1))
-            {
-                std::ostringstream msg;
-                msg << ("æ æ³æ¾å°ã");
-                _AddItemTemplateLink(master, proto, msg);
-                msg << " (id: " << uint32(itemId) << ")!";
-                me->MonsterWhisper(msg.str().c_str(), master);
-                return false;
-            }
-
-            master->DestroyItemCount(itemId, 1, true);
-        }
-
-        me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot, itemId);
-        me->SetAttackTime(WeaponAttackType(slot), einfo && einfo->ItemEntry[slot] == itemId ? me->GetCreatureTemplate()->BaseAttackTime : proto->Delay); //set attack speed
-        master->UpdateBotEquips(me, slot, itemId);
-		master->UpdateBotModelid(me);
-
-        //only for non-standard items
-        if (!(einfo && einfo->ItemEntry[slot] == itemId))
-            ApplyItemBonuses(slot);
-
-        if (slot + 1 == BOT_SLOT_OFFHAND)
-        {
-            if (proto->Class == ITEM_CLASS_WEAPON)
-            {
-                if (!me->CanDualWield())
-                    me->SetCanDualWield(true);
-            }
-            else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
-            {
-                if (me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
-                    const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
-            }
-        }
-        else if (slot + 1 == BOT_SLOT_MAINHAND && proto->InventoryType == INVTYPE_2HWEAPON &&
-            !(me->GetBotClass() == CLASS_WARRIOR && me->getLevel() >= 60))
-        {
-            //if have offhand unequip it
-            if (me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1))
-                Unequip(BOT_SLOT_OFFHAND - 1);
-        }
-    }
-    else
-    {
-        if (!Unequip(slot))
-        {
-            me->MonsterSay("ä½ æ²¡æè¶³å¤çèåç©ºé´æ¥å­æ¾æçè£å¤ãã", LANG_UNIVERSAL, master);
-            return false;
-        }
-
-        if (!master->HasItemCount(itemId, 1))
-        {
-            std::ostringstream msg;
-            msg << ("æ æ³æ¾å°ã");
-            _AddItemTemplateLink(master, proto, msg);
-            msg << " (id: " << uint32(itemId) << ")!";
-            me->MonsterWhisper(msg.str().c_str(), master);
-            return false;
-        }
-
-        master->DestroyItemCount(itemId, 1, true);
-
-        master->UpdateBotEquips(me, slot, itemId);
-		master->UpdateBotModelid(me);
-        ApplyItemBonuses(slot);
-    }
-
-    return true;
-}
-
-bool bot_minion_ai::ResetEquipment(uint8 slot)
-{
-    if (slot < BOT_SLOT_RANGED)
-    {
-        int8 id = 1;
-        EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
-        if (!einfo || !einfo->ItemEntry[slot])
-            return Unequip(slot);
-
-        if (slot + 1 == BOT_SLOT_MAINHAND && !(me->GetBotClass() == CLASS_WARRIOR && me->getLevel() >= 60))
-        {
-            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(einfo->ItemEntry[slot]))
-            {
-                if (proto->Class == ITEM_CLASS_WEAPON &&
-                    (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 || proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE2 ||
-                    proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD2 || proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM ||
-                    proto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF || proto->SubClass == ITEM_SUBCLASS_WEAPON_SPEAR))
-                {
-                    if (!Unequip(BOT_SLOT_OFFHAND - 1))
-                        return false;
-                }
-            }
-        }
-
-        return Equip(einfo->ItemEntry[slot], slot);
-    }
-
-    return Unequip(slot);
-}
-
-void bot_minion_ai::ApplyItemBonuses(uint8 slot)
-{
-    //ensurance to set zeros
-    RemoveItemBonuses(slot);
-
-    uint32 itemId = master->GetBotEquip(me, slot);
-    if (!itemId)
-        return;
-
-    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
-    if (!proto)
-        return;
-
-    ScalingStatDistributionEntry const* ssd = proto->ScalingStatDistribution ? sScalingStatDistributionStore.LookupEntry(proto->ScalingStatDistribution) : NULL;
-
-    uint32 ssd_level = me->getLevel();
-    if (ssd && ssd_level > ssd->MaxLevel)
-        ssd_level = ssd->MaxLevel;
-
-    ScalingStatValuesEntry const* ssv = proto->ScalingStatValue ? sScalingStatValuesStore.LookupEntry(ssd_level) : NULL;
-
-    for (uint8 i = 0; i != MAX_ITEM_PROTO_STATS; ++i)
-    {
-        uint32 statType = 0;
-        int32  val = 0;
-        if (ssd && ssv)
-        {
-            if (ssd->StatMod[i] < 0)
-                continue;
-            statType = ssd->StatMod[i];
-            val = (ssv->getssdMultiplier(proto->ScalingStatValue) * ssd->Modifier[i]) / 10000;
-        }
-        else
-        {
-            if (i >= proto->StatsCount)
-                continue;
-
-            statType = proto->ItemStat[i].ItemStatType;
-            val = proto->ItemStat[i].ItemStatValue;
-        }
-
-        if (val == 0)
-            continue;
-
-        _stats[slot][statType] += val;
-    }
-
-    for (uint8 i = 0; i != MAX_ITEM_SPELLS; ++i)
-    {
-        _Spell const& spellData = proto->Spells[i];
-        if (!spellData.SpellId)
-            continue;
-        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
-        if (!spellInfo)
-            continue;
-
-        if (spellInfo->HasEffect(SPELL_EFFECT_ADD_EXTRA_ATTACKS))
-            continue;
-
-        for (uint8 j = 0; j != MAX_SPELL_EFFECTS; ++j)
-        {
-            if (spellInfo->Effects[j].ApplyAuraName == SPELL_AURA_MOD_SHIELD_BLOCKVALUE)
-                _stats[slot][ITEM_MOD_BLOCK_VALUE] += spellInfo->Effects[j].CalcValue();
-        }
-
-        if (spellData.SpellTrigger != ITEM_SPELLTRIGGER_CHANCE_ON_HIT)
-            continue;
-
-        bool exists = false;
-        for (uint8 j = 0; j != MAX_BOT_CTC_SPELLS; ++j)
-        {
-            if (_ctc[j].first == spellInfo->Id)
-            {
-                exists = true;
-                break;
-            }
-        }
-        if (exists)
-            continue;
-
-        for (uint8 j = 0; j != MAX_BOT_CTC_SPELLS; ++j)
-        {
-            if (_ctc[j].first == 0)
-            {
-                _ctc[j].first = spellInfo->Id;
-                _ctc[j].second = 0; //reset cd
-                break;
-            }
-        }
-    }
-
-    _stats[slot][BOT_ITEM_MOD_RESIST_HOLY] = proto->HolyRes;
-    _stats[slot][BOT_ITEM_MOD_RESIST_FIRE] = proto->FireRes;
-    _stats[slot][BOT_ITEM_MOD_RESIST_NATURE] = proto->NatureRes;
-    _stats[slot][BOT_ITEM_MOD_RESIST_FROST] = proto->FrostRes;
-    _stats[slot][BOT_ITEM_MOD_RESIST_SHADOW] = proto->ShadowRes;
-    _stats[slot][BOT_ITEM_MOD_RESIST_ARCANE] = proto->ArcaneRes;
-
-    if (proto->Class == ITEM_CLASS_WEAPON)
-        _stats[slot][BOT_ITEM_MOD_DAMAGE] = proto->Damage[0].DamageMin;
-    else if (proto->Class == ITEM_CLASS_ARMOR)
-        _stats[slot][BOT_ITEM_MOD_ARMOR] = proto->Armor;
-
-    if (proto->Block)
-        _stats[slot][ITEM_MOD_BLOCK_VALUE] += proto->Block;
-
-    shouldUpdateStats = true;
-}
-
-void bot_minion_ai::RemoveItemBonuses(uint8 slot)
-{
-    uint32 itemId = master->GetBotEquip(me, slot);
-    if (!itemId)
-        return;
-
-    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
-    if (!proto)
-        return;
-
-    for (uint8 i = 0; i != MAX_BOT_ITEM_MOD; ++i)
-        _stats[slot][i] = 0;
-
-    for (uint8 i = 0; i != MAX_ITEM_SPELLS; ++i)
-    {
-        if (uint32 spellId = proto->Spells[i].SpellId)
-        {
-            for (uint8 j = 0; j != MAX_BOT_CTC_SPELLS; ++j)
-            {
-                if (_ctc[j].first == spellId)
-                {
-                    _ctc[j].first = 0;
-                    break;
-                }
-            }
-        }
-    }
-
-    _stats[slot][BOT_ITEM_MOD_RESIST_HOLY] = 0;
-    _stats[slot][BOT_ITEM_MOD_RESIST_FIRE] = 0;
-    _stats[slot][BOT_ITEM_MOD_RESIST_NATURE] = 0;
-    _stats[slot][BOT_ITEM_MOD_RESIST_FROST] = 0;
-    _stats[slot][BOT_ITEM_MOD_RESIST_SHADOW] = 0;
-    _stats[slot][BOT_ITEM_MOD_RESIST_ARCANE] = 0;
-
-    if (proto->Class == ITEM_CLASS_WEAPON)
-        _stats[slot][BOT_ITEM_MOD_DAMAGE] = 0;
-    else if (proto->Class == ITEM_CLASS_ARMOR)
-        _stats[slot][BOT_ITEM_MOD_ARMOR] = 0;
-
-    if (proto->Block)
-        _stats[slot][ITEM_MOD_BLOCK_VALUE] = 0;
-
-    shouldUpdateStats = true;
-}
-
-char const* bot_minion_ai::_getNameForSlot(uint8 slot) const
-{
-    switch (slot)
-    {
-        case BOT_SLOT_MAINHAND:
-            return ("ä¸»æã");
-        case BOT_SLOT_OFFHAND:
-            return ("å¯æã");
-        case BOT_SLOT_RANGED:
-            if (me->GetBotClass() == CLASS_PALADIN || me->GetBotClass() == CLASS_DRUID || me->GetBotClass() == CLASS_SHAMAN || me->GetBotClass() == CLASS_DEATH_KNIGHT)
-                return ("å£ç©ã");
-            else
-                return ("è¿ç¨ã");
-        case BOT_SLOT_HEAD:
-            return ("å¤´é¨ã");
-        case BOT_SLOT_SHOULDERS:
-            return ("è©é¨ã");
-        case BOT_SLOT_CHEST:
-            return ("è¸é¨ã");
-        case BOT_SLOT_WAIST:
-            return ("è°é¨ã");
-        case BOT_SLOT_LEGS:
-            return ("è¿é¨ã");
-        case BOT_SLOT_FEET:
-            return ("èã");
-        case BOT_SLOT_WRIST:
-            return ("æèã");
-        case BOT_SLOT_HANDS:
-            return ("æã");
-        case BOT_SLOT_BACK:
-            return ("èé¨ã");
-        case BOT_SLOT_BODY:
-            return ("è¡¬è¡£ã");
-        case BOT_SLOT_FINGER1:
-            return ("ææä¸ã");
-        case BOT_SLOT_FINGER2:
-            return ("ææäºã");
-        case BOT_SLOT_TRINKET1:
-            return ("é¥°åä¸ã");
-        case BOT_SLOT_TRINKET2:
-            return ("é¥°åäºã");
-        case BOT_SLOT_NECK:
-            return ("é¢é¨ã");
-        default:
-            return ("æªç¥ã");
-    }
-}
-
-uint8 const bot_minion_ai::_onOffIcon(uint8 role) const
-{
-    return HasRole(role) ? BOT_ICON_ON : BOT_ICON_OFF;
-}
-
-bool bot_minion_ai::CanHeal() const
-{
-    if (me->getPowerType() != POWER_MANA)
-        return false;
-
-    return
-        (me->GetBotClass() == CLASS_PRIEST || me->GetBotClass() == CLASS_DRUID ||
-        me->GetBotClass() == CLASS_SHAMAN || me->GetBotClass() == CLASS_PALADIN);
-}
-
-char const* bot_ai::GetRoleString(uint8 role) const
-{
-    switch (role)
-    {
-        case BOT_ROLE_NONE:
-            return ("æ ã");
-        case BOT_ROLE_TANK:
-            return ("å¦åã");
-        case BOT_ROLE_DPS:
-            return ("ä¼¤å®³è¾åºã");
-        case BOT_ROLE_HEAL:
-            return ("æ²»çã");
-        //case BOT_ROLE_MELEE:
-        //    return "Melee";
-        case BOT_ROLE_RANGED:
-            return ("è¿ç¨ä¼¤å®³è¾åºã");
-        default:
-        {
-            std::ostringstream str;
-            str << ("èè´£ã") << uint32(role);
-            return str.str().c_str();
-        }
-    }
-}
-
-void bot_ai::InitRoles()
-{
-	uint32 mRo = master->GetPlayerBotRoles(me->GetEntry());
-	if (mRo == 0)
-    {
-        //default roles
-        _roleMask = BOT_ROLE_DPS;
-        if (!IsMeleeClass(me->GetBotClass()))
-            _roleMask |= BOT_ROLE_RANGED;
-        if (CanHeal())
-            _roleMask |= BOT_ROLE_HEAL;
-        return;
-    }
-	_roleMask = mRo;
-}
-
-void bot_ai::ToggleRole(uint8 role)
-{
-    if (roleTimer > 0)
-        return;
-
-    roleTimer = 350; //delay next attempt (prevent abuse)
-
-    HasRole(role) ? _roleMask &= ~role : _roleMask |= role;
-
-    if (role == BOT_ROLE_TANK && HasRole(BOT_ROLE_TANK))
-    {
-        if (!HasRole(BOT_ROLE_DPS))
-            _roleMask |= BOT_ROLE_DPS;
-    }
-
-    if (role == BOT_ROLE_RANGED && HasRole(BOT_ROLE_RANGED))
-    {
-        if (!HasRole(BOT_ROLE_DPS))
-            _roleMask |= BOT_ROLE_DPS;
-    }
-
-    if (role == BOT_ROLE_DPS && !HasRole(BOT_ROLE_DPS))
-    {
-        if (HasRole(BOT_ROLE_TANK))
-            _roleMask &= ~BOT_ROLE_TANK;
-        if (HasRole(BOT_ROLE_RANGED))
-            _roleMask &= ~BOT_ROLE_RANGED;
-    }
-
-	master->SetBotRoles(me->GetEntry(), _roleMask);
-
-    //Update passives
-    ApplyPassives(me->GetBotClass());
-}
-
-bool bot_ai::IsTank(Unit* unit) const
-{
-    if (!unit)
-        unit = me;
-
-    if (unit == me)
-        return (_roleMask & BOT_ROLE_TANK);
-
-    if (Creature* bot = unit->ToCreature())
-        if (bot->GetIAmABot() || bot->GetIAmABotsPet())
-            return bot->GetBotAI()->HasRole(BOT_ROLE_TANK);
-
-    if (Player* player = unit->ToPlayer())
-    {
-        if (Group* gr = player->GetGroup())
-        {
-            Group::MemberSlotList const& slots = gr->GetMemberSlots();
-            for (Group::member_citerator itr = slots.begin(); itr != slots.end(); ++itr)
-                if (itr->guid == player->GetGUID())
-                    return ((*itr).flags & MEMBER_FLAG_MAINTANK) != 0;
-        }
-    }
-
-    return false;
-}
-
-//UTILITIES
-void bot_ai::_AddItemTemplateLink(Player* forPlayer, ItemTemplate const* item, std::ostringstream &str) const
-{
-    //color
-    str << "|c";
-    switch (item->Quality)
-    {
-        case ITEM_QUALITY_POOR:     str << "ff9d9d9d"; break;  //GREY
-        case ITEM_QUALITY_NORMAL:   str << "ffffffff"; break;  //WHITE
-        case ITEM_QUALITY_UNCOMMON: str << "ff1eff00"; break;  //GREEN
-        case ITEM_QUALITY_RARE:     str << "ff0070dd"; break;  //BLUE
-        case ITEM_QUALITY_EPIC:     str << "ffa335ee"; break;  //PURPLE
-        case ITEM_QUALITY_LEGENDARY:str << "ffff8000"; break;  //ORANGE
-        case ITEM_QUALITY_ARTIFACT: str << "ffe6cc80"; break;  //LIGHT YELLOW
-        case ITEM_QUALITY_HEIRLOOM: str << "ffe6cc80"; break;  //LIGHT YELLOW
-        default:                    str << "ff000000"; break;  //UNK BLACK
-    }
-    str << "|Hitem:" << uint32(item->ItemId) << ":";
-
-    //permanent enchantment, 3 gems, 4 unknowns, reporter_level (9)
-    str << "0:0:0:0:0:0:0:0:0";
-
-    //name
-    std::string name = item->Name1;
-    _LocalizeItem(forPlayer, name, item->ItemId);
-    str << "|h[" << name << "]|h|r";
-
-    //max in stack
-    if (item->BuyCount > 1)
-        str<< "|cff009900x" << item->BuyCount << ".|r";
-    else
-        str << "|cff009900.|r";
-}
-
-void bot_ai::_AddItemLink(Player* forPlayer, Item const* item, std::ostringstream &str) const
-{
-    ItemTemplate const* proto = item->GetTemplate();
-
-    //color
-    str << "|c";
-    switch (proto->Quality)
-    {
-        case ITEM_QUALITY_POOR:     str << "ff9d9d9d"; break;  //GREY
-        case ITEM_QUALITY_NORMAL:   str << "ffffffff"; break;  //WHITE
-        case ITEM_QUALITY_UNCOMMON: str << "ff1eff00"; break;  //GREEN
-        case ITEM_QUALITY_RARE:     str << "ff0070dd"; break;  //BLUE
-        case ITEM_QUALITY_EPIC:     str << "ffa335ee"; break;  //PURPLE
-        case ITEM_QUALITY_LEGENDARY:str << "ffff8000"; break;  //ORANGE
-        case ITEM_QUALITY_ARTIFACT: str << "ffe6cc80"; break;  //LIGHT YELLOW
-        case ITEM_QUALITY_HEIRLOOM: str << "ffe6cc80"; break;  //LIGHT YELLOW
-        default:                    str << "ff000000"; break;  //UNK BLACK
-    }
-    str << "|Hitem:" << proto->ItemId << ":";
-
-    //permanent enchantment
-    str << item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ":";
-
-    //gems (3)
-    uint32 g1 = 0, g2 = 0, g3 = 0;
-    for (uint32 slot = SOCK_ENCHANTMENT_SLOT; slot != SOCK_ENCHANTMENT_SLOT + MAX_GEM_SOCKETS; ++slot)
-    {
-        uint32 eId = item->GetEnchantmentId(EnchantmentSlot(slot));
-        if (!eId)
-            continue;
-
-        SpellItemEnchantmentEntry const* enchant = sSpellItemEnchantmentStore.LookupEntry(eId);
-        if (!enchant) continue;
-
-        switch (slot - SOCK_ENCHANTMENT_SLOT)
-        {
-            case 1: g1 = enchant->GemID;    break;
-            case 2: g2 = enchant->GemID;    break;
-            case 3: g3 = enchant->GemID;    break;
-        }
-    }
-    str << g1 << ":" << g2 << ":" << g3 << ":";
-
-    //temp enchantment, bonus enchantment and prismatic enchantment (3 + 1 unk)
-    str << "0:0:0:0:";
-
-    //reporter level
-    str << "0";
-
-    //name
-    std::string name = proto->Name1;
-    _LocalizeItem(forPlayer, name, proto->ItemId);
-    str << "|h[" << name << "]|h|r";
-
-    //quantity
-    if (item->GetCount() > 1)
-        str << "x" << item->GetCount() << ' ';
-}
-
-void bot_ai::_AddQuestLink(Player* forPlayer, Quest const* quest, std::ostringstream &str) const
-{
-    std::string questTitle = quest->GetTitle();
-    _LocalizeQuest(forPlayer, questTitle, quest->GetQuestId());
-    str << "|cFFEFFD00|Hquest:" << quest->GetQuestId() << ':' << quest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
-}
-
-void bot_ai::_AddWeaponSkillLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillid) const
-{
-    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
-    str << "|cff00ffff|Hspell:" << spellInfo->Id << "|h[" << spellInfo->SpellName[loc] << " : " << master->GetSkillValue(skillid) << " /" << master->GetMaxSkillValue(skillid) << "]|h|r";
-}
-
-void bot_ai::_AddSpellLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str) const
-{
-    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
-    str << "|cffffffff|Hspell:" << spellInfo->Id << "|h[" << spellInfo->SpellName[loc] << "]|h|r";
-}
-
-void bot_ai::_AddProfessionLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillId) const
-{
-    ASSERT(master->HasSkill(skillId));
-    // |cffffd000|Htrade:4037:1:150:1:6AAAAAAAAAAAAAAAAAAAAAAOAADAAAAAAAAAAAAAAAAIAAAAAAAAA|h[Engineering]|h|r
-    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
-    SkillLineEntry const* skillInfo = sSkillLineStore.LookupEntry(skillId);
-    if (skillInfo)
-    {
-        uint32 curValue = master->GetPureSkillValue(skillId);
-        uint32 maxValue  = master->GetPureMaxSkillValue(skillId);
-        str << "|cffffd000|Htrade:" << spellInfo->Id << ':' << curValue << ':' << maxValue << ':' << master->GetGUIDLow() << ":6AAAAAAAAAAAAAAAAAAAAAAOAADAAAAAAAAAAAAAAAAIAAAAAAAAA" << "|h[" << skillInfo->name[loc] << "]|h|r";
-    }
-}
-//Localization
-void bot_ai::_LocalizeItem(Player* forPlayer, std::string &itemName, uint32 entry) const
-{
-    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
-    std::wstring wnamepart;
-
-    ItemLocale const* itemInfo = sObjectMgr->GetItemLocale(entry);
-    if (!itemInfo)
-        return;
-
-    if (itemInfo->Name.size() > loc && !itemInfo->Name[loc].empty())
-    {
-        const std::string name = itemInfo->Name[loc];
-        if (Utf8FitTo(name, wnamepart))
-            itemName = name;
-    }
-}
-
-void bot_ai::_LocalizeQuest(Player* forPlayer, std::string &questTitle, uint32 entry) const
-{
-    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
-    std::wstring wnamepart;
-
-    QuestLocale const* questInfo = sObjectMgr->GetQuestLocale(entry);
-    if (!questInfo)
-        return;
-
-    if (questInfo->Title.size() > loc && !questInfo->Title[loc].empty())
-    {
-        const std::string title = questInfo->Title[loc];
-        if (Utf8FitTo(title, wnamepart))
-            questTitle = title;
-    }
-}
-
-void bot_ai::_LocalizeCreature(Player* forPlayer, std::string &creatureName, uint32 entry) const
-{
-    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
-    std::wstring wnamepart;
-
-    CreatureLocale const* creatureInfo = sObjectMgr->GetCreatureLocale(entry);
-    if (!creatureInfo)
-        return;
-
-    if (creatureInfo->Name.size() > loc && !creatureInfo->Name[loc].empty())
-    {
-        const std::string title = creatureInfo->Name[loc];
-        if (Utf8FitTo(title, wnamepart))
-            creatureName = title;
-    }
-}
-
-void bot_ai::_LocalizeGameObject(Player* forPlayer, std::string &gameobjectName, uint32 entry) const
-{
-    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
-    std::wstring wnamepart;
-
-    GameObjectLocale const* gameObjectInfo = sObjectMgr->GetGameObjectLocale(entry);
-    if (!gameObjectInfo)
-        return;
-
-    if (gameObjectInfo->Name.size() > loc && !gameObjectInfo->Name[loc].empty())
-    {
-        const std::string title = gameObjectInfo->Name[loc];
-        if (Utf8FitTo(title, wnamepart))
-            gameobjectName = title;
-    }
-}
-
-//Advanced
-void bot_ai::BotSpeak(std::string const& text, uint8 msgtype, uint32 language, uint64 speaker, uint64 receiver)
-{
-    if (msgtype == CHAT_MSG_WHISPER)
-        language = LANG_UNIVERSAL;
-
-    std::string _text(text);
-    //sScriptMgr->OnPlayerChat(this, CHAT_MSG_SAY, language, _text);
-
-    WorldPacket data(SMSG_MESSAGECHAT, 200);
-    //BuildPlayerChat(&data, msgType, _text, language);
-    data << uint8(msgtype);
-    data << uint32(language);
-    data << uint64(speaker);
-    data << uint32(0);                 // constant unknown time
-    data << uint64(speaker);
-    data << uint32(text.length() + 1);
-    data << text;
-    data << uint8(0);
-
-    if (msgtype == CHAT_MSG_WHISPER)
-    {
-        ASSERT(receiver || "BotSpeak(): no receiver for whisper!");
-        //ASSERT(IS_PLAYER_GUID(receiver) || "BotSpeak(): whisper receiver is not a player!");
-
-        if (Player* res = ObjectAccessor::FindPlayer(receiver))
-            res->GetSession()->SendPacket(&data);
-    }
-    else
-    {
-        if (Unit* snd = ObjectAccessor::FindUnit(speaker))
-        {
-            float dist = std::max<float>(sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY), sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_YELL) * 0.5f);
-            acore::MessageDistDeliverer notifier(snd, &data, dist, false);
-            snd->VisitNearbyWorldObject(dist, notifier);
-        }
-    }
-    //SendMessageToSetInRange(&data, sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY), true);
-}
-
-void bot_ai::JustDied(Unit*)
-{
-    if (master)
-        master->SetNpcBotDied(me->GetGUID());
-}
-
-
-std::string bot_ai::GetSlotIcon(uint8 slot, uint32 width, uint32 height, int x, int y) const
-{
-	std::ostringstream ss;
-	ss << "|TInterface/PaperDoll/";
-	switch (slot)
-	{
-	case EQUIPMENT_SLOT_HEAD: ss << "UI-PaperDoll-Slot-Head"; break;
-	case EQUIPMENT_SLOT_SHOULDERS: ss << "UI-PaperDoll-Slot-Shoulder"; break;
-	case EQUIPMENT_SLOT_BODY: ss << "UI-PaperDoll-Slot-Shirt"; break;
-	case EQUIPMENT_SLOT_CHEST: ss << "UI-PaperDoll-Slot-Chest"; break;
-	case EQUIPMENT_SLOT_WAIST: ss << "UI-PaperDoll-Slot-Waist"; break;
-	case EQUIPMENT_SLOT_LEGS: ss << "UI-PaperDoll-Slot-Legs"; break;
-	case EQUIPMENT_SLOT_FEET: ss << "UI-PaperDoll-Slot-Feet"; break;
-	case EQUIPMENT_SLOT_WRISTS: ss << "UI-PaperDoll-Slot-Wrists"; break;
-	case EQUIPMENT_SLOT_HANDS: ss << "UI-PaperDoll-Slot-Hands"; break;
-	case EQUIPMENT_SLOT_BACK: ss << "UI-PaperDoll-Slot-Chest"; break;
-	case EQUIPMENT_SLOT_MAINHAND: ss << "UI-PaperDoll-Slot-MainHand"; break;
-	case EQUIPMENT_SLOT_OFFHAND: ss << "UI-PaperDoll-Slot-SecondaryHand"; break;
-	case EQUIPMENT_SLOT_RANGED: ss << "UI-PaperDoll-Slot-Ranged"; break;
-	case EQUIPMENT_SLOT_TABARD: ss << "UI-PaperDoll-Slot-Tabard"; break;
-	default: ss << "UI-Backpack-EmptySlot";
-	}
-	ss << ":" << width << ":" << height << ":" << x << ":" << y << "|t";
-	return ss.str();
-}
-
-std::string bot_ai::GetItemIcon(uint32 entry, uint32 width, uint32 height, int x, int y) const
-{
-	std::ostringstream ss;
-	ss << "|TInterface";
-	const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
-	const ItemDisplayInfoEntry* dispInfo = NULL;
-	if (temp)
-	{
-		dispInfo = sItemDisplayInfoStore.LookupEntry(temp->DisplayInfoID);
-		if (dispInfo)
-			ss << "/ICONS/" << dispInfo->inventoryIcon;
-	}
-	if (!dispInfo)
-		ss << "/InventoryItems/WoWUnknownItem01";
-	ss << ":" << width << ":" << height << ":" << x << ":" << y << "|t";
-	return ss.str();
-}
diff --git a/src/server/game/AI/NpcBots/bot_ai.h b/src/server/game/AI/NpcBots/bot_ai.h
deleted file mode 100644
index 2331176..0000000
--- a/src/server/game/AI/NpcBots/bot_ai.h
+++ /dev/null
@@ -1,609 +0,0 @@
-#ifndef _BOT_AI_H
-#define _BOT_AI_H
-
-#include "ScriptedCreature.h"
-
-struct PlayerClassLevelInfo;
-struct BotClassLevelInfo
-{
-    BotClassLevelInfo() : basehealth(0), basemana(0) { }
-    uint32 basehealth;
-    uint32 basemana;
-};
-
-enum CommonValues
-{
-//MISC
-    BOT_ENTRY_BEGIN                     = 80001,
-    BOT_ENTRY_END                       = 80248,
-    BOT_ICON_ON                         = 9,//GOSSIP_ICON_BATTLE,
-    BOT_ICON_OFF                        = 7,//GOSSIP_ICON_TALK,
-//COMMON SPELLS
-    MANAPOTION                          = 32453,//"Uses a Holy elixir to heal the caster for 32000"
-    HEALINGPOTION                       = 15504,//"Drinks Holy Elixir to heal the caster"
-    DRINK                               = 66041,//"Restores 4% mana per sec for 30 sec"
-    EAT                                 = 66478,//"Restores Health"
-    PVPTRINKET                          = 42292,//PvP Trinket no CD
-//COMMON CDs
-    POTION_CD                           = 60000,//default 60sec potion cd
-    RATIONS_CD                          = 1000,//update rations every X milliseconds
-//COMMON PASSIVES
-  //1) "Increase(d) @whatever"
-    //SPELL_BONUS_10                      = 33021,//10spp
-    SPELL_BONUS_50                      = 45011,//50spp
-    SPELL_BONUS_150                     = 28141,//150spp
-    SPELL_BONUS_250                     = 69709,//250spp
-    FIREDAM_86                          = 33816,//86 fire spp
-    MANAREGEN45                         = 35867,//45 mp5
-    MANAREGEN100                        = 45216,//100 mp5
-    SPELL_PEN_5                         = 31921,//5 sppen
-    SPELL_PEN_20                        = 26283,//20 sppen
-  //2) Talents
-    HASTE    /*Gift of the EarthMother*/= 51183,//rank 5 10% spell haste
-    HASTE2   /*Blood Frenzy - warrior*/ = 29859,//rank 2 10% melee haste, bonus for rend (warriors only)
-    HASTE3   /*       "Haste"       */  = 29418,//rank 0 10% increased ranged attack speed
-    CRITS    /*Thundering Strikes-sham*/= 16305,//rank 5 5% crit
-    HOLYCRIT /*Holy Spec - priest*/     = 15011,//rank 5 5% holy crit
-    DODGE    /*Anticipation - paladin*/ = 20100,//rank 5 5% dodge
-    PARRY    /*Deflection - warrior*/   = 16466,//rank 5 5% parry
-    BLOCK/*zzOLD Shield Specialization*/= 16253,//rank 1 5% block 10% amount, 3.3.5 & 4.3.4 deprecated
-    PRECISION /*Precision - warrior*/   = 29592,//rank 3 3% melee hit
-    PRECISION2/*Precision - mage*/      = 29440,//rank 3 3% spell hit
-    DMG_TAKEN/*Deadened Nerves - rogue*/= 31383,//rank 3 6% reduced all damage taken
-    EXPERTISE /*Weapon Expertise-rogue*/= 30919,//rank 1 5 expertise
-    EXPERTISE2/*Weapon Expertise-rogue*/= 30920,//rank 2 10 expertise
-  //3) Pet/Special
-    THREAT   /*Tank Class Passive*/     = 57339,//+43% threat
-    BOR      /*Blood of Rhino - pet*/   = 53482,//rank 2 +40% healing taken
-    BOAR     /*Boar's Speed - pet*/     = 19596,//rank 1 +30% movement speed
-    RCP      /*Rogue Class Passive*/    = 21184,//-27% threat caused
-    DEFENSIVE_STANCE_PASSIVE            = 7376, //+ 400% threat 10% damage reduction
-//COMMON GOSSIPS
-    GOSSIP_SERVE_MASTER                 = 2279, //"I live only to serve the master."
-    GOSSIP_SENDER_BEGIN                 = 6000,
-    GOSSIP_SENDER_CLASS,
-    GOSSIP_SENDER_EQUIPMENT,
-    GOSSIP_SENDER_EQUIPMENT_LIST,
-    GOSSIP_SENDER_EQUIPMENT_SHOW,
-    GOSSIP_SENDER_EQUIPMENT_INFO,
-    GOSSIP_SENDER_UNEQUIP,
-    GOSSIP_SENDER_EQUIP_RESET,
-    GOSSIP_SENDER_EQUIP,
-    GOSSIP_SENDER_EQUIP_BEGIN           = GOSSIP_SENDER_EQUIP,
-    GOSSIP_SENDER_EQUIP_MHAND           = GOSSIP_SENDER_EQUIP_BEGIN,
-    GOSSIP_SENDER_EQUIP_OHAND,
-    GOSSIP_SENDER_EQUIP_RANGED,
-    GOSSIP_SENDER_EQUIP_HEAD,
-    GOSSIP_SENDER_EQUIP_SHOULDERS,
-    GOSSIP_SENDER_EQUIP_CHEST,
-    GOSSIP_SENDER_EQUIP_WAIST,
-    GOSSIP_SENDER_EQUIP_LEGS,
-    GOSSIP_SENDER_EQUIP_FEET,
-    GOSSIP_SENDER_EQUIP_WRIST,
-    GOSSIP_SENDER_EQUIP_HANDS,
-    GOSSIP_SENDER_EQUIP_BACK,
-    GOSSIP_SENDER_EQUIP_BODY,
-    GOSSIP_SENDER_EQUIP_FINGER1,
-    GOSSIP_SENDER_EQUIP_FINGER2,
-    GOSSIP_SENDER_EQUIP_TRINKET1,
-    GOSSIP_SENDER_EQUIP_TRINKET2,
-    GOSSIP_SENDER_EQUIP_NECK,
-    GOSSIP_SENDER_ROLES,
-    GOSSIP_SENDER_ROLES_TOGGLE,
-    GOSSIP_SENDER_ABILITIES,
-    GOSSIP_SENDER_ABILITIES_USE,
-//COMMON GAMEEVENTS
-    GAME_EVENT_WINTER_VEIL              = 2,
-//COMMON MOUNTS SPELLS
-    REINDEER                            = 25859,
-    REINDEER_FLY                        = 44827
-};
-
-enum BotRoles
-{
-    BOT_ROLE_NONE                       = 0x00,
-    BOT_ROLE_TANK                       = 0x01,
-    BOT_ROLE_DPS                        = 0x02,
-    BOT_ROLE_HEAL                       = 0x04,
-    BOT_ROLE_RANGED                     = 0x08,
-    BOT_MAX_ROLE                        = 0x10
-};
-
-enum BotStances
-{
-    BOT_STANCE_NONE                     = 0,
-    WARRIOR_BATTLE_STANCE               = 21,
-    WARRIOR_DEFENSIVE_STANCE            = 22,
-    WARRIOR_BERSERKER_STANCE            = 23,
-    DEATH_KNIGHT_BLOOD_PRESENCE         = 24,
-    DEATH_KNIGHT_FROST_PRESENCE         = 25,
-    DEATH_KNIGHT_UNHOLY_PRESENCE        = 26,
-    DRUID_BEAR_FORM                     = 27,
-    DRUID_CAT_FORM                      = 28,
-    //DRUID_TRAVEL_FORM                 = 29,   //NYI
-    //DRUID_FLY_FORM                    = 30,   //NYI
-    DRUID_MOONKIN_FORM                = 31      //NYI
-};
-
-enum BotPetTypes
-{
-    PET_TYPE_NONE,
-//Warlock
-    PET_TYPE_IMP,
-    PET_TYPE_VOIDWALKER,
-    PET_TYPE_SUCCUBUS,
-    PET_TYPE_FELHUNTER,
-    PET_TYPE_FELGUARD,
-//Mage
-    PET_TYPE_WATER_ELEMENTAL,
-//Shaman
-    //PET_TYPE_GHOSTLY_WOLF,
-    PET_TYPE_FIRE_ELEMENTAL,
-    PET_TYPE_EARTH_ELEMENTAL,
-//Hunter
-    PET_TYPE_VULTURE,
-
-    MAX_PET_TYPES
-};
-
-enum WarlockBotPets
-{
-    //PET_IMP                     = ,
-    PET_VOIDWALKER              = 70247
-    //PET_SUCCUBUS                =
-};
-
-enum HunterBotPets
-{
-    PET_VULTURE                 = 70248
-};
-
-enum BotPetsOriginalEntries
-{
-    ORIGINAL_ENTRY_VOIDWALKER   = 1860
-};
-
-enum BotEquipSlot
-{
-    BOT_SLOT_NONE               = 0,
-    BOT_SLOT_MAINHAND           = 1,
-    BOT_SLOT_OFFHAND            = 2,
-    BOT_SLOT_RANGED             = 3,
-    BOT_SLOT_HEAD               = 4,
-    BOT_SLOT_SHOULDERS          = 5,
-    BOT_SLOT_CHEST              = 6,
-    BOT_SLOT_WAIST              = 7,
-    BOT_SLOT_LEGS               = 8,
-    BOT_SLOT_FEET               = 9,
-    BOT_SLOT_WRIST              = 10,
-    BOT_SLOT_HANDS              = 11,
-    BOT_SLOT_BACK               = 12,
-    BOT_SLOT_BODY               = 13,
-    BOT_SLOT_FINGER1            = 14,
-    BOT_SLOT_FINGER2            = 15,
-    BOT_SLOT_TRINKET1           = 16,
-    BOT_SLOT_TRINKET2           = 17,
-    BOT_SLOT_NECK               = 18,
-    BOT_MAX_SLOTS,
-    BOT_INVENTORY_SIZE = BOT_MAX_SLOTS - 1
-};
-
-enum BotStatTypes
-{
-    //ItemProtoType.h
-    //ITEM_MOD_MANA                     = 0,
-    //ITEM_MOD_HEALTH                   = 1,
-    //ITEM_MOD_AGILITY                  = 3,
-    //ITEM_MOD_STRENGTH                 = 4,
-    //ITEM_MOD_INTELLECT                = 5,
-    //ITEM_MOD_SPIRIT                   = 6,
-    //ITEM_MOD_STAMINA                  = 7,
-    //ITEM_MOD_DEFENSE_SKILL_RATING     = 12,
-    //ITEM_MOD_DODGE_RATING             = 13,
-    //ITEM_MOD_PARRY_RATING             = 14,
-    //ITEM_MOD_BLOCK_RATING             = 15,
-    //ITEM_MOD_HIT_MELEE_RATING         = 16,
-    //ITEM_MOD_HIT_RANGED_RATING        = 17,
-    //ITEM_MOD_HIT_SPELL_RATING         = 18,
-    //ITEM_MOD_CRIT_MELEE_RATING        = 19,
-    //ITEM_MOD_CRIT_RANGED_RATING       = 20,
-    //ITEM_MOD_CRIT_SPELL_RATING        = 21,
-    //ITEM_MOD_HIT_TAKEN_MELEE_RATING   = 22,
-    //ITEM_MOD_HIT_TAKEN_RANGED_RATING  = 23,
-    //ITEM_MOD_HIT_TAKEN_SPELL_RATING   = 24,
-    //ITEM_MOD_CRIT_TAKEN_MELEE_RATING  = 25,
-    //ITEM_MOD_CRIT_TAKEN_RANGED_RATING = 26,
-    //ITEM_MOD_CRIT_TAKEN_SPELL_RATING  = 27,
-    //ITEM_MOD_HASTE_MELEE_RATING       = 28,
-    //ITEM_MOD_HASTE_RANGED_RATING      = 29,
-    //ITEM_MOD_HASTE_SPELL_RATING       = 30,
-    //ITEM_MOD_HIT_RATING               = 31,
-    //ITEM_MOD_CRIT_RATING              = 32,
-    //ITEM_MOD_HIT_TAKEN_RATING         = 33,
-    //ITEM_MOD_CRIT_TAKEN_RATING        = 34,
-    //ITEM_MOD_RESILIENCE_RATING        = 35,
-    //ITEM_MOD_HASTE_RATING             = 36,
-    //ITEM_MOD_EXPERTISE_RATING         = 37,
-    //ITEM_MOD_ATTACK_POWER             = 38,
-    //ITEM_MOD_RANGED_ATTACK_POWER      = 39,
-    ////ITEM_MOD_FERAL_ATTACK_POWER       = 40, not in 3.3
-    //ITEM_MOD_SPELL_HEALING_DONE       = 41,                 // deprecated
-    //ITEM_MOD_SPELL_DAMAGE_DONE        = 42,                 // deprecated
-    //ITEM_MOD_MANA_REGENERATION        = 43,
-    //ITEM_MOD_ARMOR_PENETRATION_RATING = 44,
-    //ITEM_MOD_SPELL_POWER              = 45,
-    //ITEM_MOD_HEALTH_REGEN             = 46,
-    //ITEM_MOD_SPELL_PENETRATION        = 47,
-    //ITEM_MOD_BLOCK_VALUE              = 48,
-    //END ItemProtoType.h
-
-    BOT_ITEM_MOD_DAMAGE                 = MAX_ITEM_MOD,
-    BOT_ITEM_MOD_ARMOR,
-    BOT_ITEM_MOD_RESIST_HOLY,
-    BOT_ITEM_MOD_RESIST_FIRE,
-    BOT_ITEM_MOD_RESIST_NATURE,
-    BOT_ITEM_MOD_RESIST_FROST,
-    BOT_ITEM_MOD_RESIST_SHADOW,
-    BOT_ITEM_MOD_RESIST_ARCANE,
-    BOT_ITEM_MOD_EX,
-    MAX_BOT_ITEM_MOD
-};
-
-#define MAX_BOT_CTC_SPELLS              1//(MAX_EQUIPMENT_ITEMS * MAX_ITEM_SPELLS)
-
-class bot_ai : public ScriptedAI
-{
-    public:
-        virtual ~bot_ai();
-        bot_ai(Creature* creature);
-        //Player* GetMaster() const { return master; }
-        virtual bool IsMinionAI() const = 0;
-        virtual bool IsPetAI() const = 0;
-        virtual void SetBotCommandState(CommandStates /*st*/, bool /*force*/ = false, Position* /*newpos*/ = NULL) = 0;
-        virtual const bot_minion_ai* GetMinionAI() const { return NULL; }
-        virtual const bot_pet_ai* GetPetAI() const { return NULL; }
-        bool IsInBotParty(Unit* unit) const;
-        bool CanBotAttack(Unit* target, int8 byspell = 0) const;
-        bool InDuel(Unit* target) const;
-        CommandStates GetBotCommandState() const { return m_botCommandState; }
-        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
-        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
-        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
-        void ApplyBotDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float &value) const;
-        inline void SendPartyEvadeAbort() const;
-        inline void SetShouldUpdateStats() { shouldUpdateStats = true; }
-        inline void UpdateHealth() { doHealth = true; }
-        inline void UpdateMana() { doMana = true; }
-        inline float GetManaRegen() const { return regen_mp5; }
-        inline float GetHitRating() const { return hit; }
-        inline int32 GetSpellPower() const { return m_spellpower; }
-        inline uint8 GetHaste() const { return haste; }
-        inline uint32 GetShieldBlockValue() const { return m_block; }
-        virtual uint8 GetBotStance() const { return 0; }
-        inline uint8 GetBotRoles() const { return _roleMask; }
-        inline bool HasRole(uint8 role) const { return (_roleMask & role) != 0; }
-        void ToggleRole(uint8 role);
-        char const* GetRoleString(uint8 role) const;
-		std::string GetSlotIcon(uint8 slot, uint32 width, uint32 height, int x, int y) const;
-		std::string GetItemIcon(uint32 entry, uint32 width, uint32 height, int x, int y) const;
-
-        virtual void OnBotSummon(Creature* /*summon*/) {}
-        virtual void OnBotDespawn(Creature* /*summon*/) {}
-        virtual void UnsummonAll() {}
-
-        void ReceiveEmote(Player* player, uint32 emote);
-        void ApplyPassives(uint8 botOrPetType) const;
-
-        virtual void RemoveItemBonuses(uint8 /*slot*/) {}
-        virtual void ApplyItemBonuses(uint8 /*slot*/) {}
-
-        static inline bool CCed(Unit* target, bool root = false)
-        {
-            return target ? target->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE) || (root && target->HasUnitState(UNIT_STATE_ROOT)) : true;
-        }
-
-        virtual bool CanUseOffHand() const { return false; }
-        virtual bool CanUseRanged() const { return false; }
-        virtual bool CanEquip(ItemTemplate const* /*item*/, uint8 /*slot*/) const { return false; }
-        virtual bool Unequip(uint8 /*slot*/) { return false; }
-        virtual bool Equip(uint32 /*itemId*/, uint8 /*slot*/) { return false; }
-        virtual bool ResetEquipment(uint8 /*slot*/) { return false; }
-
-        static void BotSpeak(std::string const& text, uint8 msgtype, uint32 language, uint64 sender, uint64 receiver);
-
-        virtual void JustDied(Unit*);
-
-    protected:
-        static uint32 InitSpell(Unit const* caster, uint32 spell);
-        void InitSpellMap(uint32 basespell, bool forceadd = false);
-        uint32 GetSpell(uint32 basespell) const;
-        uint32 GetSpellCooldown(uint32 basespell) const;
-        bool IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD = true, uint32 forcedTime = 0) const;
-        void SetSpellCooldown(uint32 basespell, uint32 msCooldown);
-        void ResetSpellCooldown(uint32 basespell) { SetSpellCooldown(basespell, 0); }
-        void RemoveSpell(uint32 basespell);
-        void SpellTimers(uint32 diff);
-
-        void InitRoles();
-        bool IsTank(Unit* unit = NULL) const;
-
-        bool HasAuraName(Unit* unit, uint32 spellId, uint64 casterGuid = 0, bool exclude = false) const;
-        bool RefreshAura(uint32 spell, int8 count = 1) const;
-        bool CheckAttackTarget(uint8 botOrPetType);
-        bool MoveBehind(Unit &target) const;
-        bool CheckImmunities(uint32 spell, Unit* target = NULL) const { return (spell && target && !target->ToCorpse() && target->IsHostileTo(me) ? !target->IsImmunedToDamage(sSpellMgr->GetSpellInfo(spell)) : true); }
-
-        //everything cast-related
-        bool doCast(Unit* victim, uint32 spellId, bool triggered = false, uint64 originalCaster = 0);
-        SpellCastResult CheckBotCast(Unit* victim, uint32 spellId, uint8 botclass) const;
-        virtual void removeFeralForm(bool /*force*/ = false, bool /*init*/ = true, uint32 /*diff*/ = 0) {}
-
-        inline bool Feasting() const { return (me->HasAura(EAT) || me->HasAura(DRINK)); }
-        inline bool IsMeleeClass(uint8 m_class) const { return (m_class == CLASS_WARRIOR || m_class == CLASS_ROGUE || m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT); }
-        inline bool IsTankingClass(uint8 m_class) const { return (m_class == CLASS_WARRIOR || m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT); }
-        inline bool IsChanneling(Unit* u = NULL) const { if (!u) u = me; return u->GetCurrentSpell(CURRENT_CHANNELED_SPELL); }
-        inline bool IsCasting(Unit* u = NULL) const { if (!u) u = me; return (u->HasUnitState(UNIT_STATE_CASTING) || IsChanneling(u) || u->IsNonMeleeSpellCast(false, false, true)); }
-
-        void GetInPosition(bool force = false, Unit* newtarget = NULL, Position* pos = NULL);
-        void OnSpellHit(Unit* caster, SpellInfo const* spell);
-        void CalculateAttackPos(Unit* target, Position &pos) const;
-        void CheckAttackState();
-        inline virtual void Evade() {}
-
-        //virtual void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
-        virtual void ApplyClassDamageMultiplierMelee(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool& /*crit*/) const {}
-        virtual void ApplyClassDamageMultiplierSpell(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool& /*crit*/) const {}
-        virtual void ApplyClassDamageMultiplierEffect(SpellInfo const* /*spellInfo*/, uint8 /*effect_index*/, float& /*value*/) const {}
-        virtual void CureGroup(Player* /*pTarget*/, uint32 /*cureSpell*/, uint32 /*diff*/) {}
-        virtual void CheckAuras(bool /*force*/ = false) {}
-        virtual void BuffAndHealGroup(Player* /*gPlayer*/, uint32 /*diff*/) {}
-        virtual void RezGroup(uint32 /*REZZ*/, Player* /*gPlayer*/) {}
-        //virtual void DoNonCombatActions(uint32 /*diff*/) {}
-        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
-        virtual void InitSpells() {}
-        virtual void InitPowers() {}
-        virtual void ApplyClassPassives() {}
-        virtual void _OnHealthUpdate() const = 0;
-        virtual void _OnManaUpdate(bool /*shapeshift*/ = false) = 0;
-        //virtual void _OnMeleeDamageUpdate(uint8 /*myclass*/) const = 0;
-
-        //virtual void ReceiveEmote(Player* /*player*/, uint32 /*emote*/) {}
-        //virtual void CommonTimers(uint32 diff) = 0;
-
-        virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 /*diff*/) { return false; }
-        virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
-        virtual bool CureTarget(Unit* /*target*/, uint32 /*cureSpell*/, uint32 /*diff*/) { return false; }
-        virtual bool IsMelee() const { return HasRole(BOT_ROLE_DPS) && !HasRole(BOT_ROLE_RANGED); }
-        virtual bool CanHeal() const { return false; }
-
-        uint8 GetWait();
-        inline float InitAttackRange(float origRange, bool ranged) const;
-        uint16 Rand() const;
-        static inline uint32 GetLostHP(Unit* unit) { return unit->GetMaxHealth() - unit->GetHealth(); }
-        static inline uint8 GetHealthPCT(Unit* hTarget) { if (!hTarget || !hTarget->IsInWorld() || hTarget->isDead()) return 100; return (hTarget->GetHealth()*100/hTarget->GetMaxHealth()); }
-        static inline uint8 GetManaPCT(Unit* hTarget) { if (!hTarget || !hTarget->IsInWorld() || hTarget->isDead() || hTarget->getPowerType() != POWER_MANA) return 100; return (hTarget->GetPower(POWER_MANA)*100/(hTarget->GetMaxPower(POWER_MANA) + 1)); }
-
-        typedef std::set<Unit*> AttackerSet;
-        typedef std::unordered_map<uint32 /*stat*/, int32 /*statvalue*/> BotStat;
-        typedef std::pair<uint32 /*spellId*/, uint32 /*cooldown*/> BotCTCSpell;
-
-        BotStat _stats[BOT_MAX_SLOTS - 1];
-        BotCTCSpell _ctc[MAX_BOT_CTC_SPELLS];
-        uint32 CalcCTC(uint32 /*spellId*/) const { return 8; } //placeholder
-
-        //utilities
-        void _AddItemTemplateLink(Player* forPlayer, ItemTemplate const* item, std::ostringstream &str) const;
-        void _AddItemLink(Player* forPlayer, Item const* item, std::ostringstream &str) const;
-        void _AddQuestLink(Player* forPlayer, Quest const* quest, std::ostringstream &str) const;
-        void _AddWeaponSkillLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillid) const;
-        void _AddSpellLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str) const;
-        void _AddProfessionLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillId) const;
-        void _LocalizeItem(Player* forPlayer, std::string &itemName, uint32 entry) const;
-        void _LocalizeQuest(Player* forPlayer, std::string &questTitle, uint32 entry) const;
-        void _LocalizeCreature(Player* forPlayer, std::string &creatureName, uint32 entry) const;
-        void _LocalizeGameObject(Player* forPlayer, std::string &gameobjectName, uint32 entry) const;
-
-        typedef std::pair<uint32 /*spellId*/, uint32 /*cooldown*/> BotSpell;
-        typedef std::unordered_map<uint32 /*spellId_1*/, BotSpell /*spell*/> BotSpellMap;
-
-        BotSpellMap const& GetSpellMap() const { return spells; }
-
-        Player* master;
-        Unit* opponent;
-        CommandStates m_botCommandState;
-        SpellInfo const* m_botSpellInfo;
-        Position pos, attackpos;
-        float stat, atpower, maxdist, regen_mp5, hit,
-            ap_mod, spp_mod, crit_mod;
-        uint64 aftercastTargetGuid;
-        int32 cost, value, sppower, m_spellpower, m_expertise, m_spellpen;
-        uint32 GC_Timer, temptimer, checkAurasTimer, roleTimer, wait, currentSpell, tempMana, m_block;
-        uint8 clear_cd, haste, healTargetIconFlags;
-        bool doHealth, doMana, shouldUpdateStats;
-
-    private:
-        Unit* _getTarget(bool byspell, bool ranged, bool &reset) const;
-        bool _hasAuraName(Unit* unit, const std::string spell, uint64 casterGuid = 0, bool exclude = false) const;
-        void _listAuras(Player* player, Unit* unit) const;
-        static inline float _getAttackDistance(float distance) { return distance > 0.f ? distance*0.72 : 0.f; }
-
-        BotSpellMap spells;
-        uint8 _roleMask;
-        float dmgmult_melee, dmgmult_spell;
-        float dmgmod_melee, dmgmod_spell;
-        uint64 m_TankGuid;
-};
-
-class bot_minion_ai : public bot_ai
-{
-    public:
-        virtual ~bot_minion_ai();
-        bot_minion_ai(Creature* creature);
-        const bot_minion_ai* GetMinionAI() const { return this; }
-        bool IsMinionAI() const { return true; }
-        bool IsPetAI() const { return false; }
-        void SummonBotsPet(uint32 entry);
-        inline bool IAmDead() const { return (!master || me->isDead()); }
-        void SetBotCommandState(CommandStates st, bool force = false, Position* newpos = NULL);
-        //virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 /*diff*/) { return false; }
-        //virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
-        //virtual bool doCast(Unit*  /*victim*/, uint32 /*spellId*/, bool /*triggered*/ = false) { return false; }
-        void CureGroup(Player* pTarget, uint32 cureSpell, uint32 diff);
-        bool CureTarget(Unit* target, uint32 cureSpell, uint32 diff);
-        void CheckAuras(bool force = false);
-        //virtual void DoNonCombatActions(uint32 /*diff*/) {}
-        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
-        void SetStats(bool force, bool shapeshift = false);
-        virtual uint8 GetBotStance() const { return me->GetBotClass(); }
-
-        static bool OnGossipHello(Player* player, Creature* creature);
-        bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action);
-
-        void InitSpells() {}
-        void InitPowers() {}
-        void _OnHealthUpdate() const;
-        void _OnManaUpdate(bool shapeshift = false);
-        void _OnMeleeDamageUpdate(uint8 myclass) const;
-
-        void RemoveItemBonuses(uint8 slot);
-        void ApplyItemBonuses(uint8 slot);
-
-        void OnOwnerDamagedBy(Unit* attacker);
-
-        inline void SetEvadeTimer(uint8 time) { evade_cd = time; }
-
-        bool CanUseOffHand() const;
-        bool CanUseRanged() const;
-        bool CanEquip(ItemTemplate const* item, uint8 slot) const;
-        bool Unequip(uint8 slot);
-        bool Equip(uint32 itemId, uint8 slot);
-        bool ResetEquipment(uint8 slot);
-
-        bool CanHeal() const;
-
-    protected:
-        virtual bool CanUseManually(uint32 /*basespell*/) const { return false; }
-        void BuffAndHealGroup(Player* gPlayer, uint32 diff);
-        void RezGroup(uint32 REZZ, Player* gPlayer);
-
-        void Follow(bool force = false, Position* newpos = NULL)
-        {
-            if (force ||
-                (me->IsAlive() && (!me->IsInCombat() || !opponent) && m_botCommandState != COMMAND_STAY))
-                SetBotCommandState(COMMAND_FOLLOW, force, newpos);
-        }
-
-        inline void Evade() { _evade(); }
-
-        virtual void BreakCC(uint32 diff);
-
-        void CommonTimers(uint32 diff)
-        {
-            if (pvpTrinket_cd > diff)       pvpTrinket_cd -= diff;
-            if (Potion_cd > diff)           Potion_cd -= diff;
-            if (GC_Timer > diff)            GC_Timer -= diff;
-            if (temptimer > diff)           temptimer -= diff;
-            if (checkAurasTimer != 0)       --checkAurasTimer;
-            if (wait != 0)                  --wait;
-            if (evade_cd != 0)              --evade_cd;
-
-            if (mana_cd > diff)             mana_cd -= diff;
-            else if (mana_cd > 0)           mana_cd = 0;
-            if (health_cd > diff)           health_cd -= diff;
-            else if (health_cd > 0)         health_cd = 0;
-
-            if (roleTimer > diff)           roleTimer -= diff;
-            else if (roleTimer > 0)         roleTimer = 0;
-
-            for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
-            {
-                if (_ctc[i].second > diff)  _ctc[i].second -= diff;
-                else                        _ctc[i].second = 0;
-            }
-        }
-
-        Unit* FindHostileDispelTarget(float dist = 30, bool stealable = false) const;
-        Unit* FindAffectedTarget(uint32 spellId, uint64 caster = 0, float dist = DEFAULT_VISIBILITY_DISTANCE, uint8 hostile = 0) const;
-        Unit* FindPolyTarget(float dist = 30, Unit* currTarget = NULL) const;
-        Unit* FindFearTarget(float dist = 30) const;
-        Unit* FindStunTarget(float dist = 20) const;
-        Unit* FindUndeadCCTarget(float dist = 30, uint32 spellId = 0) const;
-        Unit* FindRootTarget(float dist = 30, uint32 spellId = 0) const;
-        Unit* FindCastingTarget(float maxdist = 10, float mindist = 0, bool isFriend = false, uint32 spellId = 0) const;
-        Unit* FindAOETarget(float dist = 30, bool checkbots = false, bool targetfriend = true) const;
-        Unit* FindSplashTarget(float dist = 5, Unit* To = NULL, float splashdist = 4) const;
-        Unit* FindTranquilTarget(float mindist = 5, float maxdist = 35) const;
-        void GetNearbyTargetsList(std::list<Unit*> &targets, float maxdist = 10, float mindist = 0, bool forCC = false) const;
-
-        uint32 Potion_cd;
-
-    private:
-        bool _canCureTarget(Unit* target, uint32 cureSpell, uint32 diff) const;
-        void _getBotDispellableAuraList(Unit* target, Unit* caster, uint32 dispelMask, DispelChargesList& dispelList) const;
-        void _calculatePos(Position& pos);
-        void _updateMountedState();
-        void _updateStandState() const;
-        void _updateRations();
-        void _evade();
-        char const* _getNameForSlot(uint8 slot) const;
-        uint8 const _onOffIcon(uint8 role) const;
-        //BotClassLevelInfo classinfo;
-        PlayerClassLevelInfo* _classinfo;
-        float myangle, armor_mod, haste_mod, dodge_mod, parry_mod;
-        uint32 mana_cd, health_cd, pvpTrinket_cd;
-        uint8 rezz_cd, evade_cd;
-};
-
-class bot_pet_ai : public bot_ai
-{
-    public:
-        virtual ~bot_pet_ai();
-        bot_pet_ai(Creature* creature);
-        const bot_pet_ai* GetPetAI() const { return this; }
-        Creature* GetCreatureOwner() const { return m_creatureOwner; }
-        bool IsMinionAI() const { return false; }
-        bool IsPetAI() const { return true; }
-        inline bool IAmDead() const { return (!master || !m_creatureOwner || me->isDead()); }
-        //void SetCreatureOwner(Creature* newowner) { m_creatureOwner = newowner; }
-        void SetBotCommandState(CommandStates st, bool force = false, Position* newpos = NULL);
-        //virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 /*diff*/) { return false; }
-        //virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
-        //void BuffAndHealGroup(Player* /*gPlayer*/, uint32 /*diff*/) {}
-        //void RezGroup(uint32 /*REZZ*/, Player* /*gPlayer*/) {}
-        //virtual bool doCast(Unit*  /*victim*/, uint32 /*spellId*/, bool /*triggered*/ = false) { return false; }
-        //void CureGroup(Player* /*pTarget*/, uint32 /*cureSpell*/, uint32 /*diff*/) {}
-        //bool CureTarget(Unit* /*target*/, uint32 /*cureSpell*/, uint32 /*diff*/) { return false; }
-        void CheckAuras(bool force = false);
-        //virtual void DoNonCombatActions(uint32 /*diff*/) {}
-        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
-        void SetStats(bool force);
-
-        static uint8 GetPetType(Creature* pet);
-        static uint8 GetPetClass(Creature* pet);
-        static uint32 GetPetOriginalEntry(uint32 entry);
-
-        //debug
-        //virtual void ListSpells(ChatHandler* /*handler*/) const {}
-
-        void InitSpells() {}
-        void _OnHealthUpdate() const;
-        void _OnManaUpdate(bool shapeshift = false);
-        //void _OnMeleeDamageUpdate(uint8 /*myclass*/) const {}
-        void SetBaseArmor(uint32 armor) { basearmor = armor; }
-
-    protected:
-        void CommonTimers(uint32 diff)
-        {
-            if (GC_Timer > diff)            GC_Timer -= diff;
-            if (temptimer > diff)           temptimer -= diff;
-            if (roleTimer > diff)           roleTimer -= diff;
-            if (checkAurasTimer != 0)       --checkAurasTimer;
-            if (wait != 0)                  --wait;
-        }
-
-        Creature* m_creatureOwner;
-    private:
-        uint32 basearmor;
-};
-
-#endif
diff --git a/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp b/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
deleted file mode 100644
index deda8a1..0000000
--- a/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
+++ /dev/null
@@ -1,1691 +0,0 @@
-#include "bot_ai.h"
-#include "GameEventMgr.h"
-#include "Group.h"
-#include "Player.h"
-#include "ScriptMgr.h"
-#include "Spell.h"
-#include "SpellAuras.h"
-#include "Unit.h"
-#include "SpellInfo.h"
-/*
-Death Knight NpcBot by Graff onlysuffering@gmail.com
-Complete - around 55%
-Note: Rune system adapted from TC
-TODO: REMEMBER ALREADY DK HAS MINIMUM LEVEL 55!
-*/
-const RuneType runeSlotTypes[MAX_RUNES] =
-{
-    RUNE_BLOOD,
-    RUNE_BLOOD,
-    RUNE_UNHOLY,
-    RUNE_UNHOLY,
-    RUNE_FROST,
-    RUNE_FROST
-};
-struct BotRuneInfo
-{
-    uint8 BaseRune;
-    uint8 CurrentRune;
-    uint32 Cooldown;
-    //AuraEffect const* ConvertAura;
-};
-
-struct BotRunes
-{
-    BotRuneInfo runes[MAX_RUNES];
-    //uint8 runeState;          //UNUSED
-    //uint8 lastUsedRune;       //UNUSED
-
-    //void SetRuneState(uint8 index, bool set = true)
-    //{
-    //    if (set)
-    //        runeState |= (1 << index);    // usable
-    //    else
-    //        runeState &= ~(1 << index);   // on cooldown
-    //}
-};
-class death_knight_bot : public CreatureScript
-{
-public:
-    death_knight_bot() : CreatureScript("death_knight_bot") { }
-
-    CreatureAI* GetAI(Creature* creature) const
-    {
-        return new death_knight_botAI(creature);
-    }
-
-    bool OnGossipHello(Player* player, Creature* creature)
-    {
-        return bot_minion_ai::OnGossipHello(player, creature);
-    }
-
-    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
-    {
-        if (bot_minion_ai* ai = creature->GetBotMinionAI())
-            return ai->OnGossipSelect(player, creature, sender, action);
-        return true;
-    }
-
-    struct death_knight_botAI : public bot_minion_ai
-    {
-        death_knight_botAI(Creature* creature) : bot_minion_ai(creature) { }
-
-        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
-        {
-            if (CheckBotCast(victim, spellId, CLASS_DEATH_KNIGHT) != SPELL_CAST_OK)
-                return false;
-
-            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
-            int32 runecost[NUM_RUNE_TYPES];
-            for (uint8 i = 0; i != NUM_RUNE_TYPES; ++i)
-                runecost[i] = 0;
-
-            if (!triggered)
-            {
-                if (!HaveRunes(spellInfo, runecost))
-                    return false;
-            }
-
-            bool result = bot_ai::doCast(victim, spellId, triggered);
-
-            if (result)
-            {
-                if (!triggered)
-                {
-                    SpendRunes(runecost);
-                }
-
-                if (SpellRuneCostEntry const* src = sSpellRuneCostStore.LookupEntry(spellInfo->RuneCostID))
-                    if (int32 rp = int32(src->runePowerGain * runicpowerIncomeMult))
-                        me->ModifyPower(POWER_RUNIC_POWER, int32(rp));
-            }
-
-            return result;
-        }
-
-        bool HaveRunes(SpellInfo const* spellInfo, int32 *runecost) const
-        {
-            if (spellInfo->PowerType != POWER_RUNE || !spellInfo->RuneCostID)
-                return true;
-
-            CalcRuneCost(spellInfo, runecost);
-
-            if (runecost[RUNE_DEATH] != 0 && runecost[RUNE_DEATH] > GetDeathRunesCount())
-                return false;
-
-            return true;
-        }
-
-        void CalcRuneCost(SpellInfo const* spellInfo, int32 *runecost) const
-        {
-            SpellRuneCostEntry const* src = sSpellRuneCostStore.LookupEntry(spellInfo->RuneCostID);
-            if (!src)
-                return;
-
-            if (src->NoRuneCost())
-                return;
-
-            for (uint8 i = 0; i != RUNE_DEATH; ++i)
-                runecost[i] = src->RuneCost[i];
-
-            for (uint8 i = 0; i != MAX_RUNES; ++i)
-            {
-                uint8 rune = _runes.runes[i].BaseRune;
-                if (_runes.runes[i].CurrentRune == rune && _runes.runes[i].Cooldown == 0 && runecost[rune] > 0)
-                    runecost[rune]--;
-            }
-
-            for (uint8 i = 0; i != RUNE_DEATH; ++i)
-                if (runecost[i] > 0)
-                    runecost[RUNE_DEATH] += runecost[i];
-
-            ////restore cost to allow cooldown set
-            //for (uint8 i = 0; i != RUNE_DEATH; ++i)
-            //    runecost[i] = src->RuneCost[i];
-        }
-
-        int32 GetDeathRunesCount() const
-        {
-            int32 count = 0;
-            for (uint8 i = 0; i != MAX_RUNES; ++i)
-                if (_runes.runes[i].CurrentRune == RUNE_DEATH && _runes.runes[i].Cooldown == 0)
-                    ++count;
-
-            return count;
-        }
-
-        uint8 GetCooledRunesCount(uint8 runetype) const
-        {
-            uint8 count = 0;
-            for (uint8 i = 0; i != MAX_RUNES; ++i)
-                if (_runes.runes[i].BaseRune == runetype && _runes.runes[i].Cooldown > 0)
-                    ++count;
-
-            return count;
-        }
-
-        void SpendRunes(int32* runecost)
-        {
-            for (uint8 i = 0; i != NUM_RUNE_TYPES; ++i)
-            {
-                if (runecost[i] <= 0)
-                    continue;
-
-                for (uint8 j = 0; j != MAX_RUNES && runecost[i] > 0; ++j)
-                {
-                    if (SpendRune(i))
-                        runecost[i]--;
-                }
-            }
-
-            if (GetCooledRunesCount(RUNE_BLOOD) > 1)
-            {
-                me->CastSpell(me, BLADE_BARRIER_AURA, true);
-            }
-        }
-
-        bool SpendRune(uint8 runetype)
-        {
-            for (uint8 i = 0; i != MAX_RUNES; ++i)
-            {
-                if (_runes.runes[i].CurrentRune == runetype && _runes.runes[i].Cooldown == 0)
-                {
-                    _runes.runes[i].CurrentRune = _runes.runes[i].BaseRune;
-                    //_runes.lastUsedRune = _runes.runes[i].CurrentRune;        //UNUSED
-                    //_runes.SetRuneState(i, false);                            //UNUSED
-                    //DK receives rune regen bonus from mana regen
-                    uint32 cooldown = RUNE_BASE_COOLDOWN - std::min<uint32>(uint32(GetManaRegen() * 10), RUNE_BASE_COOLDOWN);
-                    _runes.runes[i].Cooldown = cooldown;
-                    //std::ostringstream str;
-                    //str << "Spent rune " << uint32(i) << " (type: " << uint32(runetype) << ')';
-                    //me->MonsterWhisper(str.str().c_str(), master->GetGUID());
-                    return true;
-                }
-            }
-
-            return false;
-        }
-
-        bool HaveRune(uint8 runetype) const
-        {
-            for (uint8 i = 0; i != MAX_RUNES; ++i)
-            {
-                if ((_runes.runes[i].CurrentRune == runetype || _runes.runes[i].CurrentRune == RUNE_DEATH) &&
-                    _runes.runes[i].Cooldown == 0)
-                {
-                    return true;
-                }
-            }
-
-            return false;
-        }
-
-        void ConvertRune(uint8 runetype, uint8 count)
-        {
-            if (runetype == RUNE_DEATH)
-                return;
-
-            uint8 failcount = 0;
-            for (uint8 i = 0; i != MAX_RUNES && count > 0; ++i)
-            {
-                if (_runes.runes[i].BaseRune == runetype)
-                {
-                    if (_runes.runes[i].CurrentRune == RUNE_DEATH)
-                    {
-                        ++failcount;
-                        continue;
-                    }
-
-                    if (_runes.runes[i].Cooldown > 3000)
-                        _runes.runes[i].Cooldown -= 3000;
-
-                    _runes.runes[i].CurrentRune = RUNE_DEATH;
-                    --count;
-                }
-            }
-
-            if (!count && !failcount)
-                return;
-
-            //std::ostringstream str;
-            //str << "Failed to convert rune of type: " << uint32(runetype) << ")!";
-            //me->MonsterWhisper(str.str().c_str(), master->GetGUID());
-        }
-
-        void ActivateAllRunes()
-        {
-            for (uint8 i = 0; i != MAX_RUNES; ++i)
-            {
-                _runes.runes[i].Cooldown = 0;
-                //_runes.SetRuneState(i, true);       //UNUSED
-            }
-        }
-
-        void InitRunes()
-        {
-            //_runes.runeState = 0;                   //UNUSED
-            //_runes.lastUsedRune = RUNE_BLOOD;       //UNUSED
-
-            for (uint8 i = 0; i != MAX_RUNES; ++i)
-            {
-                _runes.runes[i].BaseRune = runeSlotTypes[i];
-                _runes.runes[i].CurrentRune = _runes.runes[i].BaseRune;
-                _runes.runes[i].Cooldown = 0;
-                //_runes.runes[i].ConvertAura = NULL; //UNUSED
-                //_runes.SetRuneState(i, true);       //UNUSED
-            }
-        }
-
-        void StartAttack(Unit* u, bool force = false)
-        {
-            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
-            Aggro(u);
-            SetBotCommandState(COMMAND_ATTACK);
-            GetInPosition(force);
-        }
-
-        void RuneTimers(uint32 diff)
-        {
-            for (uint8 i = 0; i != MAX_RUNES; ++i)
-            {
-                if (_runes.runes[i].Cooldown <= diff)
-                {
-                    _runes.runes[i].Cooldown = 0;
-                    //_runes.SetRuneState(i, true);     //UNUSED
-                }
-                else
-                    _runes.runes[i].Cooldown -= diff;
-            }
-        }
-
-        void modpower(int32 mod, bool set = false)
-        {
-            if (set && mod < 0)
-                return;
-            if (mod < 0 && runicpower < uint32(abs(mod)))
-            {
-                //debug set runic power to 0
-                mod = 0;
-                set = true;
-                return;
-            }
-
-            if (set)
-                runicpower = mod ? mod * 10 : 0;
-            else
-                runicpower += mod * 10;
-
-            me->SetPower(POWER_RUNIC_POWER, runicpower);
-        }
-
-        uint32 getpower()
-        {
-            runicpower = me->GetPower(POWER_RUNIC_POWER);
-            return runicpower;
-        }
-
-        uint8 GetBotStance() const { return Presence; }
-
-        void EnterCombat(Unit*) { }
-        void Aggro(Unit*) { }
-        void AttackStart(Unit*) { }
-        void EnterEvadeMode() { }
-        void MoveInLineOfSight(Unit*) { }
-        void JustDied(Unit* u) { bot_ai::JustDied(u); }
-        void KilledUnit(Unit*) { }
-
-        void DoNonCombatActions(uint32 diff)
-        {
-            if (GC_Timer > diff || IsCasting() || Feasting() || Rand() > 20)
-                return;
-
-            //PATH OF FROST
-            if (GetSpell(PATH_OF_FROST_1) && HaveRune(RUNE_FROST)/* && !me->IsMounted()*/) //works while mounted
-            {
-                if ((me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && !me->HasAuraType(SPELL_AURA_WATER_WALK)) ||
-                    (master->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && !master->HasAuraType(SPELL_AURA_WATER_WALK) && me->GetDistance(master) < 50))
-                {
-                    if (doCast(me, GetSpell(PATH_OF_FROST_1)))
-                        return;
-                }
-            }
-        }
-
-        void CheckHysteria(uint32 diff)
-        {
-            if (!IsSpellReady(HYSTERIA_1, diff) || IsCasting() || Rand() > 15)
-                return;
-
-            Unit* target = NULL;
-
-            if (master->IsAlive() && IsMeleeClass(master->getClass()) && master->IsInCombat() &&
-                GetHealthPCT(master) > 80 && me->GetDistance(master) < 30 &&
-                master->getAttackers().empty() && !CCed(master, true))
-            {
-                if (Unit* u = master->GetVictim())
-                    if (u->GetHealth() > me->GetMaxHealth() / 2)
-                        target = master;
-            }
-
-            if (!target && IsMeleeClass(me->GetBotClass()) && GetHealthPCT(me) > 80 &&
-                me->getAttackers().empty() && !CCed(me, true))
-            {
-                if (Unit* u = me->GetVictim())
-                    if (u->GetHealth() > me->GetMaxHealth() / 2)
-                        target = me;
-            }
-
-            if (!target)
-            {
-                Group* gr = master->GetGroup();
-                if (gr)
-                {
-                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
-                    {
-                        Player* tPlayer = itr->GetSource();
-                        if (tPlayer == master) continue;
-                        if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
-                        if (!tPlayer->IsAlive() || me->GetMap() != tPlayer->FindMap()) continue;
-                        if (!IsMeleeClass(tPlayer->getClass()) || !tPlayer->IsInCombat()) continue;
-                        if (GetHealthPCT(tPlayer) < 80 || me->GetDistance(tPlayer) > 30) continue;
-                        if (!tPlayer->getAttackers().empty() || CCed(tPlayer, true)) continue;
-                        if (Unit* u = tPlayer->GetVictim())
-                        {
-                            if (u->GetHealth() > (me->GetMaxHealth() * 2) / 3)
-                            {
-                                target = tPlayer;
-                                break;
-                            }
-                        }
-                    }
-                }
-            }
-
-            if (target && doCast(target, GetSpell(HYSTERIA_1)))
-            {
-                if (target->GetTypeId() == TYPEID_PLAYER)
-                {
-                    me->MonsterWhisper("å·²ç»å¯¹ä½ æ½æ¾çä¹±ï¼ã", target->ToPlayer());
-                    SetSpellCooldown(HYSTERIA_1, 90000); //1.5 min for player
-                }
-                else
-                    SetSpellCooldown(HYSTERIA_1, 30000); //30 sec for bot
-
-                GC_Timer = 800;
-                return;
-            }
-
-            SetSpellCooldown(HYSTERIA_1, 2000); //fail
-        }
-
-        void CheckAntiMagicShell(uint32 diff)
-        {
-            if (!IsSpellReady(ANTI_MAGIC_SHELL_1, diff, false) || GetHealthPCT(me) > 55 ||
-                getpower() < 200 || IsCasting() || Rand() > 50)
-                return;
-
-			Unit::AttackerSet b_attackers = me->getAttackers();
-
-            if (b_attackers.empty())
-                return;
-
-            bool cast = false;
-            uint8 count = 0;
-
-			for (Unit::AttackerSet::const_iterator itr = b_attackers.begin(); itr != b_attackers.end(); ++itr)
-            {
-                if (!(*itr) || !(*itr)->IsAlive()) continue;
-                if (Spell* spell = (*itr)->GetCurrentSpell(CURRENT_GENERIC_SPELL))
-                {
-                    if (spell->m_targets.GetUnitTargetGUID() == me->GetGUID())
-                    {
-                        if ((*itr)->ToCreature() && (*itr)->ToCreature()->isWorldBoss())
-                        {
-                            cast = true;
-                            break;
-                        }
-
-                        if (++count >= 3)
-                        {
-                            cast = true;
-                            break;
-                        }
-                    }
-                }
-            }
-
-            if (cast)
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, GetSpell(ANTI_MAGIC_SHELL_1)))
-                {
-                    SetSpellCooldown(ANTI_MAGIC_SHELL_1, 30000); //30 sec for bot
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-
-            SetSpellCooldown(ANTI_MAGIC_SHELL_1, 1500); //fail
-        }
-
-        void CheckPresence(uint32 diff)
-        {
-            if (presencetimer > diff || IsCasting() || Rand() > 30) //no GCD
-                return;
-
-            uint8 newpresence = IsTank() ? DEATH_KNIGHT_FROST_PRESENCE : DEATH_KNIGHT_BLOOD_PRESENCE;
-            if (Presence == newpresence)
-            {
-                presencetimer = 500;
-                return;
-            }
-
-            Presence = newpresence;
-
-            if (Presence == DEATH_KNIGHT_FROST_PRESENCE && HaveRune(RUNE_FROST))
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, FROST_PRESENCE_1))
-                {
-                    GC_Timer = temptimer;
-                    presencetimer = 1000;
-                    return;
-                }
-            }
-            else if (Presence == DEATH_KNIGHT_BLOOD_PRESENCE && HaveRune(RUNE_BLOOD))
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, BLOOD_PRESENCE_1))
-                {
-                    GC_Timer = temptimer;
-                    presencetimer = 1000;
-                    return;
-                }
-            }
-
-            presencetimer = 500; //fail
-        }
-
-        void BreakCC(uint32 diff)
-        {
-            if (IsSpellReady(LICHBORNE_1, diff, false) &&/* Rand() < 75 &&*/
-                me->HasAuraWithMechanic((1<<MECHANIC_CHARM)|(1<<MECHANIC_FEAR)|(1<<MECHANIC_SLEEP)))
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, GetSpell(LICHBORNE_1)))
-                {
-                    SetSpellCooldown(LICHBORNE_1, 60000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-
-            bot_minion_ai::BreakCC(diff);
-        }
-
-        void UpdateAI(uint32 diff)
-        {
-            ReduceCD(diff);
-            if (IAmDead()) return;
-            CheckAttackState();
-
-            if (me->getPowerType() != POWER_RUNIC_POWER)
-                InitPowers();
-
-            if (runicpowertimer <= diff)
-            {
-                if (!me->IsInCombat())
-                {
-                    if (getpower() > uint32(30 * runicpowerLossMult))
-                        me->SetPower(POWER_RUNIC_POWER, runicpower - uint32(30 * runicpowerLossMult)); //-3 runic power every 2 sec
-                    else
-                        me->SetPower(POWER_RUNIC_POWER, 0);
-                }
-                runicpowertimer = 2000;
-            }
-            if (runicpowertimer2 <= diff)
-            {
-                if (me->IsInCombat())
-                {
-                    if (getpower() < me->GetMaxPower(POWER_RUNIC_POWER))
-                        me->SetPower(POWER_RUNIC_POWER, runicpower + uint32(20 * runicpowerIncomeMult)); //+2 runic power every 5 sec
-                    else
-                        me->SetPower(POWER_RUNIC_POWER, me->GetMaxPower(POWER_RUNIC_POWER));
-                }
-                runicpowertimer2 = 5000;
-            }
-
-            CheckAuras();
-            if (wait == 0)
-                wait = GetWait();
-            else
-                return;
-            BreakCC(diff);
-            if (CCed(me)) return;
-
-            if (GetHealthPCT(me) < 67 && Potion_cd <= diff)
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, HEALINGPOTION))
-                {
-                    Potion_cd = POTION_CD;
-                    GC_Timer = temptimer;
-                }
-            }
-            if (!me->IsInCombat())
-                DoNonCombatActions(diff);
-
-            CheckPresence(diff);
-
-            //HORN OF WINTER
-            if (IsSpellReady(HORN_OF_WINTER_1, diff, false, (me->IsInCombat() ? 45000 : 0)) && Rand() < 30 &&
-                (me->IsInCombat() || (me->GetDistance(master) < 28 && master->IsWithinLOSInMap(me))))
-            {
-                Aura* horn = master->GetAura(GetSpell(HORN_OF_WINTER_1));
-                if (!horn || horn->GetDuration() < 5000)
-                {
-                    temptimer = GC_Timer;
-                    if (doCast(me, GetSpell(HORN_OF_WINTER_1)))
-                    {
-                        SetSpellCooldown(HORN_OF_WINTER_1, 60000);
-                        GC_Timer = temptimer;
-                        return;
-                    }
-                }
-            }
-            //BONE SHIELD
-            if (IsSpellReady(BONE_SHIELD_1, diff) && HaveRune(RUNE_UNHOLY) && Rand() < 25)
-            {
-                Aura* bone = me->GetAura(GetSpell(BONE_SHIELD_1));
-                if (!bone || bone->GetCharges() < 2 || (!me->IsInCombat() && bone->GetDuration() < 60000))
-                {
-                    if (doCast(me, GetSpell(BONE_SHIELD_1)))
-                    {
-                        SetSpellCooldown(BONE_SHIELD_1, 30000);
-                        GC_Timer = 800;
-                        return;
-                    }
-                }
-
-                SetSpellCooldown(BONE_SHIELD_1, 1000); //fail
-            }
-
-            if (me->IsInCombat())
-            {
-                //ICEBOUND FORTITUDE
-                if (IsSpellReady(ICEBOUND_FORTITUDE_1, diff, false) && getpower() >= 200 &&
-                    GetHealthPCT(me) < std::min<uint32>(85, 45 + uint8(me->getAttackers().size()) * 7) &&
-                    Rand() < 40 + IsTank() * 50)
-                {
-                    temptimer = GC_Timer;
-                    if (doCast(me, GetSpell(ICEBOUND_FORTITUDE_1)))
-                    {
-                        GC_Timer = temptimer;
-                        SetSpellCooldown(ICEBOUND_FORTITUDE_1, 90000);
-                    }
-                }
-
-                CheckAntiMagicShell(diff);
-                CheckHysteria(diff);
-            }
-
-            if (!CheckAttackTarget(CLASS_DEATH_KNIGHT))
-                return;
-
-            Attack(diff);
-        }
-
-        void Attack(uint32 diff)
-        {
-            opponent = me->GetVictim();
-            if (opponent)
-            {
-                if (!IsCasting())
-                    StartAttack(opponent, true);
-            }
-            else
-                return;
-
-            //SELFHEAL
-
-            //RUNE TAP
-            if (IsSpellReady(RUNE_TAP_1, diff) && GetHealthPCT(me) < 40 && Rand() < 50)
-            {
-                if (!HaveRune(RUNE_BLOOD) && IsSpellReady(EMPOWER_RUNE_WEAPON_1, diff, false))
-                {
-                    temptimer = GC_Timer;
-                    if (doCast(me, GetSpell(EMPOWER_RUNE_WEAPON_1)))
-                    {
-                        ActivateAllRunes();
-                        SetSpellCooldown(EMPOWER_RUNE_WEAPON_1, 60000);
-                        GC_Timer = temptimer;
-                    }
-                }
-                temptimer = GC_Timer;
-                if (doCast(me, GetSpell(RUNE_TAP_1)))
-                {
-                    SetSpellCooldown(RUNE_TAP_1, 20000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-            //VAMPIRIC BLOOD
-            if (IsSpellReady(VAMPIRIC_BLOOD_1, diff, false) && GetHealthPCT(me) < 26/* && Rand() < 75*/)
-            {
-                if (!HaveRune(RUNE_BLOOD) && IsSpellReady(EMPOWER_RUNE_WEAPON_1, diff, false, 40000))
-                {
-                    temptimer = GC_Timer;
-                    if (doCast(me, GetSpell(EMPOWER_RUNE_WEAPON_1)))
-                    {
-                        ActivateAllRunes();
-                        SetSpellCooldown(EMPOWER_RUNE_WEAPON_1, 60000);
-                        GC_Timer = temptimer;
-                    }
-                }
-                temptimer = GC_Timer;
-                if (doCast(me, GetSpell(VAMPIRIC_BLOOD_1)))
-                {
-                    SetSpellCooldown(VAMPIRIC_BLOOD_1, 40000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-            //END SELFHEAL
-
-            //MARK OF BLOOD
-            Unit* u = opponent->GetVictim();
-            if (IsSpellReady(MARK_OF_BLOOD_1, diff) && HaveRune(RUNE_BLOOD) &&
-                u && GetHealthPCT(u) < 85 && opponent->GetHealth() > u->GetMaxHealth() / 3 &&
-                (IsTank(u) || u->GetTypeId() == TYPEID_PLAYER) &&
-                Rand() < 35 && !opponent->HasAura(MARK_OF_BLOOD_1) && IsInBotParty(u))
-            {
-                if (doCast(opponent, GetSpell(MARK_OF_BLOOD_1)))
-                {
-                    SetSpellCooldown(MARK_OF_BLOOD_1, 90000); //1.5 min for bots
-                    GC_Timer = 800;
-                    return;
-                }
-            }
-
-            //AttackerSet m_attackers = master->getAttackers();
-            //AttackerSet b_attackers = me->getAttackers();
-            float dist = me->GetExactDist(opponent);
-            float meleedist = me->GetDistance(opponent);
-
-            //NON-DISEASE SECTION
-
-            //PLACEHOLDER: ARMY OF THE DEAD
-
-            //RANGED SECTION
-
-            //STRANGULATE
-            if (IsSpellReady(STRANGULATE_1, diff) && meleedist <= 30 && HaveRune(RUNE_BLOOD) &&
-                opponent->IsNonMeleeSpellCast(false) && Rand() < 40)
-            {
-                if (me->IsNonMeleeSpellCast(false))
-                    me->InterruptNonMeleeSpells(false);
-
-                if (doCast(opponent, GetSpell(STRANGULATE_1)))
-                {
-                    SetSpellCooldown(STRANGULATE_1, 40000); //-67% for bots
-                    GC_Timer = 800;
-                    return;
-                }
-
-                SetSpellCooldown(STRANGULATE_1, 500); //fail
-            }
-
-            //DARK COMMAND
-            if (IsSpellReady(DARK_COMMAND_1, diff, false) && dist < 30 && IsTank() &&
-                opponent->GetVictim() != me && Rand() < 70)
-            {
-                temptimer = GC_Timer;
-                if (doCast(opponent, GetSpell(DARK_COMMAND_1)))
-                {
-                    SetSpellCooldown(DARK_COMMAND_1, 6000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-            ////DEATH GRIP - DISABLED
-            //if (DEATH_GRIP && DeathGrip_cd <= diff && dist < 30 &&
-            //    (tank == me && opponent->GetVictim() != me) ||
-            //    (opponent->GetVictim() == me && opponent->ToPlayer() && opponent->IsNonMeleeSpellCasted(false)) &&
-            //    Rand() < 75)
-            //{
-            //    temptimer = GC_Timer;
-            //    if (doCast(opponent, DEATH_GRIP))
-            //    {
-            //        DeathGrip_cd = 25000;
-            //        GC_Timer = temptimer;
-            //        return;
-            //    }
-
-            //    DeathGrip_cd = 1000; //fail
-            //}
-            //CHAINS OF ICE
-            if (uint32 CHAINS_OF_ICE = GetSpell(CHAINS_OF_ICE_1))
-            {
-                if (GC_Timer <= diff && dist < 20 && HaveRune(RUNE_FROST) && opponent->isMoving() &&
-                    !CCed(opponent) && !IsTank(opponent->GetVictim()) && IsInBotParty(opponent->GetVictim()) && Rand() < 25)
-                {
-                    Aura* chains = opponent->GetAura(CHAINS_OF_ICE);
-                    if (!chains || chains->GetDuration() < chains->GetMaxDuration() / 4)
-                    {
-                        if (doCast(opponent, CHAINS_OF_ICE))
-                        {
-                            //Improved Chains of Ice: convert frost rune into death rune
-                            ConvertRune(RUNE_FROST, 1);
-                            return;
-                        }
-                    }
-                }
-            }
-
-            //AOE SECTION
-
-            //HOWLING BLAST
-            if (IsSpellReady(HOWLING_BLAST_1, diff) && IsTank() && meleedist < 8 && HasRole(BOT_ROLE_DPS) &&
-                me->getAttackers().size() > 2 && HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST) && Rand() < 50)
-            {
-                if (doCast(me, GetSpell(HOWLING_BLAST_1)))
-                {
-                    SetSpellCooldown(HOWLING_BLAST_1, 7000);
-                    GC_Timer = 800;
-                    return;
-                }
-
-                SetSpellCooldown(HOWLING_BLAST_1, 500); //fail
-            }
-            //BLOOD BOIL
-            if (IsSpellReady(BLOOD_BOIL_1, diff) && HasRole(BOT_ROLE_DPS) && HaveRune(RUNE_BLOOD) && Rand() < (10 + 40 * IsTank()))
-            {
-                std::list<Unit*> targets;
-                GetNearbyTargetsList(targets, 9.5f);
-                if (targets.size() >= 5)
-                    if (doCast(me, GetSpell(BLOOD_BOIL_1)))
-                        return;
-            }
-            //DEATH AND DECAY
-            if (IsSpellReady(DEATH_AND_DECAY_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < (30 + 30 * IsTank()) &&
-                HaveRune(RUNE_BLOOD) && HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST))
-            {
-                if (Unit* target = FindAOETarget(30, true))
-                {
-                    if (doCast(target, GetSpell(DEATH_AND_DECAY_1)))
-                    {
-                        SetSpellCooldown(DEATH_AND_DECAY_1, 15000); //improved by Morbidity
-                        return;
-                    }
-                }
-
-                SetSpellCooldown(DEATH_AND_DECAY_1, 500); //fail
-            }
-
-            //END AOE SECTION
-
-            //ICY TOUCH
-            if (IsSpellReady(ICY_TOUCH_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 20 && HaveRune(RUNE_FROST) && Rand() < 25 &&
-                !opponent->HasAura(FROST_FEVER_AURA, me->GetGUID()))
-            {
-                if (doCast(opponent, GetSpell(ICY_TOUCH_1)))
-                    return;
-            }
-            //DEATH COIL //custom cd condition
-            if (GetSpell(DEATH_COIL_1) && GC_Timer <= 600 && dist < 20 && HasRole(BOT_ROLE_DPS) &&
-                int32(getpower()) >= (400 + 200 * (GetSpell(RUNE_STRIKE_1) != 0 || GetSpell(MIND_FREEZE_1) != 0 || GetSpell(ANTI_MAGIC_SHELL_1) != 0) + 400 * (GetSpell(HUNGERING_COLD_1) != 0)) &&
-                Rand() < 60)
-            {
-                if (doCast(opponent, GetSpell(DEATH_COIL_1)))
-                    return;
-            }
-
-            //MELEE SECTION
-
-            //MIND FREEZE
-            if (IsSpellReady(MIND_FREEZE_1, diff, false) && meleedist <= 5 && getpower() >= 200 &&
-                opponent->IsNonMeleeSpellCast(false) && Rand() < 60)
-            {
-                if (me->IsNonMeleeSpellCast(false))
-                    me->InterruptNonMeleeSpells(false);
-
-                temptimer = GC_Timer;
-                if (doCast(opponent, GetSpell(MIND_FREEZE_1)))
-                {
-                    SetSpellCooldown(MIND_FREEZE_1, 8000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-            //HUNGERING COLD
-            if (IsSpellReady(HUNGERING_COLD_1, diff) && HasRole(BOT_ROLE_DPS) && getpower() >= 400 && Rand() < 20)
-            {
-                std::list<Unit*> targets;
-                GetNearbyTargetsList(targets, 9.f, 0, true);
-                if (targets.size() >= 3)
-                {
-                    if (doCast(me, GetSpell(HUNGERING_COLD_1)))
-                    {
-                        SetSpellCooldown(HUNGERING_COLD_1, 45000);
-                        return;
-                    }
-                }
-
-                SetSpellCooldown(HUNGERING_COLD_1, 500); //fail
-            }
-
-            if (MoveBehind(*opponent))
-                wait = 5;
-
-            //RUNE STRIKE
-            if (IsSpellReady(RUNE_STRIKE_1, diff, false) && runestriketimer > me->getAttackTimer(BASE_ATTACK) &&
-                HasRole(BOT_ROLE_DPS) && meleedist <= 5 && getpower() >= 200/* && Rand() < 75*/)
-            {
-                temptimer = GC_Timer;
-                if (doCast(opponent, GetSpell(RUNE_STRIKE_1)))
-                {
-                    SetSpellCooldown(RUNE_STRIKE_1, me->getAttackTimer(BASE_ATTACK)); //only one per swing
-                    runestriketimer = 0; //do not remove aura, just disable ability
-                    GC_Timer = temptimer;
-                }
-            }
-            //PLAGUE STRIKE
-            if (IsSpellReady(PLAGUE_STRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && HaveRune(RUNE_UNHOLY) && Rand() < 35 &&
-                !opponent->HasAura(BLOOD_PLAGUE_AURA, me->GetGUID()))
-            {
-                if (doCast(opponent, GetSpell(PLAGUE_STRIKE_1)))
-                    return;
-            }
-
-            //DISEASE SECTION
-            uint32 diseases = opponent->GetDiseasesByCaster(me->GetGUID());
-
-            //PESTILENCE //custom cd condition
-            if (GetSpell(PESTILENCE_1) && pestilencetimer == 0 && HasRole(BOT_ROLE_DPS) && GC_Timer <= 600 &&
-                diseases > 1 && meleedist <= 5 &&
-                HaveRune(RUNE_BLOOD) && Rand() < 15)
-            {
-                std::list<Unit*> targets;
-                GetNearbyTargetsList(targets, 9.f);
-                if (targets.size() > 2)
-                {
-                    if (doCast(opponent, GetSpell(PESTILENCE_1)))
-                    {
-                        pestilencetimer = 10000;
-                        return;
-                    }
-                }
-
-                pestilencetimer = 1000; //fail
-            }
-            //DEATH STRIKE
-            if (IsSpellReady(DEATH_STRIKE_1, diff) && diseases > 0 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
-                HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST) &&
-                GetHealthPCT(me) < (91 - 10 * diseases) && Rand() < 70)
-            {
-                if (doCast(opponent, GetSpell(DEATH_STRIKE_1)))
-                    return;
-            }
-            //OBLITERATE
-            if (IsSpellReady(OBLITERATE_1, diff) && diseases > 2 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
-                HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST) && Rand() < 20)
-            {
-                if (doCast(opponent, GetSpell(OBLITERATE_1)))
-                    return;
-            }
-            //BLOOD STRIKE //custom
-            if (BLOOD_STRIKE && GC_Timer <= diff && HasRole(BOT_ROLE_DPS) && diseases > 1 && meleedist <= 5 &&
-                HaveRune(RUNE_BLOOD) && Rand() < 25)
-            {
-                if (doCast(opponent, BLOOD_STRIKE))
-                    return;
-            }
-        }
-
-        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
-        {
-            uint32 spellId = spellInfo->Id;
-            uint8 lvl = me->getLevel();
-            float fdamage = float(damage);
-            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
-            if (!crit)
-            {
-                float aftercrit = 0.f;
-
-                //Increased Plague Strike Crit (id 60130): 10% additional critical chance for Plague Strike
-                if (spellId == GetSpell(PLAGUE_STRIKE_1))
-                    aftercrit += 0.1f;
-                //Glyph of Rune Strike: 10% additional critical chance for Rune Strike
-                if (spellId == GetSpell(RUNE_STRIKE_1))
-                    aftercrit += 0.1f;
-                //Subversion: 9% additional critical chance for Blood Strike, Scourge Strike, Heart Strike and Obliterate
-                if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1) ||
-                    /*spellId == GetSpell(SCOURGE_STRIKE_1) || */spellId == GetSpell(OBLITERATE_1))
-                    aftercrit += 0.09f;
-                //Improved Death Strike (part 2): 6% additional critical chance for Death Strike
-                if (spellId == GetSpell(DEATH_STRIKE_1))
-                    aftercrit += 0.06f;
-                //Rime (part 1 melee): 15% additional critical chance for Obliterate
-                if (lvl >= 68 && spellId == GetSpell(OBLITERATE_1))
-                    aftercrit += 15.f;
-                //Vicious Strikes (part 1): 6% additional critical chance for Plague Strike and Scourge Strike
-                if (lvl >= 57 && (spellId == GetSpell(PLAGUE_STRIKE_1)/* || spellId == GetSpell(SCOURGE_STRIKE_1)*/))
-                    aftercrit += 6.f;
-
-                //Annihilation: 3% additional critical chance for melee special abilities
-                if (lvl >= 57)
-                    aftercrit += 0.03f;
-
-                //second roll (may be illogical)
-                if (aftercrit > 0.f)
-                    crit = roll_chance_f(aftercrit);
-            }
-
-            //2) apply bonus damage mods
-            float pctbonus = 0.0f;
-            if (crit)
-            {
-                //!!!Melee spell damage is not yet critical, all reduced by half
-
-                //Might of Mograine: 45% crit damage bonus for Blood Boil, Blood Strike, Death Strike and Heart Strike
-                if (lvl >= 68 &&
-                    (spellId == GetSpell(BLOOD_BOIL_1) || spellId == BLOOD_STRIKE ||
-                    spellId == GetSpell(DEATH_STRIKE_1) || spellId == GetSpell(HEART_STRIKE_1)))
-                    pctbonus += 0.45f / 2.f;
-                //Guile of Gorefiend (part 1 melee): 45% crit damage bonus for Blood Strike, Frost Strike and Obliterate
-                if (lvl >= 69 &&
-                    (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1) ||
-                    spellId == GetSpell(OBLITERATE_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/))
-                    pctbonus += 0.45f / 2.f;
-                //Vicious Strikes (part 2): 30% crit damage bonus for Plague Strike and Scourge Strike
-                if (lvl >= 57 && (spellId == GetSpell(PLAGUE_STRIKE_1)/* || spellId == GetSpell(SCOURGE_STRIKE_1)*/))
-                    pctbonus += 0.3f / 2.f;
-            }
-
-            //Glypg of Plague Strike: 20% bonus damage for Plague Strike
-            if (spellId == GetSpell(PLAGUE_STRIKE_1))
-                pctbonus += 0.2f;
-            //Glyph of Blood Strike: 20% bonus damage for Blood Strike on snared targets (Heart Strike too for bots)
-            //warning unsafe
-            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1))
-                if (damageinfo.target->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_SLOW_ATTACK)))
-                    pctbonus += 0.2f;
-            //Increased Blood Strike Damage: 90 bonus damage for Blood Strike and Heart Strike
-            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1))
-                fdamage += 90.f;
-            //Glyph of Death Strike: 1% bonus damage for every runic power point (max 25) for Death Strike
-            if (spellId == GetSpell(DEATH_STRIKE_1) && me->GetPower(POWER_RUNIC_POWER) >= 10)
-            {
-                //10 to 250 * 0.001 = 10 to 250 / 1000 = 0.01 to 0.25
-                pctbonus += float(std::min<uint32>(me->GetPower(POWER_RUNIC_POWER), 250)) * 0.001f;
-            }
-            //Glyph of Obliterate: 25% bonus damage for Obliterate
-            if (spellId == GetSpell(OBLITERATE_1))
-                pctbonus += 0.25f;
-            //Bloody Strikes: 15% bonus damage for Blood Strike, 45% for Heart Strike and 30% for Blood Boil
-            if (lvl >= 60)
-            {
-                if (spellId == BLOOD_STRIKE)
-                    pctbonus += 0.15f;
-                else if (spellId == GetSpell(HEART_STRIKE_1))
-                    pctbonus += 0.45f;
-                else if (spellId == GetSpell(BLOOD_BOIL_1))
-                    pctbonus += 0.3f;
-            }
-            //Improved Death Strike (part 1): 30% bonus damage for Death Strike
-            if (spellId == GetSpell(DEATH_STRIKE_1))
-                pctbonus += 0.3f;
-            //Merciless Combat (melee): 12% bonus damage for Obliterate on targets with less than 35% hp
-            //warning unsafe
-            if (lvl >= 67 && spellId == GetSpell(OBLITERATE_1) && damageinfo.target->GetHealthPct() < 35)
-                pctbonus += 0.12f;
-            //Blood of the North (part 1): 10% bonus damage for Blood Strike and Frost Strike (make Heart strike too)
-            if (lvl >= 69 && (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/))
-                pctbonus += 0.1f;
-            //Tundra Stalker (melee): 40% damage bonus on targets affected with Frost Fever (20% for bot, regardless of caster)
-            //warning unsafe
-            if (lvl >= 70 && damageinfo.target->HasAura(FROST_FEVER_AURA))
-                pctbonus += 0.2f;
-            //Outbreak: 30% bonus damage for Plague Strike and 20% for Scourge Strike
-            if (lvl >= 59)
-            {
-                if (spellId == GetSpell(PLAGUE_STRIKE_1))
-                    pctbonus += 0.3f;
-                //else if (spellId == GetSpell(SCOURGE_STRIKE_1))
-                //    pctbonus += 0.2f;
-            }
-
-            damage = int32(fdamage * (1.0f + pctbonus));
-        }
-
-        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
-        {
-            uint32 spellId = spellInfo->Id;
-            uint8 lvl = me->getLevel();
-            float fdamage = float(damage);
-            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
-            if (!crit)
-            {
-                float aftercrit = 0.f;
-                //Rime (part 1 spell): 15% additional critical chance for Icy Touch
-                if (lvl >= 68 && spellId == GetSpell(ICY_TOUCH_1))
-                    aftercrit += 15.f;
-
-                if (aftercrit > 0.f)
-                    crit = roll_chance_f(aftercrit);
-            }
-
-            //2) apply bonus damage mods
-            float pctbonus = 0.0f;
-            if (crit)
-            {
-                //!!!spell damage is not yet critical and will be multiplied by 1.5
-                //so we should put here bonus damage mult /1.5
-
-                //Guile of Gorefiend (part 1 spell): 45% crit damage bonus for Howling Blast
-                if (lvl >= 69 && spellId == GetSpell(HOWLING_BLAST_1))
-                    pctbonus += 0.45f / 1.5f;
-
-                //Runic Focus: 50% crit damage bonus for all spells
-                pctbonus += 0.5f / 1.5f;
-            }
-
-            //Improved Icy Touch: 15% bonus damage for Icy Touch
-            if (spellId == GetSpell(ICY_TOUCH_1))
-                pctbonus += 0.15f;
-            //Increased Icy Touch Damage (id 54800): 111 bonus damage for Icy Touch
-            if (spellId == GetSpell(ICY_TOUCH_1))
-                fdamage += 111.f;
-            //Increased Death Coil Damage (id 54807): 80 bonus damage for Death Coil
-            if (spellId == GetSpell(DEATH_COIL_1))
-                fdamage += 80.f;
-            //Black Ice: 10% bonus damage for all Shadow and Frost spells
-            if (lvl >= 58 &&
-                ((SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()) ||
-                (SPELL_SCHOOL_MASK_SHADOW & spellInfo->GetSchoolMask())))
-                pctbonus += 0.1f;
-            //Glacier Rot: 20% bonus damage for Icy Touch, Howling Blast and Frost Strike
-            //warning unsafe
-            if (lvl >= 63 && (spellId == GetSpell(ICY_TOUCH_1) || spellId == GetSpell(HOWLING_BLAST_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/) &&
-                damageinfo.target->GetDiseasesByCaster(me->GetGUID()) > 0)
-                pctbonus += 0.2f;
-            //Merciless Combat (spell): 12% bonus damage for Icy Touch, Howling Blast and Frost Strike on targets with less than 35% hp
-            //warning unsafe
-            if (lvl >= 67 &&
-                (spellId == GetSpell(ICY_TOUCH_1) || spellId == GetSpell(HOWLING_BLAST_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/) &&
-                damageinfo.target->GetHealthPct() < 35)
-                pctbonus += 0.12f;
-            //Tundra Stalker (spell): 40% damage bonus on targets affected with Frost Fever (20% for bot, regardless of caster)
-            //warning unsafe
-            if (lvl >= 70 && damageinfo.target->HasAura(FROST_FEVER_AURA))
-                pctbonus += 0.2f;
-            //Morbidity: 15% damage bonus for Death Coil
-            if (lvl >= 58 && spellId == GetSpell(DEATH_COIL_1))
-                pctbonus += 0.15f;
-
-            //temp
-            if (spellId == GetSpell(RUNE_TAP_1))
-                pctbonus += 1.f;
-
-            damage = int32(fdamage * (1.0f + pctbonus));
-        }
-
-        void ApplyClassDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float& value) const
-        {
-            uint32 spellId = spellInfo->Id;
-            uint8 lvl = me->getLevel();
-            float pct_mod = 1.f;
-
-            //Periodic damage bonuses
-            if (spellInfo->Effects[effect_index].ApplyAuraName == SPELL_AURA_PERIODIC_DAMAGE)
-            {
-                //float ticksnum = float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
-
-                //Increased Plague Strike DoT Damage (id 54802): increased DoT damage by 100
-                if (spellId == BLOOD_PLAGUE_AURA)
-                    value += 100.f;
-                //Glyph of Icy Touch: 20% bonus damage for Frost Fever
-                if (spellId == FROST_FEVER_AURA)
-                    pct_mod += 0.2f;
-                //Black Ice: 10% bonus damage for all Shadow and Frost spells
-                if (lvl >= 58 &&
-                    ((SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()) ||
-                    (SPELL_SCHOOL_MASK_SHADOW & spellInfo->GetSchoolMask())))
-                    pct_mod += 0.1f;
-                //Glyph of Unholy Blight: 40% damage bonus for Unholy Blight (100% for bot)
-                if (spellId == UNHOLY_BLIGHT_AURA)
-                    pct_mod += 1.f;
-            }
-            //Heal bonuses
-            if (spellInfo->Effects[effect_index].Effect == SPELL_EFFECT_HEAL)
-            {
-                //Improved Rune Tap: 100% bonus healing from Rune Tap
-                if (spellId == GetSpell(RUNE_TAP_1))
-                    pct_mod += 1.f;
-            }
-
-            value *= pct_mod;
-        }
-
-        void SpellHitTarget(Unit* target, SpellInfo const* spell)
-        {
-            uint32 spellId = spell->Id;
-
-            //Glyph of Horn of Winter: 1 minute bonus duration (3 for bot)
-            if (spellId == GetSpell(HORN_OF_WINTER_1))
-            {
-                if (Aura* horn = target->GetAura(spellId, me->GetGUID()))
-                {
-                    uint32 dur = horn->GetDuration() + 180000;
-                    horn->SetDuration(dur);
-                    horn->SetMaxDuration(dur);
-                }
-
-                //Winter Veil addition
-                if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
-                    me->AddAura(44755, target); //snowflakes
-            }
-
-            if (target == me)
-                return;
-
-            //Epidemic: 10 sec bonus duration for all diseases
-            if (spellId == FROST_FEVER_AURA || spellId == BLOOD_PLAGUE_AURA ||
-                spellId == CRYPT_FEVER_AURA || spellId == EBON_PLAGUE_AURA)
-            {
-                if (Aura* fever = target->GetAura(spellId, me->GetGUID()))
-                {
-                    uint32 dur = fever->GetDuration() + 10000;
-                    fever->SetDuration(dur);
-                    fever->SetMaxDuration(dur);
-                }
-            }
-            //Sudden Doom: 15% ctc Death Coil on Blood Strike or Heart Strike (up to 30% for bot)
-            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1))
-            {
-                if (GetSpell(DEATH_COIL_1) && me->getLevel() >= 65 && irand(1,100) <= (me->getLevel() - 50))
-                {
-                    //debug: dk bot cannot cast without runic power even triggered spells
-                    modpower(40);
-                    me->CastSpell(target, GetSpell(DEATH_COIL_1), true);
-                }
-            }
-            //Rime (part 2): Obliterate has 15% chance to reset Howling Blast cooldown (25% for bot, screw runes part)
-            if (spellId == GetSpell(OBLITERATE_1))
-            {
-                if (me->getLevel() >= 67 && urand(1,100) <= 25)
-                    ResetSpellCooldown(HOWLING_BLAST_1);
-            }
-            //Chillblains Improved: increase duration by 10 sec (disable on players)
-            if (spellId == ICY_CLUTCH)
-            {
-                if (target->GetTypeId() != TYPEID_PLAYER)
-                {
-                    if (Aura* chill = target->GetAura(spellId, me->GetGUID()))
-                    {
-                        uint32 dur = chill->GetDuration() + 10000;
-                        chill->SetDuration(dur);
-                        chill->SetMaxDuration(dur);
-                    }
-                }
-            }
-            //Blood of the North (part 2): Blood Strike and Pestilence convert Blood Rune to Dark Rune (make Heart Strike too)
-            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1) || GetSpell(spellId == PESTILENCE_1))
-            {
-                if (me->getLevel() >= 69)
-                    ConvertRune(RUNE_BLOOD, 1);
-            }
-        }
-
-        void SpellHit(Unit* caster, SpellInfo const* spell)
-        {
-            uint32 spellId = spell->Id;
-
-            if (spellId == RUNE_STRIKE_ACIVATION_AURA)
-            {
-                //Rune Strike activation and timer set
-                runestriketimer = 10000;
-            }
-            if (spellId == GetSpell(ANTI_MAGIC_SHELL_1))
-            {
-                //Glyph of Anti-Magic Shell: 2 sec increased duration (5 for bot)
-                if (Aura* shell = me->GetAura(spellId))
-                {
-                    uint32 dur = shell->GetDuration() + 5000;
-                    shell->SetDuration(dur);
-                    shell->SetMaxDuration(dur);
-                }
-            }
-            if (spellId == GetSpell(VAMPIRIC_BLOOD_1))
-            {
-                //Glyph of Vampiric Blood: 5 sec increased duration
-                if (Aura* blood = me->GetAura(spellId))
-                {
-                    uint32 dur = blood->GetDuration() + 5000;
-                    blood->SetDuration(dur);
-                    blood->SetMaxDuration(dur);
-                }
-            }
-            if (spellId == GetSpell(BONE_SHIELD_1))
-            {
-                //Glyph of Bone Shield: 1 bonus charge (2 for bot, 7 for tank)
-                if (Aura* bone = me->GetAura(spellId))
-                {
-                    bone->SetCharges(bone->GetCharges() + (IsTank() ? 3 : 1));
-                }
-            }
-            if (spellId == ICY_TALONS_AURA1 || spellId == ICY_TALONS_AURA2 ||
-                spellId == ICY_TALONS_AURA3 || spellId == ICY_TALONS_AURA4 || spellId == ICY_TALONS_AURA5)
-            {
-                //Icy Talons: Synchronize with Epidemic, add 10 sec duration
-                if (Aura* talons = me->GetAura(spellId))
-                {
-                    uint32 dur = talons->GetDuration() + 10000;
-                    talons->SetDuration(dur);
-                    talons->SetMaxDuration(dur);
-                }
-            }
-            if (spellId == GetSpell(DEATH_STRIKE_1) || spellId == GetSpell(OBLITERATE_1))
-            {
-                //Death Rune Mastery: convert Unholy and Frost Runes into Death Runes
-                ConvertRune(RUNE_UNHOLY, 1);
-                ConvertRune(RUNE_FROST, 1);
-            }
-            if (spellId == GetSpell(ICEBOUND_FORTITUDE_1))
-            {
-                //Guile of Gorefiend (part 2): Icebound Fortitude 6 sec increased duration (18 for bot)
-                if (Aura* fort = me->GetAura(spellId))
-                {
-                    uint32 dur = fort->GetDuration() + 18000;
-                    fort->SetDuration(dur);
-                    fort->SetMaxDuration(dur);
-                }
-            }
-
-            OnSpellHit(caster, spell);
-        }
-
-        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
-        {
-            if (victim == me)
-                return;
-
-            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
-            {
-                //Blood Presence Heal
-                if (me->HasAura(IMPROVED_BLOOD_PRESENCE_AURA))
-                {
-                    int32 bp0 = int32(damage / 25); //4%
-                    me->CastCustomSpell(me, BLOOD_PRESENCE_HEAL_EFFECT, &bp0, NULL, NULL, true);
-                }
-
-                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
-                {
-                    if (_ctc[i].first && !_ctc[i].second)
-                    {
-                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
-                            _ctc[i].second = 1000;
-
-                        if (_ctc[i].second > 0)
-                            me->CastSpell(victim, _ctc[i].first, true);
-                    }
-                }
-            }
-        }
-
-		void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType, SpellSchoolMask)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void OwnerAttackedBy(Unit* u)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void Reset()
-        {
-            presencetimer = 0;
-            runicpowertimer = 2000;
-            runicpowertimer2 = 5000;
-            runestriketimer = 0;
-            pestilencetimer = 0;
-
-            Presence = BOT_STANCE_NONE;
-
-            runicpowerIncomeMult = sWorld->getRate(RATE_POWER_RUNICPOWER_INCOME);
-            runicpowerLossMult = sWorld->getRate(RATE_POWER_RUNICPOWER_LOSS);
-            me->setPowerType(POWER_RUNIC_POWER);
-            me->SetMaxPower(POWER_RUNIC_POWER, me->GetCreatePowers(POWER_RUNIC_POWER));
-
-            if (master)
-            {
-                SetStats(true);
-                InitRoles();
-                InitPowers();
-                InitRunes();
-                ApplyPassives(CLASS_DEATH_KNIGHT);
-            }
-        }
-
-        void ReduceCD(uint32 diff)
-        {
-            CommonTimers(diff);
-            SpellTimers(diff);
-            RuneTimers(diff);
-
-            if (presencetimer > diff)               presencetimer -= diff;
-            if (runicpowertimer > diff)             runicpowertimer -= diff;
-            if (runicpowertimer2 > diff)            runicpowertimer2 -= diff;
-
-            if (runestriketimer > diff)             runestriketimer -= diff;
-            else                                    runestriketimer = 0;
-            if (pestilencetimer > diff)             pestilencetimer -= diff;
-            else                                    pestilencetimer = 0;
-        }
-
-        bool CanRespawn()
-        {return false;}
-
-        void InitPowers()
-        {
-            if (master->getLevel() >= 70)
-                RefreshAura(RUNIC_POWER_MASTERY,5);
-            else if (master->getLevel() >= 58)
-                RefreshAura(RUNIC_POWER_MASTERY,4);
-            else
-                me->SetMaxPower(POWER_RUNIC_POWER, me->GetCreatePowers(POWER_RUNIC_POWER));
-
-            if (runicpower)
-                me->SetPower(POWER_RUNIC_POWER, runicpower);
-        }
-
-        void InitSpells()
-        {
-            uint8 lvl = me->getLevel();
-            //InitSpellMap(BLOOD_STRIKE_1);
-            InitSpellMap(ICY_TOUCH_1);
-            InitSpellMap(PLAGUE_STRIKE_1);
-            InitSpellMap(DEATH_STRIKE_1);
-            InitSpellMap(OBLITERATE_1);
-            InitSpellMap(RUNE_STRIKE_1);
-  /*Talent*/InitSpellMap(HEART_STRIKE_1);
-
-            InitSpellMap(BLOOD_BOIL_1);
-            InitSpellMap(DEATH_AND_DECAY_1);
-  /*Talent*/lvl >= 63 ? InitSpellMap(HOWLING_BLAST_1) : RemoveSpell(HOWLING_BLAST_1);
-
-            InitSpellMap(DEATH_COIL_1);
-            InitSpellMap(DEATH_GRIP_1, true);
-            InitSpellMap(PESTILENCE_1);
-            InitSpellMap(MIND_FREEZE_1);
-            InitSpellMap(STRANGULATE_1);
-            InitSpellMap(CHAINS_OF_ICE_1);
-            InitSpellMap(ICEBOUND_FORTITUDE_1);
-            InitSpellMap(DARK_COMMAND_1);
-            InitSpellMap(ANTI_MAGIC_SHELL_1);
-            InitSpellMap(ARMY_OF_THE_DEAD_1);
-  /*Talent*/InitSpellMap(LICHBORNE_1, true);
-  /*Talent*/lvl >= 60 ? InitSpellMap(HUNGERING_COLD_1) : RemoveSpell(HUNGERING_COLD_1);
-
-            InitSpellMap(PATH_OF_FROST_1);
-            InitSpellMap(HORN_OF_WINTER_1);
-  /*Talent*/InitSpellMap(RUNE_TAP_1, true);
-  /*Talent*/lvl >= 58 ? InitSpellMap(BONE_SHIELD_1) : RemoveSpell(BONE_SHIELD_1);
-            InitSpellMap(EMPOWER_RUNE_WEAPON_1);
-  /*Talent*/InitSpellMap(MARK_OF_BLOOD_1, true);
-  /*Talent*/InitSpellMap(VAMPIRIC_BLOOD_1, true);
-  /*Talent*/lvl >= 59 ? InitSpellMap(HYSTERIA_1) : RemoveSpell(HYSTERIA_1);
-
-            InitSpellMap(BLOOD_PRESENCE_1, true);
-            InitSpellMap(FROST_PRESENCE_1, true);
-            //InitSpellMap(UNHOLY_PRESENCE_1, true);
-
-  /*Custom*/BLOOD_STRIKE = lvl >= 65 ? GetSpell(HEART_STRIKE_1) : InitSpell(me, BLOOD_STRIKE_1);
-        }
-
-        void ApplyClassPassives()
-        {
-            uint8 level = master->getLevel();
-
-            if (level >= 58)
-                RefreshAura(GLYPH_OF_CHAINS_OF_ICE);
-            if (level >= 80)
-                RefreshAura(CHAINS_OF_ICE_FROST_RUNE_REFRESH,4);
-            else if (level >= 77)
-                RefreshAura(CHAINS_OF_ICE_FROST_RUNE_REFRESH,3);
-            else if (level >= 68)
-                RefreshAura(CHAINS_OF_ICE_FROST_RUNE_REFRESH,2);
-            else if (level >= 58)
-                RefreshAura(CHAINS_OF_ICE_FROST_RUNE_REFRESH);
-            if (level >= 65)
-                RefreshAura(GLYPH_OF_HEART_STRIKE);
-            if (level >= 68)
-                RefreshAura(GLYPH_OF_RUNE_TAP,2);
-            else if (level >= 60)
-                RefreshAura(GLYPH_OF_RUNE_TAP);
-            if (level >= 63)
-                RefreshAura(GLYPH_OF_HOWLING_BLAST);
-            if (level >= 57)
-                RefreshAura(BUTCHERY);
-            if (level >= 58)
-                RefreshAura(SCENT_OF_BLOOD);
-            if (level >= 59)
-                RefreshAura(VENDETTA);
-            if (level >= 65)
-                RefreshAura(BLOODY_VENGEANCE3);
-            else if (level >= 60)
-                RefreshAura(BLOODY_VENGEANCE2);
-            else if (level >= 57)
-                RefreshAura(BLOODY_VENGEANCE1);
-            if (level >= 60)
-                RefreshAura(ABOMINATIONS_MIGHT);
-            if (level >= 67)
-                RefreshAura(IMPROVED_BLOOD_PRESENCE);
-            if (level >= 65)
-                RefreshAura(BLOODWORMS,2);
-            //if (level >= 66)
-            //    RefreshAura(IMPROVED_DEATH_STRIKE);
-            if (level >= 57)
-                RefreshAura(TOUGHNESS);
-            if (level >= 57)
-                RefreshAura(ANNIHILATION);
-            if (level >= 60)
-                RefreshAura(ICY_TALONS);
-            if (level >= 68)
-                RefreshAura(CHILL_OF_THE_GRAVE,2);
-            else if (level >= 58)
-                RefreshAura(CHILL_OF_THE_GRAVE);
-            if (level >= 64)
-                RefreshAura(IMPROVED_ICY_TALONS);
-            if (level >= 68)
-                RefreshAura(CHILBLAINS);
-            if (level >= 69)
-                RefreshAura(ACCLIMATION);
-            if (level >= 63)
-                RefreshAura(NECROSIS5);
-            else if (level >= 62)
-                RefreshAura(NECROSIS4);
-            else if (level >= 61)
-                RefreshAura(NECROSIS3);
-            else if (level >= 60)
-                RefreshAura(NECROSIS2);
-            else if (level >= 59)
-                RefreshAura(NECROSIS1);
-            if (level >= 65)
-                RefreshAura(BLOOD_CAKED_BLADE3);
-            else if (level >= 62)
-                RefreshAura(BLOOD_CAKED_BLADE2);
-            else if (level >= 60)
-                RefreshAura(BLOOD_CAKED_BLADE1);
-            if (level >= 67)
-                RefreshAura(DIRGE,2);
-            else if (level >= 61)
-                RefreshAura(DIRGE);
-            if (level >= 61)
-                RefreshAura(UNHOLY_BLIGHT);
-            if (level >= 62)
-                RefreshAura(DESECRATION);
-            if (level >= 64)
-                RefreshAura(CRYPT_FEVER);
-            if (level >= 68)
-                RefreshAura(EBON_PLAGUEBRINGER);
-            if (level >= 67)
-                RefreshAura(WANDERING_PLAGUE);
-
-            RefreshAura(FROST_FEVER);
-            RefreshAura(BLOOD_PLAGUE);
-        }
-
-        bool CanUseManually(uint32 basespell) const
-        {
-            switch (basespell)
-            {
-                case LICHBORNE_1:
-                case PATH_OF_FROST_1:
-                case HORN_OF_WINTER_1:
-                case BONE_SHIELD_1:
-                case RUNE_TAP_1:
-                case EMPOWER_RUNE_WEAPON_1:
-                case VAMPIRIC_BLOOD_1:
-                case HYSTERIA_1:
-                    return true;
-                default:
-                    return false;
-            }
-        }
-
-    private:
-        uint32 BLOOD_STRIKE;
-/*tmrs*/uint32 presencetimer, runicpowertimer, runicpowertimer2, runestriketimer, pestilencetimer;
-/*misc*/uint32 runicpower;
-/*misc*/float runicpowerIncomeMult, runicpowerLossMult;
-/*Chck*/uint8 Presence;
-
-        BotRunes _runes;
-
-        enum DeathKnightBaseSpells
-        {
-            BLOOD_STRIKE_1                      = 45902,
-            ICY_TOUCH_1                         = 45477,
-            PLAGUE_STRIKE_1                     = 45462,
-            DEATH_STRIKE_1                      = 49998,
-            OBLITERATE_1                        = 49020,
-            RUNE_STRIKE_1                       = 56815,
-            HEART_STRIKE_1                      = 55050,
-
-            BLOOD_BOIL_1                        = 48721,
-            DEATH_AND_DECAY_1                   = 43265,
-            HOWLING_BLAST_1                     = 49184,
-
-            DEATH_COIL_1                        = 47541,
-            DEATH_GRIP_1                        = 49576,
-            PESTILENCE_1                        = 50842,
-            MIND_FREEZE_1                       = 47528,
-            STRANGULATE_1                       = 47476,
-            CHAINS_OF_ICE_1                     = 45524,
-            ICEBOUND_FORTITUDE_1                = 48792,
-            DARK_COMMAND_1                      = 56222,
-            ANTI_MAGIC_SHELL_1                  = 48707,
-            ARMY_OF_THE_DEAD_1                  = 42650,
-            LICHBORNE_1                         = 49039,
-            HUNGERING_COLD_1                    = 49203,
-
-            PATH_OF_FROST_1                     = 3714,
-            HORN_OF_WINTER_1                    = 57330,
-            BONE_SHIELD_1                       = 49222,
-            RUNE_TAP_1                          = 48982,
-            EMPOWER_RUNE_WEAPON_1               = 47568,
-            MARK_OF_BLOOD_1                     = 49005,
-            VAMPIRIC_BLOOD_1                    = 55233,
-            HYSTERIA_1                          = 49016,
-
-            BLOOD_PRESENCE_1                    = 48266,
-            FROST_PRESENCE_1                    = 48263
-            //UNHOLY_PRESENCE_1                   = 48265
-        };
-        enum DeathKnightPassives
-        {
-        //Talents
-            BUTCHERY                            = 49483,//rank 2
-            SCENT_OF_BLOOD                      = 49509,//rank 3
-            VENDETTA                            = 55136,//rank 3
-            BLOODY_VENGEANCE1                   = 48988,
-            BLOODY_VENGEANCE2                   = 49503,
-            BLOODY_VENGEANCE3                   = 49504,
-            ABOMINATIONS_MIGHT                  = 53138,//rank 2
-            IMPROVED_BLOOD_PRESENCE             = 50371,//rank 2
-            BLOODWORMS                          = 49543,//rank 3
-            IMPROVED_DEATH_STRIKE               = 62908,//rank 2
-            TOUGHNESS                           = 49789,//rank 5
-            ANNIHILATION                        = 51473,//rank 3
-            ICY_TALONS                          = 50887,//rank 5
-            CHILL_OF_THE_GRAVE                  = 50115,//rank 2
-            IMPROVED_ICY_TALONS                 = 55610,
-            CHILBLAINS                          = 50043,//rank 3
-            ACCLIMATION                         = 50152,//rank 3
-            NECROSIS1                           = 51459,
-            NECROSIS2                           = 51462,
-            NECROSIS3                           = 51463,
-            NECROSIS4                           = 51464,
-            NECROSIS5                           = 51465,
-            BLOOD_CAKED_BLADE1                  = 49219,
-            BLOOD_CAKED_BLADE2                  = 49227,
-            BLOOD_CAKED_BLADE3                  = 49228,
-            DIRGE                               = 51206,//rank 2
-            UNHOLY_BLIGHT                       = 49194,
-            DESECRATION                         = 55667,//rank 2
-            CRYPT_FEVER                         = 49632,//rank 3
-            EBON_PLAGUEBRINGER                  = 51161,//rank 3
-            WANDERING_PLAGUE                    = 49655,//rank 3
-        //Special
-  /*Talent*/RUNIC_POWER_MASTERY                 = 50147,//rank 2
-            FROST_FEVER                         = 59921,
-            BLOOD_PLAGUE                        = 59879,
-        //Other
-            GLYPH_OF_CHAINS_OF_ICE              = 58620,//damage proc
-            CHAINS_OF_ICE_FROST_RUNE_REFRESH    = 62459,//5 runic power gain
-            GLYPH_OF_HEART_STRIKE               = 58616,//snare 50% for 10 sec
-            GLYPH_OF_RUNE_TAP                   = 59327,//10% heal for party
-            GLYPH_OF_HOWLING_BLAST              = 63335 //frost fever on targets
-        };
-        enum DeathKnightSpecial
-        {
-            FROST_FEVER_AURA                    = 55095,
-            BLOOD_PLAGUE_AURA                   = 55078,
-            CRYPT_FEVER_AURA                    = 50510,//rank 3
-            EBON_PLAGUE_AURA                    = 51735,//rank 3
-
-            RUNE_STRIKE_ACIVATION_AURA          = 56817,
-
-            IMPROVED_BLOOD_PRESENCE_AURA        = 63611,
-            BLOOD_PRESENCE_HEAL_EFFECT          = 50475,
-            BLADE_BARRIER_AURA                  = 64859,//rank 5
-            UNHOLY_BLIGHT_AURA                  = 50536,
-
-            ICY_TALONS_AURA1                    = 50882,//rank 1
-            ICY_TALONS_AURA2                    = 58575,//rank 2
-            ICY_TALONS_AURA3                    = 58576,//rank 3
-            ICY_TALONS_AURA4                    = 58577,//rank 4
-            ICY_TALONS_AURA5                    = 58578,//rank 5
-
-            DEATH_COIL_ENEMY                    = 47632,
-            ICY_CLUTCH                          = 50436 //rank 3 Chilblains proc
-        };
-        //enum RunePlacing
-        //{
-        //    RUNE_BLOOD_FIRST,
-        //    RUNE_BLOOD_SECOND,
-        //    RUNE_UNHOLY_FIRST,
-        //    RUNE_UNHOLY_SECOND,
-        //    RUNE_FROST_FIRST,
-        //    RUNE_FROST_SECOND,
-        //    NO_RUNE
-        //};
-    };
-};
-
-void AddSC_death_knight_bot()
-{
-    new death_knight_bot();
-}
diff --git a/src/server/game/AI/NpcBots/bot_druid_ai.cpp b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
deleted file mode 100644
index cdb0929..0000000
--- a/src/server/game/AI/NpcBots/bot_druid_ai.cpp
+++ /dev/null
@@ -1,1197 +0,0 @@
-#include "bot_ai.h"
-#include "Group.h"
-#include "Player.h"
-#include "ScriptMgr.h"
-#include "SpellAuras.h"
-#include "WorldSession.h"
-#include "SpellInfo.h"
-/*
-Druid NpcBot (reworked by Graff onlysuffering@gmail.com)
-Complete - Maybe 30%
-TODO: Feral Spells (from scratch), More Forms, Balance Spells + treants...
-*/
-class druid_bot : public CreatureScript
-{
-public:
-    druid_bot() : CreatureScript("druid_bot") { }
-
-    CreatureAI* GetAI(Creature* creature) const
-    {
-        return new bot_druid_ai(creature);
-    }
-
-    bool OnGossipHello(Player* player, Creature* creature)
-    {
-        return bot_minion_ai::OnGossipHello(player, creature);
-    }
-
-    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
-    {
-        if (bot_minion_ai* ai = creature->GetBotMinionAI())
-            return ai->OnGossipSelect(player, creature, sender, action);
-        return true;
-    }
-
-    struct bot_druid_ai : public bot_minion_ai
-    {
-        bot_druid_ai(Creature* creature) : bot_minion_ai(creature) { }
-
-        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
-        {
-            if (CheckBotCast(victim, spellId, CLASS_DRUID) != SPELL_CAST_OK)
-                return false;
-
-            m_botSpellInfo = sSpellMgr->GetSpellInfo(spellId);
-            if (me->GetShapeshiftForm() == FORM_NONE && swiftness && m_botSpellInfo->CalcCastTime() > 0)
-            {
-                DoCast(victim, spellId, true);
-                me->RemoveAurasDueToSpell(NATURES_SWIFTNESS_1, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
-                me->RemoveAurasDueToSpell(CRIT_50, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
-                swiftness = false;
-                return true;
-            }
-            if (spellId == GetSpell(BEAR_FORM_1) || GetSpell(spellId == CAT_FORM_1))
-            {
-                me->ModifyPower(POWER_MANA, - int32(m_botSpellInfo->CalcPowerCost(me, m_botSpellInfo->GetSchoolMask())));
-                mana = me->GetPower(POWER_MANA);
-                if (Unit* u = me->GetVictim())
-                    GetInPosition(true, u);
-            }
-
-            bool result = bot_ai::doCast(victim, spellId, triggered);
-
-            if (result &&
-                //spellId != GetSpell(BEAR_FORM_1) && spellId != GetSpell(spellId == CAT_FORM_1) &&
-                spellId != MANAPOTION && spellId != WARSTOMP_1 &&
-                me->HasAura(OMEN_OF_CLARITY_BUFF))
-            {
-                cost = m_botSpellInfo->CalcPowerCost(me, m_botSpellInfo->GetSchoolMask());
-                clearcast = true;
-                power = me->getPowerType();
-            }
-            return result;
-        }
-
-        void EnterCombat(Unit*) { }
-        void Aggro(Unit*) { }
-        void AttackStart(Unit*) { }
-        void KilledUnit(Unit*) { }
-        void EnterEvadeMode() { }
-        void MoveInLineOfSight(Unit*) { }
-        void JustDied(Unit* u) { removeFeralForm(true, false); bot_ai::JustDied(u); }
-
-
-        uint8 GetBotStance() const
-        {
-            switch (me->GetShapeshiftForm())
-            {
-                case FORM_BEAR:
-                case FORM_DIREBEAR:
-                    return DRUID_BEAR_FORM;
-                case FORM_CAT:
-                    return DRUID_CAT_FORM;
-            }
-
-            return CLASS_DRUID;
-        }
-
-        void warstomp(uint32 diff)
-        {
-            if (me->getRace() != RACE_TAUREN) return;
-            if (IsSpellReady(WARSTOMP_1, diff, false)) return;
-            if (me->GetShapeshiftForm() != FORM_NONE)
-                return;
-
-			Unit::AttackerSet b_attackers = me->getAttackers();
-
-            if (b_attackers.empty())
-            {
-                Unit* u = me->SelectNearestTarget(5);
-                if (u && u->IsInCombat() && u->isTargetableForAttack())
-                {
-                    if (doCast(me, WARSTOMP_1))
-                    {
-                        SetSpellCooldown(WARSTOMP_1, 30000); //30sec
-                        return;
-                    }
-                }
-            }
-			for (Unit::AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
-            {
-                if (!(*iter) || (*iter)->isDead()) continue;
-                if (!(*iter)->isTargetableForAttack()) continue;
-                if (me->GetDistance((*iter)) <= 5)
-                {
-                    if (doCast(me, WARSTOMP_1))
-                        SetSpellCooldown(WARSTOMP_1, 30000); //30sec
-                }
-            }
-        }
-
-        bool DamagePossible()
-        {
-            return true;
-            //return (GetManaPCT(me) < 30 || GetHealthPCT(master) < 50);
-            /*if (GetHealthPCT(master) < 75 || GetHealthPCT(me) < 75) return false;
-
-            if (Group* pGroup = master->GetGroup())
-            {
-                uint8 LHPcount = 0;
-                uint8 DIScount = 0;
-                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-                {
-                    Player* tPlayer = itr->GetSource();
-                    if (!tPlayer || tPlayer->isDead()) continue;
-                    if (me->GetExactDist(tPlayer) > 30) continue;
-                    if (tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth() < 75)
-                        ++LHPcount;
-                    Unit::AuraApplicationMap const& auras = tPlayer->GetAppliedAuras();
-                    for (Unit::AuraApplicationMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
-                        if (itr->second->GetBase()->GetSpellInfo()->Dispel == DISPEL_POISON)
-                            ++DIScount;
-                }
-                uint8 members = master->GetGroup()->GetMembersCount();
-
-                if (members > 10)
-                {
-                    if (LHPcount > 1 || DIScount > 2) return false;
-                }
-                if (members > 4)
-                {
-                    if (LHPcount > 0 || DIScount > 1) return false;
-                }
-                if (members < 5)
-                {
-                    if (LHPcount > 0 || DIScount > 0) return false;
-                }
-            }//endif unitlist
-
-            Unit* u = master->GetVictim();
-            if (master->getAttackers().size() > 4 ||
-              (!master->getAttackers().empty() &&
-                u != NULL && u->GetHealth() > me->GetMaxHealth()*17))
-                return false;
-
-            return true;*/
-        }
-
-        void removeFeralForm(bool force = false, bool init = true, uint32 diff = 0)
-        {
-            if (!force && formtimer > diff) return;
-            ShapeshiftForm form = me->GetShapeshiftForm();
-            if (form != FORM_NONE)
-            {
-                switch (form)
-                {
-                    case FORM_DIREBEAR:
-                    case FORM_BEAR:
-                        me->RemoveAurasDueToSpell(GetSpell(BEAR_FORM_1));
-                        break;
-                    case FORM_CAT:
-                        me->RemoveAurasDueToSpell(GetSpell(CAT_FORM_1));
-                        me->RemoveAurasDueToSpell(ENERGIZE);
-                        break;
-                    default:
-                        break;
-                }
-                setStats(CLASS_DRUID, init);
-            }
-        }
-
-        bool IsMelee() const
-        {
-            if (GetBotStance() == DRUID_BEAR_FORM || GetBotStance() == DRUID_CAT_FORM)
-                return true;
-
-            return bot_ai::IsMelee();
-        }
-
-        void StartAttack(Unit* u, bool force = false)
-        {
-            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
-            Aggro(u);
-            SetBotCommandState(COMMAND_ATTACK);
-            GetInPosition(force);
-        }
-
-        void doBearActions(uint32 diff)
-        {
-            if (me->getPowerType() != POWER_RAGE) return;
-
-            if (GetHealthPCT(me) < 75)
-                if (HealTarget(me, GetHealthPCT(me), diff))
-                    return;
-            opponent = me->GetVictim();
-            if (opponent)
-                StartAttack(opponent, true);
-            else
-                return;
-
-            //range check (melee) to prevent fake casts
-            if (me->GetDistance(opponent) > 5) return;
-
-            if (IsSpellReady(MANGLE_BEAR_1, diff) && HasRole(BOT_ROLE_DPS) && rage >= 150 && Rand() < 35 &&
-                doCast(opponent, GetSpell(MANGLE_BEAR_1)))
-            {
-                SetSpellCooldown(MANGLE_BEAR_1, 6000);
-                return;
-            }
-
-            if (IsSpellReady(SWIPE_1, diff) && HasRole(BOT_ROLE_DPS) && rage >= 150 && Rand() < 75 &&
-                doCast(opponent, GetSpell(SWIPE_1)))
-                return;
-
-        }//end doBearActions
-
-        void doCatActions(uint32 diff)
-        {
-            if (me->getPowerType() != POWER_ENERGY) return;
-
-            if (GetHealthPCT(me) < 75)
-                if (HealTarget(me, GetHealthPCT(me), diff))
-                    return;
-            opponent = me->GetVictim();
-            if (opponent)
-                StartAttack(opponent, true);
-            else
-                return;
-
-            uint32 energy = me->GetPower(POWER_ENERGY);
-
-            if (MoveBehind(*opponent))
-                wait = 5;
-
-            //range check (melee) to prevent fake casts
-            if (me->GetDistance(opponent) > 5) return;
-
-            if (IsSpellReady(MANGLE_CAT_1, diff) && energy > 45 && HasRole(BOT_ROLE_DPS) && Rand() < 35 &&
-                doCast(opponent, GetSpell(MANGLE_CAT_1)))
-            {
-                SetSpellCooldown(MANGLE_CAT_1, 6000);
-                return;
-            }
-            if (IsSpellReady(RAKE_1, diff) && energy > 40 && HasRole(BOT_ROLE_DPS) && Rand() < 30 &&
-                doCast(opponent, GetSpell(RAKE_1)))
-            {
-                SetSpellCooldown(RAKE_1, 10000);
-                return;
-            }
-            if (IsSpellReady(SHRED_1, diff) && energy > 60 && HasRole(BOT_ROLE_DPS) && !opponent->HasInArc(M_PI, me) && Rand() < 50 &&
-                doCast(opponent, GetSpell(SHRED_1)))
-            {
-                SetSpellCooldown(SHRED_1, 12000);
-                return;
-            }
-            if (IsSpellReady(RIP_1, diff) && energy > 30 && HasRole(BOT_ROLE_DPS) && Rand() < 30 &&
-                doCast(opponent, GetSpell(RIP_1)))
-            {
-                SetSpellCooldown(RIP_1, 15000);
-                return;
-            }
-            if (IsSpellReady(CLAW_1, diff) && energy > 45 && HasRole(BOT_ROLE_DPS) && Rand() < 80 &&
-                doCast(opponent, GetSpell(CLAW_1)))
-                return;
-        }//end doCatActions
-
-        void doBalanceActions(uint32 diff)
-        {
-            removeFeralForm(true, true);
-            opponent = me->GetVictim();
-            if (opponent)
-            {
-                if (!IsCasting())
-                    StartAttack(opponent);
-            }
-            else
-                return;
-
-			Unit::AttackerSet m_attackers = master->getAttackers();
-			Unit::AttackerSet b_attackers = me->getAttackers();
-
-            //range check to prevent fake casts
-            if (me->GetExactDist(opponent) > 30 || !DamagePossible()) return;
-
-            if (IsSpellReady(HURRICANE_1, diff) && !me->isMoving() && HasRole(BOT_ROLE_DPS) && Rand() < 35)
-            {
-                Unit* target = FindAOETarget(30, true);
-                if (target && doCast(target, GetSpell(HURRICANE_1)))
-                {
-                    SetSpellCooldown(HURRICANE_1, 5000);
-                    return;
-                }
-                SetSpellCooldown(HURRICANE_1, 2000); //fail
-            }
-            if (uint32 FAERIE_FIRE = GetSpell(FAERIE_FIRE_1))
-            {
-                if (GC_Timer <= diff &&
-                    opponent->getAttackers().size() > 1 &&//check if faerie fire is not useless 50/50
-                    Rand() < 20 && !HasAuraName(opponent, FAERIE_FIRE_1))
-                {
-                    if (doCast(opponent, FAERIE_FIRE))
-                        return;
-                }
-            }
-            if (IsSpellReady(MOONFIRE_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 20 &&
-                !HasAuraName(opponent, MOONFIRE_1, me->GetGUID()))
-            {
-                if (doCast(opponent, GetSpell(MOONFIRE_1)))
-                {
-                    SetSpellCooldown(MOONFIRE_1, 5000);
-                    return;
-                }
-            }
-            if (IsSpellReady(STARFIRE_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
-            {
-                if (doCast(opponent, GetSpell(STARFIRE_1)))
-                {
-                    SetSpellCooldown(STARFIRE_1, 11000);
-                    return;
-                }
-            }
-            if (IsSpellReady(WRATH_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 40)
-            {
-                if (doCast(opponent, GetSpell(WRATH_1)))
-                {
-                    SetSpellCooldown(WRATH_1, uint32(sSpellMgr->GetSpellInfo(GetSpell(WRATH_1))->CalcCastTime()/100 * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 1));
-                    return;
-                }
-            }
-        }
-
-        bool MassGroupHeal(Player* gPlayer, uint32 diff)
-        {
-            if (!gPlayer || GC_Timer > diff) return false;
-            if (IsCasting()) return false; // if I'm already casting
-            bool tranq = IsSpellReady(TRANQUILITY_1, diff, false);
-            bool growt = IsSpellReady(WILD_GROWTH_1, diff, false);
-            if (!tranq && !growt) return false;
-            if (Rand() > 30) return false;
-            Group* pGroup = gPlayer->GetGroup();
-            if (!pGroup) return false;
-            uint8 LHPcount = 0;
-            uint8 pct = 100;
-            Unit* healTarget = NULL;
-            for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-            {
-                Player* tPlayer = itr->GetSource();
-                if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->GetMapId() != me->GetMapId() ||
-                    (tPlayer->isDead() && !tPlayer->HaveBot())) continue;
-                if (me->GetExactDist(tPlayer) > 39) continue;
-                if (GetHealthPCT(tPlayer) < 80)
-                {
-                    if (GetHealthPCT(tPlayer) < pct)
-                    {
-                        pct = GetHealthPCT(tPlayer);
-                        healTarget = tPlayer;
-                    }
-                    ++LHPcount;
-                    if (LHPcount > 2) break;
-                }
-                if (tPlayer->HaveBot())
-                {
-                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
-                    {
-                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
-                        if (bot && bot->IsInWorld() && bot->GetExactDist(me) < 40 && GetHealthPCT(bot) < 80)
-                        {
-                            if (GetHealthPCT(bot) < pct)
-                            {
-                                pct = GetHealthPCT(bot);
-                                healTarget = bot;
-                            }
-                            ++LHPcount;
-                            if (LHPcount > 2) break;
-                        }
-                    }
-                }
-            }
-            if (LHPcount > 2 && tranq &&
-                doCast(me, GetSpell(TRANQUILITY_1)))
-            {
-                SetSpellCooldown(TRANQUILITY_1, 60000);
-                return true;
-            }
-            if (LHPcount > 0 && growt && healTarget &&
-                doCast(healTarget, GetSpell(WILD_GROWTH_1)))
-            {
-                SetSpellCooldown(WILD_GROWTH_1, 6000);
-                return true;
-            }
-            return false;
-        }//end MassGroupHeal
-
-        void UpdateAI(uint32 diff)
-        {
-            ReduceCD(diff);
-            if ((me->GetShapeshiftForm() == FORM_DIREBEAR || me->GetShapeshiftForm() == FORM_BEAR) &&
-                me->getPowerType() != POWER_RAGE)
-                me->setPowerType(POWER_RAGE);
-            if (me->GetShapeshiftForm() == FORM_CAT && me->getPowerType() != POWER_ENERGY)
-                me->setPowerType(POWER_ENERGY);
-            if (me->GetShapeshiftForm() == FORM_NONE && me->getPowerType() != POWER_MANA)
-                me->setPowerType(POWER_MANA);
-            if (IAmDead()) return;
-            CheckAttackState();
-
-            if (me->GetShapeshiftForm() == FORM_DIREBEAR || me->GetShapeshiftForm() == FORM_BEAR)
-            {
-                rage = me->GetPower(POWER_RAGE);
-                if (ragetimer2 <= diff)
-                {
-                    if (me->IsInCombat() && me->getLevel() >= 30)
-                    {
-                        if (rage < 990)
-                            me->SetPower(POWER_RAGE, rage + uint32(10.f*rageIncomeMult));//1 rage per 2 sec
-                        else
-                            me->SetPower(POWER_RAGE, 1000);
-                    }
-                    ragetimer2 = 2000;
-                }
-                if (ragetimer <= diff)
-                {
-                    if (!me->IsInCombat())
-                    {
-                        if (rage > 10.f*rageLossMult)
-                            me->SetPower(POWER_RAGE, rage - uint32(10.f*rageLossMult)); //-1 rage per 1.5 sec
-                        else
-                            me->SetPower(POWER_RAGE, 0);
-                    }
-                    ragetimer = 1500;
-                    if (rage > 1000) me->SetPower(POWER_RAGE, 1000);
-                    if (rage < 10) me->SetPower(POWER_RAGE, 0);
-                }
-            }
-            if (clearcast && me->HasAura(OMEN_OF_CLARITY_BUFF) && !me->IsNonMeleeSpellCast(false))
-            {
-                me->ModifyPower(power, cost);
-                me->RemoveAurasDueToSpell(OMEN_OF_CLARITY_BUFF,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
-                clearcast = false;
-            }
-            CheckAuras();
-            if (wait == 0)
-                wait = GetWait();
-            else
-                return;
-            BreakCC(diff);
-            if (CCed(me)) return;
-            warstomp(diff);
-
-            if (Potion_cd <= diff && me->getPowerType() == POWER_MANA && GetManaPCT(me) < 20)
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, MANAPOTION))
-                {
-                    Potion_cd = POTION_CD;
-                    GC_Timer = temptimer;
-                }
-            }
-
-            //Heal master
-            if (GetHealthPCT(master) < 85)
-                HealTarget(master, GetHealthPCT(master), diff);
-            //Innervate
-            doInnervate(diff);
-
-            MassGroupHeal(master, diff);
-            if (!me->IsInCombat())
-                DoNonCombatActions(diff);
-            else
-                CheckBattleRez(diff);
-            BuffAndHealGroup(master, diff);
-            //CureTarget(master, GetSpell(CURE_POISON_1), diff);
-            CureGroup(master, GetSpell(CURE_POISON_1), diff);
-
-            if (!CheckAttackTarget(CLASS_DRUID))
-                return;
-
-            //debug
-            opponent = me->GetVictim();
-
-            if (GetHealthPCT(me) < 75)
-            {
-                HealTarget(me, GetHealthPCT(me), diff);
-                return;
-            }
-
-            if (IsCasting()) return; //Casting heal or something
-            CheckRoots(diff);
-
-            if (DamagePossible() && opponent != NULL)
-            {
-                Unit* u = opponent->GetVictim();
-                //if the target is attacking us, we want to go bear
-                if (GetSpell(BEAR_FORM_1) && !CCed(opponent) &&
-                    ((u == me || (IsTank() && IsInBotParty(u))) ||
-                    (!me->getAttackers().empty() && (*me->getAttackers().begin()) == opponent && opponent->GetMaxHealth() > me->GetMaxHealth()*2)))
-                {
-                    //if we don't have bear yet
-                    if (me->GetShapeshiftForm() != FORM_DIREBEAR &&
-                        me->GetShapeshiftForm() != FORM_BEAR &&
-                        formtimer <= diff &&
-                        doCast(me, GetSpell(BEAR_FORM_1)))
-                    {
-                        setStats(DRUID_BEAR_FORM);
-                        formtimer = 1500;
-                    }
-                    if (me->GetShapeshiftForm() == FORM_DIREBEAR ||
-                        me->GetShapeshiftForm() == FORM_BEAR)
-                        doBearActions(diff);
-                }
-                else
-                if (GetSpell(CAT_FORM_1) && master->GetVictim() != opponent && u &&
-                    IsTank(u) && u != me &&
-                    opponent->GetMaxHealth() < u->GetMaxHealth()*3)
-                {
-                    //if we don't have cat yet
-                    if (me->GetShapeshiftForm() != FORM_CAT && formtimer <= diff)
-                    {
-                        if (doCast(me, GetSpell(CAT_FORM_1)))
-                        {
-                            setStats(DRUID_CAT_FORM);
-                            formtimer = 1500;
-                        }
-                    }
-                    if (me->GetShapeshiftForm() == FORM_CAT)
-                        doCatActions(diff);
-                }
-                else if (!IsTank())
-                    doBalanceActions(diff);
-            }
-            else if (!IsTank())
-                doBalanceActions(diff);
-        }
-
-        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
-        {
-            if (!HasRole(BOT_ROLE_HEAL)) return false;
-            if (hp > 95) return false;
-            if (!target || target->isDead()) return false;
-            if (IsTank() && hp > 35) return false;
-            if (hp > 50 && me->GetShapeshiftForm() != FORM_NONE) return false; //do not waste heal if in feral or so
-            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid() - 50*me->GetShapeshiftForm()) return false;
-            if (me->GetExactDist(target) > 40) return false;
-
-            if (IsSpellReady(NATURES_SWIFTNESS_1, diff, false) &&
-                (hp < 15 || (hp < 35 && target->getAttackers().size() > 2)) &&
-                (target->IsInCombat() || !target->getAttackers().empty()))
-            {
-                if (me->IsNonMeleeSpellCast(false))
-                    me->InterruptNonMeleeSpells(false);
-                if (doCast(me, GetSpell(NATURES_SWIFTNESS_1)) && RefreshAura(CRIT_50, 2))
-                {
-                    swiftness = true;
-                    SetSpellCooldown(NATURES_SWIFTNESS_1, 120000); //2 min
-                    if (doCast(target, GetSpell(HEALING_TOUCH_1), true))
-                        Heal_Timer = 3000;
-                    return true;
-                }
-            }
-            if (IsSpellReady(SWIFTMEND_1, diff, false, 3000) &&
-                (hp < 25 || GetLostHP(target) > 5000) &&
-                (HasAuraName(target, REGROWTH_1) || HasAuraName(target, REJUVENATION_1)))
-            {
-                if (doCast(target, GetSpell(SWIFTMEND_1)))
-                {
-                    SetSpellCooldown(SWIFTMEND_1, 10000);
-                    if (GetHealthPCT(target) > 75)
-                        return true;
-                    else if (!target->getAttackers().empty())
-                    {
-                        if (doCast(target, GetSpell(REGROWTH_1)))
-                        {
-                            GC_Timer = 300;
-                            return true;
-                        }
-                    }
-                }
-            }
-            if (hp > 35 && (hp < 75 || GetLostHP(target) > 3000) && Heal_Timer <= diff && GetSpell(NOURISH_1))
-            {
-                switch (urand(1,3))
-                {
-                    case 1:
-                    case 2:
-                        if (doCast(target, GetSpell(NOURISH_1)))
-                        {
-                            Heal_Timer = 3000;
-                            return true;
-                        }
-                        break;
-                    case 3:
-                        if (doCast(target, GetSpell(HEALING_TOUCH_1)))
-                        {
-                            Heal_Timer = 3000;
-                            return true;
-                        }
-                        break;
-                }
-            }
-            //maintain HoTs
-            Unit* u = target->GetVictim();
-            Creature* boss = u && u->ToCreature() && u->ToCreature()->isWorldBoss() ? u->ToCreature() : NULL;
-            bool tanking = IsTank(target) && boss;
-            bool regrowth = IsSpellReady(REGROWTH_1, diff);
-            if ( ( (hp < 80 || GetLostHP(target) > 3500 || tanking) &&
-                regrowth && !HasAuraName(target, REGROWTH_1, me->GetGUID()) )
-                ||
-                (HasAuraName(target, REGROWTH_1, me->GetGUID()) && HasAuraName(target, REJUVENATION_1, me->GetGUID()) &&
-                (hp < 70 || GetLostHP(target) > 3000) && regrowth))
-            {
-                if (doCast(target, GetSpell(REGROWTH_1)))
-                {
-                    SetSpellCooldown(REGROWTH_1, 2000);
-                    return true;
-                }
-            }
-            if (GetSpell(REJUVENATION_1) && GC_Timer <= diff && hp > 25 &&
-                (hp < 90 || GetLostHP(target) > 2000 || tanking) &&
-                !HasAuraName(target, REJUVENATION_1, me->GetGUID()))
-            {
-                if (doCast(target, GetSpell(REJUVENATION_1)))
-                {
-                    if (!target->getAttackers().empty() && (hp < 75 || GetLostHP(target) > 4000))
-                        if (IsSpellReady(SWIFTMEND_1, diff, false) && doCast(target, GetSpell(SWIFTMEND_1)))
-                            SetSpellCooldown(SWIFTMEND_1, 10000);
-                    GC_Timer = 500;
-                    return true;
-                }
-            }
-            if (IsSpellReady(LIFEBLOOM_1, diff) &&
-                ((hp < 85 && hp > 40) || (hp > 70 && tanking) ||
-                (hp < 70 && hp > 25 && HasAuraName(target, REGROWTH_1) && HasAuraName(target, REJUVENATION_1)) ||
-                (GetLostHP(target) > 1500 && hp > 35)))
-            {
-                Aura* bloom = target->GetAura(GetSpell(LIFEBLOOM_1), me->GetGUID());
-                if ((!bloom || bloom->GetStackAmount() < 3) && doCast(target, GetSpell(LIFEBLOOM_1)))
-                    return true;
-            }
-            if (hp > 30 && (hp < 70 || GetLostHP(target) > 3000) && Heal_Timer <= diff &&
-                doCast(target, GetSpell(HEALING_TOUCH_1)))
-            {
-                Heal_Timer = 3000;
-                return true;
-            }
-            return false;
-        }
-
-        bool BuffTarget(Unit* target, uint32 diff)
-        {
-            if (GC_Timer > diff || Rand() > 20) return false;
-            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
-            if (target && target->IsAlive() && me->GetExactDist(target) < 30)
-            {
-                if (uint32 MARK_OF_THE_WILD = GetSpell(MARK_OF_THE_WILD_1))
-                    if (!HasAuraName(target, MARK_OF_THE_WILD_1))
-                        if (doCast(target, MARK_OF_THE_WILD))
-                            return true;
-                if (uint32 THORNS = GetSpell(THORNS_1))
-                    if (!HasAuraName(target, THORNS_1))
-                        if (doCast(target, THORNS))
-                            return true;
-            }
-            return false;
-        }
-
-        void DoNonCombatActions(uint32 diff)
-        {
-            if (GC_Timer > diff || IsCasting() || me->IsMounted()) return;
-
-            RezGroup(GetSpell(REVIVE_1), master);
-
-            //if (Feasting()) return;
-
-            //if (BuffTarget(master, diff))
-            //{
-            //    /*GC_Timer = 800;*/
-            //    return;
-            //}
-            //if (BuffTarget(me, diff))
-            //{
-            //    /*GC_Timer = 800;*/
-            //    return;
-            //}
-        }
-
-        void doInnervate(uint32 diff, uint8 minmanaval = 30)
-        {
-            if (!IsSpellReady(INNERVATE_1, diff) || Rand() > 15)
-                return;
-            if (me->GetShapeshiftForm() != FORM_NONE && (IsTank() || me->getAttackers().size() > 3))
-                return;
-
-            uint32 INNERVATE = GetSpell(INNERVATE_1);
-            Unit* iTarget = NULL;
-
-            if (master->IsInCombat() && master->getPowerType() == POWER_MANA &&
-                GetManaPCT(master) < 20 && !master->HasAura(INNERVATE))
-                iTarget = master;
-            else if (me->IsInCombat() && me->getPowerType() == POWER_MANA &&
-                GetManaPCT(me) < 20 && !me->HasAura(INNERVATE))
-                iTarget = me;
-
-            Group* group = master->GetGroup();
-            if (!iTarget && !group) //first check master's bots
-            {
-                for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
-                {
-                    Creature* bot = master->GetBotMap(i)->_Cre();
-                    if (!bot || !bot->IsInCombat() || bot->isDead()) continue;
-                    if (me->GetExactDist(bot) > 30) continue;
-                    if (bot->getPowerType() != POWER_MANA) continue;
-                    if (GetManaPCT(bot) < minmanaval && !bot->HasAura(INNERVATE))
-                    {
-                        iTarget = bot;
-                        break;
-                    }
-                }
-            }
-            if (!iTarget && group) //cycle through player members...
-            {
-                for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
-                {
-                    Player* tPlayer = itr->GetSource();
-                    if (tPlayer == NULL || !tPlayer->IsInWorld() || !tPlayer->IsInCombat() || tPlayer->isDead()) continue;
-                    if (me->GetExactDist(tPlayer) > 30) continue;
-                    if (tPlayer->getPowerType() != POWER_MANA) continue;
-                    if (GetManaPCT(tPlayer) < minmanaval && !tPlayer->HasAura(INNERVATE))
-                    {
-                        iTarget = tPlayer;
-                        break;
-                    }
-                    if (iTarget)
-                        break;
-                }
-            }
-            if (!iTarget && group) //... and their bots.
-            {
-                for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
-                {
-                    Player* tPlayer = itr->GetSource();
-                    if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
-                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
-                    {
-                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
-                        if (!bot || bot->isDead()) continue;
-                        if (me->GetExactDist(bot) > 30) continue;
-                        if (bot->getPowerType() != POWER_MANA) continue;
-                        if (GetManaPCT(bot) < minmanaval && !bot->HasAura(INNERVATE))
-                        {
-                            iTarget = bot;
-                            break;
-                        }
-                    }
-                    if (iTarget)
-                        break;
-                }
-            }
-
-            //fail
-            if (!iTarget)
-            {
-                SetSpellCooldown(INNERVATE_1, 3000);
-                return;
-            }
-
-            if (doCast(iTarget, INNERVATE))
-            {
-                if (iTarget->GetTypeId() == TYPEID_PLAYER)
-                    me->MonsterWhisper("Innervate on You!", iTarget->ToPlayer());
-                else
-                {
-                    std::ostringstream msg;
-                    msg << "Innervate on " << (iTarget == me ? "myself" : iTarget->GetName()) << '!';
-                    me->MonsterWhisper(msg.str().c_str(), master);
-                }
-
-                SetSpellCooldown(INNERVATE_1, iTarget->GetTypeId() == TYPEID_PLAYER ? 60000 : 20000); //1 min if player and 20 sec if bot
-            }
-        }
-
-        void CheckRoots(uint32 diff)
-        {
-            if (GC_Timer > diff || Rand() > 35) return;
-            if (me->GetShapeshiftForm() != FORM_NONE) return;
-            uint32 ENTANGLING_ROOTS = GetSpell(ENTANGLING_ROOTS_1);
-            if (!ENTANGLING_ROOTS) return;
-            if (FindAffectedTarget(ENTANGLING_ROOTS, me->GetGUID(), 60)) return;
-            if (Unit* target = FindRootTarget(30, ENTANGLING_ROOTS))
-                if (doCast(target, ENTANGLING_ROOTS))
-                    return;
-        }
-
-        void CheckBattleRez(uint32 diff)
-        {
-            if (!IsSpellReady(REBIRTH_1, diff, false) || me->IsMounted() || IsCasting() || Rand() > 10) return;
-
-            Group* gr = master->GetGroup();
-            if (!gr)
-            {
-                Unit* target = master;
-                if (master->IsAlive()) return;
-                if (master->isResurrectRequested()) return; //ressurected
-                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
-                    target = (Unit*)master->GetCorpse();
-                if (!target || !target->IsInWorld())
-                    return;
-                if (me->GetExactDist(target) > 30)
-                {
-                    me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
-                    SetSpellCooldown(REBIRTH_1, 1500);
-                    return;
-                }
-                else if (!target->IsWithinLOSInMap(me))
-                    me->Relocate(*target);
-
-                if (doCast(target, GetSpell(REBIRTH_1))) //rezzing
-                {
-                    me->MonsterWhisper("Rezzing You", master);
-                    SetSpellCooldown(REBIRTH_1, me->getLevel() >= 60 ? 300000 : 600000); //5-10 min (improved possible)
-                }
-                return;
-            }
-            for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
-            {
-                Player* tPlayer = itr->GetSource();
-                Unit* target = tPlayer;
-                if (!tPlayer || tPlayer->IsAlive()) continue;
-                if (tPlayer->isResurrectRequested()) continue; //ressurected
-                if (tPlayer->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
-                    target = (Unit*)tPlayer->GetCorpse();
-                if (!target || !target->IsInWorld()) continue;
-                if (master->GetMap() != target->FindMap()) continue;
-                if (me->GetExactDist(target) > 30)
-                {
-                    me->GetMotionMaster()->MovePoint(target->GetMapId(), *target);
-                    SetSpellCooldown(REBIRTH_1, 1500);
-                    return;
-                }
-                else if (!target->IsWithinLOSInMap(me))
-                    me->Relocate(*target);
-
-                if (doCast(target, GetSpell(REBIRTH_1))) //rezzing
-                {
-                    me->MonsterWhisper("Rezzing You", tPlayer);
-                    SetSpellCooldown(REBIRTH_1, me->getLevel() >= 60 ? 300000 : 600000); //5-10 min (improved possible)
-                    return;
-                }
-            }
-        }
-
-        void setStats(uint8 form, bool init = true)
-        {
-            switch (form)
-            {
-                case DRUID_BEAR_FORM:
-                    me->SetBotClass(DRUID_BEAR_FORM);
-                    if (me->getPowerType() != POWER_RAGE)
-                    {
-                        me->setPowerType(POWER_RAGE);
-                        me->SetMaxPower(POWER_RAGE, 1000);
-                    }
-                    if (me->getLevel() >= 15)
-                        me->SetPower(POWER_RAGE, 200);
-                    else
-                        me->SetPower(POWER_RAGE, 0);
-                    if (me->getLevel() >= 40 && !me->HasAura(LEADER_OF_THE_PACK))
-                        RefreshAura(LEADER_OF_THE_PACK);
-                    break;
-                case DRUID_CAT_FORM:
-                    me->SetBotClass(DRUID_CAT_FORM);
-                    if (me->getPowerType() != POWER_ENERGY)
-                    {
-                        me->setPowerType(POWER_ENERGY);
-                        me->SetMaxPower(POWER_ENERGY, 100);
-                        me->SetPower(POWER_ENERGY, 0);
-                    }
-                    if (me->getLevel() >= 15)
-                        me->SetPower(POWER_ENERGY, 60);
-                    else
-                        me->SetPower(POWER_ENERGY, 0);
-                    if (me->getLevel() >= 40 && !me->HasAura(LEADER_OF_THE_PACK))
-                        RefreshAura(LEADER_OF_THE_PACK);
-                    RefreshAura(ENERGIZE, me->getLevel()/40 + master->Has310Flyer(false));
-                    break;
-                case CLASS_DRUID:
-                    me->SetBotClass(CLASS_DRUID);
-                    if (me->getPowerType() != POWER_MANA)
-                        me->setPowerType(POWER_MANA);
-                    if (init)
-                        me->SetPower(POWER_MANA, mana);
-                    break;
-            }
-
-            SetStats(false);
-        }
-
-        void SpellHit(Unit* caster, SpellInfo const* spell)
-        {
-            OnSpellHit(caster, spell);
-        }
-
-        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
-        {
-            if (victim == me)
-                return;
-
-            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
-            {
-                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
-                {
-                    if (_ctc[i].first && !_ctc[i].second)
-                    {
-                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
-                            _ctc[i].second = 1000;
-
-                        if (_ctc[i].second > 0)
-                            me->CastSpell(victim, _ctc[i].first, true);
-                    }
-                }
-            }
-        }
-
-		void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType, SpellSchoolMask)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void OwnerAttackedBy(Unit* u)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void Reset()
-        {
-            Heal_Timer = 0;
-            formtimer = 0;
-
-            clearcast = false;
-            swiftness = false;
-
-            power = POWER_MANA;
-
-            mana = 0;
-            rage = 0;
-
-            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
-            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
-
-            ragetimer = 0;
-            ragetimer2 = 0;
-
-            if (master)
-            {
-                SetStats(true);
-                InitRoles();
-                ApplyPassives(CLASS_DRUID);
-            }
-        }
-
-        void ReduceCD(uint32 diff)
-        {
-            CommonTimers(diff);
-            SpellTimers(diff);
-            if (Heal_Timer > diff)                  Heal_Timer -= diff;
-            if (formtimer > diff)                   formtimer -= diff;
-            if (ragetimer > diff)                   ragetimer -= diff;
-            if (ragetimer2 > diff)                  ragetimer2 -= diff;
-        }
-
-        bool CanRespawn()
-        {return false;}
-
-        void InitSpells()
-        {
-            uint8 lvl = me->getLevel();
-
-            InitSpellMap(WARSTOMP_1, true);
-
-            InitSpellMap(MARK_OF_THE_WILD_1);
-            InitSpellMap(THORNS_1);
-            InitSpellMap(HEALING_TOUCH_1);
-            InitSpellMap(REGROWTH_1);
-            InitSpellMap(REJUVENATION_1);
-            InitSpellMap(LIFEBLOOM_1);
-            InitSpellMap(NOURISH_1);
-     /*tal*/lvl >= 60 ? InitSpellMap(WILD_GROWTH_1) : RemoveSpell(WILD_GROWTH_1);
-     /*tal*/lvl >= 40 ? InitSpellMap(SWIFTMEND_1) : RemoveSpell(SWIFTMEND_1);
-            InitSpellMap(TRANQUILITY_1);
-            InitSpellMap(REVIVE_1);
-            InitSpellMap(REBIRTH_1);
-            InitSpellMap(BEAR_FORM_1);
-            InitSpellMap(SWIPE_1);
-     /*tal*/lvl >= 50 ? InitSpellMap(MANGLE_BEAR_1) : RemoveSpell(MANGLE_BEAR_1);
-            InitSpellMap(BASH_1);
-            InitSpellMap(CAT_FORM_1);
-            InitSpellMap(CLAW_1);
-            InitSpellMap(RAKE_1);
-            InitSpellMap(SHRED_1);
-            InitSpellMap(RIP_1);
-     /*tal*/lvl >= 50 ? InitSpellMap(MANGLE_CAT_1) : RemoveSpell(MANGLE_CAT_1);
-            InitSpellMap(MOONFIRE_1);
-            InitSpellMap(STARFIRE_1);
-            InitSpellMap(WRATH_1);
-            InitSpellMap(HURRICANE_1);
-            InitSpellMap(FAERIE_FIRE_1);
-            InitSpellMap(CURE_POISON_1);
-            InitSpellMap(INNERVATE_1);
-            InitSpellMap(ENTANGLING_ROOTS_1);
-     /*tal*/lvl >= 30 ? InitSpellMap(NATURES_SWIFTNESS_1) : RemoveSpell(NATURES_SWIFTNESS_1);
-        }
-
-        void ApplyClassPassives()
-        {
-            uint8 level = master->getLevel();
-            if (level >= 78)
-                RefreshAura(SPELLDMG2, 3); //+18%
-            else if (level >= 65)
-                RefreshAura(SPELLDMG2, 2); //+12%
-            else if (level >= 50)
-                RefreshAura(SPELLDMG2); //+6%
-            if (level >= 45)
-                RefreshAura(NATURAL_PERFECTION3); //4%
-            else if (level >= 43)
-                RefreshAura(NATURAL_PERFECTION2); //3%
-            else if (level >= 41)
-                RefreshAura(NATURAL_PERFECTION1); //2%
-            if (level >= 50)
-                RefreshAura(LIVING_SEED3); //100%
-            else if (level >= 48)
-                RefreshAura(LIVING_SEED2); //66%
-            else if (level >= 46)
-                RefreshAura(LIVING_SEED1); //33%
-            if (level >= 55)
-                RefreshAura(REVITALIZE3, 5); //75% (15%)x5
-            else if (level >= 53)
-                RefreshAura(REVITALIZE2, 3); //30% (10%)x3
-            else if (level >= 51)
-                RefreshAura(REVITALIZE1, 3); //15%  (5%)x3
-            if (level >= 70)
-                RefreshAura(OMEN_OF_CLARITY, 3); //x3
-            else if (level >= 40)
-                RefreshAura(OMEN_OF_CLARITY, 2); //x2
-            else if (level >= 20)
-                RefreshAura(OMEN_OF_CLARITY); //x1
-            if (level >= 45)
-                RefreshAura(GLYPH_SWIFTMEND); //no comsumption
-            if (level >= 40)
-                RefreshAura(GLYPH_INNERVATE); //no comsumption
-            if (level >= 20)
-                RefreshAura(NATURESGRACE);
-            if (level >= 78)
-            {
-                RefreshAura(T9_RESTO_P4_BONUS);
-                RefreshAura(T8_RESTO_P4_BONUS);
-                RefreshAura(T9_BALANCE_P2_BONUS);
-                RefreshAura(T10_BALANCE_P2_BONUS);
-                RefreshAura(T10_BALANCE_P4_BONUS);
-            }
-        }
-
-        bool CanUseManually(uint32 basespell) const
-        {
-            switch (basespell)
-            {
-                case MARK_OF_THE_WILD_1:
-                case THORNS_1:
-                case HEALING_TOUCH_1:
-                case REJUVENATION_1:
-                case LIFEBLOOM_1:
-                case REGROWTH_1:
-                case NOURISH_1:
-                case WILD_GROWTH_1:
-                case SWIFTMEND_1:
-                case TRANQUILITY_1:
-                case CURE_POISON_1:
-                case INNERVATE_1:
-                    return true;
-                default:
-                    return false;
-            }
-        }
-
-    private:
-        //Timers/other
-/*Heal*/uint32 Heal_Timer;
-/*Misc*/uint32 formtimer, ragetimer, ragetimer2;
-/*Chck*/bool clearcast, swiftness;
-/*Misc*/Powers power; uint32 mana, rage;
-/*Misc*/float rageIncomeMult, rageLossMult;
-
-        enum DruidBaseSpells
-        {
-            MARK_OF_THE_WILD_1                  = 1126,
-            THORNS_1                            = 467,
-            HEALING_TOUCH_1                     = 5185,
-            REGROWTH_1                          = 8936,
-            REJUVENATION_1                      = 774,
-            LIFEBLOOM_1                         = 33763,
-            NOURISH_1                           = 50464,
-     /*tal*/WILD_GROWTH_1                       = 48438,
-     /*tal*/SWIFTMEND_1                         = 18562,
-            TRANQUILITY_1                       = 740,
-            REVIVE_1                            = 50769,
-            REBIRTH_1                           = 20484,
-            BEAR_FORM_1                         = 5487,
-            SWIPE_1                             = 779,
-     /*tal*/MANGLE_BEAR_1                       = 33878,
-            BASH_1                              = 5211,
-            CAT_FORM_1                          = 768,
-            CLAW_1                              = 1082,
-            RAKE_1                              = 1822,
-            SHRED_1                             = 5221,
-            RIP_1                               = 1079,
-     /*tal*/MANGLE_CAT_1                        = 33876,
-            MOONFIRE_1                          = 8921,
-            STARFIRE_1                          = 2912,
-            WRATH_1                             = 5176,
-            HURRICANE_1                         = 16914,
-            FAERIE_FIRE_1                       = 770,
-            CURE_POISON_1                       = 8946,
-            INNERVATE_1                         = 29166,
-            ENTANGLING_ROOTS_1                  = 339,
-     /*tal*/NATURES_SWIFTNESS_1                 = 17116,
-            WARSTOMP_1                          = 20549
-        };
-        enum DruidPassives
-        {
-        //Talents
-            OMEN_OF_CLARITY                     = 16864,//clearcast
-            NATURESGRACE                        = 61346,//haste 20% for 3 sec
-            NATURAL_PERFECTION1                 = 33881,
-            NATURAL_PERFECTION2                 = 33882,
-            NATURAL_PERFECTION3                 = 33883,
-            LIVING_SEED1                        = 48496,//rank 1
-            LIVING_SEED2                        = 48499,//rank 2
-            LIVING_SEED3                        = 48500,//rank 3
-            REVITALIZE1                         = 48539,//rank 1
-            REVITALIZE2                         = 48544,//rank 2
-            REVITALIZE3                         = 48545,//rank 3
-  /*Talent*/LEADER_OF_THE_PACK                  = 24932,
-        //Glyphs
-            GLYPH_SWIFTMEND                     = 54824,//no consumption
-            GLYPH_INNERVATE                     = 54832,//self regen
-        //other
-            T9_RESTO_P4_BONUS                   = 67128,//rejuve crits
-            T8_RESTO_P4_BONUS                   = 64760,//rejuve init heal
-            T9_BALANCE_P2_BONUS                 = 67125,//moonfire crits
-            T10_BALANCE_P2_BONUS                = 70718,//omen of doom (15%)
-            T10_BALANCE_P4_BONUS                = 70723,//Languish(DOT)
-            SPELLDMG/*Arcane Instability-mage*/ = 15060,//rank3 3% dam/crit
-            SPELLDMG2/*Earth and Moon - druid*/ = 48511,//rank3 6% dam
-            ENERGIZE                            = 27787,//Rogue Armor Energize (chance: +35 energy on hit)
-            CRIT_50                             = 23434 //50% spell crit
-        };
-        enum DruidSpecial
-        {
-            HURRICANE_DAMAGE                    = 42231,
-  /*Talent*/LEADER_OF_THE_PACK_BUFF             = 24932,
-            //NATURESGRACEBUFF                    = 16886,
-            OMEN_OF_CLARITY_BUFF                = 16870 //434 deprecated
-        };
-    };
-};
-
-void AddSC_druid_bot()
-{
-    new druid_bot();
-}
diff --git a/src/server/game/AI/NpcBots/bot_hunter_ai.cpp b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
deleted file mode 100644
index 0848dc5..0000000
--- a/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
+++ /dev/null
@@ -1,1168 +0,0 @@
-#include "bot_ai.h"
-#include "Player.h"
-#include "ScriptMgr.h"
-#include "Spell.h"
-#include "SpellAuras.h"
-#include "SpellInfo.h"
-/*
-Hunter NpcBot (reworked by Graff onlysuffering@gmail.com)
-Complete - around 35%
-TODO:
-*/
-class hunter_bot : public CreatureScript
-{
-public:
-    hunter_bot() : CreatureScript("hunter_bot") { }
-
-    CreatureAI* GetAI(Creature* creature) const
-    {
-        return new hunter_botAI(creature);
-    }
-
-    bool OnGossipHello(Player* player, Creature* creature)
-    {
-        return bot_minion_ai::OnGossipHello(player, creature);
-    }
-
-    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
-    {
-        if (bot_minion_ai* ai = creature->GetBotMinionAI())
-            return ai->OnGossipSelect(player, creature, sender, action);
-        return true;
-    }
-
-    struct hunter_botAI : public bot_minion_ai
-    {
-        hunter_botAI(Creature* creature) : bot_minion_ai(creature)
-        {
-            Reset();
-        }
-
-        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
-        {
-            if (CheckBotCast(victim, spellId, CLASS_HUNTER) != SPELL_CAST_OK)
-                return false;
-
-            return bot_ai::doCast(victim, spellId, triggered);
-        }
-
-        void StartAttack(Unit* u, bool force = false)
-        {
-            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
-            Aggro(u);
-            SetBotCommandState(COMMAND_ATTACK);
-            GetInPosition(force);
-        }
-
-        void EnterCombat(Unit*) { }
-        void Aggro(Unit*) { }
-        void AttackStart(Unit*) { }
-        void KilledUnit(Unit*) { }
-        void EnterEvadeMode() { }
-        void MoveInLineOfSight(Unit*) { }
-        void JustDied(Unit* u) { bot_ai::JustDied(u); }
-        void DoNonCombatActions(uint32 /*diff*/) { }
-
-        void Counter(uint32 diff)
-        {
-            if (IsCasting() || Rand() > 35)
-                return;
-
-            Unit* target = NULL;
-
-            if (IsSpellReady(SCATTER_SHOT_1, diff, false, 10000) && HasRole(BOT_ROLE_DPS) && Rand() < 40)
-            {
-                target = FindCastingTarget(15, 0, false, GetSpell(SCATTER_SHOT_1));
-                temptimer = GC_Timer;
-                if (target && doCast(target, GetSpell(SCATTER_SHOT_1)))
-                {
-                    SetSpellCooldown(SCATTER_SHOT_1, 20000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-            if (!target && IsSpellReady(WYVERN_STING_1, diff, true, 10000) && HasRole(BOT_ROLE_DPS) && Rand() < 70)
-            {
-                target = FindCastingTarget(35, 5, false, GetSpell(WYVERN_STING_1));
-                if (target && doCast(target, GetSpell(WYVERN_STING_1)))
-                {
-                    SetSpellCooldown(WYVERN_STING_1, 40000);
-                    return;
-                }
-            }
-            //if (!target && FREEZING_ARROW && Trap_cd <= 10000 && Rand() < 40)
-            //{
-            //    target = FindCastingTarget(40, 0, false, FREEZING_ARROW);
-            //    temptimer = GC_Timer;
-            //    if (target && doCast(target, FREEZING_ARROW))
-            //    {
-            //        Trap_cd = 20000;
-            //        GC_Timer = temptimer;
-            //        return;
-            //    }
-            //}
-            if (!target && IsSpellReady(SCARE_BEAST_1, diff, true, 7500) && Rand() < 35)
-            {
-                target = FindCastingTarget(30, 0, false, GetSpell(SCARE_BEAST_1));
-                if (target && doCast(target, GetSpell(SCARE_BEAST_1)))
-                {
-                    SetSpellCooldown(SCARE_BEAST_1, 15000);
-                    GC_Timer = 800;
-                    return;
-                }
-            }
-            if (!target && IsSpellReady(SILENCING_SHOT_1, diff, false, 7500) && Rand() < 30)
-            {
-                target = FindCastingTarget(35, 5, false, GetSpell(SILENCING_SHOT_1));
-                temptimer = GC_Timer;
-                if (target && doCast(target, GetSpell(SILENCING_SHOT_1)))
-                {
-                    SetSpellCooldown(SILENCING_SHOT_1, 15000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-        }
-
-        void CheckScatter(uint32 diff)
-        {
-            if (!IsSpellReady(SCATTER_SHOT_1, diff, false) || !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 50)
-                return;
-
-            if (Unit* target = FindStunTarget(15))
-            {
-                temptimer = GC_Timer;
-                if (doCast(target, GetSpell(SCATTER_SHOT_1)))
-                {
-                    SetSpellCooldown(SCATTER_SHOT_1, 20000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-
-            SetSpellCooldown(SCATTER_SHOT_1, 1000); //fail
-        }
-
-        void CheckWyvernSting(uint32 diff)
-        {
-            if (!IsSpellReady(WYVERN_STING_1, diff, false) || !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 50)
-                return;
-
-            if (Unit* target = FindStunTarget(35))
-            {
-                temptimer = GC_Timer;
-                if (doCast(target, GetSpell(WYVERN_STING_1)))
-                {
-                    SetSpellCooldown(WYVERN_STING_1, 40000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-
-            SetSpellCooldown(WYVERN_STING_1, 1000); //fail
-        }
-
-        void CheckFreezingArrow(uint32 diff)
-        {
-            //Freezing Trap shares cooldown with traps
-            if (!GetSpell(FREEZING_ARROW_1) || Trap_cd > diff || IsCasting() || Rand() > 75)
-                return;
-
-            if (Unit* target = FindStunTarget(40))
-            {
-                temptimer = GC_Timer;
-                if (doCast(target, GetSpell(FREEZING_ARROW_1)))
-                {
-                    GC_Timer = temptimer;
-                    Trap_cd = 20000;
-                    return;
-                }
-            }
-
-            Trap_cd = 1000; //fail
-        }
-
-        void CheckTraps(uint32 diff)
-        {
-            if (!GetSpell(FROST_TRAP_1) || Trap_cd > diff || IsCasting() || Rand() > 90)
-                return;
-
-            Unit* target = me->GetVictim();
-            if (!(target && me->GetDistance(target) < 6 && me->HasInArc(M_PI, target) &&
-                IsInBotParty(target->GetVictim())))
-                target = NULL;
-            if (!target)
-                target = FindAOETarget(3.f, true);
-
-            if (target)
-            {
-                temptimer = GC_Timer;
-                if (doCast(target, GetSpell(FROST_TRAP_1)))
-                {
-                    GC_Timer = temptimer;
-                    Trap_cd = 20000;
-                    return;
-                }
-            }
-
-            Trap_cd = 500; //fail
-        }
-
-        void CheckScare(uint32 diff)
-        {
-            if (!IsSpellReady(SCARE_BEAST_1, diff) || IsCasting() || Rand() > 35)
-                return;
-
-            if (Unit* scareTarget = FindFearTarget())
-            {
-                if (doCast(scareTarget, GetSpell(SCARE_BEAST_1), true))
-                {
-                    SetSpellCooldown(SCARE_BEAST_1, 15000); //-50% for bot
-                    GC_Timer = 800;
-                    return;
-                }
-            }
-
-            SetSpellCooldown(SCARE_BEAST_1, 1500); //fail
-        }
-
-        void CheckAspects(uint32 diff)
-        {
-            if (Aspect_Timer > diff || GC_Timer > diff || IsCasting() || Feasting() || Rand() > 35)
-                return;
-
-            uint32 ASPECT_OF_THE_VIPER = GetSpell(ASPECT_OF_THE_VIPER_1);
-            uint32 ASPECT_OF_THE_PACK = GetSpell(ASPECT_OF_THE_PACK_1);
-            if (!ASPECT_OF_THE_VIPER && !ASPECT_OF_THE_PACK)
-                return;
-
-            uint32 needaspect = 0;
-            uint8 pct = GetManaPCT(me);
-
-            if (ASPECT_OF_THE_VIPER && pct < 25)
-                needaspect = ASPECT_OF_THE_VIPER;
-            else if (ASPECT_OF_THE_PACK && (pct > 70 || !Aspect))
-                needaspect = ASPECT_OF_THE_PACK;
-
-            if (!needaspect || (needaspect == Aspect && HasAuraName(me, needaspect)))
-            {
-                Aspect_Timer = 2000;
-                return;
-            }
-
-            if (Aspect)
-                me->RemoveAurasDueToSpell(Aspect);
-
-            if (doCast(me, needaspect))
-            {
-                Aspect = needaspect;
-                GC_Timer = 800;
-                return;
-            }
-        }
-
-        void doDefend(uint32 diff)
-        {
-            //No GCD abilities
-            if (!IsSpellReady(FEIGN_DEATH_1, diff, false) && !IsSpellReady(DETERRENCE_1, diff, false))
-                return;
-            if (IsTank() || Rand() > 35)
-                return;
-
-            Unit::AttackerSet b_attackers = me->getAttackers();
-            bool cast = false;
-
-            if (b_attackers.size() == 1)
-            {
-                if (Creature* cre = (*b_attackers.begin())->ToCreature())
-                {
-                    if (cre->isWorldBoss() || cre->IsDungeonBoss() || cre->GetMaxHealth() > me->GetMaxHealth() * 10)
-                    {
-                        cast = true;
-                        //need feign death
-                        SetSpellCooldown(DETERRENCE_1, std::max<uint32>(GetSpellCooldown(DETERRENCE_1), diff + 500));
-                    }
-                }
-            }
-            else
-                cast = (uint8(b_attackers.size()) > (GetHealthPCT(me) > 20 ? 1 : 0));
-
-            if (!cast || b_attackers.empty())
-            {
-                //delay next try
-                SetSpellCooldown(FEIGN_DEATH_1, std::max<uint32>(GetSpellCooldown(FEIGN_DEATH_1), 1000));
-                SetSpellCooldown(DETERRENCE_1, std::max<uint32>(GetSpellCooldown(DETERRENCE_1), 1000));
-                return;
-            }
-
-            if (IsSpellReady(FEIGN_DEATH_1, diff, false) && (*b_attackers.begin())->getAttackers().size() > 1)
-            {
-                if (me->IsNonMeleeSpellCast(false))
-                    me->InterruptNonMeleeSpells(false);
-
-                temptimer = GC_Timer;
-                if (doCast(me, GetSpell(FEIGN_DEATH_1)))
-                {
-                    SetSpellCooldown(FEIGN_DEATH_1, 20000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-
-            if (IsSpellReady(DETERRENCE_1, diff, false))
-            {
-                if (me->IsNonMeleeSpellCast(false))
-                    me->InterruptNonMeleeSpells(false);
-
-                temptimer = GC_Timer;
-                if (doCast(me, GetSpell(DETERRENCE_1)))
-                {
-                    SetSpellCooldown(DETERRENCE_1, 60000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-        }
-
-        void CheckAutoShot()
-        {
-            //Auto Shot is always present
-            //if (!AUTO_SHOT)
-            //    return;
-
-            Unit* target = me->GetVictim();
-            if (!target)
-                return;
-
-            if (!HasRole(BOT_ROLE_DPS))
-                return;
-
-            if (IsCasting())
-                return;
-
-            if (Spell* shot = me->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL))
-            {
-                if (shot->GetSpellInfo()->Id != AUTO_SHOT_1)
-                {
-                    ////casting some other autorepeat spell, wtf?
-                    //////TC_LOG_ERROR("entities.player", "CheckAutoShot(): Bot %s is casting autorepeatable spell %u (%s) during check!",
-                    //    me->GetName().c_str(), shot->GetSpellInfo()->Id, shot->GetSpellInfo()->SpellName[0]);
-                    return;
-                }
-                else if (shot->m_targets.GetUnitTarget() != target)
-                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
-            }
-
-            float dist = me->GetExactDist(target);
-            if (dist < 5 || dist > 35)
-                return;
-
-            temptimer = GC_Timer;
-            if (doCast(target, AUTO_SHOT_1))
-            {
-                GC_Timer = temptimer;
-                return;
-            }
-        }
-
-        void CheckTranquil(uint32 diff)
-        {
-            if (!IsSpellReady(TRANQ_SHOT_1, diff, false) || Rand() > 35) //No GCD
-                return;
-
-            //First check current target
-            Unit* target = me->GetVictim();
-            if (target)
-            {
-                Unit::AuraMap const &auras = target->GetOwnedAuras();
-                for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
-                {
-                    SpellInfo const* spellInfo = itr->second->GetSpellInfo();
-                    if (spellInfo->Dispel != DISPEL_MAGIC && spellInfo->Dispel != DISPEL_ENRAGE) continue;
-                    if (spellInfo->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
-                    AuraApplication const* aurApp = itr->second->GetApplicationOfTarget(target->GetGUID());
-                    if (aurApp && aurApp->IsPositive())
-                    {
-                        temptimer = GC_Timer;
-                        //me->InterruptNonMeleeSpells(true, AUTO_SHOT);
-                        if (doCast(target, GetSpell(TRANQ_SHOT_1)))
-                        {
-                            SetSpellCooldown(TRANQ_SHOT_1, 6000); //with glyph
-                            GC_Timer = temptimer;
-                            return;
-                        }
-                    }
-                }
-            }
-
-            target = FindTranquilTarget();
-            if (target)
-            {
-                temptimer = GC_Timer;
-                //me->InterruptNonMeleeSpells(true, AUTO_SHOT);
-                if (doCast(target, GetSpell(TRANQ_SHOT_1)))
-                {
-                    SetSpellCooldown(TRANQ_SHOT_1, 6000); //with glyph
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-
-            SetSpellCooldown(TRANQ_SHOT_1, 2000); //fail
-        }
-
-        void CheckSilence(uint32 diff)
-        {
-            if (!IsSpellReady(SILENCING_SHOT_1, diff, false) || IsCasting() || Rand() > 50) //No GCD
-                return;
-
-            Unit* target = me->GetVictim();
-            if (target && target->IsNonMeleeSpellCast(false))
-            {
-                temptimer = GC_Timer;
-                if (doCast(target, GetSpell(SILENCING_SHOT_1)))
-                {
-                    SetSpellCooldown(SILENCING_SHOT_1, 15000); //-5 sec for bot
-                    GC_Timer = temptimer;
-                    //return;
-                }
-
-                return; //succeed or failed, our hightest priority target casts spell and it must be interrupted above all else
-            }
-
-            target = FindCastingTarget(35, 5);
-            if (target)
-            {
-                temptimer = GC_Timer;
-                if (doCast(target, GetSpell(SILENCING_SHOT_1)))
-                {
-                    SetSpellCooldown(SILENCING_SHOT_1, 15000); //-5 sec for bot
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-
-            SetSpellCooldown(SILENCING_SHOT_1, 1000); //fail
-        }
-
-        void UpdateAI(uint32 diff)
-        {
-            ReduceCD(diff);
-            if (IAmDead()) return;
-            CheckAttackState();
-            CheckAuras();
-            if (wait == 0)
-                wait = GetWait();
-            else
-                return;
-            BreakCC(diff);
-            if (CCed(me)) return;
-
-            if (GetHealthPCT(me) < 67 && Potion_cd <= diff)
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, HEALINGPOTION))
-                {
-                    Potion_cd = POTION_CD;
-                    GC_Timer = temptimer;
-                }
-            }
-
-            if (GetManaPCT(me) < 40 && Potion_cd <= diff)
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, MANAPOTION))
-                {
-                    Potion_cd = POTION_CD;
-                    GC_Timer = temptimer;
-                }
-            }
-
-            //Deterrence check
-            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
-            {
-                if (!me->isMoving())
-                    GetInPosition(true);
-                return;
-            }
-
-            if (!me->IsInCombat())
-                DoNonCombatActions(diff);
-            else
-                doDefend(diff);
-
-            CheckAspects(diff);
-
-            if (master->IsInCombat() || me->IsInCombat())
-            {
-                CheckTranquil(diff);
-                CheckSilence(diff);
-            }
-
-            if (!CheckAttackTarget(CLASS_HUNTER))
-            {
-                me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
-                return;
-            }
-
-            DoRangedAttack(diff);
-        }
-
-        void DoRangedAttack(uint32 diff)
-        {
-            opponent = me->GetVictim();
-            if (opponent)
-            {
-                if (!IsCasting())
-                    StartAttack(opponent, true);
-            }
-            else
-                return;
-
-            Counter(diff);
-
-            CheckAutoShot();
-            CheckScare(diff);
-            CheckScatter(diff);
-
-            //AttackerSet m_attackers = master->getAttackers();
-            //AttackerSet b_attackers = me->getAttackers();
-            //float dist = me->GetExactDist(opponent);
-            float meleedist = me->GetDistance(opponent);
-
-            //special
-            if (IsSpellReady(SCATTER_SHOT_1, diff, false) && HasRole(BOT_ROLE_DPS) && meleedist < 15 && Rand() < 60)
-            {
-                temptimer = GC_Timer;
-                if (doCast(opponent, GetSpell(SCATTER_SHOT_1)))
-                {
-                    SetSpellCooldown(SCATTER_SHOT_1, 20000);
-                    GC_Timer = temptimer;
-                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
-                    me->AttackStop();
-                    return;
-                }
-            }
-
-            //MELEE SECTION
-            if (!(meleedist > 5))
-            {
-                //TRAPS
-                CheckTraps(diff);
-
-                //RAPTOR STRIKE
-                if (IsSpellReady(RAPTOR_STRIKE_1, diff, false) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
-                {
-                    temptimer = GC_Timer;
-                    if (doCast(opponent, GetSpell(RAPTOR_STRIKE_1), true))
-                    {
-                        SetSpellCooldown(RAPTOR_STRIKE_1, 6000);
-                        GC_Timer = temptimer;
-                        return;
-                    }
-                }
-                //WING CLIP
-                if (IsSpellReady(WING_CLIP_1, diff) && (!IsTank() || opponent->isMoving()) &&
-                    Rand() < 80 && !opponent->HasAuraWithMechanic(/*(1<<MECHANIC_SNARE)|*/(1<<MECHANIC_ROOT)))
-                {
-                    if (doCast(opponent, GetSpell(WING_CLIP_1)))
-                    {
-                        GC_Timer = 1000;
-                        return;
-                    }
-                }
-                //DISENGAGE
-                if (IsSpellReady(DISENGAGE_1, diff, false) && me->IsInCombat() && !IsTank() &&
-                    !me->getAttackers().empty() && me->HasInArc(M_PI, *me->getAttackers().begin()) && Rand() < 30)
-                {
-                    temptimer = GC_Timer;
-                    if (doCast(me, GetSpell(DISENGAGE_1)))
-                    {
-                        SetSpellCooldown(DISENGAGE_1, 16000); //improved, with glyph
-                        GC_Timer = temptimer;
-                    }
-                }
-
-                return; //don't try to do anything else in melee
-            }
-
-            //RANGED SECTION
-
-            //HUNTERS MARK
-            if (IsSpellReady(HUNTERS_MARK_1, diff, false) && Rand() < 25 &&
-                !HasAuraName(opponent, HUNTERS_MARK_1)) //100 yd range so don't check it
-            {
-                //Hunter's Mark has exclusive GCD
-                temptimer = GC_Timer;
-                if (doCast(opponent, GetSpell(HUNTERS_MARK_1)))
-                {
-                    markTarget = opponent;
-                    SetSpellCooldown(HUNTERS_MARK_1, 2000); //1500 + 500 for bot
-                    GC_Timer = temptimer;
-                    //return;
-                }
-            }
-
-            //FREEZING ARROW
-            CheckFreezingArrow(diff);
-            CheckWyvernSting(diff);
-
-            //attack range check 1
-            if (!(meleedist < 45))
-                return;
-
-            //KILL SHOT //No GCD
-            if (IsSpellReady(KILL_SHOT_1, diff, false) && HasRole(BOT_ROLE_DPS) && GetHealthPCT(opponent) < 20 && Rand() < 95)
-            {
-                temptimer = GC_Timer;
-                if (doCast(opponent, GetSpell(KILL_SHOT_1)))
-                {
-                    SetSpellCooldown(KILL_SHOT_1, 8000); //with glyph
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-
-            //attack range check 2
-            if (!(meleedist < 35))
-                return;
-
-            //CONCUSSIVE SHOT
-            if (IsSpellReady(CONCUSSIVE_SHOT_1, diff) && Rand() < 80)
-            {
-                if (doCast(opponent, GetSpell(CONCUSSIVE_SHOT_1)))
-                {
-                    SetSpellCooldown(CONCUSSIVE_SHOT_1, 10000); //improved
-                    GC_Timer = 800;
-                    return;
-                }
-            }
-            //DISTRACTING SHOT
-            if (Unit* u = opponent->GetVictim())
-            {
-                if (IsSpellReady(DISTRACTING_SHOT_1, diff, false) && IsTank() && u != me && !CCed(opponent) &&
-                    Rand() < 75 && IsInBotParty(u))
-                {
-                    temptimer = GC_Timer;
-                    if (doCast(opponent, GetSpell(DISTRACTING_SHOT_1)))
-                    {
-                        SetSpellCooldown(DISTRACTING_SHOT_1, 8000);
-                        GC_Timer = temptimer;
-                    }
-                }
-            }
-            //BLACK ARROW //custom cd condition
-            //Black Arrow shares cooldown with traps, but we'll have it only partially
-            if (IsSpellReady(BLACK_ARROW_1, diff) && Trap_cd <= 10000 && HasRole(BOT_ROLE_DPS) &&
-                opponent->GetHealth() > me->GetMaxHealth()/3 && Rand() < 75)
-            {
-                if (doCast(opponent, GetSpell(BLACK_ARROW_1)))
-                {
-                    Trap_cd = 20000;
-                    return;
-                }
-            }
-            //RAPID FIRE
-            if (IsSpellReady(RAPID_FIRE_1, diff, false) && HasRole(BOT_ROLE_DPS) &&
-                opponent->GetHealth() > me->GetMaxHealth() / 2 && Rand() < 25)
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, GetSpell(RAPID_FIRE_1)))
-                {
-                    SetSpellCooldown(RAPID_FIRE_1, 90000); //1.5 min for bot
-                    GC_Timer = temptimer;
-                }
-            }
-            //EXPLOSIVE SHOT
-            if (IsSpellReady(EXPLOSIVE_SHOT_1, diff) && HasRole(BOT_ROLE_DPS))
-            {
-                if (doCast(opponent, GetSpell(EXPLOSIVE_SHOT_1)))
-                {
-                    SetSpellCooldown(EXPLOSIVE_SHOT_1, 6000);
-                    return;
-                }
-
-                SetSpellCooldown(EXPLOSIVE_SHOT_1, 500); //fail
-            }
-            //SCORPID STING //custom cd condition
-            if (uint32 SCORPID_STING = GetSpell(SCORPID_STING_1))
-            {
-                if (GC_Timer <= diff && (ScorpidSting_Timer <= diff || stingTargetGuid != opponent->GetGUID()))
-                {
-                    Aura* sSting = opponent->GetAura(SCORPID_STING);
-                    if (sSting && sSting->GetDuration() > 3000)
-                    {
-                        stingTargetGuid = opponent->GetGUID();
-                        SetSpellCooldown(SCORPID_STING_1, 2000);
-                    }
-                    else if (Rand() < 40 && doCast(opponent, SCORPID_STING))
-                    {
-                        stingTargetGuid = opponent->GetGUID();
-                        SetSpellCooldown(SCORPID_STING_1, 18000);
-                        GC_Timer = 800;
-                        return;
-                    }
-                }
-            }
-            //CHIMERA SHOT TODO:
-            if (IsSpellReady(CHIMERA_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) && stingTargetGuid == opponent->GetGUID() &&
-                !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) && Rand() < 30)
-            {
-                if (doCast(opponent, GetSpell(CHIMERA_SHOT_1)))
-                {
-                    SetSpellCooldown(CHIMERA_SHOT_1, 9000); //with glyph
-                    return;
-                }
-            }
-            //MULTI-SHOT
-            if (IsSpellReady(MULTISHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 60)
-            {
-                if (Unit* target = FindSplashTarget(35, opponent))
-                {
-                    if (doCast(target, GetSpell(MULTISHOT_1)))
-                    {
-                        SetSpellCooldown(MULTISHOT_1, 8000); //with glyph
-                        GC_Timer = 800;
-                        return;
-                    }
-                }
-
-                SetSpellCooldown(MULTISHOT_1, 1000); //fail
-            }
-            //VOLLEY
-            if (IsSpellReady(VOLLEY_1, diff) && HasRole(BOT_ROLE_DPS) && !me->isMoving() && Rand() < 25)
-            {
-                if (Unit* target = FindAOETarget(35, true, false))
-                {
-                    if (doCast(target, GetSpell(VOLLEY_1)))
-                    {
-                        SetSpellCooldown(VOLLEY_1, 5000);
-                        return;
-                    }
-                }
-
-                SetSpellCooldown(VOLLEY_1, 1000); //fail
-            }
-            //AIMED SHOT
-            if (IsSpellReady(AIMED_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 80)
-            {
-                if (doCast(opponent, GetSpell(AIMED_SHOT_1)))
-                {
-                    SetSpellCooldown(AIMED_SHOT_1, 8000); //with glyph
-                    return;
-                }
-            }
-            //ARCANE SHOT
-            if (IsSpellReady(ARCANE_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
-            {
-                if (doCast(opponent, GetSpell(ARCANE_SHOT_1)))
-                {
-                    SetSpellCooldown(ARCANE_SHOT_1, 6000);
-                    return;
-                }
-            }
-        }
-
-        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
-        {
-            uint32 spellId = spellInfo->Id;
-            uint8 lvl = me->getLevel();
-            float fdamage = float(damage);
-            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
-            if (!crit)
-            {
-                float aftercrit = 0.f;
-
-                //Glyph of TrueShot Aura (req lvl 40): 10% additional critical chance for Aimed Shot
-                if (lvl >= 40 && spellId == GetSpell(AIMED_SHOT_1))
-                    aftercrit += 10.f;
-                //Improved Barrage: 12% additional critical chance for Multi-Shot and Aimed Shot
-                if (lvl >= 40 && (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(MULTISHOT_1)))
-                    aftercrit += 12.f;
-                //Survival Instincts: 4% additional critical chance for Arcane Shot, Steady Shot and Explosive Shot
-                if (lvl >= 15 && (spellId == GetSpell(ARCANE_SHOT_1)/* || spellId == GetSpell(STEADY_SHOT_1)*/ || spellId == GetSpell(EXPLOSIVE_SHOT_1)))
-                    aftercrit += 4.f;
-                //Sniper Training (part 1): 15% additional critical chance for Kill Shot
-                if (lvl >= 50 && spellId == GetSpell(KILL_SHOT_1))
-                    aftercrit += 15.f;
-                //Point of No Escape: 6% additional critical chance on victims of any kind of frost trap (crew this condition)
-                if (lvl >= 50)
-                    aftercrit += 6.f;
-
-                //Savage Strikes: 20% additional critical chance for Raptor Strike, Mongoose Bite and Counterattack
-                if (lvl >= 10 && (spellId == GetSpell(RAPTOR_STRIKE_1)/* || spellId == GetSpell(MONGOOSE_BITE_1) || spellId == GetSpell(COUNTERATTACK_1)*/))
-
-                //second roll (may be illogical)
-                if (aftercrit > 0.f)
-                    crit = roll_chance_f(aftercrit);
-            }
-
-            //2) apply bonus damage mods
-            float pctbonus = 0.0f;
-            if (crit)
-            {
-                //!!!Melee spell damage is not yet critical, all reduced by half
-                //Mortal Shots: 30% crit damage bonus for all ranged abilities
-                if (lvl >= 15 && attackType == RANGED_ATTACK)
-                    pctbonus += 0.15f;
-                //Marked for Death (part 2): 10% crit damage bonus for Aimed Shot, Arcane Shot, Steady Shot, Kill Shot and Chimera Shot
-                if (lvl >= 55 &&
-                    (spellId == GetSpell(AIMED_SHOT_1) ||
-                    spellId == GetSpell(ARCANE_SHOT_1) ||
-                    //spellId == GetSpell(STEADY_SHOT_1) ||
-                    spellId == GetSpell(KILL_SHOT_1) ||
-                    spellId == GetSpell(CHIMERA_SHOT_1)))
-                    pctbonus += 0.05f;
-            }
-
-            //Ranged Weapon Specialization: 5% bonus damage for ranged attacks
-            if (lvl >= 35 && attackType == RANGED_ATTACK)
-                pctbonus += 0.05f;
-            //Improved Arcane Shot: 15% bonus damage for Arcane Shot
-            if (lvl >= 20 && spellId == GetSpell(ARCANE_SHOT_1))
-                pctbonus += 0.15f;
-            //Rapid Killing (buff): 20% bonus damage for Aimed Shot, Arcane Shot or Chimera Shot (removed in SpellHitTarget())
-            if (lvl >= 20 && (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(ARCANE_SHOT_1) || spellId == GetSpell(CHIMERA_SHOT_1)) &&
-                me->HasAura(RAPID_KILLING_BUFF))
-                pctbonus += 0.2f;
-            //Barrage: 12% bonus damage for Aimed Shot, Multi-Shot or Volley (removed in SpellHitTarget())
-            if (lvl >= 30 && (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(MULTISHOT_1) ||
-                spellInfo->IsRankOf(sSpellMgr->GetSpellInfo(VOLLEY_DAMAGE_1))))
-                pctbonus += 0.12f;
-            //Marked for Death (part 1): 5% bonus damage for all ranged shots on marked target
-            if (lvl >= 55 && attackType == RANGED_ATTACK && damageinfo.target == markTarget)
-                pctbonus += 0.05f;
-            //T.N.T: 6% bonus damage for Explosive Shot (handled here) and Black Arrow (can be handler in ApplyClassDamageMultiplierEffect())
-            if (lvl >= 25 && spellId == GetSpell(EXPLOSIVE_SHOT_1))
-                pctbonus += 0.06f;
-            //Sniper Training (part 2): 6% bonus damage for Steady Shot, Aimed Shot, Black Arrow and Explosive Shot (screw aura stuff, just increase)
-            if (lvl >= 50 &&
-                (spellId == GetSpell(AIMED_SHOT_1) ||
-                //spellId == GetSpell(STEADY_SHOT_1) ||
-                //spellId == GetSpell(BLACK_ARROW_1) ||//cannot be handled here
-                spellId == GetSpell(EXPLOSIVE_SHOT_1)))
-
-            damage = int32(fdamage * (1.0f + pctbonus));
-
-            //Thrill of the Hunt additive (stage 1): store mana restore value (50%) while ability crits
-            if (lvl >= 40)
-                (static_cast<ManaRestoreList>(TotH))[spellId] = crit && attackType == RANGED_ATTACK ? spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()) / 2 : 0;
-        }
-
-        void SpellHitTarget(Unit* target, SpellInfo const* spell)
-        {
-            if (target == me)
-                return;
-
-            uint32 spellId = spell->Id;
-
-            //Thrill of the Hunt additive (stage 1): store mana restore value while ability crits
-            if (me->getLevel() >= 40 && TotH[spellId] > 0 && uint32(TotH[spellId]) < me->GetMaxPower(POWER_MANA))
-            {
-                me->EnergizeBySpell(me, THRILL_OF_THE_HUNT_EFFECT, TotH[spellId], POWER_MANA);
-                TotH[spellId] = 0;
-            }
-
-            if (spellId == GetSpell(WING_CLIP_1))
-            {
-                //zzzOLD Improved Wing Clip (only on creatures): 30% to root target with Wing Clip
-                //normal creatures are rooted for 10 sec, elites+ for 6 sec
-                if (target->GetTypeId() == TYPEID_UNIT)
-                {
-                    if (urand(1,100) <= 30)
-                    {
-                        uint32 clip = target->ToCreature()->GetCreatureTemplate()->rank == CREATURE_ELITE_NORMAL ? IMPROVED_WING_CLIP_NORMAL : IMPROVED_WING_CLIP_EX;
-                        me->CastSpell(target, clip, true);
-                    }
-                }
-            }
-            if (spellId == GetSpell(CONCUSSIVE_SHOT_1))
-            {
-                //Improved Concussion Shot rank 2: 2 sec increased daze duration
-                if (Aura* concus = target->GetAura(spellId, me->GetGUID()))
-                {
-                    int32 dur = concus->GetDuration() + 2000;
-                    concus->SetDuration(dur);
-                    concus->SetMaxDuration(dur);
-                }
-
-                //zzzOLD Improved Concussion Shot: chance to stun target for 3 sec
-                if (urand(1,100) <= 15)
-                {
-                    me->CastSpell(target, IMPROVED_CONCUSSION, true);
-                }
-            }
-
-            //Rapid Killing: use up buff manually
-            if (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(ARCANE_SHOT_1) || spellId == GetSpell(CHIMERA_SHOT_1))
-            {
-                if (me->HasAura(RAPID_KILLING_BUFF))
-                    me->RemoveAura(RAPID_KILLING_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
-            }
-        }
-
-        void SpellHit(Unit* caster, SpellInfo const* spell)
-        {
-            uint32 spellId = spell->Id;
-
-            if (spellId == GetSpell(RAPID_FIRE_1))
-            {
-                //Rapid Fire (id 28755): 4 sec increased duration
-                if (Aura* rapid = me->GetAura(spellId))
-                {
-                    uint32 dur = rapid->GetDuration() + 4000;
-                    rapid->SetDuration(dur);
-                    rapid->SetMaxDuration(dur);
-                }
-            }
-
-            OnSpellHit(caster, spell);
-        }
-
-        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
-        {
-            if (victim == me)
-                return;
-
-            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
-            {
-                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
-                {
-                    if (_ctc[i].first && !_ctc[i].second)
-                    {
-                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
-                            _ctc[i].second = 1000;
-
-                        if (_ctc[i].second > 0)
-                            me->CastSpell(victim, _ctc[i].first, true);
-                    }
-                }
-            }
-        }
-
-		void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType, SpellSchoolMask)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void OwnerAttackedBy(Unit* u)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void Reset()
-        {
-            Trap_cd = 0;
-
-            ScorpidSting_Timer = 0;
-            Aspect_Timer = 0;
-
-            Aspect = 0;
-
-            stingTargetGuid = 0;
-
-            markTarget = NULL;
-
-            if (master)
-            {
-                SetStats(true);
-                InitRoles();
-                ApplyPassives(CLASS_HUNTER);
-             }
-        }
-
-        void ReduceCD(uint32 diff)
-        {
-            CommonTimers(diff);
-            SpellTimers(diff);
-
-            if (Trap_cd > diff)                     Trap_cd -= diff;
-
-            if (ScorpidSting_Timer > diff)          ScorpidSting_Timer -= diff;
-            if (Aspect_Timer > diff)                Aspect_Timer -= diff;
-        }
-
-        bool CanRespawn()
-        {return false;}
-
-        void InitSpells()
-        {
-            uint8 lvl = me->getLevel();
-            InitSpellMap(AUTO_SHOT_1, true);
-            InitSpellMap(TRANQ_SHOT_1);
-  /*Talent*/lvl >= 50 ? InitSpellMap(SILENCING_SHOT_1) : RemoveSpell(SILENCING_SHOT_1);
-  /*Talent*/lvl >= 60 ? InitSpellMap(CHIMERA_SHOT_1) : RemoveSpell(CHIMERA_SHOT_1);
-            InitSpellMap(ARCANE_SHOT_1);
-  /*Talent*/lvl >= 20 ? InitSpellMap(AIMED_SHOT_1) : RemoveSpell(AIMED_SHOT_1);
-            InitSpellMap(KILL_SHOT_1);
-  /*Talent*/lvl >= 60 ? InitSpellMap(EXPLOSIVE_SHOT_1) : RemoveSpell(EXPLOSIVE_SHOT_1);
-            InitSpellMap(MULTISHOT_1);
-            InitSpellMap(VOLLEY_1);
-  /*Talent*/lvl >= 20 ? InitSpellMap(SCATTER_SHOT_1) : RemoveSpell(SCATTER_SHOT_1);
-            InitSpellMap(CONCUSSIVE_SHOT_1);
-            InitSpellMap(DISTRACTING_SHOT_1);
-            InitSpellMap(SCORPID_STING_1);
-            //InitSpellMap(VIPER_STING_1);
-            InitSpellMap(RAPID_FIRE_1);
-            InitSpellMap(WING_CLIP_1);
-            InitSpellMap(RAPTOR_STRIKE_1);
-            InitSpellMap(DISENGAGE_1);
-            InitSpellMap(FROST_TRAP_1);
-            InitSpellMap(FREEZING_ARROW_1);
-  /*Talent*/lvl >= 40 ? InitSpellMap(WYVERN_STING_1) : RemoveSpell(WYVERN_STING_1);
-  /*Talent*/lvl >= 50 ? InitSpellMap(BLACK_ARROW_1) : RemoveSpell(BLACK_ARROW_1);
-            InitSpellMap(HUNTERS_MARK_1);
-            InitSpellMap(SCARE_BEAST_1);
-            InitSpellMap(FEIGN_DEATH_1);
-            InitSpellMap(DETERRENCE_1);
-            //InitSpellMap(ASPECT_OF_THE_VIPER_1);
-  /*Custom*///ASPECT_OF_THE_PACK                      = ASPECT_OF_THE_VIPER ? ASPECT_OF_THE_PACK_1 : 0;
-  /*Custom*/lvl >= 20 ? InitSpellMap(ASPECT_OF_THE_PACK_1, true) : RemoveSpell(ASPECT_OF_THE_PACK_1);
-            //InitSpellMap(ASPECT_OF_THE_DRAGONHAWK_1);
-        }
-
-        void ApplyClassPassives()
-        {
-            uint8 level = master->getLevel();
-            if (level >= 20)
-                RefreshAura(RAPID_KILLING); //20%
-            if (level >= 30)
-                RefreshAura(CONCUSSIVE_BARRAGE); //100%
-            if (level >= 40)
-                RefreshAura(PIERCING_SHOTS); //30%
-            if (level >= 40)
-                RefreshAura(TRUESHOT_AURA); //10%
-            if (level >= 45)
-                RefreshAura(RAPID_RECUPERATION); //4%
-            if (level >= 45)
-                RefreshAura(MASTER_MARKSMAN); //5%
-            if (level >= 70)
-                RefreshAura(WILD_QUIVER,3); //36%
-            else if (level >= 60)
-                RefreshAura(WILD_QUIVER,2); //24%
-            else if (level >= 50)
-                RefreshAura(WILD_QUIVER); //12%
-            if (level >= 15)
-                RefreshAura(SUREFOOTED); //30%
-            if (level >= 15)
-                RefreshAura(ENTRAPMENT); //4 sec
-            if (level >= 67)
-                RefreshAura(MASTER_TACTICIAN5,3); //30%
-            else if (level >= 58)
-                RefreshAura(MASTER_TACTICIAN5,2); //20%
-            else if (level >= 50)
-                RefreshAura(MASTER_TACTICIAN5); //10%
-            else if (level >= 49)
-                RefreshAura(MASTER_TACTICIAN4); //8%
-            else if (level >= 48)
-                RefreshAura(MASTER_TACTICIAN3); //6%
-            else if (level >= 47)
-                RefreshAura(MASTER_TACTICIAN2); //4%
-            else if (level >= 46)
-                RefreshAura(MASTER_TACTICIAN1); //2%
-            if (level >= 45)
-                RefreshAura(NOXIOUS_STINGS); //50%
-            if (level >= 55)
-                RefreshAura(HUNTING_PARTY); //100%
-        }
-
-        bool CanUseManually(uint32 basespell) const
-        {
-            switch (basespell)
-            {
-                case RAPID_FIRE_1:
-                case FROST_TRAP_1:
-                case ASPECT_OF_THE_PACK_1:
-                case ASPECT_OF_THE_VIPER_1:
-                    return true;
-                default:
-                    return false;
-            }
-        }
-
-    private:
-        typedef std::unordered_map<uint32 /*spellId*/, int32 /*manaCost*/> ManaRestoreList;
-        ManaRestoreList TotH;
-        uint32 Trap_cd;
-        uint32 ScorpidSting_Timer, Aspect_Timer;
-        uint32 Aspect;
-        uint64 stingTargetGuid;
-        Unit* markTarget;
-
-        enum HunterBaseSpells
-        {
-            AUTO_SHOT_1                         = 75,
-            TRANQ_SHOT_1                        = 19801,
-            SILENCING_SHOT_1                    = 34490,
-            CHIMERA_SHOT_1                      = 53209,
-            ARCANE_SHOT_1                       = 3044,
-            AIMED_SHOT_1                        = 19434,
-            KILL_SHOT_1                         = 53351,
-            EXPLOSIVE_SHOT_1                    = 53301,
-            MULTISHOT_1                         = 2643,
-            VOLLEY_1                            = 1510,
-            SCATTER_SHOT_1                      = 1991,
-            CONCUSSIVE_SHOT_1                   = 5116,
-            DISTRACTING_SHOT_1                  = 20736,
-            SCORPID_STING_1                     = 3043,
-            //VIPER_STING_1                       = 3034,
-            RAPID_FIRE_1                        = 3045,
-            WING_CLIP_1                         = 2974,
-            RAPTOR_STRIKE_1                     = 2973,
-            DISENGAGE_1                         = 781,
-            FROST_TRAP_1                        = 13809,
-            FREEZING_ARROW_1                    = 60192,
-            WYVERN_STING_1                      = 19386,
-            BLACK_ARROW_1                       = 3674,
-            HUNTERS_MARK_1                      = 1130,
-            SCARE_BEAST_1                       = 1513,
-            FEIGN_DEATH_1                       = 5384,
-            DETERRENCE_1                        = 19263,
-            ASPECT_OF_THE_PACK_1                = 36613,//Aspect of the Spirit Hunter
-            ASPECT_OF_THE_VIPER_1               = 34074
-            //ASPECT_OF_THE_DRAGONHAWK_1          = 61846
-        };
-
-        enum HunterPassives
-        {
-        //Talents
-            RAPID_KILLING                       = 34949,//rank 2
-            CONCUSSIVE_BARRAGE                  = 35102,//rank 2
-            PIERCING_SHOTS                      = 53238,//rank 3
-            TRUESHOT_AURA                       = 19506,
-            RAPID_RECUPERATION                  = 53232,//rank 2
-            MASTER_MARKSMAN                     = 34489,//rank 5
-            WILD_QUIVER                         = 53217,//rank 3
-            SUREFOOTED                          = 24283,//rank 3
-            ENTRAPMENT                          = 19388,//rank 3
-            MASTER_TACTICIAN1                   = 34506,
-            MASTER_TACTICIAN2                   = 34507,
-            MASTER_TACTICIAN3                   = 34508,
-            MASTER_TACTICIAN4                   = 34838,
-            MASTER_TACTICIAN5                   = 34839,
-            NOXIOUS_STINGS                      = 53297,//rank 3
-            HUNTING_PARTY                       = 53292 //rank 3
-        };
-
-        enum HunterSpecial
-        {
-            IMPROVED_CONCUSSION                 = 28445,
-            IMPROVED_WING_CLIP_NORMAL           = 47168,
-            IMPROVED_WING_CLIP_EX               = 35963,
-
-            RAPID_KILLING_BUFF                  = 35099,//rank 2
-            THRILL_OF_THE_HUNT_EFFECT           = 34720,
-            FROST_TRAP_AURA                     = 13810,
-            FREEZING_ARROW_EFFECT               = 60210,
-            //FREEZING_TRAP_EFFECT_1              = 3355,
-            //FREEZING_TRAP_EFFECT_2              = 14308,
-            //FREEZING_TRAP_EFFECT_3              = 14309,
-            VOLLEY_DAMAGE_1                     = 42243 //rank 1
-        };
-    };
-};
-
-void AddSC_hunter_bot()
-{
-    new hunter_bot();
-}
diff --git a/src/server/game/AI/NpcBots/bot_mage_ai.cpp b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
deleted file mode 100644
index e264680..0000000
--- a/src/server/game/AI/NpcBots/bot_mage_ai.cpp
+++ /dev/null
@@ -1,1008 +0,0 @@
-#include "bot_ai.h"
-#include "GameEventMgr.h"
-#include "Group.h"
-#include "Player.h"
-#include "ScriptMgr.h"
-#include "SpellAuras.h"
-#include "WorldSession.h"
-#include "SpellInfo.h"
-/*
-Mage NpcBot (reworked by Graff onlysuffering@gmail.com)
-Complete - Around 45%
-TODO: Ice Lance, Deep Freeze, Mana Gems, Pet etc...
-*/
-class mage_bot : public CreatureScript
-{
-public:
-    mage_bot() : CreatureScript("mage_bot") { }
-
-    CreatureAI* GetAI(Creature* creature) const
-    {
-        return new mage_botAI(creature);
-    }
-
-    bool OnGossipHello(Player* player, Creature* creature)
-    {
-        return bot_minion_ai::OnGossipHello(player, creature);
-    }
-
-    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
-    {
-        if (bot_minion_ai* ai = creature->GetBotMinionAI())
-            return ai->OnGossipSelect(player, creature, sender, action);
-        return true;
-    }
-
-    struct mage_botAI : public bot_minion_ai
-    {
-        mage_botAI(Creature* creature) : bot_minion_ai(creature) { }
-
-        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
-        {
-            if (CheckBotCast(victim, spellId, CLASS_MAGE) != SPELL_CAST_OK)
-                return false;
-
-            bool result = bot_ai::doCast(victim, spellId, triggered);
-
-            if (result && spellId != MANAPOTION && me->HasAura(CLEARCASTBUFF))
-            {
-                cost = m_botSpellInfo->CalcPowerCost(me, m_botSpellInfo->GetSchoolMask());
-                if (cost)
-                    clearcast = true;
-            }
-
-            return result;
-        }
-
-        void EnterCombat(Unit*) { }
-        void Aggro(Unit*) { }
-        void AttackStart(Unit*) { }
-        void KilledUnit(Unit*) { }
-        void EnterEvadeMode() { }
-        void MoveInLineOfSight(Unit*) { }
-        void JustDied(Unit* u) { bot_ai::JustDied(u); }
-
-        void StartAttack(Unit* u, bool force = false)
-        {
-            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
-            Aggro(u);
-            SetBotCommandState(COMMAND_ATTACK);
-            GetInPosition(force);
-        }
-
-        void Counter()
-        {
-            Unit* u = me->GetVictim();
-            bool cSpell = IsSpellReady(COUNTERSPELL_1, NULL, false, 5000);
-            bool blast = IsSpellReady(FIREBLAST_1, NULL, false, 3000) && HasRole(BOT_ROLE_DPS) && !(u && u->ToCreature() && (u->ToCreature()->isWorldBoss() || u->ToCreature()->IsDungeonBoss())) && me->HasAura(IMPACT_BUFF);
-            if (!cSpell && !blast) return;
-            if (u && u->IsNonMeleeSpellCast(false) &&
-                ((cSpell && me->GetDistance(u) < 30) || (blast && me->GetDistance(u) < 30)))
-            {
-                temptimer = GC_Timer;
-                if (me->IsNonMeleeSpellCast(false))
-                    me->InterruptNonMeleeSpells(false);
-                if (cSpell && doCast(u, GetSpell(COUNTERSPELL_1)))
-                    SetSpellCooldown(COUNTERSPELL_1, 15000);
-                else if (blast && doCast(u, GetSpell(FIREBLAST_1)))
-                    SetSpellCooldown(FIREBLAST_1, 6000);
-                GC_Timer = temptimer;
-            }
-            else if (cSpell)
-            {
-                if (Unit* target = FindCastingTarget(30))
-                {
-                    temptimer = GC_Timer;
-                    if (me->IsNonMeleeSpellCast(false))
-                        me->InterruptNonMeleeSpells(false);
-                    if (doCast(target, GetSpell(COUNTERSPELL_1)))
-                    {
-                        SetSpellCooldown(COUNTERSPELL_1, 15000);
-                        GC_Timer = temptimer;
-                    }
-                }
-            }
-        }
-
-        void CheckSpellSteal(uint32 diff)
-        {
-            if (!IsSpellReady(SPELLSTEAL_1, diff) || IsCasting() || Rand() > 25) return;
-            Unit* target = FindHostileDispelTarget(30, true);
-            if (target && doCast(target, GetSpell(SPELLSTEAL_1)))
-                GC_Timer = 800;
-        }
-
-        void DoNonCombatActions(uint32 diff)
-        {
-            if (GC_Timer > diff || me->IsMounted() || Feasting())
-                return;
-
-            if (uint32 DAMPENMAGIC = GetSpell(DAMPENMAGIC_1))
-            {
-                if (!HasAuraName(me, DAMPENMAGIC) &&
-                    doCast(me, DAMPENMAGIC))
-                    return;
-            }
-
-            if (ICEARMOR && !HasAuraName(me, ICEARMOR) &&
-                doCast(me, ICEARMOR))
-                return;
-        }
-
-        bool BuffTarget(Unit* target, uint32 diff)
-        {
-            if (GC_Timer > diff || Rand() > 20) return false;
-            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
-            if (me->GetExactDist(target) > 30) return false;
-
-            if (uint32 ARCANEINTELLECT = GetSpell(ARCANEINTELLECT_1))
-            {
-                if (target->getPowerType() == POWER_MANA && !HasAuraName(target, ARCANEINTELLECT) &&
-                    doCast(target, ARCANEINTELLECT))
-                    return true;
-            }
-
-            return false;
-        }
-
-        void UpdateAI(uint32 diff)
-        {
-            ReduceCD(diff);
-            if (IAmDead()) return;
-            CheckAttackState();
-            if (clearcast && me->HasAura(CLEARCASTBUFF) && !me->IsNonMeleeSpellCast(false))
-            {
-                me->ModifyPower(POWER_MANA, cost);
-                me->RemoveAurasDueToSpell(CLEARCASTBUFF,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
-                if (me->HasAura(ARCANE_POTENCY_BUFF1))
-                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF1,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
-                if (me->HasAura(ARCANE_POTENCY_BUFF2))
-                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF2,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
-                clearcast = false;
-            }
-            CheckAuras();
-            if (wait == 0)
-                wait = GetWait();
-            else
-                return;
-            BreakCC(diff);
-            if (CCed(me) && (!GetSpell(ICEBLOCK_1) || !me->HasAura(GetSpell(ICEBLOCK_1)))) return; //TODO
-
-            CheckBlink(diff);
-            CheckPoly(diff);
-            CheckPots(diff);
-            CureGroup(master, GetSpell(REMOVE_CURSE_1), diff);
-
-            FocusMagic(diff);
-            BuffAndHealGroup(master, diff);
-
-            if (!me->IsInCombat())
-                DoNonCombatActions(diff);
-
-            if (!CheckAttackTarget(CLASS_MAGE))
-                return;
-
-            CheckPoly2();//this should go AFTER getting opponent
-
-            Counter();
-            CheckSpellSteal(diff);
-            DoNormalAttack(diff);
-        }
-
-        void DoNormalAttack(uint32 diff)
-        {
-            opponent = me->GetVictim();
-            if (opponent)
-            {
-                if (!IsCasting())
-                    StartAttack(opponent);
-            }
-            else
-                return;
-
-			Unit::AttackerSet m_attackers = master->getAttackers();
-			Unit::AttackerSet b_attackers = me->getAttackers();
-
-            Unit* u = me->SelectNearestTarget(20);
-            //ICE_BARRIER
-            uint32 ICE_BARRIER = GetSpell(ICE_BARRIER_1);
-            if (IsSpellReady(ICE_BARRIER_1, diff, false) && u && u->GetVictim() == me && u->GetDistance(me) < 8 &&
-                !me->HasAura(ICE_BARRIER))
-            {
-                if (me->IsNonMeleeSpellCast(true))
-                    me->InterruptNonMeleeSpells(true);
-                if (doCast(me, ICE_BARRIER))
-                {
-                    SetSpellCooldown(ICE_BARRIER_1, 25000);
-                    GC_Timer = 800;
-                    return;
-                }
-            }
-            if (!IsSpellReady(ICE_BARRIER_1, diff, false) &&
-                IsSpellReady(BLINK_1, diff, false, 3000) && u && u->GetVictim() == me &&
-                u->GetDistance(me) < 6 && !me->HasAura(ICE_BARRIER))
-            {
-                if (me->IsNonMeleeSpellCast(true))
-                    me->InterruptNonMeleeSpells(true);
-                if (doCast(me, GetSpell(BLINK_1)))
-                {
-                    SetSpellCooldown(BLINK_1, 13000);
-                    GC_Timer = 800;
-                    return;
-                }
-            }
-
-            //ICEBLOCK
-            if (uint32 ICEBLOCK = GetSpell(ICEBLOCK_1))
-            {
-                if (IsSpellReady(ICEBLOCK_1, diff, false, 57000))
-                {
-                    if (((GetManaPCT(me) > 45 && GetHealthPCT(me) > 80) || b_attackers.empty()) &&
-                        me->HasAura(ICEBLOCK))
-                        me->RemoveAurasDueToSpell(ICEBLOCK);
-                }
-
-                if (IsSpellReady(ICEBLOCK_1, diff, false) && !b_attackers.empty() && Rand() < 50 &&
-                    (GetManaPCT(me) < 15 || GetHealthPCT(me) < 45 || b_attackers.size() > 4) &&
-                    !me->HasAura(ICEBLOCK))
-                {
-                    if (me->IsNonMeleeSpellCast(true))
-                        me->InterruptNonMeleeSpells(true);
-                    if (doCast(me, ICEBLOCK))
-                    {
-                        SetSpellCooldown(ICEBLOCK_1, 60000);
-                        Nova_cd = 0; //Glyph of Iceblock
-                        return;
-                    }
-                }
-            }
-
-            if (IsCasting()) return;
-
-            float dist = me->GetExactDist(opponent);
-
-            uint32 FROSTBOLT = GetSpell(FROSTBOLT_1);
-            uint32 FIREBALL = GetSpell(FIREBALL_1);
-            uint32 BLASTWAVE = GetSpell(BLASTWAVE_1);
-            uint32 FROSTNOVA = GetSpell(FROSTNOVA_1);
-            BOLT = (CCed(opponent, true) || !FROSTBOLT) ? FIREBALL : FROSTBOLT;
-            NOVA = BOLT == FROSTBOLT && BLASTWAVE && dist > 5 ? BLASTWAVE : FROSTNOVA ? FROSTNOVA : 0;
-
-            if (IsSpellReady(COMBUSTION_1, diff, false) && HasRole(BOT_ROLE_DPS) &&
-                (opponent->GetMaxHealth() > master->GetMaxHealth()*6 ||
-                m_attackers.size() > 1 || b_attackers.size() > 2) &&
-                Rand() < 15 && !HasAuraName(me, COMBUSTION_1))
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, GetSpell(COMBUSTION_1)))
-                {
-                    SetSpellCooldown(COMBUSTION_1, 60000);
-                    GC_Timer = temptimer;
-                    //Reset timers for fun
-                    ResetSpellCooldown(FIREBLAST_1);
-                    ResetSpellCooldown(DRAGONBREATH_1);
-                    Nova_cd = 0;
-                }
-            }
-            //DAMAGE
-            //PYROBLAST
-            if (IsSpellReady(PYROBLAST_1, diff) && opponent->IsPolymorphed() && HasRole(BOT_ROLE_DPS) &&
-                (b_attackers.size() < 2 || (*b_attackers.begin()) == opponent) &&
-                dist < 35 && Rand() < 75 &&
-                doCast(opponent, GetSpell(PYROBLAST_1)))
-            {
-                SetSpellCooldown(PYROBLAST_1, 7500);
-                //debug
-                SetSpellCooldown(DRAGONBREATH_1, std::max<uint32>(GetSpellCooldown(DRAGONBREATH_1), uint32(float(sSpellMgr->GetSpellInfo(GetSpell(PYROBLAST_1))->CalcCastTime()/100) * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 400)));
-                Nova_cd = std::max<uint32>(Nova_cd, 450);
-                return;
-            }
-            //nova //TODO: SEPARATE
-            u = me->SelectNearestTarget(6.3f);
-            if (NOVA && Nova_cd <= diff && HasRole(BOT_ROLE_DPS) && u && Rand() < 75 && !CCed(u, true) && IsInBotParty(u->GetVictim()))
-            {
-                if (doCast(me, NOVA))
-                {
-                    Nova_cd = 15000;
-                    GetInPosition(true);
-                    return;
-                }
-            }
-            //living bomb
-            if (IsSpellReady(LIVINGBOMB_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 35 && opponent->GetHealth() > me->GetHealth()/2 &&
-                Rand() < 45 && !HasAuraName(opponent, LIVINGBOMB_1, me->GetGUID()) &&
-                doCast(opponent, GetSpell(LIVINGBOMB_1)))
-            {
-                SetSpellCooldown(LIVINGBOMB_1, 6000);
-                GC_Timer = 500;
-                return;
-            }
-            //cone of cold
-            if (IsSpellReady(CONEOFCOLD_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 7 && Rand() < 50 &&
-                me->HasInArc(M_PI*0.75f, opponent) &&
-                doCast(opponent, GetSpell(CONEOFCOLD_1)))
-            {
-                SetSpellCooldown(CONEOFCOLD_1, 8000);
-                GC_Timer = 500;
-                GetInPosition(true);
-                return;
-            }
-            //dragon's breath
-            if (IsSpellReady(DRAGONBREATH_1, diff) && HasRole(BOT_ROLE_DPS) && !CCed(opponent, true) &&
-                ((me->HasInArc(M_PI*0.75f, opponent) && dist < 7) ||
-                (u && u != opponent && me->HasInArc(M_PI*0.75f, u) && IsInBotParty(u->GetVictim()))) &&
-                doCast(me, GetSpell(DRAGONBREATH_1)))
-            {
-                SetSpellCooldown(DRAGONBREATH_1, 25000);
-                GC_Timer = 800;
-                return;
-            }
-            /*//blast wave //TODO Separate again
-            u = me->SelectNearestTarget(8);
-            if (BLASTWAVE != 0 && u && isTimerReady(BlastWave_cd) &&
-                !HasAuraName(u, FROSTNOVA) && !HasAuraName(u, DRAGONBREATH) &&
-                doCast(me, BLASTWAVE))
-            {
-                BlastWave_cd = BLASTWAVE_CD;
-                GC_Timer = 800;
-            }*/
-            //fire blast
-            if (IsSpellReady(FIREBLAST_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 25 &&
-                Rand() < 20 + 80*(!opponent->isFrozen() && !opponent->HasAuraType(SPELL_AURA_MOD_STUN) && me->HasAura(IMPACT_BUFF)))
-            {
-                if (doCast(opponent, GetSpell(FIREBLAST_1)))
-                {
-                    SetSpellCooldown(FIREBLAST_1, 6000);
-                    GC_Timer = 500;
-                    return;
-                }
-            }
-            //flamestrike - use Improved Flamestrike for instant cast
-            if (IsSpellReady(FLAMESTRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && me->HasAura(FIRESTARTERBUFF) && Rand() < 25)
-            {
-                Unit* FStarget = FindAOETarget(30, true, false);
-                if (FStarget && doCast(FStarget, GetSpell(FLAMESTRIKE_1), true))
-                {
-                    me->RemoveAurasDueToSpell(FIRESTARTERBUFF);
-                    GC_Timer = 300;
-                    return;
-                }
-            }
-            //blizzard
-            if (IsSpellReady(BLIZZARD_1, diff, false) && HasRole(BOT_ROLE_DPS) && !me->isMoving() && Rand() < 40)
-            {
-                Unit* blizztarget = FindAOETarget(30, true);
-                if (blizztarget && doCast(blizztarget, GetSpell(BLIZZARD_1)))
-                {
-                    SetSpellCooldown(BLIZZARD_1, 5000);
-                    return;
-                }
-                SetSpellCooldown(BLIZZARD_1, 1500); //fail
-            }
-            //Frost or Fire Bolt
-            if (BOLT && Bolt_cd <= diff && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 75 &&
-                doCast(opponent, BOLT))
-            {
-                Bolt_cd = uint32(float(sSpellMgr->GetSpellInfo(BOLT)->CalcCastTime()/100) * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 200);
-                //debug
-                SetSpellCooldown(DRAGONBREATH_1, std::max<uint32>(GetSpellCooldown(DRAGONBREATH_1), Bolt_cd + 200));
-                Nova_cd = std::max<uint32>(Nova_cd, 450);
-                return;
-            }
-            //Arcane Missiles
-            if (IsSpellReady(ARCANEMISSILES_1, diff) && !me->isMoving() && HasRole(BOT_ROLE_DPS) && dist < 20 && Rand() < 15 &&
-                doCast(opponent, GetSpell(ARCANEMISSILES_1)))
-                return;
-        }
-
-        void CheckPoly(uint32 diff)
-        {
-            if (polyCheckTimer <= diff)
-            {
-                Polymorph = FindAffectedTarget(GetSpell(POLYMORPH_1), me->GetGUID());
-                polyCheckTimer = 2000;
-            }
-        }
-
-        void CheckPoly2()
-        {
-            if (Polymorph == false && GC_Timer < 500 && GetSpell(POLYMORPH_1))
-            {
-                if (Unit* target = FindPolyTarget(30, me->GetVictim()))
-                {
-                    if (doCast(target, GetSpell(POLYMORPH_1)))
-                    {
-                        Polymorph = true;
-                        polyCheckTimer += 2000;
-                    }
-                }
-            }
-        }
-
-        void CheckPots(uint32 diff)
-        {
-            if (me->IsMounted() || IsCasting())
-                return;
-
-            if (GetHealthPCT(me) < 67 && Potion_cd <= diff)
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, HEALINGPOTION))
-                {
-                    Potion_cd = POTION_CD;
-                    GC_Timer = temptimer;
-                }
-            }
-            if (GetManaPCT(me) < 35 && Rand() < 35)
-            {
-                if (IsSpellReady(EVOCATION_1, diff, false) && !me->isMoving() && me->getAttackers().empty() &&
-                    doCast(me, GetSpell(EVOCATION_1)))
-                {
-                    SetSpellCooldown(EVOCATION_1, 60000);
-                    return;
-                }
-                if (Potion_cd <= diff)
-                {
-                    temptimer = GC_Timer;
-                    if (doCast(me, MANAPOTION))
-                    {
-                        Potion_cd = POTION_CD;
-                        GC_Timer = temptimer;
-                    }
-                }
-            }
-        }
-
-        void CheckBlink(uint32 diff)
-        {
-            if (GetBotCommandState() == COMMAND_STAY || me->IsMounted()) return;
-            if (!IsSpellReady(BLINK_1, diff, false) || me->getLevel() < 20 || IsCasting()) return;
-
-            if (!me->IsInCombat() && me->GetExactDist(master) > std::max<uint8>(master->GetBotFollowDist(), 35) &&
-                me->HasInArc(M_PI*0.75f, master))
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, GetSpell(BLINK_1)))
-                {
-                    SetSpellCooldown(BLINK_1, 13000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-            if (!me->getAttackers().empty() && me->GetExactDist(master) > 15)
-            {
-                if (Unit* op = me->SelectNearestTarget(7))
-                {
-                    if (op->GetVictim() == me)
-                    {
-                        me->SetFacingTo(me->GetAngle(master));
-                        temptimer = GC_Timer;
-                        if (doCast(me, GetSpell(BLINK_1)))
-                        {
-                            SetSpellCooldown(BLINK_1, 13000);
-                            GC_Timer = temptimer;
-                        }
-                    }
-                }
-            }
-        }
-
-        void FocusMagic(uint32 diff)
-        {
-            if (fmCheckTimer > diff || GC_Timer > diff || me->getLevel() < 20 || IsCasting() || Rand() < 50)
-                return;
-
-            uint32 FOCUSMAGIC = GetSpell(FOCUSMAGIC_1);
-            if (!FOCUSMAGIC)
-                return;
-
-            if (Unit* target = FindAffectedTarget(FOCUSMAGIC, me->GetGUID(), 70, 2))
-            {
-                fmCheckTimer = 15000;
-                return;
-            }
-            else
-            {
-                Group* pGroup = master->GetGroup();
-                if (!pGroup)
-                {
-                    if (master->getPowerType() == POWER_MANA && me->GetExactDist(master) < 30 &&
-                        !master->HasAura(FOCUSMAGIC))
-                    target = master;
-                }
-                else
-                {
-                    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-                    {
-                        Player* pPlayer = itr->GetSource();
-                        if (!pPlayer || pPlayer->IsInWorld() || pPlayer->isDead()) continue;
-                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
-                        if (pPlayer->getPowerType() == POWER_MANA && me->GetExactDist(pPlayer) < 30 &&
-                            !pPlayer->HasAura(FOCUSMAGIC))
-                        {
-                            target = pPlayer;
-                            break;
-                        }
-                    }
-                    if (!target)
-                    {
-                        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-                        {
-                            Player* pPlayer = itr->GetSource();
-                            if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->HaveBot()) continue;
-                            if (me->GetMapId() != pPlayer->GetMapId()) continue;
-                            for (uint8 i = 0; i != pPlayer->GetMaxNpcBots(); ++i)
-                            {
-                                Creature* cre = pPlayer->GetBotMap(i)->_Cre();
-                                if (!cre || !cre->IsInWorld() || cre == me || cre->isDead()) continue;
-                                if (cre->getPowerType() == POWER_MANA && me->GetExactDist(cre) < 30 &&
-                                    !cre->HasAura(FOCUSMAGIC))
-                                {
-                                    target = cre;
-                                    break;
-                                }
-                            }
-                        }
-                    }
-                }
-
-                if (target && doCast(target, FOCUSMAGIC))
-                {
-                    GC_Timer = 500;
-                    fmCheckTimer = 30000;
-                    return;
-                }
-            }
-
-            fmCheckTimer = 5000;
-        }
-
-        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
-        {
-            uint32 spellId = spellInfo->Id;
-            uint8 lvl = me->getLevel();
-            float fdamage = float(damage);
-            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
-            if (!crit)
-            {
-                float aftercrit = 0.f;
-                //Combustion: 10% per stack
-                if (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask())
-                    if (Aura* combustion = me->GetAura(COMBUSTION_BUFF))
-                        aftercrit += float(combustion->GetStackAmount()*10);
-                //Incineration: 6% additional critical chance for Fire Blast, Scorch, Arcane Blast and Cone of Cold
-                if (lvl >= 10 &&
-                    (spellId == GetSpell(FIREBLAST_1) ||
-                    spellId == GetSpell(CONEOFCOLD_1)/* ||
-                    spellId == ARCANEBLAST ||
-                    spellId == SCORCH*/))
-                    aftercrit += 6.f;
-                //World In Flames: 6% additional critical chance for
-                //Flamestrike, Pyroblast, Blast Wave, Dragon's Breath, Living Bomb, Blizzard and Arcane Explosion
-                if (lvl >= 15 &&
-                    (spellId == GetSpell(FLAMESTRIKE_1) ||
-                    spellId == GetSpell(PYROBLAST_1) ||
-                    spellId == GetSpell(BLASTWAVE_1) ||
-                    spellId == GetSpell(DRAGONBREATH_1)/* ||
-                    spellId == ARCANEXPLOSION ||
-                    spellId == LIVINGBOMB ||    //cannot be handled here
-                    spellId == BLIZZARD*/))    //cannot be handled here
-                    aftercrit += 6.f;
-
-                if (aftercrit > 0.f)
-                    crit = roll_chance_f(aftercrit);
-            }
-
-            //2) apply bonus damage mods
-            float pctbonus = 0.0f;
-            if (crit)
-            {
-                //!!!spell damage is not yet critical and will be multiplied by 1.5
-                //so we should put here bonus damage mult /1.5
-                //Spell Power: 50% additional crit damage bonus for All spells
-                if (lvl >= 55)
-                    pctbonus += 0.333f;
-                //Ice Shards: 50% additional crit damage bonus for Frost spells
-                else if (lvl >= 15 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
-                    pctbonus += 0.333f;
-            }
-            //Improved Cone of Cold: 35% bonus damage for Cone of Cold
-            if (lvl >= 30 && spellId == GetSpell(CONEOFCOLD_1))
-                pctbonus += 0.35f;
-            //Fire Power: 10% bonus damage for Fire spells
-            if (lvl >= 35 && (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask()))
-                pctbonus += 0.1f;
-
-            damage = int32(fdamage * (1.0f + pctbonus));
-        }
-
-        void SpellHit(Unit* caster, SpellInfo const* spell)
-        {
-            OnSpellHit(caster, spell);
-        }
-
-        void SpellHitTarget(Unit* target, SpellInfo const* spell)
-        {
-            if (aftercastTargetGuid != 0)
-            {
-                //only players for now
-                if (!IS_PLAYER_GUID(aftercastTargetGuid))
-                {
-                    aftercastTargetGuid = 0;
-                    return;
-                }
-
-                Player* pTarget = sObjectAccessor->FindPlayer(aftercastTargetGuid);
-                aftercastTargetGuid = 0;
-
-                if (!pTarget/* || me->GetDistance(pTarget) > 15*/)
-                    return;
-
-                //handle effects
-                for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
-                {
-                    switch (spell->Effects[i].Effect)
-                    {
-                        case SPELL_EFFECT_CREATE_ITEM:
-                        case SPELL_EFFECT_CREATE_ITEM_2:
-                        {
-                            uint32 newitemid = spell->Effects[i].ItemType;
-                            if (newitemid)
-                            {
-                                ItemPosCountVec dest;
-                                ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(newitemid);
-                                if (!pProto)
-                                    return;
-                                uint32 count = pProto->GetMaxStackSize();
-                                uint32 no_space = 0;
-                                InventoryResult msg = pTarget->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, newitemid, count, &no_space);
-                                if (msg != EQUIP_ERR_OK)
-                                {
-                                    if (msg == EQUIP_ERR_INVENTORY_FULL || msg == EQUIP_ERR_CANT_CARRY_MORE_OF_THIS)
-                                        count -= no_space;
-                                    else
-                                    {
-                                        // if not created by another reason from full inventory or unique items amount limitation
-                                        pTarget->SendEquipError(msg, NULL, NULL, newitemid);
-                                        continue;
-                                    }
-                                }
-                                if (count)
-                                {
-                                    Item* pItem = pTarget->StoreNewItem(dest, newitemid, true, Item::GenerateItemRandomPropertyId(newitemid));
-                                    if (!pItem)
-                                    {
-                                        pTarget->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
-                                        continue;
-                                    }
-                                    //unsafe possible
-                                    pItem->SetUInt32Value(ITEM_FIELD_CREATOR, me->GetGUIDLow());
-
-                                    pTarget->SendNewItem(pItem, count, true, false, true);
-                                }
-                            }
-                            break;
-                        }
-                        default:
-                            break;
-                    }
-                }
-
-                return;
-            }
-
-            //Winter Veil addition
-            uint32 spellId = spell->Id;
-            if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
-            {
-                if (SPELL_SCHOOL_MASK_FROST & spell->GetSchoolMask())
-                    me->AddAura(44755, target); //snowflakes
-
-                if (spellId == GetSpell(FROSTBOLT_1) && urand(1,100) <= 10)
-                    me->CastSpell(target, 25686, true); //10% super snowball
-            }
-        }
-
-        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
-        {
-            if (victim == me)
-                return;
-
-            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
-            {
-                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
-                {
-                    if (_ctc[i].first && !_ctc[i].second)
-                    {
-                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
-                            _ctc[i].second = 1000;
-
-                        if (_ctc[i].second > 0)
-                            me->CastSpell(victim, _ctc[i].first, true);
-                    }
-                }
-            }
-        }
-
-		void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType, SpellSchoolMask)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void OwnerAttackedBy(Unit* u)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void Reset()
-        {
-            Bolt_cd = 0;
-            Nova_cd = 0;
-            polyCheckTimer = 0;
-            fmCheckTimer = 0;
-            Polymorph = false;
-            clearcast = false;
-            BOLT = 0;
-            NOVA = 0;
-
-            if (master)
-            {
-                SetStats(true);
-                InitRoles();
-                ApplyPassives(CLASS_MAGE);
-           }
-        }
-
-        void ReduceCD(uint32 diff)
-        {
-            CommonTimers(diff);
-            SpellTimers(diff);
-
-            if (Bolt_cd > diff)                     Bolt_cd -= diff;
-            if (Nova_cd > diff)                     Nova_cd -= diff;
-
-            if (polyCheckTimer > diff)              polyCheckTimer -= diff;
-            if (fmCheckTimer > diff)                fmCheckTimer -= diff;
-        }
-
-        bool CanRespawn()
-        {return false;}
-
-        void InitSpells()
-        {
-            uint8 lvl = me->getLevel();
-            InitSpellMap(DAMPENMAGIC_1);
-            InitSpellMap(ARCANEINTELLECT_1);
-            InitSpellMap(ARCANEMISSILES_1);
-            InitSpellMap(POLYMORPH_1);
-            InitSpellMap(COUNTERSPELL_1);
-            InitSpellMap(SPELLSTEAL_1);
-            InitSpellMap(EVOCATION_1);
-            InitSpellMap(BLINK_1);
-            InitSpellMap(REMOVE_CURSE_1);
-            //InitSpellMap(INVISIBILITY_1);
-            InitSpellMap(FIREBALL_1);
-  /*Talent*/lvl >= 30 ? InitSpellMap(BLASTWAVE_1) : RemoveSpell(BLASTWAVE_1);
-  /*Talent*/lvl >= 40 ? InitSpellMap(DRAGONBREATH_1) : RemoveSpell(DRAGONBREATH_1);
-            InitSpellMap(FIREBLAST_1);
-  /*Talent*/lvl >= 20 ? InitSpellMap(PYROBLAST_1) : RemoveSpell(PYROBLAST_1);
-  /*Talent*/lvl >= 60 ? InitSpellMap(LIVINGBOMB_1) : RemoveSpell(LIVINGBOMB_1);
-            InitSpellMap(DAMPENMAGIC_1);
-  /*Talent*/lvl >= 50 ? InitSpellMap(COMBUSTION_1) : RemoveSpell(COMBUSTION_1);
-            InitSpellMap(FROSTBOLT_1);
-            InitSpellMap(FROSTNOVA_1);
-            InitSpellMap(CONEOFCOLD_1);
-            InitSpellMap(BLIZZARD_1);
- /*Special*/ICEARMOR = lvl >= 20 ? InitSpell(me, ICEARMOR_1) : InitSpell(me, FROSTARMOR_1);
-  /*Talent*/lvl >= 40 ? InitSpellMap(ICE_BARRIER_1) : RemoveSpell(ICE_BARRIER_1);
-            InitSpellMap(ICEBLOCK_1);
-  /*Talent*/lvl >= 20 ? InitSpellMap(FOCUSMAGIC_1) : RemoveSpell(FOCUSMAGIC_1);
-        }
-
-        void ApplyClassPassives()
-        {
-            uint8 level = master->getLevel();
-            //Dam+(-Hit)
-            if (level >= 50)
-                RefreshAura(ARCTIC_WINDS,3); //+15%/-15%
-            else if (level >= 25)
-                RefreshAura(ARCTIC_WINDS,2); //+10%/-10%
-            else if (level >= 10)
-                RefreshAura(ARCTIC_WINDS); //+5%/-5%
-            //CHILL
-            if (level >= 30)
-                RefreshAura(WINTERS_CHILL3); //100%
-            else if (level >= 25)
-                RefreshAura(WINTERS_CHILL2); //66%
-            else if (level >= 20)
-                RefreshAura(WINTERS_CHILL1); //33%
-            //Imp Blizzard
-            if (level >= 20)
-                RefreshAura(IMPROVED_BLIZZARD); //50% slow
-            //Frostbite
-            if (level >= 80)
-                FROSTBITE = FROSTBITE3;
-            else if (level >= 50)
-                FROSTBITE = FROSTBITE2;
-            else if (level >= 10)
-                FROSTBITE = FROSTBITE1;
-            if (level >= 60)
-                RefreshAura(FROSTBITE,3); //3x
-            else if (level >= 30)
-                RefreshAura(FROSTBITE,2); //2x
-            else if (level >= 10)
-                RefreshAura(FROSTBITE); //1x
-            //Shattered Barrier
-            if (level >= 45)
-                RefreshAura(SHATTERED_BARRIER);
-            //Bonus
-            if (level >= 65)
-                RefreshAura(ARCANE_INSTABILITY,4); //+12%dmg crit
-            else if (level >= 55)
-                RefreshAura(ARCANE_INSTABILITY,3); //+9%dmg crit
-            else if (level >= 45)
-                RefreshAura(ARCANE_INSTABILITY,2); //+6%dmg crit
-            else if (level >= 35)
-                RefreshAura(ARCANE_INSTABILITY); //+3%dmg crit
-            //Absorb
-            if (level >= 50)
-                RefreshAura(INCANTERS_ABSORPTION3);
-            else if (level >= 45)
-                RefreshAura(INCANTERS_ABSORPTION2);
-            else if (level >= 40)
-                RefreshAura(INCANTERS_ABSORPTION1);
-            //Shatter
-            if (level >= 35)
-                RefreshAura(SHATTER3);
-            else if (level >= 30)
-                RefreshAura(SHATTER2);
-            else if (level >= 25)
-                RefreshAura(SHATTER1);
-            //ClearCasting
-            if (level >= 75)
-                RefreshAura(CLEARCAST,3); //30%
-            else if (level >= 40)
-                RefreshAura(CLEARCAST,2); //20%
-            else if (level >= 15)
-                RefreshAura(CLEARCAST); //10%
-            //Fingers
-            if (level >= 45)
-                RefreshAura(FINGERS_OF_FROST); //15%
-            //Potency
-            if (level >= 40)
-                RefreshAura(ARCANE_POTENCY2); //30% bonus
-            else if (level >= 35)
-                RefreshAura(ARCANE_POTENCY1); //15% bonus
-            //Ignite
-            if (level >= 15)
-                RefreshAura(IGNITE);
-            //Impact
-            if (level >= 60)
-                RefreshAura(IMPACT,2);
-            else if (level >= 20)
-                RefreshAura(IMPACT);
-            //Imp. Counterspell
-            if (level >= 35)
-                RefreshAura(IMPROVED_COUNTERSPELL2); //4 sec
-            else if (level >= 25)
-                RefreshAura(IMPROVED_COUNTERSPELL1); //2 sec
-            //Firestarter
-            if (level >= 55)
-                RefreshAura(FIRESTARTER2); //100% chance
-            else if (level >= 45)
-                RefreshAura(FIRESTARTER1); //50% chance
-            //Spells
-            if (GetSpell(LIVINGBOMB_1))
-                RefreshAura(GLYPH_LIVING_BOMB);
-            if (GetSpell(POLYMORPH_1))
-                RefreshAura(GLYPH_POLYMORPH);
-        }
-
-        bool CanUseManually(uint32 basespell) const
-        {
-            switch (basespell)
-            {
-                case DAMPENMAGIC_1:
-                case ARCANEINTELLECT_1:
-                case EVOCATION_1:
-                case REMOVE_CURSE_1:
-                case FOCUSMAGIC_1:
-                case FROSTARMOR_1:
-                case ICEARMOR_1:
-                    return true;
-                default:
-                    return false;
-            }
-        }
-
-    private:
-        //Spells
-/*frst*/uint32 ICEARMOR;
-/*exc.*/uint32 BOLT, NOVA;
-/*exc.*/uint32 FROSTBITE;
-        //Timers
-/*exc.*/uint32 Bolt_cd, Nova_cd;
-/*exc.*/uint32 polyCheckTimer, fmCheckTimer;
-        //Check
-/*exc.*/bool Polymorph, clearcast;
-
-        enum MageBaseSpells
-        {
-            DAMPENMAGIC_1                       = 604,
-            ARCANEINTELLECT_1                   = 1459,
-            ARCANEMISSILES_1                    = 5143,
-            POLYMORPH_1                         = 118,
-            COUNTERSPELL_1                      = 2139,
-            SPELLSTEAL_1                        = 30449,
-            EVOCATION_1                         = 12051,
-            BLINK_1                             = 1953,
-            REMOVE_CURSE_1                      = 475,
-            //INVISIBILITY_1                      = 0,
-            FIREBALL_1                          = 133,
-            BLASTWAVE_1                         = 11113,
-            DRAGONBREATH_1                      = 31661,
-            FIREBLAST_1                         = 2136,
-            PYROBLAST_1                         = 11366,
-            LIVINGBOMB_1                        = 44457,
-            FLAMESTRIKE_1                       = 2120,
-            COMBUSTION_1                        = 11129,
-            FROSTBOLT_1                         = 116,
-            FROSTNOVA_1                         = 122,
-            CONEOFCOLD_1                        = 120,
-            BLIZZARD_1                          = 10,
-            FROSTARMOR_1                        = 168,
-            ICEARMOR_1                          = 7302,
-            ICE_BARRIER_1                       = 11426,
-            ICEBLOCK_1                          = 45438,
-            FOCUSMAGIC_1                        = 54646
-        };
-
-        enum MagePassives
-        {
-        //Talents
-            SHATTERED_BARRIER                   = 54787,//rank 2
-            ARCTIC_WINDS                        = 31678,//rank 5
-            WINTERS_CHILL1                      = 11180,
-            WINTERS_CHILL2                      = 28592,
-            WINTERS_CHILL3                      = 28593,
-            FROSTBITE1                          = 11071,
-            FROSTBITE2                          = 12496,
-            FROSTBITE3                          = 12497,
-            IMPROVED_BLIZZARD                   = 12488,//rank 3
-            CLEARCAST /*Arcane Concentration*/  = 12577,//rank 5
-            ARCANE_POTENCY1                     = 31571,
-            ARCANE_POTENCY2                     = 31572,
-            SHATTER1                            = 11170,
-            SHATTER2                            = 12982,
-            SHATTER3                            = 12983,
-            INCANTERS_ABSORPTION1               = 44394,
-            INCANTERS_ABSORPTION2               = 44395,
-            INCANTERS_ABSORPTION3               = 44396,
-            FINGERS_OF_FROST                    = 44545,//rank 2
-            ARCANE_INSTABILITY                  = 15060,//rank 3
-            IMPROVED_COUNTERSPELL1              = 11255,
-            IMPROVED_COUNTERSPELL2              = 12598,
-            IGNITE                              = 12848,
-            FIRESTARTER1                        = 44442,
-            FIRESTARTER2                        = 44443,
-            IMPACT                              = 12358,
-            GLYPH_LIVING_BOMB                   = 63091,
-        //Special
-            GLYPH_POLYMORPH                     = 56375
-        };
-        enum MageSpecial
-        {
-            CLEARCASTBUFF                       = 12536,
-            IMPACT_BUFF                         = 64343,
-            FIRESTARTERBUFF                     = 54741,
-            ARCANE_POTENCY_BUFF1                = 57529,
-            ARCANE_POTENCY_BUFF2                = 57531,
-            COMBUSTION_BUFF                     = 28682
-        };
-    };
-};
-
-void AddSC_mage_bot()
-{
-    new mage_bot();
-}
diff --git a/src/server/game/AI/NpcBots/bot_paladin_ai.cpp b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
deleted file mode 100644
index dbc2d48..0000000
--- a/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
+++ /dev/null
@@ -1,1127 +0,0 @@
-#include "bot_ai.h"
-#include "Group.h"
-#include "Player.h"
-#include "ScriptMgr.h"
-#include "SpellAuraEffects.h"
-#include "WorldSession.h"
-#include "SpellInfo.h"
-/*
-Paladin NpcBot (reworked by Graff onlysuffering@gmail.com)
-Complete - Around 45-50%
-TODO: Tanking, Shield Abilities, Auras
-*/
-class paladin_bot : public CreatureScript
-{
-public:
-    paladin_bot() : CreatureScript("paladin_bot") { }
-
-    CreatureAI* GetAI(Creature* creature) const
-    {
-        return new paladin_botAI(creature);
-    }
-
-    bool OnGossipHello(Player* player, Creature* creature)
-    {
-        return bot_minion_ai::OnGossipHello(player, creature);
-    }
-
-    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
-    {
-        if (bot_minion_ai* ai = creature->GetBotMinionAI())
-            return ai->OnGossipSelect(player, creature, sender, action);
-        return true;
-    }
-
-    struct paladin_botAI : public bot_minion_ai
-    {
-        paladin_botAI(Creature* creature) : bot_minion_ai(creature) { }
-
-        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
-        {
-            if (CheckBotCast(victim, spellId, CLASS_PALADIN) != SPELL_CAST_OK)
-                return false;
-            return bot_ai::doCast(victim, spellId, triggered);
-        }
-
-        void HOFGroup(Player* pTarget, uint32 diff)
-        {
-            if (!IsSpellReady(HOF_1, diff) || IsCasting() || Rand() > 60)
-                return;
-
-            if (Group* pGroup = pTarget->GetGroup())
-            {
-                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-                {
-                    Player* tPlayer = itr->GetSource();
-                    if (!tPlayer) continue;
-                    if (HOFTarget(tPlayer, diff))
-                        return;
-                }
-                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-                {
-                    Player* tPlayer = itr->GetSource();
-                    if (!tPlayer || !tPlayer->HaveBot()) continue;
-                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
-                    {
-                        Creature* cre = tPlayer->GetBotMap(i)->_Cre();
-                        if (!cre || !cre->IsInWorld()) continue;
-                        if (HOFTarget(cre, diff))
-                            return;
-                    }
-                }
-            }
-        }
-
-        bool HOFTarget(Unit* target, uint32 diff)
-        {
-            if (!target || target->isDead()) return false;
-            if (!IsSpellReady(HOF_1, diff)) return false;
-            if (target->ToCreature() && Rand() > 25) return false;
-            if (me->GetExactDist(target) > 30) return false;//too far away
-            if (HasAuraName(target, HOF_1)) return false;     //Alredy has HOF
-
-            Unit::AuraMap const &auras = target->GetOwnedAuras();
-            for (Unit::AuraMap::const_iterator i = auras.begin(); i != auras.end(); ++i)
-            {
-                Aura* aura = i->second;
-                if (aura->IsPassive()) continue;//most
-                if (aura->GetDuration() < 2000) continue;
-                if (AuraApplication* app = aura->GetApplicationOfTarget(target->GetGUID()))
-                    if (app->IsPositive()) continue;
-                SpellInfo const* spellInfo = aura->GetSpellInfo();
-                if (spellInfo->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE) continue;
-                if (me->getLevel() >= 40 && (spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_STUN)))
-                {
-                    if (doCast(target, GetSpell(HOF_1)))
-                    {
-                        if (target->ToCreature())
-                            SetSpellCooldown(HOF_1, 10000); //10 sec for selfcast after stun
-                        else
-                            SetSpellCooldown(HOF_1, 15000); //improved
-                        return true;
-                    }
-                }
-       /*else */if (spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_SNARE) ||
-                    spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_ROOT))
-                {
-                    uint32 spell = GetSpell(CLEANSE_1) &&
-                        (spellInfo->Dispel == DISPEL_MAGIC ||
-                        spellInfo->Dispel == DISPEL_DISEASE ||
-                        spellInfo->Dispel == DISPEL_POISON) ? GetSpell(CLEANSE_1) : GetSpell(HOF_1);
-
-                    if (doCast(target, spell))
-                    {
-                        if (spell == GetSpell(HOF_1))
-                        {
-                            if (target->ToCreature())
-                                SetSpellCooldown(HOF_1, 5000); //5 sec for bots
-                            else
-                                SetSpellCooldown(HOF_1, 15000); //improved
-                        }
-                        return true;
-                    }
-                }
-            }
-            return false;
-        }
-
-        void HOSGroup(Player* hTarget, uint32 diff)
-        {
-            if (!IsSpellReady(HOS_1, diff) || IsCasting() || Rand() > 30)
-                return;
-
-            if (Group* pGroup = hTarget->GetGroup())
-            {
-                bool bots = false;
-                float threat;
-                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-                {
-                    Player* HOSPlayer = itr->GetSource();
-                    if (!HOSPlayer) continue;
-                    if (HOSPlayer->HaveBot())
-                        bots = true;
-                    if (HOSPlayer->isDead()) continue;
-                    if (IsTank(HOSPlayer)) continue; //tanks do not need it
-                    if (!HOSPlayer->IsInWorld() || master->GetMap() != HOSPlayer->FindMap() || me->GetExactDist(HOSPlayer) > 30) continue;
-                    if (HasAuraName(HOSPlayer, HOS_1)) continue;
-					Unit::AttackerSet h_attackers = HOSPlayer->getAttackers();
-                    if (h_attackers.empty()) continue;
-					for (Unit::AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
-                    {
-                        if (!(*iter)) continue;
-                        if ((*iter)->isDead()) continue;
-                        if (!(*iter)->CanHaveThreatList()) continue;
-                        threat = (*iter)->getThreatManager().getThreat(HOSPlayer);
-                        if (threat < 25.f) continue;//too small threat
-                        //if ((*iter)->getThreatManager().getThreat(tank) < threat * 0.33f) continue;//would be useless
-                        if (HOSPlayer->GetDistance((*iter)) > 10) continue;
-                        if (HOSTarget(HOSPlayer, diff))
-                            return;
-                    }//end for
-                }//end for
-                if (!bots) return;
-                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-                {
-                    Player* pl = itr->GetSource();
-                    if (!pl) continue;
-                    if (!pl->HaveBot()) continue;
-                    if (master->GetMap() != pl->FindMap()) continue;
-                    if (!pl->IsInWorld() || pl->IsBeingTeleported()) continue;
-                    for (uint8 i = 0; i != pl->GetMaxNpcBots(); ++i)
-                    {
-                        Creature* cre = pl->GetBotMap(i)->_Cre();
-                        if (!cre || cre->isDead()) continue;
-                        if (IsTank(cre)) continue;
-                        if (me->GetExactDist(cre) > 30) continue;
-                        if (HasAuraName(cre, HOS_1)) continue; //Alredy has HOS
-						Unit::AttackerSet h_attackers = cre->getAttackers();
-                        if (h_attackers.empty()) continue;
-						for (Unit::AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
-                        {
-                            if (!(*iter)) continue;
-                            if ((*iter)->isDead()) continue;
-                            if (!(*iter)->CanHaveThreatList()) continue;
-                            threat = (*iter)->getThreatManager().getThreat(cre);
-                            if (threat < 25.f) continue;//too small threat
-                            //if ((*iter)->getThreatManager().getThreat(tank) < threat * 0.33f) continue;//would be useless
-                            if (cre->GetDistance((*iter)) > 10) continue;
-                            if (HOSTarget(cre, diff))
-                                return;
-                        }//end for
-                    }//end for
-                }//end for
-            }//end if
-        }
-
-        bool HOSTarget(Unit* target, uint32 diff)
-        {
-            if (!target || target->isDead()) return false;
-            if (!IsSpellReady(HOS_1, diff) || Rand() > 50) return false;
-            if (IsTank(target)) return false; //tanks do not need it
-            if (IsCasting()) return false; //I'm busy casting
-            if (me->GetExactDist(target) > 30) return false; //too far away
-            if (HasAuraName(target, HOS_1)) return false; //Alredy has HOS
-
-			Unit::AttackerSet h_attackers = target->getAttackers();
-            if (h_attackers.empty()) return false; //no aggro
-            float threat;
-            uint8 Tattackers = 0;
-			for (Unit::AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
-            {
-                if (!(*iter)) continue;
-                if ((*iter)->isDead()) continue;
-                if (!(*iter)->CanHaveThreatList()) continue;
-                threat = (*iter)->getThreatManager().getThreat(target);
-                if (threat < 25.f) continue; //too small threat
-                //if ((*iter)->getThreatManager().getThreat(tank) < threat * 0.33f) continue;//would be useless
-                if (target->GetDistance((*iter)) <= 10)
-                    Tattackers++;
-            }
-            if (Tattackers > 0 && doCast(target, GetSpell(HOS_1)))
-            {
-				for (Unit::AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
-                    if ((*iter)->getThreatManager().getThreat(target) > 0.f)
-                        (*iter)->getThreatManager().modifyThreatPercent(target, -(30 + 50*(target->HasAura(586)))); //Fade
-                SetSpellCooldown(HOS_1, target->ToCreature() ? 10000 : 25000);
-                return true;
-            }
-            return false;
-        }
-        //Holy_Shock setup (Modify HERE)
-        bool HS(Unit* target, uint32 diff)
-        {
-            if (!target || target->isDead()) return false;
-            if (!IsSpellReady(HOLY_SHOCK_1, diff)) return false;
-            if (IsCasting()) return false;
-            if (target->GetTypeId() == TYPEID_PLAYER && (target->IsCharmed() || target->isPossessed()))
-                return false; //do not damage friends under control
-            if (me->GetExactDist(target) > 40) return false;
-
-            if (doCast(target, GetSpell(HOLY_SHOCK_1)))
-            {
-                if (urand(1,100) > 20) //Daybreak: 20% to not trigger HS CD, only GCD
-                    SetSpellCooldown(HOLY_SHOCK_1, 5000);
-                return true;
-            }
-            return false;
-        }
-
-        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
-        {
-            if (!HasRole(BOT_ROLE_HEAL)) return false;
-            if (!target || target->isDead()) return false;
-            if (hp > 97) return false;
-            //sLog->outBasic("HealTarget() by %s on %s", me->GetName().c_str(), target->GetName().c_str());
-            if (Rand() > 40 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid()) return false;
-            if (me->GetExactDist(target) > 35) return false;
-            if (IsCasting()) return false;
-            if (IsSpellReady(HAND_OF_PROTECTION_1, diff, false) && target->GetTypeId() == TYPEID_PLAYER &&
-                ((master->GetGroup() && master->GetGroup()->IsMember(target->GetGUID())) || target == master) &&
-                ((hp < 30 && !target->getAttackers().empty()) || (hp < 50 && target->getAttackers().size() > 3)) &&
-                me->GetExactDist(target) < 30 &&
-                !HasAuraName(target, HAND_OF_PROTECTION_1) &&
-                !HasAuraName(target, FORBEARANCE_AURA))
-            {
-                if (doCast(target, GetSpell(HAND_OF_PROTECTION_1)))
-                {
-                    me->MonsterWhisper("BOP on you!", target->ToPlayer());
-                    SetSpellCooldown(HAND_OF_PROTECTION_1, 60000); //1 min
-
-                    //debug
-                    if (!HasAuraName(target, FORBEARANCE_AURA))
-                        me->AddAura(FORBEARANCE_AURA, target);
-                    if (HasAuraName(target, FORBEARANCE_AURA) && !HasAuraName(target, HAND_OF_PROTECTION_1))
-                        me->AddAura(GetSpell(HAND_OF_PROTECTION_1), target);
-                }
-                return true;
-            }
-            else if (hp < 20 && !HasAuraName(target, HAND_OF_PROTECTION_1))
-            {
-                // 20% to cast loh, else just do a Shock
-                switch (rand()%3)
-                {
-                    case 1:
-                        if (IsSpellReady(LAY_ON_HANDS_1, diff, false) && hp < 20 &&
-                            target->GetTypeId() == TYPEID_PLAYER &&
-                            (target->IsInCombat() || !target->getAttackers().empty()) &&
-                            !HasAuraName(target, FORBEARANCE_AURA))
-                        {
-                            if (doCast(target, GetSpell(LAY_ON_HANDS_1)))
-                            {
-                                me->MonsterWhisper("Lay of Hands on you!", target->ToPlayer());
-                                SetSpellCooldown(LAY_ON_HANDS_1, 150000); //2.5 min
-                                return true;
-                            }
-                        }
-                    case 2:
-                        if (GC_Timer > diff) return false;
-                        if (doCast(target, GetSpell(FLASH_OF_LIGHT_1), me->HasAura(THE_ART_OF_WAR_BUFF)))
-                            return true;
-                    case 3:
-                        if (GC_Timer > diff) return false;
-                        if (HS(target, diff))
-                            return true;
-                }
-            }
-
-            Unit* u = target->GetVictim();
-            if (IsSpellReady(SACRED_SHIELD_1, diff) && target->GetTypeId() == TYPEID_PLAYER &&
-                (hp < 65 || target->getAttackers().size() > 1 || (u && u->GetMaxHealth() > target->GetMaxHealth()*10 && target->IsInCombat())) &&
-                !HasAuraName(target, SACRED_SHIELD_1) &&
-                ((master->GetGroup() && master->GetGroup()->IsMember(target->GetGUID())) || target == master))
-            {
-                Unit* aff = FindAffectedTarget(GetSpell(SACRED_SHIELD_1), me->GetGUID(), 50, 1);//use players since we cast only on them
-                if ((!aff || (aff->getAttackers().empty() && !IsTank(aff))) &&
-                    doCast(target, GetSpell(SACRED_SHIELD_1)))
-                {
-                    SetSpellCooldown(SACRED_SHIELD_1, 3000);
-                    return true;
-                }
-            }
-            if ((hp < 85 || GetLostHP(target) > 6000))
-                if (HS(target, diff))
-                    return true;
-            if ((hp > 35 && (hp < 75 || GetLostHP(target) > 8000)) || (!GetSpell(FLASH_OF_LIGHT_1) && hp < 85))
-                if (doCast(target, GetSpell(HOLY_LIGHT_1)))
-                    return true;
-            if ((hp < 90 || GetLostHP(target) > 1500))
-                if (doCast(target, GetSpell(FLASH_OF_LIGHT_1), me->HasAura(THE_ART_OF_WAR_BUFF)))
-                    return true;
-            return false;
-        }//end HealTarget
-
-        void StartAttack(Unit* u, bool force = false)
-        {
-            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
-            Aggro(u);
-            SetBotCommandState(COMMAND_ATTACK);
-            GetInPosition(force);
-        }
-
-        void EnterCombat(Unit*) { }
-        void Aggro(Unit*) { }
-        void AttackStart(Unit*) { }
-        void KilledUnit(Unit*) { }
-        void EnterEvadeMode() { }
-        void MoveInLineOfSight(Unit*) { }
-        void JustDied(Unit* u) { bot_ai::JustDied(u); }
-
-
-        void UpdateAI(uint32 diff)
-        {
-            ReduceCD(diff);
-            if (IAmDead()) return;
-            CheckAttackState();
-            CheckAuras();
-            if (wait == 0)
-                wait = GetWait();
-            else
-                return;
-            BreakCC(diff);
-            //HOFTarget(me, diff);//self stun cure goes FIRST
-            if (CCed(me)) return;
-
-            if (GetManaPCT(me) < 30 && Potion_cd <= diff)
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, MANAPOTION))
-                {
-                    Potion_cd = POTION_CD;
-                    GC_Timer = temptimer;
-                }
-            }
-            if (GetManaPCT(me) < 40 && IsSpellReady(DIVINE_PLEA_1, diff, false))
-                if (doCast(me, GetSpell(DIVINE_PLEA_1)))
-                    SetSpellCooldown(DIVINE_PLEA_1, 45000);
-
-            CureTarget(me, GetSpell(CLEANSE_1), diff); //maybe unnecessary but this goes FIRST
-            HOFTarget(master, diff); //maybe unnecessary
-            CureTarget(master,  GetSpell(CLEANSE_1), diff); //maybe unnecessary
-            BuffAndHealGroup(master, diff);
-            HOSTarget(master, diff);
-            CureGroup(master,  GetSpell(CLEANSE_1), diff);
-            HOFGroup(master, diff);
-            HOSGroup(master, diff);
-
-            if (GetHealthPCT(me) < 50 && Potion_cd <= diff)
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, HEALINGPOTION))
-                {
-                    Potion_cd = POTION_CD;
-                    GC_Timer = temptimer;
-                }
-            }
-            if (!me->IsInCombat())
-                DoNonCombatActions(diff);
-            //buff
-            if (IsSpellReady(SEAL_OF_COMMAND_1, diff, false) && Rand() < 20 && !HasAuraName(me, SEAL_OF_COMMAND_1) &&
-                doCast(me, GetSpell(SEAL_OF_COMMAND_1)))
-                GC_Timer = 500;
-
-            // Heal myself
-            if (GetHealthPCT(me) < 80)
-                HealTarget(me, GetHealthPCT(me), diff);
-
-            if (!CheckAttackTarget(CLASS_PALADIN))
-                return;
-
-            Repentance(diff);
-            //Counter(diff);
-            DoNormalAttack(diff);
-        }
-
-        void DoNonCombatActions(uint32 diff)
-        {
-            if (GC_Timer > diff || me->IsMounted())
-                return;
-
-            RezGroup(GetSpell(REDEMPTION_1), master);
-
-            if (Feasting())
-                return;
-
-            //aura
-            if (master->IsAlive() && me->GetExactDist(master) < 20)
-            {
-                uint8 myAura;
-                uint32 DEVOTION_AURA = GetSpell(DEVOTION_AURA_1);
-                uint32 CONCENTRATION_AURA = GetSpell(CONCENTRATION_AURA_1);
-                if (me->HasAura(DEVOTION_AURA, me->GetGUID()))
-                    myAura = DEVOTIONAURA;
-                else if (me->HasAura(CONCENTRATION_AURA, me->GetGUID()))
-                    myAura = CONCENTRATIONAURA;
-                else myAura = NOAURA;
-
-                if (myAura != NOAURA)
-                    return; //do not bother
-
-                Aura* concAura = master->GetAura(CONCENTRATION_AURA);
-                Aura* devAura = master->GetAura(DEVOTION_AURA);
-                if (devAura && concAura) return;
-                if (devAura && devAura->GetCasterGUID() == me->GetGUID()) return;
-                if (concAura && concAura->GetCasterGUID() == me->GetGUID()) return;
-
-                if ((master->getClass() == CLASS_MAGE ||
-                    master->getClass() == CLASS_PRIEST ||
-                    master->getClass() == CLASS_WARLOCK ||
-                    master->getClass() == CLASS_DRUID || devAura) &&
-                    !concAura &&
-                    doCast(me, CONCENTRATION_AURA))
-                {
-                    /*GC_Timer = 800;*/
-                    return;
-                }
-                if (!devAura && doCast(me, DEVOTION_AURA))
-                {
-                    /*GC_Timer = 800;*/
-                    return;
-                }
-            }
-        }
-
-        bool BuffTarget(Unit* target, uint32 diff)
-        {
-            if (!target || target->isDead() || GC_Timer > diff || Rand() > 30) return false;
-            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
-            if (me->GetExactDist(target) > 30) return false;
-            if (HasAuraName(target, BLESSING_OF_WISDOM_1, me->GetGUID()) ||
-                HasAuraName(target, BLESSING_OF_KINGS_1, me->GetGUID()) ||
-                HasAuraName(target, BLESSING_OF_SANCTUARY_1, me->GetGUID()) ||
-                HasAuraName(target, BLESSING_OF_MIGHT_1, me->GetGUID()))
-                return false;
-            //if (HasAuraName(target, "Greater Blessing of Wisdom", me->GetGUID()) ||
-            //    HasAuraName(target, "Greater Blessing of Might", me->GetGUID()) ||
-            //    HasAuraName(target, "Greater Blessing of Kings", me->GetGUID()) ||
-            //    HasAuraName(target, "Greater Blessing of Sanctuary", me->GetGUID()))
-            //    return false;
-
-            uint32 BLESSING_OF_WISDOM = GetSpell(BLESSING_OF_WISDOM_1);
-            uint32 BLESSING_OF_KINGS = GetSpell(BLESSING_OF_KINGS_1);
-            uint32 BLESSING_OF_SANCTUARY = GetSpell(BLESSING_OF_SANCTUARY_1);
-            uint32 BLESSING_OF_MIGHT = GetSpell(BLESSING_OF_MIGHT_1);
-            bool wisdom = HasAuraName(target, BLESSING_OF_WISDOM_1) || HasAuraName(target, GREATER_BLESSING_OF_WISDOM_1);
-            bool kings = HasAuraName(target, BLESSING_OF_KINGS_1) || HasAuraName(target, GREATER_BLESSING_OF_KINGS_1);
-            bool sanctuary = HasAuraName(target, BLESSING_OF_SANCTUARY_1) || HasAuraName(target, GREATER_BLESSING_OF_SANCTUARY_1);
-            bool might = (HasAuraName(target, BLESSING_OF_MIGHT_1) || HasAuraName(target, GREATER_BLESSING_OF_MIGHT_1) || HasAuraName(target, BATTLESHOUT_1));
-
-            uint8 Class = 0;
-            if (target->GetTypeId() == TYPEID_PLAYER)
-                Class = target->ToPlayer()->getClass();
-            else if (target->ToCreature())
-                Class = target->ToCreature()->GetBotClass();
-            switch (Class)
-            {
-                case CLASS_PRIEST:
-                    if (BLESSING_OF_WISDOM && !wisdom && doCast(target, BLESSING_OF_WISDOM))
-                        return true;
-                    else if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
-                        return true;
-                    break;
-                case CLASS_DEATH_KNIGHT:
-                case CLASS_WARRIOR:
-                case CLASS_PALADIN:
-                case CLASS_ROGUE:
-                case CLASS_HUNTER:
-                case CLASS_SHAMAN:
-                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
-                        return true;
-                    else if (!might && doCast(target, BLESSING_OF_MIGHT))
-                        return true;
-                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
-                        return true;
-                    else if (BLESSING_OF_WISDOM && !wisdom && target->getPowerType() == POWER_MANA && doCast(target, BLESSING_OF_WISDOM))
-                        return true;
-                    break;
-                default:
-                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
-                        return true;
-                    else if (BLESSING_OF_WISDOM && !wisdom && target->getPowerType() == POWER_MANA && doCast(target, BLESSING_OF_WISDOM))
-                        return true;
-                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
-                        return true;
-                    else if (!might && doCast(target, BLESSING_OF_MIGHT))
-                        return true;
-                    break;
-            }
-            return false;
-        }
-
-        void Repentance(uint32 diff, Unit* target = NULL)
-        {
-            temptimer = GC_Timer;
-            if (target)
-            {
-                if (IsSpellReady(REPENTANCE_1, diff, false, 25000) && doCast(target, GetSpell(REPENTANCE_1)))
-                    SetSpellCooldown(REPENTANCE_1, 45000);
-            }
-            else if (IsSpellReady(REPENTANCE_1, diff, false))
-            {
-                Unit* u = FindStunTarget();
-                if (u && u->GetVictim() != me && doCast(u, GetSpell(REPENTANCE_1)))
-                    SetSpellCooldown(REPENTANCE_1, 45000);
-            }
-            GC_Timer = temptimer;
-        }
-
-        void Counter(uint32 diff)
-        {
-            if (IsCasting())
-                return;
-            if (Rand() > 60)
-                return;
-
-            Unit* target = IsSpellReady(REPENTANCE_1, diff, false, 25000) ? FindCastingTarget(20, 0, false, REPENTANCE_1) : NULL;
-            if (target)
-                Repentance(diff, target); //first check repentance
-            else if (IsSpellReady(TURN_EVIL_1, diff, false, 1500))
-            {
-                target = FindCastingTarget(20, 0, false, TURN_EVIL_1);
-                temptimer = GC_Timer;
-                if (target && doCast(target, GetSpell(TURN_EVIL_1), true))
-                {
-                    SetSpellCooldown(TURN_EVIL_1, 3000);
-                    GC_Timer = temptimer;
-                }
-            }
-            else if (IsSpellReady(HOLY_WRATH_1, diff, false, 8000) && HasRole(BOT_ROLE_DPS))
-            {
-                target = FindCastingTarget(8, 0, false, TURN_EVIL_1); //here we check target as with turn evil cuz of same requirements
-                temptimer = GC_Timer;
-                if (target && doCast(me, GetSpell(HOLY_WRATH_1)))
-                {
-                    SetSpellCooldown(HOLY_WRATH_1, 23000 - me->getLevel() * 100); //23 - 0...8 sec (15 sec on 80 as with glyph)
-                    GC_Timer = temptimer;
-                }
-            }
-            else if (IsSpellReady(HAMMER_OF_JUSTICE_1, diff, /*true*/false, 7000))
-            {
-                target = FindCastingTarget(10);
-                if (target && doCast(opponent, GetSpell(HAMMER_OF_JUSTICE_1)))
-                    SetSpellCooldown(HAMMER_OF_JUSTICE_1, 65000 - master->getLevel()*500); //25 sec on 80
-            }
-        }
-
-        void TurnEvil(uint32 diff)
-        {
-            if (!IsSpellReady(TURN_EVIL_1, diff) || IsCasting() || Rand() > 50 ||
-                FindAffectedTarget(GetSpell(TURN_EVIL_1), me->GetGUID(), 50))
-                return;
-            Unit* target = FindUndeadCCTarget(20, TURN_EVIL_1);
-            if (target &&
-                (target != me->GetVictim() || GetHealthPCT(me) < 70 || target->GetVictim() == master) &&
-                doCast(target, GetSpell(TURN_EVIL_1), true))
-            {
-                SetSpellCooldown(TURN_EVIL_1, 3000);
-                return;
-            }
-            else
-            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) &&
-                !CCed(opponent) &&
-                opponent->GetVictim() && !IsTank(opponent->GetVictim()) && opponent->GetVictim() != me &&
-                GetHealthPCT(me) < 90 &&
-                doCast(opponent, GetSpell(TURN_EVIL_1), true))
-            {
-                SetSpellCooldown(TURN_EVIL_1, 3000);
-                return;
-            }
-        }
-
-        void Wrath(uint32 diff)
-        {
-            if (!IsSpellReady(HOLY_WRATH_1, diff) || !HasRole(BOT_ROLE_DPS) || Rand() > 50)
-                return;
-            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) &&
-                me->GetExactDist(opponent) <= 8 && doCast(me, GetSpell(HOLY_WRATH_1)))
-                SetSpellCooldown(HOLY_WRATH_1, 23000 - me->getLevel() * 100); //23 - 0...8 sec (15 sec on 80 as with glyph)
-            else
-            {
-                Unit* target = FindUndeadCCTarget(8, GetSpell(HOLY_WRATH_1));
-                if (target && doCast(me, GetSpell(HOLY_WRATH_1)))
-                    SetSpellCooldown(HOLY_WRATH_1, 23000 - me->getLevel() * 100); //23 - 0...8 sec (15 sec on 80 as with glyph)
-            }
-        }
-
-        void DoNormalAttack(uint32 diff)
-        {
-            opponent = me->GetVictim();
-            if (opponent)
-            {
-                if (!IsCasting())
-                    StartAttack(opponent, true);
-            }
-            else
-                return;
-
-            Counter(diff);
-            TurnEvil(diff);
-
-            if (MoveBehind(*opponent))
-                wait = 5;
-
-            //HAMMER OF WRATH //custom GCD check
-            if (IsSpellReady(HOW_1, diff, false) && GC_Timer <= 300 && HasRole(BOT_ROLE_DPS) && Rand() < 30 && GetHealthPCT(opponent) < 19 &&
-                me->GetExactDist(opponent) < 30)
-            {
-                temptimer = GC_Timer;
-                if (doCast(opponent, GetSpell(HOW_1)))
-                {
-                    SetSpellCooldown(HOW_1, 6000); //6 sec
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-            //HAND OF RECKONING //No GCD
-            Unit* u = opponent->GetVictim();
-            if (IsSpellReady(HANDOFRECKONING_1, diff, false) && me->GetExactDist(opponent) < 30 &&
-                HasRole(BOT_ROLE_DPS) && u && u != me && !IsTank(u) && Rand() < 50 &&
-                (IsInBotParty(u) || IsTank()))
-            {
-                Creature* cre = opponent->ToCreature();
-                temptimer = GC_Timer;
-                if (((cre && cre->isWorldBoss() && !IsMeleeClass(u->getClass())) ||
-                    GetHealthPCT(u) < GetHealthPCT(me) - 5 || IsTank()) &&
-                    doCast(opponent, GetSpell(HANDOFRECKONING_1)))
-                {
-                    SetSpellCooldown(HANDOFRECKONING_1, IsTank() ? 4000 : 8000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-
-            if (IsSpellReady(HAMMER_OF_JUSTICE_1, diff) && !CCed(opponent) &&
-                me->GetExactDist(opponent) < 10 && Rand() < 20)
-            {
-                if (doCast(opponent, GetSpell(HAMMER_OF_JUSTICE_1)))
-                {
-                    SetSpellCooldown(HAMMER_OF_JUSTICE_1, 65000 - master->getLevel()*500); //25 sec on 80
-                    return;
-                }
-            }
-
-            if (IsSpellReady(JUDGEMENT_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetExactDist(opponent) < 10 &&
-                Rand() < 50 && me->HasAura(GetSpell(SEAL_OF_COMMAND_1)))
-            {
-                if (doCast(opponent, GetSpell(JUDGEMENT_1)))
-                {
-                    SetSpellCooldown(JUDGEMENT_1, 7000);
-                    return;
-                }
-            }
-
-            if (IsSpellReady(CONSECRATION_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetDistance(opponent) < 7 &&
-                !opponent->isMoving() && Rand() < 50)
-            {
-                if (doCast(me, GetSpell(CONSECRATION_1)))
-                {
-                    SetSpellCooldown(CONSECRATION_1, 8000);
-                    return;
-                }
-            }
-
-            if (IsSpellReady(AVENGING_WRATH_1, diff, false) && HasRole(BOT_ROLE_DPS) &&
-                opponent->GetHealth() > (master->GetMaxHealth()*2)/3 && Rand() < 25)
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, GetSpell(AVENGING_WRATH_1)))
-                {
-                    SetSpellCooldown(AVENGING_WRATH_1, 60000); //1 min
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-
-            if (IsSpellReady(CRUSADER_STRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetDistance(opponent) < 5)
-            {
-                if (doCast(opponent, GetSpell(CRUSADER_STRIKE_1)))
-                {
-                    SetSpellCooldown(CRUSADER_STRIKE_1, 12000 - me->getLevel() * 100);//4 sec on 80
-                    return;
-                }
-            }
-
-            if (IsSpellReady(EXORCISM_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetExactDist(opponent) < 30 &&
-                (!IsTank() || opponent->GetVictim() == me || opponent->IsVehicle() || opponent->ToPlayer()))
-            {
-                if (doCast(opponent, GetSpell(EXORCISM_1), me->HasAura(THE_ART_OF_WAR_BUFF)))
-                {
-                    SetSpellCooldown(EXORCISM_1, 7000);
-                    return;
-                }
-            }
-
-            Wrath(diff);
-
-            if (IsSpellReady(DIVINE_STORM_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetExactDist(opponent) < 7)
-            {
-                if (doCast(opponent, GetSpell(DIVINE_STORM_1)))
-                {
-                    SetSpellCooldown(DIVINE_STORM_1, 10000 - me->getLevel()/4 * 100); //10 - 2 sec
-                    return;
-                }
-            }
-        }
-
-        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
-        {
-            uint32 spellId = spellInfo->Id;
-            uint8 lvl = me->getLevel();
-            float fdamage = float(damage);
-            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
-            if (!crit)
-            {
-                float aftercrit = 0.f;
-                //Fanaticism: 18% additional critical chance for all Judgements (not shure which check is right)
-                if (lvl >= 45 && (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT || spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT))
-                    aftercrit += 18.f;
-
-                if (aftercrit > 0.f)
-                    crit = roll_chance_f(aftercrit);
-            }
-
-            //2) apply bonus damage mods
-            float pctbonus = 0.0f;
-            //if (crit)
-            //{
-            //}
-            //Sanctity of Battle: 15% bonus damage for Exorcism and Crusader Strike
-            if (lvl >= 25 && spellId == GetSpell(EXORCISM_1))
-                pctbonus += 0.15f;
-            //The Art of War (damage part): 10% bonus damage for Judgements, Crusader Strike and Divine Storm
-            if (lvl >= 40 &&
-                (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT ||
-                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT ||
-                spellId == GetSpell(CRUSADER_STRIKE_1) ||
-                spellId == GetSpell(DIVINE_STORM_1)))
-                pctbonus += 0.1f;
-
-            damage = int32(fdamage * (1.0f + pctbonus));
-        }
-
-        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
-        {
-            uint32 spellId = spellInfo->Id;
-            uint8 lvl = me->getLevel();
-            float fdamage = float(damage);
-            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
-            if (!crit)
-            {
-                float aftercrit = 0.f;
-                //Sanctified Wrath: 50% additional critical chance for Hammer of Wrath
-                if (lvl >= 45 && spellId == GetSpell(HOW_1))
-                    aftercrit += 50.f;
-
-                if (aftercrit > 0.f)
-                    crit = roll_chance_f(aftercrit);
-            }
-
-            //2) apply bonus damage mods
-            float pctbonus = 0.0f;
-            //if (crit)
-            //{
-            //}
-
-            damage = int32(fdamage * (1.0f + pctbonus));
-        }
-
-        void SpellHitTarget(Unit* target, SpellInfo const* spell)
-        {
-            uint32 spellId = spell->Id;
-
-            if ((spellId == GetSpell(EXORCISM_1) || spellId == GetSpell(FLASH_OF_LIGHT_1)) &&
-                me->HasAura(THE_ART_OF_WAR_BUFF))
-            {
-                //Art of War: consume buff
-                me->RemoveAura(THE_ART_OF_WAR_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
-            }
-
-            if (spellId == GetSpell(BLESSING_OF_KINGS_1) || spellId == GetSpell(BLESSING_OF_MIGHT_1) ||
-                spellId == GetSpell(BLESSING_OF_WISDOM_1) || spellId == GetSpell(BLESSING_OF_SANCTUARY_1))
-            {
-                //Blessings duration 1h
-                if (Aura* bless = target->GetAura(spellId, me->GetGUID()))
-                {
-                    uint32 dur = HOUR * IN_MILLISECONDS;
-                    bless->SetDuration(dur);
-                    bless->SetMaxDuration(dur);
-                }
-            }
-            if (spellId == GetSpell(HOF_1))
-            {
-                //Guardian's Favor part 2 (handled separately)
-                if (Aura* hof = target->GetAura(spellId, me->GetGUID()))
-                {
-                    uint32 dur = hof->GetDuration() + 4000;
-                    hof->SetDuration(dur);
-                    hof->SetMaxDuration(dur);
-                }
-            }
-        }
-
-        void SpellHit(Unit* caster, SpellInfo const* spell)
-        {
-            OnSpellHit(caster, spell);
-        }
-
-		void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType, SpellSchoolMask)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
-        {
-            //Custom OnHit() handlers
-
-            if (damageType == DIRECT_DAMAGE)
-            {
-                //The Art of War: 20% on autoattack
-                if (me->getLevel() >= 33)
-                    if (urand(1,100) <= 20)
-                        me->CastSpell(me, THE_ART_OF_WAR_BUFF, true);
-            }
-
-            if (victim == me)
-                return;
-
-            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
-            {
-                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
-                {
-                    if (_ctc[i].first && !_ctc[i].second)
-                    {
-                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
-                            _ctc[i].second = 1000;
-
-                        if (_ctc[i].second > 0)
-                            me->CastSpell(victim, _ctc[i].first, true);
-                    }
-                }
-            }
-        }
-
-        void OwnerAttackedBy(Unit* u)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void Reset()
-        {
-            if (master)
-            {
-                SetStats(true);
-                InitRoles();
-                ApplyPassives(CLASS_PALADIN);
-            }
-        }
-
-        void ReduceCD(uint32 diff)
-        {
-            CommonTimers(diff);
-            SpellTimers(diff);
-        }
-
-        bool CanRespawn()
-        {return false;}
-
-        void InitSpells()
-        {
-            uint8 lvl = me->getLevel();
-            InitSpellMap(FLASH_OF_LIGHT_1);
-            InitSpellMap(HOLY_LIGHT_1);
-            InitSpellMap(LAY_ON_HANDS_1);
-            InitSpellMap(SACRED_SHIELD_1);
-  /*Talent*/lvl >= 40 ? InitSpellMap(HOLY_SHOCK_1) : RemoveSpell(HOLY_SHOCK_1);
-            InitSpellMap(CLEANSE_1);
-            InitSpellMap(REDEMPTION_1);
-            InitSpellMap(HAMMER_OF_JUSTICE_1);
-  /*Talent*/lvl >= 45 ? InitSpellMap(REPENTANCE_1) : RemoveSpell(REPENTANCE_1);
-            InitSpellMap(TURN_EVIL_1);
-            InitSpellMap(HOLY_WRATH_1);
-            InitSpellMap(EXORCISM_1);
-  /*Talent*/lvl >= 25 ? InitSpellMap(SEAL_OF_COMMAND_1) : RemoveSpell(SEAL_OF_COMMAND_1);
-  /*Talent*/lvl >= 20 ? InitSpellMap(CRUSADER_STRIKE_1) : RemoveSpell(CRUSADER_STRIKE_1);
-            InitSpellMap(JUDGEMENT_1);
-            InitSpellMap(CONSECRATION_1);
-  /*Talent*/lvl >= 60 ? InitSpellMap(DIVINE_STORM_1) : RemoveSpell(DIVINE_STORM_1);
-            InitSpellMap(HOW_1);
-            InitSpellMap(AVENGING_WRATH_1);
-            InitSpellMap(BLESSING_OF_MIGHT_1);
-            InitSpellMap(BLESSING_OF_WISDOM_1);
-            InitSpellMap(BLESSING_OF_KINGS_1);
-  /*Talent*/lvl >= 30 ? InitSpellMap(BLESSING_OF_SANCTUARY_1) : RemoveSpell(BLESSING_OF_SANCTUARY_1);
-            InitSpellMap(DEVOTION_AURA_1);
-            InitSpellMap(CONCENTRATION_AURA_1);
-            InitSpellMap(DIVINE_PLEA_1);
-            InitSpellMap(HAND_OF_PROTECTION_1);
-            InitSpellMap(HOF_1);
-            InitSpellMap(HOS_1);
-            InitSpellMap(HANDOFRECKONING_1);
-        }
-
-        void ApplyClassPassives()
-        {
-            uint8 level = master->getLevel();
-            //1 - SPD 3% crit 3%
-            if (level >= 78)
-                RefreshAura(SPELLDMG,5); //+15%
-            else if (level >= 75)
-                RefreshAura(SPELLDMG,4); //+12%
-            else if (level >= 55)
-                RefreshAura(SPELLDMG,3); //+9%
-            else if (level >= 35)
-                RefreshAura(SPELLDMG,2); //+6%
-            else if (level >= 15)
-                RefreshAura(SPELLDMG); //+3%
-            //2 - SPD 6%
-            if (level >= 55)
-                RefreshAura(SPELLDMG2,3); //+18%
-            else if (level >= 35)
-                RefreshAura(SPELLDMG2,2); //+12%
-            else if (level >= 15)
-                RefreshAura(SPELLDMG2); //+6%
-            //Talents
-            if (level >= 55)
-                RefreshAura(PURE1);
-            if (level >= 35)
-                RefreshAura(WISE);
-            if (level >= 50)
-                RefreshAura(RECKONING5); //10%
-            else if (level >= 45)
-                RefreshAura(RECKONING4); //8%
-            else if (level >= 40)
-                RefreshAura(RECKONING3); //6%
-            else if (level >= 35)
-                RefreshAura(RECKONING2); //4%
-            else if (level >= 30)
-                RefreshAura(RECKONING1); //2%
-            //if (level >= 50)
-            //    RefreshAura(RIGHTEOUS_VENGEANCE3);
-            //else if (level >= 47)
-            //    RefreshAura(RIGHTEOUS_VENGEANCE2);
-            //else if (level >= 45)
-            //    RefreshAura(RIGHTEOUS_VENGEANCE1);
-            if (level >= 30)
-                RefreshAura(VENGEANCE3);
-            else if (level >= 27)
-                RefreshAura(VENGEANCE2);
-            else if (level >= 25)
-                RefreshAura(VENGEANCE1);
-            if (level >= 60)
-                RefreshAura(SHOFL3);
-            else if (level >= 55)
-                RefreshAura(SHOFL2);
-            else if (level >= 50)
-                RefreshAura(SHOFL1);
-            if (level >= 45)
-                RefreshAura(SACRED_CLEANSING);
-            if (level >= 35)
-                RefreshAura(DIVINE_PURPOSE);
-            if (level >= 25)
-                RefreshAura(VINDICATION2);
-            else if (level >= 20)
-                RefreshAura(VINDICATION1);
-            if (level >= 30)
-                RefreshAura(LAYHANDS);
-            if (level >= 20)
-                RefreshAura(FANATICISM,2); //-60% aggro
-            if (level >= 15)
-                RefreshAura(GLYPH_HOLY_LIGHT); //10% heal
-            //if (level >= 70)
-            //    RefreshAura(PALADIN_T9_2P_BONUS); //Righteous Vengeance Crits
-        }
-
-        bool CanUseManually(uint32 basespell) const
-        {
-            switch (basespell)
-            {
-                case FLASH_OF_LIGHT_1:
-                case HOLY_LIGHT_1:
-                case LAY_ON_HANDS_1:
-                case HOF_1:
-                case SACRED_SHIELD_1:
-                case HOLY_SHOCK_1:
-                case CLEANSE_1:
-                case HAND_OF_PROTECTION_1:
-                case HOS_1:
-                case SEAL_OF_COMMAND_1:
-                case DIVINE_PLEA_1:
-                case AVENGING_WRATH_1:
-                case BLESSING_OF_MIGHT_1:
-                case BLESSING_OF_WISDOM_1:
-                case BLESSING_OF_KINGS_1:
-                case BLESSING_OF_SANCTUARY_1:
-                    return true;
-                default:
-                    return false;
-            }
-        }
-
-    private:
-
-        enum PaladinBaseSpells// all orignals
-        {
-            FLASH_OF_LIGHT_1                    = 19750,
-            HOLY_LIGHT_1                        = 635,
-            LAY_ON_HANDS_1                      = 633,
-            REDEMPTION_1                        = 7328,
-            HOF_1  /*Hand of Freedom*/          = 1044,
-            SACRED_SHIELD_1                     = 53601,
-            HOLY_SHOCK_1                        = 20473,
-            CLEANSE_1                           = 4987,
-            HAND_OF_PROTECTION_1                = 1022,
-            HOS_1 /*Hand of salvation*/         = 1038,
-            SEAL_OF_COMMAND_1                   = 20375,
-            HANDOFRECKONING_1                   = 62124,
-            DIVINE_PLEA_1                       = 54428,
-            REPENTANCE_1                        = 20066,
-            TURN_EVIL_1                         = 10326,
-            CRUSADER_STRIKE_1                   = 35395,
-            JUDGEMENT_1                         = 20271,
-            CONSECRATION_1                      = 26573,
-            HAMMER_OF_JUSTICE_1                 = 853,
-            DIVINE_STORM_1                      = 53385,
-            HOW_1   /*Hammer of Wrath*/         = 24275,
-            EXORCISM_1                          = 879,
-            HOLY_WRATH_1                        = 2812,
-            AVENGING_WRATH_1                    = 31884,
-            BLESSING_OF_MIGHT_1                 = 19740,
-            BLESSING_OF_WISDOM_1                = 19742,
-            BLESSING_OF_KINGS_1                 = 20217,
-            BLESSING_OF_SANCTUARY_1             = 20911,
-            DEVOTION_AURA_1                     = 465,
-            CONCENTRATION_AURA_1                = 19746
-        };
-        enum PaladinPassives
-        {
-        //Talents
-            DIVINE_PURPOSE                      = 31872,
-            PURE1                               = 54155, /*Judgements of the Pure*/
-            WISE                                = 31878, /*Judgements of the Wise*/
-            SACRED_CLEANSING                    = 53553,//rank 3
-            RECKONING1                          = 20177,
-            RECKONING2                          = 20179,
-            RECKONING3                          = 20181,
-            RECKONING4                          = 20180,
-            RECKONING5                          = 20182,
-            VINDICATION1                        = 9452 ,//rank 1
-            VINDICATION2                        = 26016,//rank 2
-            LAYHANDS                            = 20235, /*Improved LOH rank 2*/
-            FANATICISM                          = 31881,//rank 3
-            //RIGHTEOUS_VENGEANCE1                = 53380,//rank 1
-            //RIGHTEOUS_VENGEANCE2                = 53381,//rank 2
-            //RIGHTEOUS_VENGEANCE3                = 53382,//rank 3
-            VENGEANCE1                          = 20049,//rank 1
-            VENGEANCE2                          = 20056,//rank 2
-            VENGEANCE3                          = 20057,//rank 3
-            SHOFL1                              = 53501,//Sheath of Light rank 1
-            SHOFL2                              = 53502,//rank 2
-            SHOFL3                              = 53503,//rank 3
-        //Glyphs
-            GLYPH_HOLY_LIGHT                    = 54937,
-        //other
-            SPELLDMG/*Arcane Instability-mage*/ = 15060,//rank3 3% dam/crit
-            SPELLDMG2/*Earth and Moon - druid*/ = 48511 //rank3 6% dam
-        };
-
-        enum PaladinSpecial
-        {
-            NOAURA,
-            DEVOTIONAURA,
-            CONCENTRATIONAURA,
-
-            THE_ART_OF_WAR_BUFF                 = 59578,
-            FORBEARANCE_AURA                    = 25771,
-
-            GREATER_BLESSING_OF_MIGHT_1         = 25782,
-            GREATER_BLESSING_OF_WISDOM_1        = 25894,
-            GREATER_BLESSING_OF_KINGS_1         = 25898,
-            GREATER_BLESSING_OF_SANCTUARY_1     = 25899,
-            BATTLESHOUT_1                       = 6673
-        };
-    };
-};
-
-void AddSC_paladin_bot()
-{
-    new paladin_bot();
-}
diff --git a/src/server/game/AI/NpcBots/bot_priest_ai.cpp b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
deleted file mode 100644
index 326cc1b..0000000
--- a/src/server/game/AI/NpcBots/bot_priest_ai.cpp
+++ /dev/null
@@ -1,1043 +0,0 @@
-#include "bot_ai.h"
-#include "Group.h"
-#include "Player.h"
-#include "ScriptMgr.h"
-#include "SpellAuras.h"
-#include "WorldSession.h"
-#include "SpellInfo.h"
-/*
-Priest NpcBot (reworked by Graff onlysuffering@gmail.com)
-Complete - Around 50%
-TODO: maybe remove Divine Spirit or so, too much buffs
-*/
-class priest_bot : public CreatureScript
-{
-public:
-    priest_bot() : CreatureScript("priest_bot") { }
-
-    CreatureAI* GetAI(Creature* creature) const
-    {
-        return new priest_botAI(creature);
-    }
-
-    bool OnGossipHello(Player* player, Creature* creature)
-    {
-        return bot_minion_ai::OnGossipHello(player, creature);
-    }
-
-    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
-    {
-        if (bot_minion_ai* ai = creature->GetBotMinionAI())
-            return ai->OnGossipSelect(player, creature, sender, action);
-        return true;
-    }
-
-    struct priest_botAI : public bot_minion_ai
-    {
-        priest_botAI(Creature* creature) : bot_minion_ai(creature) { }
-
-        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
-        {
-            if (CheckBotCast(victim, spellId, CLASS_PRIEST) != SPELL_CAST_OK)
-                return false;
-            return bot_ai::doCast(victim, spellId, triggered);
-        }
-
-        bool MassGroupHeal(Player* player, uint32 diff)
-        {
-            if (!player->GetGroup()) return false;
-            if (IsCasting()) return false;
-            if (Rand() > 35) return false;
-
-            if (IsSpellReady(DIVINE_HYMN_1, diff, false))
-            {
-                Group* gr = player->GetGroup();
-                uint8 LHPcount = 0;
-                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
-                {
-                    Player* tPlayer = itr->GetSource();
-                    if (!tPlayer || !tPlayer->IsInWorld() || me->GetMap() != tPlayer->FindMap() ||
-                        tPlayer->IsBeingTeleported() || tPlayer->isPossessed() || tPlayer->IsCharmed()) continue;
-                    if (tPlayer->IsAlive())
-                    {
-                        if (me->GetExactDist(tPlayer) > 35) continue;
-                        uint8 pct = 50 + tPlayer->getAttackers().size()*10;
-                        pct = pct < 80 ? pct : 80;
-                        if (GetHealthPCT(tPlayer) < pct && GetLostHP(tPlayer) > 4000)
-                            ++LHPcount;
-                    }
-                    if (LHPcount > 1)
-                        break;
-                    if (!tPlayer->HaveBot()) continue;
-                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
-                    {
-                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
-                        if (bot && GetHealthPCT(bot) < 40 && me->GetExactDist(bot) < 30)
-                            ++LHPcount;
-                        if (LHPcount > 1)
-                            break;
-                    }
-                }
-                if (LHPcount > 1 && doCast(me, GetSpell(DIVINE_HYMN_1)))
-                {
-                    SetSpellCooldown(DIVINE_HYMN_1, 180000); //3 min
-                    return true;
-                }
-            }
-            if (GetSpell(PRAYER_OF_HEALING_1))
-            {
-                Group* gr = player->GetGroup();
-                Unit* castTarget = NULL;
-                uint8 LHPcount = 0;
-                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
-                {
-                    uint8 lowestPCT = 100;
-                    Player* tPlayer = itr->GetSource();
-                    if (!tPlayer || !tPlayer->IsInWorld() || me->GetMap() != tPlayer->GetMap() ||
-                        tPlayer->IsBeingTeleported() || tPlayer->isPossessed() || tPlayer->IsCharmed()) continue;
-                    if (tPlayer->IsAlive())
-                    {
-                        if (me->GetExactDist(tPlayer) > 25) continue;
-                        if (GetHealthPCT(tPlayer) < 85)
-                        {
-                            ++LHPcount;
-                            if (GetHealthPCT(tPlayer) < lowestPCT)
-                            lowestPCT = GetHealthPCT(tPlayer);
-                            castTarget = tPlayer;
-                        }
-                    }
-                    if (LHPcount > 2)
-                        break;
-                    if (!tPlayer->HaveBot()) continue;
-                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
-                    {
-                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
-                        if (bot && GetHealthPCT(bot) < 70 && me->GetExactDist(bot) < 15)
-                        {
-                            ++LHPcount;
-                            if (GetHealthPCT(bot) < lowestPCT)
-                            lowestPCT = GetHealthPCT(bot);
-                            castTarget = bot;
-                        }
-                        if (LHPcount > 2)
-                            break;
-                    }
-                }
-
-                if (LHPcount > 2 && castTarget && doCast(castTarget, GetSpell(PRAYER_OF_HEALING_1)))
-                    return true;
-            }
-
-            return false;
-        }
-
-        bool ShieldTarget(Unit* target, uint32 diff)
-        {
-            if (!IsSpellReady(PW_SHIELD_1, diff, false) || IsCasting() || Rand() > 50)
-                return false;
-            if (me->GetExactDist(target) > 40)
-                return false;
-            if (target->getAttackers().empty() && GetHealthPCT(target) > 33 &&
-                !target->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
-                return false;
-            if (target->HasAura(WEAKENED_SOUL_DEBUFF) || HasAuraName(target, PW_SHIELD_1))
-                return false;
-
-            if (doCast(target, GetSpell(PW_SHIELD_1)))
-            {
-                if (me->getLevel() >= 30 || (target->ToCreature() && target->ToCreature()->GetBotAI()))
-                    SetSpellCooldown(PW_SHIELD_1, 1000);
-                else
-                    SetSpellCooldown(PW_SHIELD_1, 4000);
-                GC_Timer = 800;
-                return true;
-            }
-            return false;
-        }
-
-        void StartAttack(Unit* u, bool force = false)
-        {
-            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
-            Aggro(u);
-            SetBotCommandState(COMMAND_ATTACK);
-            GetInPosition(force);
-        }
-
-        void EnterCombat(Unit*) { }
-        void Aggro(Unit*) { }
-        void AttackStart(Unit*) { }
-        void KilledUnit(Unit*) { }
-        void EnterEvadeMode() { }
-        void MoveInLineOfSight(Unit*) { }
-        void JustDied(Unit* u) { bot_ai::JustDied(u); }
-
-        void UpdateAI(uint32 diff)
-        {
-            ReduceCD(diff);
-            if (IAmDead()) return;
-            CheckAttackState();
-            CheckAuras();
-            if (wait == 0)
-                wait = GetWait();
-            else
-                return;
-            Disperse(diff);
-            BreakCC(diff);
-            if (CCed(me)) return;
-            DoDevCheck(diff);
-
-            if (GetManaPCT(me) < 33 && Potion_cd <= diff)
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, MANAPOTION))
-                {
-                    Potion_cd = POTION_CD;
-                    GC_Timer = temptimer;
-                }
-            }
-            //check possible fear
-            doDefend(diff);
-            //buff and heal master's group
-            MassGroupHeal(master, diff);
-            BuffAndHealGroup(master, diff);
-            CureGroup(master, DISPELMAGIC, diff);
-            CureGroup(master, GetSpell(CURE_DISEASE_1), diff);
-            //ShieldGroup(master);
-            if (master->IsInCombat() || me->IsInCombat())
-            {
-                CheckDispel(diff);
-                CheckSilence(diff);
-            }
-
-            if (me->IsInCombat())
-                CheckShackles(diff);
-            else
-                DoNonCombatActions(diff);
-
-            if (!CheckAttackTarget(CLASS_PRIEST))
-                return;
-
-			Unit::AttackerSet m_attackers = master->getAttackers();
-			Unit::AttackerSet b_attackers = me->getAttackers();
-
-            if (GetHealthPCT(master) > 90 && GetManaPCT(me) > 35 && GetHealthPCT(me) > 90 &&
-                (m_attackers.size() < 4 || b_attackers.size() + m_attackers.size() < 3) &&
-                !IsCasting())
-                //general rule
-            {
-                opponent = me->GetVictim();
-                if (opponent)
-                {
-                    if (!IsCasting())
-                        StartAttack(opponent);
-                }
-                else
-                    return;
-                float dist = me->GetExactDist(opponent);
-                if (HasRole(BOT_ROLE_DPS) && dist < 30)
-                {
-                    if (IsSpellReady(SW_DEATH_1, diff, false) && Rand() < 50 &&
-                        (GetHealthPCT(opponent) < 15 || opponent->GetHealth() < me->GetMaxHealth()/6) &&
-                        doCast(opponent, GetSpell(SW_DEATH_1)))
-                    {
-                        SetSpellCooldown(SW_DEATH_1, 8000);
-                        return;
-                    }
-                    if (IsSpellReady(SW_PAIN_1, diff) && Rand() < 25 &&
-                        opponent->GetHealth() > me->GetMaxHealth()/4 &&
-                        !HasAuraName(opponent, SW_PAIN_1, me->GetGUID()) &&
-                        doCast(opponent, GetSpell(SW_PAIN_1)))
-                        return;
-                    if (IsSpellReady(VAMPIRIC_TOUCH_1, diff) && Rand() < 50 &&
-                        opponent->GetHealth() > me->GetMaxHealth()/4 &&
-                        !HasAuraName(opponent, VAMPIRIC_TOUCH_1, me->GetGUID()) &&
-                        doCast(opponent, GetSpell(VAMPIRIC_TOUCH_1)))
-                        return;
-                    if (IsSpellReady(DEVOURING_PLAGUE_1, diff) && !Devcheck && Rand() < 30 &&
-                        opponent->GetHealth() > me->GetMaxHealth()/3 &&
-                        !HasAuraName(opponent, DEVOURING_PLAGUE_1, me->GetGUID()) &&
-                        doCast(opponent, GetSpell(DEVOURING_PLAGUE_1)))
-                        return;
-                    if (IsSpellReady(MIND_BLAST_1, diff) && Rand() < 35 &&
-                        (!GetSpell(VAMPIRIC_TOUCH_1) || HasAuraName(opponent, VAMPIRIC_TOUCH_1, me->GetGUID())) &&
-                        doCast(opponent, GetSpell(MIND_BLAST_1)))
-                    {
-                        SetSpellCooldown(MIND_BLAST_1, 6000);
-                        return;
-                    }
-                    if (IsSpellReady(MIND_FLAY_1, diff, false) && !me->isMoving() && Rand() < 20 &&
-                        (opponent->isMoving() || opponent->GetHealth() < me->GetMaxHealth()/5 ||
-                        (HasAuraName(opponent, SW_PAIN_1, me->GetGUID()) && HasAuraName(opponent, DEVOURING_PLAGUE_1, me->GetGUID()))) &&
-                        doCast(opponent, GetSpell(MIND_FLAY_1)))
-                    {
-                        SetSpellCooldown(MIND_FLAY_1, 2500);
-                        return;
-                    }
-                    if (IsSpellReady(MIND_SEAR_1, diff, false) && !me->isMoving() && !opponent->isMoving() && dist < 35 && Rand() < 50 &&
-                        HasAuraName(opponent, SW_PAIN_1, me->GetGUID()) &&
-                        HasAuraName(opponent, DEVOURING_PLAGUE_1, me->GetGUID()))
-                    {
-                        if (Unit* u = FindSplashTarget(30, opponent))
-                            if (doCast(u, GetSpell(MIND_SEAR_1)))
-                                return;
-                    }
-                }//endif opponent
-            }//endif damage
-            //check horror after dots/damage
-            if (IsSpellReady(PSYCHIC_HORROR_1, diff, false) &&
-                opponent->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
-                opponent->GetHealth() > me->GetMaxHealth()/5 && !CCed(opponent) && Rand() < 30 &&
-                me->GetExactDist(opponent) < 30 && !HasAuraName(opponent, PSYCHIC_HORROR_1))
-            {
-                if (doCast(opponent, GetSpell(PSYCHIC_HORROR_1)))
-                {
-                    SetSpellCooldown(PSYCHIC_HORROR_1, 60000);
-                    return;
-                }
-            }
-        }//end UpdateAI
-
-        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
-        {
-            if (!HasRole(BOT_ROLE_HEAL))
-                return false;
-            if (hp > 98)
-                return false;
-            if (!target || !target->IsAlive() || me->GetExactDist(target) > 40)
-                return false;
-            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid())
-                return false;
-
-            //GUARDIAN SPIRIT
-            if (IsSpellReady(GUARDIAN_SPIRIT_1, diff, false) && target->IsInCombat() &&
-                !target->getAttackers().empty() && hp < (5 + std::min(20, uint8(target->getAttackers().size())*5)) &&
-                ((master->GetGroup() && master->GetGroup()->IsMember(target->GetGUID())) || target == master) &&
-                Rand() < 80 && !target->HasAura(GetSpell(GUARDIAN_SPIRIT_1)))
-            {
-                temptimer = GC_Timer;
-                if (me->IsNonMeleeSpellCast(false))
-                    me->InterruptNonMeleeSpells(false);
-                if (doCast(target, GetSpell(GUARDIAN_SPIRIT_1)))
-                {
-                    GC_Timer = temptimer;
-                    if (target->GetTypeId() == TYPEID_PLAYER)
-                    {
-                        me->MonsterWhisper("Guardian Spirit on you!", target->ToPlayer());
-                        SetSpellCooldown(GUARDIAN_SPIRIT_1, 90000); //1.5 min
-                    }
-                    else
-                    {
-                        std::ostringstream msg;
-                        msg << "Guardian Spirit on " << (target == me ? "myself" : target->GetName()) << '!';
-                        me->MonsterWhisper(msg.str().c_str(), master);
-                        SetSpellCooldown(GUARDIAN_SPIRIT_1, 30000); //30 sec for creatures
-                    }
-
-                    return true;
-                }
-            }
-
-            if (IsCasting()) return false;
-
-            //PAIN SUPPRESSION
-            if (hp < 35 && IsSpellReady(PAIN_SUPPRESSION_1, diff, false) &&
-                (target->IsInCombat() || !target->getAttackers().empty()) && Rand() < 50 &&
-                !target->HasAura(GetSpell(PAIN_SUPPRESSION_1)))
-            {
-                if (me->IsNonMeleeSpellCast(false))
-                    me->InterruptNonMeleeSpells(false);
-                temptimer = GC_Timer;
-                if (doCast(target, GetSpell(PAIN_SUPPRESSION_1)))
-                {
-                    GC_Timer = temptimer;
-                    if (target->GetTypeId() == TYPEID_PLAYER)
-                    {
-                        me->MonsterWhisper("Pain Suppression on you!", target->ToPlayer());
-                        SetSpellCooldown(PAIN_SUPPRESSION_1, 60000); //60 sec
-                    }
-                    else
-                    {
-                        std::ostringstream msg;
-                        msg << "Guardin Spirit on " << (target == me ? "myself" : target->GetName()) << '!';
-                        me->MonsterWhisper(msg.str().c_str(), master);
-                        SetSpellCooldown(PAIN_SUPPRESSION_1, 15000); //15 sec for creatures
-                    }
-
-                    return true;
-                }
-            }
-
-            //Now Heals Requires GCD
-            if ((hp < 80 || !target->getAttackers().empty()) &&
-                ShieldTarget(target, diff))
-                return true;
-
-            //PENANCE/Greater Heal
-            if (hp < 75 || GetLostHP(target) > 4000)
-            {
-                if (IsSpellReady(PENANCE_1, diff, false) && !me->isMoving() && Rand() < 80 &&
-                    (target->GetTypeId() != TYPEID_PLAYER ||
-                    !(target->ToPlayer()->IsCharmed() || target->ToPlayer()->isPossessed())) &&
-                    doCast(target, GetSpell(PENANCE_1)))
-                {
-                    SetSpellCooldown(PENANCE_1, 8000);
-                    return true;
-                }
-                else if (HEAL && Heal_Timer <= diff && GC_Timer <= diff && hp > 50 && Rand() < 70 &&
-                    doCast(target, HEAL))
-                {
-                    Heal_Timer = 2500;
-                    return true;
-                }
-            }
-            //Flash Heal
-            if (IsSpellReady(FLASH_HEAL_1, diff) &&
-                ((hp > 75 && hp < 90) || hp < 50 || GetLostHP(target) > 1500) &&
-                doCast(target, GetSpell(FLASH_HEAL_1)))
-                return true;
-            //maintain HoTs
-            Unit* u = target->GetVictim();
-            Creature* boss = u && u->ToCreature() && u->ToCreature()->isWorldBoss() ? u->ToCreature() : NULL;
-            bool tanking = IsTank(target) && boss;
-            //Renew
-            if (IsSpellReady(RENEW_1, diff) &&
-                ((hp < 98 && hp > 70) || GetLostHP(target) > 500 || tanking) &&
-                !HasAuraName(target, RENEW_1, me->GetGUID()) &&
-                doCast(target, GetSpell(RENEW_1)))
-            {
-                GC_Timer = 800;
-                return true;
-            }
-
-            return false;
-        }
-
-        bool BuffTarget(Unit* target, uint32 diff)
-        {
-            if (!target || !target->IsInWorld() || target->isDead() ||
-                GC_Timer > diff || me->GetExactDist(target) > 30 || Rand() > 20)
-                return false;
-
-            if (IsSpellReady(FEAR_WARD_1, false) && !target->HasAura(GetSpell(FEAR_WARD_1)) &&
-                doCast(target, GetSpell(FEAR_WARD_1)))
-            {
-                SetSpellCooldown(FEAR_WARD_1, target->GetTypeId() == TYPEID_PLAYER ? 60000 : 30000); //30sec for bots
-                GC_Timer = 800;
-                return true;
-            }
-
-            if (target == me)
-            {
-                uint32 INNER_FIRE = GetSpell(INNER_FIRE_1);
-                if (INNER_FIRE && !me->HasAura(INNER_FIRE) &&
-                    doCast(me, INNER_FIRE))
-                {
-                    GC_Timer = 800;
-                    return true;
-                }
-                uint32 VAMPIRIC_EMBRACE = GetSpell(VAMPIRIC_EMBRACE_1);
-                if (VAMPIRIC_EMBRACE && !me->HasAura(VAMPIRIC_EMBRACE) &&
-                    doCast(me, VAMPIRIC_EMBRACE))
-                {
-                    GC_Timer = 800;
-                    return true;
-                }
-            }
-
-            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
-
-            if (uint32 PW_FORTITUDE = GetSpell(PW_FORTITUDE_1))
-            {
-                if (!HasAuraName(target, PW_FORTITUDE) &&
-                    doCast(target, PW_FORTITUDE))
-                {
-                    /*GC_Timer = 800;*/
-                    return true;
-                }
-            }
-            if (uint32 SHADOW_PROTECTION = GetSpell(SHADOW_PROTECTION_1))
-            {
-                if (!HasAuraName(target, SHADOW_PROTECTION) &&
-                    doCast(target, SHADOW_PROTECTION))
-                {
-                    /*GC_Timer = 800;*/
-                    return true;
-                }
-            }
-            if (uint32 DIVINE_SPIRIT = GetSpell(DIVINE_SPIRIT_1))
-            {
-                if (!HasAuraName(target, DIVINE_SPIRIT) &&
-                    doCast(target, DIVINE_SPIRIT))
-                {
-                    /*GC_Timer = 800;*/
-                    return true;
-                }
-            }
-
-            return false;
-        }
-
-        void DoNonCombatActions(uint32 diff)
-        {
-            if (GC_Timer > diff || me->IsMounted() || Rand() > 50)
-                return;
-
-            RezGroup(GetSpell(RESURRECTION_1), master);
-
-            //if (Feasting())
-            //    return;
-
-            //if (BuffTarget(master, diff))
-            //    return;
-            //if (BuffTarget(me, diff))
-            //    return;
-        }
-
-        void CheckDispel(uint32 diff)
-        {
-            if (!DISPELMAGIC || CheckDispelTimer > diff || Rand() > 25 || IsCasting())
-                return;
-
-            Unit* target = FindHostileDispelTarget();
-            if (target && doCast(target, DISPELMAGIC))
-                CheckDispelTimer = 1000;
-
-            CheckDispelTimer = 3000; //fail
-        }
-
-        void CheckShackles(uint32 diff)
-        {
-            if (!IsSpellReady(SHACKLE_UNDEAD_1, diff) || IsCasting() || Rand() > 50)
-                return;
-
-            uint32 SHACKLE_UNDEAD = GetSpell(SHACKLE_UNDEAD_1);
-            if (FindAffectedTarget(SHACKLE_UNDEAD, me->GetGUID()))
-            {
-                Shackle_Timer = 1500;
-                return;
-            }
-            Unit* target = FindUndeadCCTarget(30, SHACKLE_UNDEAD);
-            if (target && doCast(target, SHACKLE_UNDEAD))
-            {
-                Shackle_Timer = 3000;
-                GC_Timer = 800;
-            }
-        }
-
-        void CheckSilence(uint32 diff)
-        {
-            if (IsCasting()) return;
-            temptimer = GC_Timer;
-            if (IsSpellReady(SILENCE_1, diff, false))
-            {
-                if (Unit* target = FindCastingTarget(30))
-                    if (doCast(target, GetSpell(SILENCE_1)))
-                        SetSpellCooldown(SILENCE_1, 30000);
-            }
-            else if (IsSpellReady(PSYCHIC_HORROR_1, diff, false, 20000))
-            {
-                if (Unit* target = FindCastingTarget(30))
-                    if (doCast(target, GetSpell(PSYCHIC_HORROR_1)))
-                        SetSpellCooldown(PSYCHIC_HORROR_1, 60000);
-            }
-            GC_Timer = temptimer;
-        }
-
-        void doDefend(uint32 diff)
-        {
-			Unit::AttackerSet m_attackers = master->getAttackers();
-			Unit::AttackerSet b_attackers = me->getAttackers();
-
-            //fear master's attackers
-            if (IsSpellReady(PSYCHIC_SCREAM_1, diff, false))
-            {
-                if (!m_attackers.empty() && (!IsTank(master) || GetHealthPCT(master) < 75))
-                {
-                    uint8 tCount = 0;
-					for (Unit::AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
-                    {
-                        if (!(*iter)) continue;
-                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
-                        if (me->GetExactDist((*iter)) > 7) continue;
-                        if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
-                        if (me->IsValidAttackTarget(*iter))
-                            ++tCount;
-                    }
-                    if (tCount > 1 && doCast(me, GetSpell(PSYCHIC_SCREAM_1)))
-                    {
-                        SetSpellCooldown(PSYCHIC_SCREAM_1, 22000);
-                        return;
-                    }
-                }
-
-                // Defend myself (psychic horror)
-                if (!b_attackers.empty())
-                {
-                    uint8 tCount = 0;
-					for (Unit::AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
-                    {
-                        if (!(*iter)) continue;
-                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
-                        if (me->GetExactDist((*iter)) > 7) continue;
-                        if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
-                        if (me->IsValidAttackTarget(*iter))
-                            ++tCount;
-                    }
-                    if (tCount > 0 && doCast(me, GetSpell(PSYCHIC_SCREAM_1)))
-                    {
-                        SetSpellCooldown(PSYCHIC_SCREAM_1, 22000);
-                        return;
-                    }
-                }
-            }
-            // Heal myself
-            if (GetHealthPCT(me) < 98 && !b_attackers.empty())
-            {
-                if (ShieldTarget(me, diff)) return;
-
-                if (IsSpellReady(FADE_1, diff, false) && me->IsInCombat())
-                {
-                    if (b_attackers.empty()) return;
-                    uint8 Tattackers = 0;
-					for (Unit::AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
-                    {
-                        if (!(*iter)) continue;
-                        if ((*iter)->isDead()) continue;
-                        if (!(*iter)->ToCreature()) continue;
-                        if (!(*iter)->CanHaveThreatList()) continue;
-                        if (me->GetExactDist((*iter)) < 15)
-                            Tattackers++;
-                    }
-                    if (Tattackers > 0)
-                    {
-                        temptimer = GC_Timer;
-                        if (doCast(me, GetSpell(FADE_1)))
-                        {
-							for (Unit::AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
-                                if ((*iter)->getThreatManager().getThreat(me) > 0.f)
-                                    (*iter)->getThreatManager().modifyThreatPercent(me, -50);
-                            SetSpellCooldown(FADE_1, 10000);
-                            GC_Timer = temptimer;
-                            return;
-                        }
-                    }
-                }
-                if (GetHealthPCT(me) < 90 && HealTarget(me, GetHealthPCT(me), diff))
-                    return;
-            }
-        }
-
-        void DoDevCheck(uint32 diff)
-        {
-            if (DevcheckTimer <= diff)
-            {
-                Devcheck = FindAffectedTarget(GetSpell(DEVOURING_PLAGUE_1), me->GetGUID());
-                DevcheckTimer = 5000;
-            }
-        }
-
-        void Disperse(uint32 diff)
-        {
-            if (!IsSpellReady(DISPERSION_1, diff) || IsCasting() || Rand() > 60)
-                return;
-            if ((me->getAttackers().size() > 3 && !IsSpellReady(FADE_1, diff, false) && GetHealthPCT(me) < 90) ||
-                (GetHealthPCT(me) < 20 && me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) ||
-                (GetManaPCT(me) < 30) ||
-                (me->getAttackers().size() > 1 && me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT))))
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, GetSpell(DISPERSION_1)))
-                    SetSpellCooldown(DISPERSION_1, 60000);
-                GC_Timer = temptimer;
-                return;
-            }
-
-            SetSpellCooldown(DISPERSION_1, 2000); //fail
-        }
-
-        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
-        {
-            uint32 spellId = spellInfo->Id;
-            uint8 lvl = me->getLevel();
-            float fdamage = float(damage);
-            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
-            if (!crit)
-            {
-                float aftercrit = 0.f;
-                //434 new
-                //Improved Fire Blast (part 1): 8% additional crit chance for Fire Blast
-                //if (lvl >= 11 && spellId == FLAMESTRIKE)
-                //    aftercrit += 8.f;
-
-                if (aftercrit > 0.f)
-                    crit = roll_chance_f(aftercrit);
-            }
-
-            //2) apply bonus damage mods
-            float pctbonus = 0.0f;
-            if (crit)
-            {
-                ////!!!spell damage is not yet critical and will be multiplied by 1.5
-                ////so we should put here bonus damage mult /1.5
-                ////Ice Shards: 50% additional crit damage bonus for Frost spells
-                //else if (lvl >= 15 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
-                //    pctbonus += 0.333f;
-            }
-            //Twin Disciplines (damage part): 6% bonus damage for shadow and holy spells
-            if (lvl >= 13)
-                if ((SPELL_SCHOOL_MASK_HOLY & spellInfo->GetSchoolMask()) ||
-                    (SPELL_SCHOOL_MASK_SHADOW & spellInfo->GetSchoolMask()))
-                    pctbonus += 0.06f;
-            //Twisted Faith (part 1): 2% bonus damage for shadow spells
-            if (lvl >= 21 && (SPELL_SCHOOL_MASK_SHADOW & spellInfo->GetSchoolMask()))
-                pctbonus += 0.02f;
-            //Mind Melt (part 1): 30% bonus damage for Shadow Word: Death
-            if (lvl >= 41 && spellId == GetSpell(SW_DEATH_1))
-                pctbonus += 0.3f;
-
-            //Glyph of Mind Flay: 10% damage bonus for Mind Flay
-            if (lvl >= 25 && spellId == GetSpell(MIND_FLAY_1))
-                pctbonus += 0.1f;
-
-            //other
-            if (spellId == SW_DEATH_BACKLASH)
-            {
-                //T13 Shadow 2P Bonus (Shadow Word: Death), part 2
-                if (lvl >= 60) //buffed
-                    pctbonus -= 0.95f;
-                //Pain and Suffering (part 2): 40% reduced backlash damage
-                if (lvl >= 50)
-                    pctbonus -= 0.4f;
-
-                pctbonus = std::min<float>(pctbonus, 1.0f);
-            }
-
-            damage = int32(fdamage * (1.0f + pctbonus));
-        }
-
-        void SpellHitTarget(Unit* target, SpellInfo const* spell)
-        {
-            uint32 spellId = spell->Id;
-
-            //Strength of Soul: direct heals reduce Weakened Soul duration on target by 4 sec
-            if (spellId == HEAL || spellId == GetSpell(FLASH_HEAL_1))
-            {
-                if (me->getLevel() >= 51)
-                {
-                    if (Aura* soul = target->GetAura(WEAKENED_SOUL_DEBUFF))
-                    {
-                        if (soul->GetDuration() > 4000)
-                            soul->SetDuration(soul->GetDuration() - 4000);
-                        else
-                            target->RemoveAura(soul, AURA_REMOVE_BY_EXPIRE);
-                    }
-                }
-            }
-
-            //Pain and Suffering (part 1, 335 version): 100% to refresh Shadow Word: Pain on target hit by Mind Flay
-            if (spellId == GetSpell(MIND_FLAY_1))
-                if (me->getLevel() >= 51)
-                    if (Aura* pain = target->GetAura(GetSpell(SW_PAIN_1), me->GetGUID()))
-                        pain->RefreshDuration();
-
-            if (spellId == GetSpell(FEAR_WARD_1))
-            {
-                //2 minutes bonus duration for Fear Ward
-                if (Aura* ward = target->GetAura(GetSpell(FEAR_WARD_1), me->GetGUID()))
-                {
-                    uint32 dur = ward->GetDuration() + 120000;
-                    ward->SetDuration(dur);
-                    ward->SetMaxDuration(dur);
-                }
-            }
-
-            if (spellId == GetSpell(INNER_FIRE_1) || spellId == GetSpell(VAMPIRIC_EMBRACE_1) || spellId == GetSpell(PW_FORTITUDE_1) ||
-                spellId == GetSpell(SHADOW_PROTECTION_1) || spellId == GetSpell(DIVINE_SPIRIT_1))
-            {
-                //1 hour duration for all buffs
-                if (Aura* buff = target->GetAura(spellId, me->GetGUID()))
-                {
-                    uint32 dur = HOUR * IN_MILLISECONDS;
-                    buff->SetDuration(dur);
-                    buff->SetMaxDuration(dur);
-                }
-            }
-        }
-
-        void SpellHit(Unit* caster, SpellInfo const* spell)
-        {
-            OnSpellHit(caster, spell);
-        }
-
-        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
-        {
-            if (victim == me)
-                return;
-
-            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
-            {
-                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
-                {
-                    if (_ctc[i].first && !_ctc[i].second)
-                    {
-                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
-                            _ctc[i].second = 1000;
-
-                        if (_ctc[i].second > 0)
-                            me->CastSpell(victim, _ctc[i].first, true);
-                    }
-                }
-            }
-        }
-
-		void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType, SpellSchoolMask)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void OwnerAttackedBy(Unit* u)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void Reset()
-        {
-            Heal_Timer = 0;
-            Shackle_Timer = 0;
-
-            CheckDispelTimer = 0;
-            DevcheckTimer = 0;
-
-            Devcheck = false;
-
-            if (master)
-            {
-                SetStats(true);
-                InitRoles();
-                ApplyPassives(CLASS_PRIEST);
-            }
-        }
-
-        void ReduceCD(uint32 diff)
-        {
-            CommonTimers(diff);
-            SpellTimers(diff);
-
-            if (Heal_Timer > diff)                  Heal_Timer -= diff;
-            if (Shackle_Timer > diff)               Shackle_Timer -= diff;
-
-            if (CheckDispelTimer > diff)            CheckDispelTimer -= diff;
-            if (DevcheckTimer > diff)               DevcheckTimer -= diff;
-        }
-
-        bool CanRespawn()
-        {return false;}
-
-        void InitSpells()
-        {
-            uint8 lvl = me->getLevel();
-            DISPELMAGIC = lvl >= 70 ? MASS_DISPEL_1 : InitSpell(me, DISPEL_MAGIC_1);
-            InitSpellMap(CURE_DISEASE_1);
-            InitSpellMap(FEAR_WARD_1);
-  /*Talent*/lvl >= 50 ? InitSpellMap(PAIN_SUPPRESSION_1) : RemoveSpell(PAIN_SUPPRESSION_1);
-            InitSpellMap(PSYCHIC_SCREAM_1);
-            InitSpellMap(FADE_1);
-  /*Talent*/lvl >= 50 ? InitSpellMap(PSYCHIC_HORROR_1) : RemoveSpell(PSYCHIC_HORROR_1);
-  /*Talent*/lvl >= 30 ? InitSpellMap(SILENCE_1) : RemoveSpell(SILENCE_1);
-  /*Talent*/lvl >= 60 ? InitSpellMap(PENANCE_1) : RemoveSpell(PENANCE_1);
-  /*Talent*/lvl >= 30 ? InitSpellMap(VAMPIRIC_EMBRACE_1) : RemoveSpell(VAMPIRIC_EMBRACE_1);
-  /*Talent*/lvl >= 60 ? InitSpellMap(DISPERSION_1) : RemoveSpell(DISPERSION_1);
-            InitSpellMap(MIND_SEAR_1);
-  /*Talent*/lvl >= 60 ? InitSpellMap(GUARDIAN_SPIRIT_1) : RemoveSpell(GUARDIAN_SPIRIT_1);
-            InitSpellMap(SHACKLE_UNDEAD_1);
-            HEAL = lvl >= 40 ? InitSpell(me, GREATER_HEAL_1) : lvl >= 16 ? InitSpell(me, NORMAL_HEAL_1) : InitSpell(me, LESSER_HEAL_1);
-            InitSpellMap(RENEW_1);
-            InitSpellMap(FLASH_HEAL_1);
-            InitSpellMap(PRAYER_OF_HEALING_1);
-            InitSpellMap(DIVINE_HYMN_1);
-            InitSpellMap(RESURRECTION_1);
-            InitSpellMap(PW_SHIELD_1);
-            InitSpellMap(INNER_FIRE_1);
-            InitSpellMap(PW_FORTITUDE_1);
-            InitSpellMap(SHADOW_PROTECTION_1);
-            InitSpellMap(DIVINE_SPIRIT_1);
-            InitSpellMap(SW_PAIN_1);
-            InitSpellMap(MIND_BLAST_1);
-            InitSpellMap(SW_DEATH_1);
-            InitSpellMap(DEVOURING_PLAGUE_1);
-  /*Talent*/lvl >= 20 ? InitSpellMap(MIND_FLAY_1) : RemoveSpell(MIND_FLAY_1);
-  /*Talent*/lvl >= 50 ? InitSpellMap(VAMPIRIC_TOUCH_1) : RemoveSpell(VAMPIRIC_TOUCH_1);
-        }
-        void ApplyClassPassives()
-        {
-            uint8 level = master->getLevel();
-            if (level >= 65)
-                RefreshAura(BORROWED_TIME); //25%haste/40%bonus
-            if (level >= 55)
-                RefreshAura(DIVINE_AEGIS); //30%
-            if (level >= 55)
-                RefreshAura(EMPOWERED_RENEW3); //15%
-            else if (level >= 50)
-                RefreshAura(EMPOWERED_RENEW2); //10%
-            else if (level >= 45)
-                RefreshAura(EMPOWERED_RENEW1); //5%
-            if (level >= 45)
-                RefreshAura(BODY_AND_SOUL1); //30%
-            if (level >= 50)
-                RefreshAura(PAINANDSUFFERING3); //100%
-            else if (level >= 48)
-                RefreshAura(PAINANDSUFFERING2); //66%
-            else if (level >= 45)
-                RefreshAura(PAINANDSUFFERING1); //33%
-            if (level >= 50)
-                RefreshAura(MISERY3); //3%
-            else if (level >= 48)
-                RefreshAura(MISERY2); //2%
-            else if (level >= 45)
-                RefreshAura(MISERY1); //1%
-            if (level >= 45)
-                RefreshAura(GRACE); //100%
-            if (level >= 35)
-                RefreshAura(IMPROVED_DEVOURING_PLAGUE); //30%
-            if (level >= 25)
-                RefreshAura(INSPIRATION3); //10%
-            else if (level >= 23)
-                RefreshAura(INSPIRATION2); //6%
-            else if (level >= 20)
-                RefreshAura(INSPIRATION1); //3%
-            if (level >= 30)
-                RefreshAura(SHADOW_WEAVING3); //100%
-            else if (level >= 28)
-                RefreshAura(SHADOW_WEAVING2); //66%
-            else if (level >= 25)
-                RefreshAura(SHADOW_WEAVING1); //33%
-            if (level >= 15)
-            {
-                RefreshAura(GLYPH_SW_PAIN);
-                RefreshAura(GLYPH_PW_SHIELD); //20% heal
-            }
-            if (level >= 40)
-                RefreshAura(SHADOWFORM); //allows dots to crit, passive
-            if (level >= 70)
-                RefreshAura(PRIEST_T10_2P_BONUS);
-        }
-
-        bool CanUseManually(uint32 basespell) const
-        {
-            switch (basespell)
-            {
-                case DISPEL_MAGIC_1:
-                case MASS_DISPEL_1:
-                case CURE_DISEASE_1:
-                case FEAR_WARD_1:
-                case PAIN_SUPPRESSION_1:
-                case FADE_1:
-                case PENANCE_1:
-                case VAMPIRIC_EMBRACE_1:
-                case DISPERSION_1:
-                case GUARDIAN_SPIRIT_1:
-                case LESSER_HEAL_1:
-                case NORMAL_HEAL_1:
-                case GREATER_HEAL_1:
-                case RENEW_1:
-                case FLASH_HEAL_1:
-                case PRAYER_OF_HEALING_1:
-                case DIVINE_HYMN_1:
-                case PW_SHIELD_1:
-                case INNER_FIRE_1:
-                case PW_FORTITUDE_1:
-                case SHADOW_PROTECTION_1:
-                case DIVINE_SPIRIT_1:
-                    return true;
-                default:
-                    return false;
-            }
-        }
-
-    private:
-        uint32 DISPELMAGIC, HEAL;
-        uint32 Heal_Timer, Shackle_Timer;
-/*Misc*/uint16 CheckDispelTimer, DevcheckTimer;
-/*Misc*/bool Devcheck;
-
-        enum PriestBaseSpells
-        {
-            DISPEL_MAGIC_1                      = 527,
-            MASS_DISPEL_1                       = 32375,
-            CURE_DISEASE_1                      = 528,
-            FEAR_WARD_1                         = 6346,
-  /*Talent*/PAIN_SUPPRESSION_1                  = 33206,
-            PSYCHIC_SCREAM_1                    = 8122,
-            FADE_1                              = 586,
-  /*Talent*/PSYCHIC_HORROR_1                    = 64044,
-  /*Talent*/SILENCE_1                           = 15487,
-  /*Talent*/PENANCE_1                           = 47540,
-  /*Talent*/VAMPIRIC_EMBRACE_1                  = 15286,
-  /*Talent*/DISPERSION_1                        = 47585,
-            MIND_SEAR_1                         = 48045,
-  /*Talent*/GUARDIAN_SPIRIT_1                   = 47788,
-            SHACKLE_UNDEAD_1                    = 9484,
-            LESSER_HEAL_1                       = 2050,
-            NORMAL_HEAL_1                       = 2054,
-            GREATER_HEAL_1                      = 2060,
-            RENEW_1                             = 139,
-            FLASH_HEAL_1                        = 2061,
-            PRAYER_OF_HEALING_1                 = 596,
-            DIVINE_HYMN_1                       = 64843,
-            RESURRECTION_1                      = 2006,
-            PW_SHIELD_1                         = 17,
-            INNER_FIRE_1                        = 588,
-            PW_FORTITUDE_1                      = 1243,
-            SHADOW_PROTECTION_1                 = 976,
-            DIVINE_SPIRIT_1                     = 14752,
-            SW_PAIN_1                           = 589,
-            MIND_BLAST_1                        = 8092,
-            SW_DEATH_1                          = 32379,
-            DEVOURING_PLAGUE_1                  = 2944,
-  /*Talent*/MIND_FLAY_1                         = 15407,
-  /*Talent*/VAMPIRIC_TOUCH_1                    = 34914
-        };
-        enum PriestPassives
-        {
-            SHADOWFORM  /*For DOT crits*/   = 49868,
-        //Talents
-            IMPROVED_DEVOURING_PLAGUE       = 63627,//rank 3
-            MISERY1                         = 33191,
-            MISERY2                         = 33192,
-            MISERY3                         = 33193,
-            PAINANDSUFFERING1               = 47580,
-            PAINANDSUFFERING2               = 47581,
-            PAINANDSUFFERING3               = 47582,
-            SHADOW_WEAVING1                 = 15257,
-            SHADOW_WEAVING2                 = 15331,
-            SHADOW_WEAVING3                 = 15332,
-            DIVINE_AEGIS                    = 47515,//rank 3
-            BORROWED_TIME                   = 52800,//rank 5
-            GRACE                           = 47517,//rank 2
-            EMPOWERED_RENEW1                = 63534,
-            EMPOWERED_RENEW2                = 63542,
-            EMPOWERED_RENEW3                = 63543,
-            INSPIRATION1                    = 14892,
-            INSPIRATION2                    = 15362,
-            INSPIRATION3                    = 15363,
-            BODY_AND_SOUL1                  = 64127,
-        //Glyphs
-            GLYPH_SW_PAIN                   = 55681,
-            GLYPH_PW_SHIELD                 = 55672,
-        //other
-            PRIEST_T10_2P_BONUS             = 70770 //33% renew
-        };
-        enum PriestSpecial
-        {
-            IMPROVED_DEVOURING_PLAGUE_DAMAGE= 63675,
-            MIND_SEAR_DAMAGE                = 49821,
-            SW_DEATH_BACKLASH               = 32409,
-            WEAKENED_SOUL_DEBUFF            = 6788
-        };
-    };
-};
-
-void AddSC_priest_bot()
-{
-    new priest_bot();
-}
diff --git a/src/server/game/AI/NpcBots/bot_rogue_ai.cpp b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
deleted file mode 100644
index a8fad6e..0000000
--- a/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
+++ /dev/null
@@ -1,885 +0,0 @@
-#include "bot_ai.h"
-//#include "Group.h"
-#include "Player.h"
-#include "ScriptMgr.h"
-#include "SpellAuras.h"
-#include "SpellInfo.h"
-/*
-Rogue NpcBot (reworked by Graff onlysuffering@gmail.com)
-Complete - 25% maybe...
-TODO:
-*/
-#define DMGMIN              1
-#define DMGMAX              2
-#define MAX_COMBO_POINTS    5
-#define EVISCERATE_MAX_RANK 12
-const uint32 EVSCRDamage[EVISCERATE_MAX_RANK+1][MAX_COMBO_POINTS+1][DMGMAX+1] =
-{
-    { { 0,0,0 }, { 0,0,0 },     { 0,0,0 },      { 0,0,0 },       { 0,0,0 },       { 0,0,0 }       },
-    { { 0,0,0 }, { 0,6,11 },    { 0,12,16 },    { 0,17,22 },     { 0,22,28 },     { 0,28,34 }     },
-    { { 0,0,0 }, { 0,14,23 },   { 0,26,34 },    { 0,37,46 },     { 0,48,58 },     { 0,60,70 }     },
-    { { 0,0,0 }, { 0,25,49 },   { 0,45,59 },    { 0,64,79 },     { 0,83,99 },     { 0,103,119 }   },
-    { { 0,0,0 }, { 0,41,62 },   { 0,73,93 },    { 0,104,125 },   { 0,135,157 },   { 0,167,189 }   },
-    { { 0,0,0 }, { 0,60,91 },   { 0,106,136 },  { 0,151,182 },   { 0,196,228 },   { 0,242,274 }   },
-    { { 0,0,0 }, { 0,93,138 },  { 0,165,209 },  { 0,236,281 },   { 0,307,353 },   { 0,379,425 }   },
-    { { 0,0,0 }, { 0,144,213 }, { 0,255,323 },  { 0,365,434 },   { 0,475,545 },   { 0,586,656 }   },
-    { { 0,0,0 }, { 0,199,296 }, { 0,351,447 },  { 0,502,599 },   { 0,653,751 },   { 0,805,903 }   },
-    { { 0,0,0 }, { 0,224,333 }, { 0,395,503 },  { 0,565,674 },   { 0,735,845 },   { 0,906,1016 }  },
-    { { 0,0,0 }, { 0,245,366 }, { 0,431,551 },  { 0,616,737 },   { 0,801,923 },   { 0,987,1109 }  },
-    { { 0,0,0 }, { 0,405,614 }, { 0,707,915 },  { 0,1008,1217 }, { 0,1309,1519 }, { 0,1611,1821 } },
-    { { 0,0,0 }, { 0,497,752 }, { 0,868,1122 }, { 0,1238,1493 }, { 0,1608,1864 }, { 0,1979,2235 } }
-};
-#define RUPTURE_MAX_RANK    9
-const uint32 RuptureDamage[RUPTURE_MAX_RANK+1][MAX_COMBO_POINTS+1] =
-{
-    { 0, 0,   0,   0,    0,    0    },
-    { 0, 41,  61,  86,   114,  147  },
-    { 0, 61,  91,  128,  170,  219  },
-    { 0, 89,  131, 182,  240,  307  },
-    { 0, 129, 186, 254,  331,  419  },
-    { 0, 177, 256, 350,  457,  579  },
-    { 0, 273, 381, 506,  646,  803  },
-    { 0, 325, 461, 620,  800,  1003 },
-    { 0, 489, 686, 914,  1171, 1459 },
-    { 0, 581, 816, 1088, 1395, 1739 }
-};
-
-class rogue_bot : public CreatureScript
-{
-public:
-    rogue_bot() : CreatureScript("rogue_bot") { }
-
-    CreatureAI* GetAI(Creature* creature) const
-    {
-        return new rogue_botAI(creature);
-    }
-
-    bool OnGossipHello(Player* player, Creature* creature)
-    {
-        return bot_minion_ai::OnGossipHello(player, creature);
-    }
-
-    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
-    {
-        if (bot_minion_ai* ai = creature->GetBotMinionAI())
-            return ai->OnGossipSelect(player, creature, sender, action);
-        return true;
-    }
-
-    struct rogue_botAI : public bot_minion_ai
-    {
-        rogue_botAI(Creature* creature) : bot_minion_ai(creature)
-        {
-            Reset();
-        }
-
-        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
-        {
-            if (CheckBotCast(victim, spellId, CLASS_ROGUE) != SPELL_CAST_OK)
-                return false;
-            return bot_ai::doCast(victim, spellId, triggered);
-        }
-
-        void StartAttack(Unit* u, bool force = false)
-        {
-            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
-            Aggro(u);
-            SetBotCommandState(COMMAND_ATTACK);
-            GetInPosition(force);
-        }
-
-        void EnterCombat(Unit*) { }
-        void Aggro(Unit*) { }
-        void AttackStart(Unit*) { }
-        void KilledUnit(Unit*) { }
-        void EnterEvadeMode() { }
-        void MoveInLineOfSight(Unit*) { }
-        void JustDied(Unit* u) { comboPoints = 0; tempComboPoints = 0; bot_ai::JustDied(u); }
-        void DoNonCombatActions(uint32 /*diff*/)
-        {}
-
-        //This method should be used to emulate energy usage reduction
-        void modenergy(int32 mod, bool set = false)
-        {
-            //can't set enery to -x (2 cases)
-            if (set && mod < 0)
-                return;
-            if (mod < 0 && energy < uint32(abs(mod)))
-            {
-                mod = 0;
-                set = true;
-            }
-
-            if (set)
-                energy = mod;
-            else
-                energy += mod;
-
-            energy = std::min<uint32>(energy, 100);
-            me->SetPower(POWER_ENERGY, energy);
-        }
-
-        uint32 getenergy()
-        {
-            energy = me->GetPower(POWER_ENERGY);
-            return energy;
-        }
-
-        void UpdateAI(uint32 diff)
-        {
-            ReduceCD(diff);
-            if (IAmDead()) return;
-            CheckAttackState();
-            CheckAuras();
-            if (wait == 0)
-                wait = GetWait();
-            else
-                return;
-            BreakCC(diff);
-            if (CCed(me)) return;
-
-            if (GetHealthPCT(me) < 67 && Potion_cd <= diff)
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, HEALINGPOTION))
-                {
-                    Potion_cd = POTION_CD;
-                    GC_Timer = temptimer;
-                }
-            }
-
-            if (!me->IsInCombat())
-                DoNonCombatActions(diff);
-
-            if (!CheckAttackTarget(CLASS_ROGUE))
-                return;
-
-            Attack(diff);
-        }
-
-        void Attack(uint32 diff)
-        {
-            opponent = me->GetVictim();
-            if (opponent)
-            {
-                if (!IsCasting())
-                    StartAttack(opponent, true);
-            }
-            else
-                return;
-
-            comboPoints = std::min<uint8>(comboPoints, 5);
-            //AttackerSet m_attackers = master->getAttackers();
-			Unit::AttackerSet b_attackers = me->getAttackers();
-            float dist = me->GetExactDist(opponent);
-            float meleedist = me->GetDistance(opponent);
-
-            //Blade Flurry (434 deprecated)
-            if (IsSpellReady(BLADE_FLURRY_1, diff, false) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
-                Rand() < 30 && getenergy() >= 25 && FindSplashTarget(7, opponent))
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, GetSpell(BLADE_FLURRY_1)))
-                {
-                    SetSpellCooldown(BLADE_FLURRY_1, 75000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-
-            if (MoveBehind(*opponent))
-                wait = 5;
-
-            //KICK
-            if (IsSpellReady(KICK_1, diff, false) && meleedist <= 5 && Rand() < 80 && getenergy() >= 25 &&
-                opponent->IsNonMeleeSpellCast(false))
-            {
-                temptimer = GC_Timer;
-                if (doCast(opponent, GetSpell(KICK_1)))
-                {
-                    SetSpellCooldown(KICK_1, 8000); //improved
-                    GC_Timer = temptimer;
-                    //return;
-                }
-            }
-            //SHADOWSTEP
-            if (IsSpellReady(SHADOWSTEP_1, diff, false) && HasRole(BOT_ROLE_DPS) && dist < 25 &&
-                (opponent->GetVictim() != me || opponent->GetTypeId() == TYPEID_PLAYER) &&
-                Rand() < 30 && getenergy() >= 10)
-            {
-                temptimer = GC_Timer;
-                if (doCast(opponent, GetSpell(SHADOWSTEP_1)))
-                {
-                    SetSpellCooldown(SHADOWSTEP_1, 20000);
-                    GC_Timer = temptimer;
-                    //return;
-                }
-            }
-            //BACKSTAB
-            if (IsSpellReady(BACKSTAB_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints < 4 &&
-                /*Rand() < 90 && */getenergy() >= 60 && !opponent->HasInArc(M_PI, me))
-            {
-                if (doCast(opponent, GetSpell(BACKSTAB_1)))
-                    return;
-            }
-            //SINISTER STRIKE
-            if (IsSpellReady(SINISTER_STRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints < 5 &&
-                Rand() < 25 && getenergy() >= 45)
-            {
-                if (doCast(opponent, GetSpell(SINISTER_STRIKE_1)))
-                    return;
-            }
-            //SLICE AND DICE
-            if (IsSpellReady(SLICE_DICE_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 20 && comboPoints > 1 && getenergy() >= 25 &&
-                (b_attackers.size() <= 1 || !IsSpellReady(BLADE_FLURRY_1, diff)) && Rand() < 30)
-            {
-                if (doCast(opponent, GetSpell(SLICE_DICE_1)))
-                    return;
-            }
-            //KIDNEY SHOT
-            if (IsSpellReady(KIDNEY_SHOT_1, diff) && meleedist <= 5 && comboPoints > 0 &&
-                !CCed(opponent) && getenergy() >= 25 && ((Rand() < 15 + comboPoints*15 && opponent->GetVictim() == me && comboPoints > 2) || opponent->IsNonMeleeSpellCast(false)))
-            {
-                if (doCast(opponent, GetSpell(KIDNEY_SHOT_1)))
-                    return;
-            }
-            //EVISCERATE
-            if (IsSpellReady(EVISCERATE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints > 2 &&
-                getenergy() >= 35 && Rand() < comboPoints*15)
-            {
-                uint32 EVISCERATE = GetSpell(EVISCERATE_1);
-                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(EVISCERATE);
-                uint8 rank = spellInfo->GetRank();
-                float ap = me->GetTotalAttackPowerValue(BASE_ATTACK);
-                float combo = float(comboPoints);
-                int32 damage = int32(urand(EVSCRDamage[rank][comboPoints][DMGMIN], EVSCRDamage[rank][comboPoints][DMGMAX]));//base damage
-                damage += irand(int32(ap*combo*0.03f), int32(ap*combo*0.07f));//ap bonus
-
-                currentSpell = EVISCERATE;
-                me->CastCustomSpell(opponent, EVISCERATE, &damage, NULL, NULL, false);
-                return;
-            }
-            //MUTILATE
-            //if (isTimerReady(Mutilate_Timer) && energy>60)
-            //{
-            //    // TODO: calculate correct dmg for mutilate (dont forget poison bonus)
-            //    // for now use same formula as evicerate
-            //    uint32 base_attPower = me->GetUInt32Value(UNIT_FIELD_ATTACK_POWER);
-            //    //float minDmg = me->GetFloatValue(UNIT_FIELD_MINDAMAGE);
-            //    float minDmg = me->GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE);
-            //    int damage = irand(int32(base_attPower*7*0.03f),int32(base_attPower*7*0.08f))+minDmg+me->getLevel();
-
-            //    // compensate for lack of attack power
-            //    damage = damage*(rand()%4+1);
-
-            //    me->CastCustomSpell(opponent, MUTILATE, &damage, NULL, NULL, false, NULL, NULL);
-
-            //    //doCast (me, MUTILATE);
-            //    Mutilate_Timer = 10;
-            //    comboPoints+=3;
-            //    energy -= 60;
-            //}
-
-            //RUPTURE
-            if (IsSpellReady(RUPTURE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints > 3 && getenergy() >= 25 &&
-                opponent->GetHealth() > me->GetMaxHealth()/3 && Rand() < (50 + 70 * opponent->isMoving()))
-            {
-                uint32 RUPTURE = GetSpell(RUPTURE_1);
-                //no damage range for rupture
-                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(RUPTURE);
-                uint8 rank = spellInfo->GetRank();
-                float ap = me->GetTotalAttackPowerValue(BASE_ATTACK);
-                float AP_per_combo[6] = {0.0f, 0.015f, 0.024f, 0.03f, 0.03428571f, 0.0375f};
-                float divider[6] = {0.0f, 4.f, 5.f, 6.f, 7.f, 8.f};//duration/2 = number of ticks
-                int32 damage = int32(RuptureDamage[rank][comboPoints]/divider[comboPoints]);//base damage
-                damage += int32(ap*AP_per_combo[comboPoints]);//ap bonus is strict - applied to every tick
-
-                currentSpell = RUPTURE;
-                me->CastCustomSpell(opponent, RUPTURE, &damage, NULL, NULL, false);
-                return;
-            }
-            //DISMANTLE
-            if (IsSpellReady(DISMANTLE_1, diff, false) && meleedist <= 5 && opponent->GetTypeId() == TYPEID_PLAYER &&
-                Rand() < 20 && getenergy() >= 25 && !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) &&
-                (opponent->ToPlayer()->GetWeaponForAttack(BASE_ATTACK) || opponent->ToPlayer()->GetWeaponForAttack(RANGED_ATTACK)))
-            {
-                temptimer = GC_Timer;
-                if (doCast(opponent, GetSpell(DISMANTLE_1)))
-                {
-                    SetSpellCooldown(DISMANTLE_1, 60000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-        }
-
-        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
-        {
-            uint32 spellId = spellInfo->Id;
-            uint8 lvl = me->getLevel();
-            float fdamage = float(damage);
-            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
-            if (!crit)
-            {
-                float aftercrit = 0.f;
-                //Puncturing Wounds: 30% additional critical chance for Backstab
-                if (lvl >= 15 && spellId == GetSpell(BACKSTAB_1))
-                    aftercrit += 30.f;
-                //Puncturing Wounds: 15% additional critical chance for Mutilate
-                else if (spellId == GetSpell(MUTILATE_1))
-                    aftercrit += 15.f;
-                //Glyph of Eviscerate: 10% additional critical chance for Eviscerate
-                else if (spellId == GetSpell(EVISCERATE_1))
-                    aftercrit += 10.f;
-                //Improved Ambush: 60% additional critical chance for Ambush
-                //else if (spellId == AMBUSH)
-                //    crit_chance += 60.f;
-                if (lvl >= 50 && spellInfo->HasEffect(SPELL_EFFECT_ADD_COMBO_POINTS) && me->HasAura(TURN_THE_TABLES_EFFECT))
-                    aftercrit += 6.f;
-
-                //second roll (may be illogical)
-                if (aftercrit > 0.f)
-                    crit = roll_chance_f(aftercrit);
-            }
-
-            //2) apply bonus damage mods
-            float pctbonus = 0.0f;
-            if (crit)
-            {
-                //!!!Melee spell damage is not yet critical, all reduced by half
-                //Lethality: 30% crit damage bonus for non-stealth combo-generating abilities (on 25 lvl)
-                if (lvl >= 25 && !(spellInfo->Attributes & SPELL_ATTR0_ONLY_STEALTHED) &&
-                    spellInfo->HasEffect(SPELL_EFFECT_ADD_COMBO_POINTS))
-                    pctbonus += 0.15f;
-            }
-            //Shadowstep: 20% bonus damage to all abilities once
-            //if (shadowstep == true)
-            //{
-            //    shadowstep = false;
-            //    me->RemoveAurasDueToSpell(SHADOWSTEP_EFFECT_DAMAGE);
-            //    pctbonus += 0.2f;
-            //}
-            //Find Weakness: 6% bonus damage to all abilities
-            if (lvl >= 45)
-                pctbonus += 0.06f;
-            //DeathDealer set bonus: 15% damage bonus for Eviscerate
-            if (lvl >= 60 && spellId == GetSpell(EVISCERATE_1))
-                pctbonus += 0.15f;
-            //Imoroved Eviscerate: 20% damage bonus for Eviscerate
-            if (spellId == GetSpell(EVISCERATE_1))
-                pctbonus += 0.2f;
-            //Opportunity: 20% damage bonus for Backstab, Mutilate, Garrote and Ambush
-            if (spellId == GetSpell(BACKSTAB_1) || spellId == GetSpell(MUTILATE_1)/* ||
-                spellId == GARROTE || spellId == AMBUSH*/)
-                pctbonus += 0.2f;
-            //Aggression: 15% damage bonus for Sinister Strike, Backstab and Eviscerate
-            if (lvl >= 30 && (spellId == GetSpell(SINISTER_STRIKE_1) || spellId == GetSpell(BACKSTAB_1) || spellId == GetSpell(EVISCERATE_1)))
-                pctbonus += 0.15f;
-            //Blood Spatter: 30% bonus damage for Rupture and Garrote
-            if (lvl >= 15 && (spellId == GetSpell(RUPTURE_1)/* || spellId == GARROTE*/))
-                pctbonus += 0.3f;
-            //Serrated Blades: 30% bonus damage for Rupture
-            if (lvl >= 20 && spellId == GetSpell(RUPTURE_1))
-                pctbonus += 0.3f;
-            //Surprise Attacks: 10% bonus damage for Sinister Strike, Backstab, Shiv, Hemmorhage and Gouge
-            if (lvl >= 50 && (spellId == GetSpell(SINISTER_STRIKE_1) || spellId == GetSpell(BACKSTAB_1)/* ||
-                spellId == SHIV || spellId == HEMMORHAGE || spellId == GOUGE*/))
-                pctbonus += 0.1f;
-
-            damage = int32(fdamage * (1.0f + pctbonus));
-        }
-
-        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
-        {
-            uint32 WOUND_POISON = GetSpell(WOUND_POISON_1);
-            uint32 MIND_NUMBING_POISON = GetSpell(MIND_NUMBING_POISON_1);
-            if (!WOUND_POISON && !MIND_NUMBING_POISON)
-                return;
-
-            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
-            {
-                if (victim && me->GetExactDist(victim) <= 40)
-                {
-                    switch (rand()%2)
-                    {
-                        case 0:
-                            break;
-                        case 1:
-                        {
-                            switch (rand()%2)
-                            {
-                                case 0:
-                                    if (WOUND_POISON)
-                                    {
-                                        currentSpell = WOUND_POISON;
-                                        DoCast(victim, WOUND_POISON, true);
-                                    }
-                                    break;
-                                case 1:
-                                    if (MIND_NUMBING_POISON)
-                                    {
-                                        currentSpell = MIND_NUMBING_POISON;
-                                        DoCast(victim, MIND_NUMBING_POISON, true);
-                                    }
-                                    break;
-                            }
-                        }
-                    }
-                }
-            }
-
-            if (victim == me)
-                return;
-
-            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
-            {
-                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
-                {
-                    if (_ctc[i].first && !_ctc[i].second)
-                    {
-                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
-                            _ctc[i].second = 1000;
-
-                        if (_ctc[i].second > 0)
-                            me->CastSpell(victim, _ctc[i].first, true);
-                    }
-                }
-            }
-        }
-
-        void SpellHit(Unit* caster, SpellInfo const* spell)
-        {
-            OnSpellHit(caster, spell);
-        }
-
-        void SpellHitTarget(Unit* target, SpellInfo const* spell)
-        {
-            uint32 spellId = spell->Id;
-
-            //combo points use up
-            if (spellId == GetSpell(SLICE_DICE_1))
-            {
-                SetSpellCooldown(SLICE_DICE_1, 15000 + (tempComboPoints-1)*4500);
-                GC_Timer = 800;
-
-                if (Aura* dice = me->GetAura(GetSpell(SLICE_DICE_1)))
-                {
-                    uint32 dur = dice->GetDuration();
-                    dur += tempComboPoints * 3000; //use cp
-                    dur += 6000; // Glyph of Slice and Dice
-                    dur = (dur * 3) / 2; //Improved Slice and Dice
-                    dice->SetDuration(dur);
-                    dice->SetMaxDuration(dur);
-                }
-            }
-            else if (spellId == GetSpell(RUPTURE_1))
-            {
-                SetSpellCooldown(RUPTURE_1, 8000 + (tempComboPoints-1)*2000 + 4000);
-                GC_Timer = 800;
-
-                if (Aura* rupture = target->GetAura(GetSpell(RUPTURE_1), me->GetGUID()))
-                {
-                    uint32 dur = rupture->GetDuration() + tempComboPoints*2000; //use cp
-                    dur += 4000; //Glyph of Rupture
-                    rupture->SetDuration(dur);
-                    rupture->SetMaxDuration(dur);
-                }
-            }
-            else if (spellId == GetSpell(KIDNEY_SHOT_1))
-            {
-                SetSpellCooldown(KIDNEY_SHOT_1, 20000);
-
-                if (Aura* kidney = target->GetAura(GetSpell(KIDNEY_SHOT_1), me->GetGUID()))
-                {
-                    uint32 dur = kidney->GetDuration() + tempComboPoints*1000;
-                    kidney->SetDuration(dur);
-                    kidney->SetMaxDuration(dur);
-                }
-            }
-
-            if (currentSpell == 0)
-                return;
-
-            //BONUS CP MANAGEMENT
-
-            //if (spellId == EVISCERATE || spellId == KIDNEY_SHOT || spellId == SLICE_DICE || spellId == RUPTURE/* || spellId == EXPOSE_ARMOR || spellId == ENVENOM*/)
-            //Relentless Strikes
-            if (spell->NeedsComboPoints())
-            {
-                //std::ostringstream msg;
-                //msg << "casting ";
-                //if (spellId == EVISCERATE)
-                //    msg << "Eviscerate, ";
-                //else if (spellId == RUPTURE)
-                //    msg << "Rupture, ";
-                //else if (spellId == SLICE_DICE)
-                //    msg << "Slice and Dice, ";
-                //else if (spellId == KIDNEY_SHOT)
-                //    msg << "Kidney Shot, ";
-                ////else if (spellId == EXPOSE_ARMOR)
-                ////    msg << "Expose Armor, ";
-                ////else if (spellId == ENVENOM)
-                ////    msg << "Envenom, ";
-                //msg << "combo points: " << uint32(std::min<uint32>(comboPoints,5));
-                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
-                if (irand(0, 99) < 20 * (comboPoints > 5 ? 5 : comboPoints))
-                {
-                    currentSpell = RELENTLESS_STRIKES_EFFECT;
-                    DoCast(me, RELENTLESS_STRIKES_EFFECT, true);
-                }
-                tempComboPoints = comboPoints;
-                //CP adding effects are handled before actual finisher so use temp value
-                //std::ostringstream msg2;
-                //msg2 << "cp set to 0";
-                if (tempAddCP)
-                {
-                    //msg2 << " + " << uint32(tempAddCP) << " (temp)";
-                    comboPoints = tempAddCP;
-                    tempAddCP = 0;
-                }
-                else
-                    comboPoints = 0;
-                //me->MonsterWhisper(msg2.str().c_str(), master->GetGUID());
-            }
-            else if (spellId == GetSpell(SINISTER_STRIKE_1) ||
-                spellId == GetSpell(BACKSTAB_1)/* ||
-                spellId == GOUGE ||
-                spellId == HEMORRHAGE*/)
-            {
-                ++comboPoints;
-                //std::ostringstream msg;
-                //msg << "1 cp generated ";
-                //if (spellId == SINISTER_STRIKE)
-                //    msg << "(Sinister Strike)";
-                //else if (spellId == BACKSTAB)
-                //    msg << "(Backstab)";
-                //msg << " set to " << uint32(comboPoints);
-                //if (tempAddCP)
-                //    msg << " + " << uint32(tempAddCP) << " (triggered)";
-                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
-                if (tempAddCP)
-                {
-                    comboPoints += tempAddCP;
-                    tempAddCP = 0;
-                }
-            }
-            else if (spellId == GetSpell(MUTILATE_1)/* ||
-                spellId == AMBUSH*/)
-            {
-                comboPoints += 2;
-                //std::ostringstream msg;
-                //msg << "2 cp generated (Mutilate), set to " << uint32(comboPoints);
-                //if (tempAddCP)
-                //    msg << " + " << uint32(tempAddCP) << " (triggered)";
-                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
-                if (tempAddCP)
-                {
-                    comboPoints += tempAddCP;
-                    tempAddCP = 0;
-                }
-            }
-            else if (spellId == SEAL_FATE_EFFECT || spellId == RUTHLESSNESS_EFFECT)
-            {
-                ++tempAddCP;
-                //std::ostringstream msg;
-                //msg << "1 temp cp generated ";
-                //if (spellId == SEAL_FATE_EFFECT)
-                //    msg << "(Seal Fate)";
-                //else if (spellId == RUTHLESSNESS_EFFECT)
-                //    msg << "(Ruthleness)";
-                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
-            }
-
-            //Glyph of Sinister Strike (20% to add cp on hit)
-            //Seal Fate means crit so this glyph is enabled from lvl 35)
-            //as addition always add cp on ss crit
-            if (currentSpell == GetSpell(SINISTER_STRIKE_1) && (spellId == SEAL_FATE_EFFECT || urand(0,100) >= 20))
-            {
-                ++tempAddCP;
-                //me->MonsterWhisper("1 temp cp generated (glyph of SS)", master->GetGUID());
-            }
-
-            //ENERGY COST REDUCTION
-
-            if (spellId == GetSpell(SINISTER_STRIKE_1))
-            {
-                //Improved Sinister Strike
-                //instead of restoring energy we should override current value
-                if (me->getLevel() >= 10)
-                    modenergy(-40, true);//45 - 5
-            }
-            //Slaughter from the Shadows energy restore
-            //instead of restoring energy we should override current value
-            if (me->getLevel() >= 55)
-            {
-                if (spellId == GetSpell(BACKSTAB_1)/* || spellId == AMBUSH*/)
-                    modenergy(-40, true);
-                //else if (spellId == HEMORRHAGE)
-                //    modenergy(-30, true);
-            }
-
-            //OTHER
-
-            if (spellId == GetSpell(EVISCERATE_1))
-            {
-                //Eviscerate speedup
-                GC_Timer = 800;
-
-                //Serrated Blades: Eviscerate has 20% chance per cp to refresh Rupture
-                //getting cheaty - remove roll
-                //getting cheaty - increase duration
-                //if (irand(0, 99) < 20 * (comboPoints > 5 ? 5 : comboPoints))
-                {
-                    if (Aura* rupture = target->GetAura(GetSpell(RUPTURE_1), me->GetGUID()))
-                    {
-                        int32 dur = rupture->GetMaxDuration() + 2000;
-                        dur = std::min<int32>(dur, 30000);
-                        rupture->SetDuration(dur);
-                        rupture->SetMaxDuration(dur);
-                        SetSpellCooldown(RUPTURE_1, dur - 2000);
-                    }
-                }
-            }
-
-            //Cut to the Chase: Eviscerate and Envenom will refresh Slice and Dice duration
-            //getting cheaty - increase duration
-            if (spellId == GetSpell(EVISCERATE_1)/* || spellId == ENVENOM*/)
-            {
-                if (Aura* dice = me->GetAura(GetSpell(SLICE_DICE_1)))
-                {
-                    int32 dur = dice->GetMaxDuration() + 2000;
-                    dur = std::min<int32>(dur, 59000);
-                    dice->SetDuration(dur);
-                    dice->SetMaxDuration(dur);
-                    SetSpellCooldown(SLICE_DICE_1, dur - 2000);
-                }
-            }
-
-            //Murderous Intent: When Backstabbing enemy that is below 35% hp, instantly restoring 30 energy
-            if (spellId == GetSpell(BACKSTAB_1))
-            {
-                if (target->HealthBelowPct(35))
-                {
-                    //since talent doesn't work just restore energy manually
-                    //DoCast(me, MURDEROUS_INTENT_EFFECT, true);
-                    modenergy(30);
-                }
-            }
-
-            //Waylay
-            if ((spellId == GetSpell(BACKSTAB_1)/* || spellId == AMBUSH*/) &&
-                me->getLevel() >= 20)
-            {
-                DoCast(target, WAYLAY_EFFECT, true);
-            }
-
-            //if (spellId == SHADOWSTEP)
-            //{
-            //    Shadowstep_eff_Timer = 10000;
-            //    shadowstep = true;
-            //}
-
-            //move behind on Kidney Shot and Gouge (optionally)
-            if (spellId == GetSpell(KIDNEY_SHOT_1)/* || spellId == GOUGE*/)
-                if (MoveBehind(*target))
-                    wait = 3;
-
-            if (spellId == currentSpell)
-                currentSpell = 0;
-        }
-
-		void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType, SpellSchoolMask)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void OwnerAttackedBy(Unit* u)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void Reset()
-        {
-            comboPoints = 0;
-            tempComboPoints = 0;
-            tempAddCP = 0;
-
-            tempDICE = false;
-            //shadowstep = false;
-
-            me->setPowerType(POWER_ENERGY);
-            //10 energy gained per stack
-            RefreshAura(GLADIATOR_VIGOR, 10);
-
-            if (master)
-            {
-                SetStats(true);
-                InitRoles();
-                ApplyPassives(CLASS_ROGUE);
-            }
-
-            me->SetPower(POWER_ENERGY, me->GetMaxPower(POWER_ENERGY));
-        }
-
-        void ReduceCD(uint32 diff)
-        {
-            CommonTimers(diff);
-            SpellTimers(diff);
-            //if (Shadowstep_eff_Timer > diff)        Shadowstep_eff_Timer -= diff;
-            //else if (shadowstep)                    shadowstep = false;
-        }
-
-        bool CanRespawn()
-        {return false;}
-
-        void InitSpells()
-        {
-            uint8 lvl = me->getLevel();
-            InitSpellMap(BACKSTAB_1);
-            InitSpellMap(SINISTER_STRIKE_1);
-            InitSpellMap(SLICE_DICE_1);
-            InitSpellMap(EVISCERATE_1);
-            InitSpellMap(KICK_1);
-            InitSpellMap(RUPTURE_1);
-            InitSpellMap(KIDNEY_SHOT_1);
-            lvl >= 50 ? InitSpellMap(MUTILATE_1) : RemoveSpell(MUTILATE_1);
-            lvl >= 50 ? InitSpellMap(SHADOWSTEP_1) : RemoveSpell(SHADOWSTEP_1);
-            InitSpellMap(DISMANTLE_1);
-            lvl >= 30 ? InitSpellMap(BLADE_FLURRY_1) : RemoveSpell(BLADE_FLURRY_1);
-
-            InitSpellMap(WOUND_POISON_1);
-            InitSpellMap(MIND_NUMBING_POISON_1);
-        }
-
-        void ApplyClassPassives()
-        {
-            uint8 level = master->getLevel();
-
-            //if (level >= 78)
-            //    RefreshAura(ROGUE_ARMOR_ENERGIZE,2);
-            //else if (level >= 60)
-            //    RefreshAura(ROGUE_ARMOR_ENERGIZE);
-            if (level >= 70)
-                RefreshAura(COMBAT_POTENCY5,2);
-            else if (level >= 55)
-                RefreshAura(COMBAT_POTENCY5);
-            else if (level >= 52)
-                RefreshAura(COMBAT_POTENCY4);
-            else if (level >= 49)
-                RefreshAura(COMBAT_POTENCY3);
-            else if (level >= 47)
-                RefreshAura(COMBAT_POTENCY2);
-            else if (level >= 45)
-                RefreshAura(COMBAT_POTENCY1);
-            if (level >= 35)
-                RefreshAura(SEAL_FATE5);
-            else if (level >= 32)
-                RefreshAura(SEAL_FATE4);
-            else if (level >= 29)
-                RefreshAura(SEAL_FATE3);
-            else if (level >= 27)
-                RefreshAura(SEAL_FATE2);
-            else if (level >= 25)
-                RefreshAura(SEAL_FATE1);
-            if (level >= 78)
-                RefreshAura(VITALITY,4);
-            else if (level >= 70)
-                RefreshAura(VITALITY,3);
-            else if (level >= 55)
-                RefreshAura(VITALITY,2);
-            else if (level >= 40)
-                RefreshAura(VITALITY);
-            if (level >= 55)
-                RefreshAura(TURN_THE_TABLES);
-            if (level >= 40)
-                RefreshAura(DEADLY_BREW);
-            if (level >= 35)
-                RefreshAura(BLADE_TWISTING1);//allow rank 1 only
-            if (level >= 35)
-                RefreshAura(QUICK_RECOVERY2);
-            else if (level >= 30)
-                RefreshAura(QUICK_RECOVERY1);
-            if (level >= 30)
-                RefreshAura(IMPROVED_KIDNEY_SHOT);
-            if (level >= 10)
-                RefreshAura(GLYPH_BACKSTAB);
-            if (level >= 10)
-                RefreshAura(SURPRISE_ATTACKS);
-
-            //On 25 get Glyph of Vigor
-            if (level >= 25)
-                RefreshAura(ROGUE_VIGOR,2);
-            else if (level >= 20)
-                RefreshAura(ROGUE_VIGOR);
-        }
-
-    private:
-        uint32 energy;
-        uint8 comboPoints, tempComboPoints, tempAddCP;
-        bool tempDICE/*, shadowstep*/;
-
-        enum RogueBaseSpells
-        {
-            BACKSTAB_1                          = 53,
-            SINISTER_STRIKE_1                   = 1757,
-            SLICE_DICE_1                        = 5171,
-            EVISCERATE_1                        = 2098,
-            KICK_1                              = 1766,
-            RUPTURE_1                           = 1943,
-            KIDNEY_SHOT_1                       = 408,
-  /*Talent*/MUTILATE_1                          = 1329,
-  /*Talent*/SHADOWSTEP_1                        = 36554,
-            DISMANTLE_1                         = 51722,
-            BLADE_FLURRY_1                      = 33735,
-        //Special
-            WOUND_POISON_1                      = 13218,
-            MIND_NUMBING_POISON_1               = 5760
-        };
-
-        enum RoguePassives
-        {
-            //Talents
-            SEAL_FATE1                          = 14189,
-            SEAL_FATE2                          = 14190,
-            SEAL_FATE3                          = 14193,
-            SEAL_FATE4                          = 14194,
-            SEAL_FATE5                          = 14195,
-            COMBAT_POTENCY1                     = 35541,
-            COMBAT_POTENCY2                     = 35550,
-            COMBAT_POTENCY3                     = 35551,
-            COMBAT_POTENCY4                     = 35552,
-            COMBAT_POTENCY5                     = 35553,
-            QUICK_RECOVERY1                     = 31244,
-            QUICK_RECOVERY2                     = 31245,
-            BLADE_TWISTING1                     = 31124,
-            //BLADE_TWISTING2                     = 31126,
-            VITALITY                            = 61329,//rank 3
-            DEADLY_BREW                         = 51626,//rank 2
-            IMPROVED_KIDNEY_SHOT                = 14176,//rank 3
-            TURN_THE_TABLES                     = 51629,//rank 3
-            SURPRISE_ATTACKS                    = 32601,
-            ROGUE_VIGOR                         = 14983,
-            //Other
-            //ROGUE_ARMOR_ENERGIZE/*Deathmantle*/ = 27787,
-            GLADIATOR_VIGOR                     = 21975,
-            GLYPH_BACKSTAB                      = 56800
-        };
-
-        enum RogueSpecial
-        {
-            RELENTLESS_STRIKES_EFFECT           = 14181,
-            RUTHLESSNESS_EFFECT                 = 14157,
-            SEAL_FATE_EFFECT                    = 14189,
-            //SHADOWSTEP_EFFECT_DAMAGE            = 36563,
-            TURN_THE_TABLES_EFFECT              = 52910,//'rank 3'
-            WAYLAY_EFFECT                       = 51693,
-            //434
-            MURDEROUS_INTENT_EFFECT             = 79132
-        };
-    };
-};
-
-void AddSC_rogue_bot()
-{
-    new rogue_bot();
-}
diff --git a/src/server/game/AI/NpcBots/bot_shaman_ai.cpp b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
deleted file mode 100644
index 96e6fbc..0000000
--- a/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
+++ /dev/null
@@ -1,1384 +0,0 @@
-#include "bot_ai.h"
-#include "Group.h"
-#include "Player.h"
-#include "ScriptMgr.h"
-#include "SpellAuras.h"
-#include "Totem.h"
-#include "WorldSession.h"
-#include "SpellInfo.h"
-
-/*
-Shaman NpcBot (reworked by Graff onlysuffering@gmail.com)
-Complete - around 30%
-TODO:
-*/
-enum TotemSlot
-{
-    T_FIRE  = 0,//m_SummonSlot[1]
-    T_EARTH = 1,//m_SummonSlot[2]
-    T_WATER = 2,//m_SummonSlot[3]
-    T_AIR   = 3,//m_SummonSlot[4]
-    MAX_TOTEMS
-};
-struct TotemParam
-{
-    TotemParam() : effradius(0.f) {}
-    Position pos;
-    float effradius;
-};
-class shaman_bot : public CreatureScript
-{
-public:
-    shaman_bot() : CreatureScript("shaman_bot") { }
-
-    CreatureAI* GetAI(Creature* creature) const
-    {
-        return new shaman_botAI(creature);
-    }
-
-    bool OnGossipHello(Player* player, Creature* creature)
-    {
-        return bot_minion_ai::OnGossipHello(player, creature);
-    }
-
-    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
-    {
-        if (bot_minion_ai* ai = creature->GetBotMinionAI())
-            return ai->OnGossipSelect(player, creature, sender, action);
-        return true;
-    }
-
-    struct shaman_botAI : public bot_minion_ai
-    {
-        shaman_botAI(Creature* creature) : bot_minion_ai(creature)
-        {
-            Reset();
-        }
-
-        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
-        {
-            if (CheckBotCast(victim, spellId, CLASS_SHAMAN) != SPELL_CAST_OK)
-                return false;
-
-            bool maelstrom = false;
-            if (!triggered)
-                maelstrom = (MaelstromCount >= 5 &&
-                (spellId == GetSpell(LIGHTNING_BOLT_1) || spellId == GetSpell(CHAIN_LIGHTNING_1) ||
-                spellId == GetSpell(HEALING_WAVE_1) || spellId == GetSpell(LESSER_HEALING_WAVE_1) ||
-                spellId == GetSpell(CHAIN_HEAL_1) || spellId == GetSpell(HEX_1)));
-
-            triggered |= maelstrom;
-
-            bool result = bot_ai::doCast(victim, spellId, triggered, me->GetGUID());
-
-            if (result && maelstrom)
-            {
-                MaelstromCount = 0;
-                me->RemoveAurasDueToSpell(MAELSTROM_WEAPON_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
-            }
-
-            return result;
-        }
-
-        void StartAttack(Unit* u, bool force = false)
-        {
-            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
-            Aggro(u);
-            SetBotCommandState(COMMAND_ATTACK);
-            GetInPosition(force);
-        }
-
-        void EnterCombat(Unit*) { }
-        void Aggro(Unit*) { }
-        void AttackStart(Unit*) { }
-        void KilledUnit(Unit*) { }
-        void EnterEvadeMode() { }
-        void MoveInLineOfSight(Unit*) { }
-        void JustDied(Unit* u) { bot_ai::JustDied(u); }
-
-        bool Shielded(Unit* target) const
-        {
-            return
-                (HasAuraName(target, WATER_SHIELD_1) ||
-                HasAuraName(target, EARTH_SHIELD_1) ||
-                HasAuraName(target, LIGHTNING_SHIELD_1));
-        }
-
-        void CheckBloodlust(uint32 diff)
-        {
-            if (!IsSpellReady(BLOODLUST_1, diff, false) || me->GetDistance(master) > 18 || IsCasting() || Rand() > 15)
-                return;
-            if (!me->IsInCombat() || !master->IsInCombat())
-                return;
-
-            if (HasAuraName(master, BLOODLUST_1))
-            {
-                SetSpellCooldown(BLOODLUST_1, GetSpellCooldown(BLOODLUST_1) + 3000);
-                return;
-            }
-
-            if (Unit* u = me->GetVictim())
-            {
-                Creature* cre = u->ToCreature();
-                if (u->GetMaxHealth() > me->GetHealth() * 2 ||
-                    (cre && (cre->IsDungeonBoss() || cre->isWorldBoss())) ||
-                    me->getAttackers().size() + master->getAttackers().size() > 5)
-                {
-                    temptimer = GC_Timer;
-                    if (doCast(me, GetSpell(BLOODLUST_1)))
-                    {
-                        GC_Timer = temptimer;
-                        SetSpellCooldown(BLOODLUST_1, 180000); //3 min
-                        return;
-                    }
-                }
-            }
-
-            SetSpellCooldown(BLOODLUST_1, 2000); //fail
-        }
-
-        void CheckTotems(uint32 diff)
-        {
-            //update rate
-            if (Rand() > 25)
-                return;
-            //Unsummon
-            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
-            {
-                if (_totems[i].first != 0)
-                {
-                    if (master->GetDistance2d(_totems[i].second.pos.m_positionX, _totems[i].second.pos.m_positionY) > _totems[i].second.effradius &&
-                        me->GetDistance2d(_totems[i].second.pos.m_positionX, _totems[i].second.pos.m_positionY) > _totems[i].second.effradius)
-                    {
-                        Unit* to = sObjectAccessor->FindUnit(_totems[i].first);
-                        if (!to)
-                        {
-                            _totems[i].first = 0;
-                            //////TC_LOG_ERROR("entities.player", "%s has lost totem in slot %u! Despawned normally?", me->GetName().c_str(), i);
-                            continue;
-                        }
-
-                        to->ToTotem()->UnSummon();
-                    }
-                }
-            }
-            if (GC_Timer > diff || IsCasting() || me->GetDistance(master) > 15 || Feasting())
-                return;
-            //Summon
-            //TODO: role-based totems (attack/heal)
-            if (me->IsInCombat())
-            {
-                if (GetSpell(WINDFURY_TOTEM_1) && !_totems[T_AIR].first && !master->m_SummonSlot[T_AIR+1])
-                {
-                    temptimer = GC_Timer;
-                    if (doCast(me, GetSpell(WINDFURY_TOTEM_1)))
-                    {
-                        if (me->getLevel() >= 57)
-                            GC_Timer = temptimer;
-                        return;
-                    }
-                }
-
-                if (!_totems[T_EARTH].first && !master->m_SummonSlot[T_EARTH+1])
-                {
-                    if (GetSpell(STRENGTH_OF_EARTH_TOTEM_1))
-                    {
-                        temptimer = GC_Timer;
-                        if (doCast(me, GetSpell(STRENGTH_OF_EARTH_TOTEM_1)))
-                        {
-                            if (me->getLevel() >= 57)
-                                GC_Timer = temptimer;
-                            return;
-                        }
-                    }
-                    else if (GetSpell(STONESKIN_TOTEM_1))
-                    {
-                        temptimer = GC_Timer;
-                        if (doCast(me, GetSpell(STONESKIN_TOTEM_1)))
-                        {
-                            if (me->getLevel() >= 57)
-                                GC_Timer = temptimer;
-                            return;
-                        }
-                    }
-                }
-
-                if (!_totems[T_FIRE].first && !master->m_SummonSlot[T_FIRE+1])
-                {
-                    if (IsSpellReady(TOTEM_OF_WRATH_1, diff, false))
-                    {
-                        temptimer = GC_Timer;
-                        if (doCast(me, GetSpell(TOTEM_OF_WRATH_1)))
-                        {
-                            //bot's poor AI cannot use totems wisely so just reduce CD on this
-                            SetSpellCooldown(TOTEM_OF_WRATH_1, 30000); //30 sec, old 5 min
-                            if (me->getLevel() >= 57)
-                                GC_Timer = temptimer;
-                            return;
-                        }
-                    }
-                    else if (IsSpellReady(SEARING_TOTEM_1, diff, false))
-                    {
-                        if (Unit* u = me->GetVictim())
-                        {
-                            if (HasRole(BOT_ROLE_DPS) && me->GetExactDist(u) < (u->isMoving() ? 10 : 25))
-                            {
-                                temptimer = GC_Timer;
-                                if (doCast(me, GetSpell(SEARING_TOTEM_1)))
-                                {
-                                    SetSpellCooldown(SEARING_TOTEM_1, 20000);
-                                    if (me->getLevel() >= 57)
-                                        GC_Timer = temptimer;
-                                    return;
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-            if (!me->isMoving() && !master->isMoving())
-            {
-                if (!_totems[T_WATER].first && !master->m_SummonSlot[T_WATER+1])
-                {
-                    uint8 manapct = GetManaPCT(master);
-                    uint8 hppct = GetHealthPCT(master);
-                    if (GetSpell(HEALINGSTREAM_TOTEM_1) && hppct < 98 && master->getPowerType() != POWER_MANA &&
-                        (hppct < 25 || manapct > hppct))
-                    {
-                        temptimer = GC_Timer;
-                        if (doCast(me, GetSpell(HEALINGSTREAM_TOTEM_1)))
-                        {
-                            GC_Timer = temptimer;
-                            return;
-                        }
-                    }
-                    else if (GetSpell(MANASPRING_TOTEM_1) && (manapct < 97 || GetManaPCT(me) < 90))
-                    {
-                        temptimer = GC_Timer;
-                        if (doCast(me, GetSpell(MANASPRING_TOTEM_1)))
-                        {
-                            GC_Timer = temptimer;
-                            return;
-                        }
-                    }
-                }
-            }
-        }
-
-        void CheckThunderStorm(uint32 diff)
-        {
-            if (!IsSpellReady(THUNDERSTORM_1, diff, false) || !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 25)
-                return;
-
-            //case 1: low mana
-            if (GetManaPCT(me) < 15)
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, GetSpell(THUNDERSTORM_1)))
-                {
-                    GC_Timer = temptimer;
-                    SetSpellCooldown(THUNDERSTORM_1, 25000); //45 - 20 = 25 sec for mana restore
-                }
-                return;
-            }
-
-            //case 2: knock attackers
-            if (IsTank()) //pretty stupid idea I think
-                return;
-
-            //AttackerSet m_attackers = master->getAttackers();
-			Unit::AttackerSet b_attackers = me->getAttackers();
-            if (b_attackers.empty())
-                return;
-
-            uint8 tCount = 0;
-			for (Unit::AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
-            {
-                if (!(*iter)) continue;
-                if (me->GetExactDist((*iter)) > 9) continue;
-                if (CCed(*iter)) continue;
-                if (me->IsValidAttackTarget(*iter))
-                {
-                    ++tCount;
-                    break;
-                }
-            }
-
-            if (tCount > 0)
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, GetSpell(THUNDERSTORM_1)))
-                {
-                    GC_Timer = temptimer;
-                    SetSpellCooldown(THUNDERSTORM_1, 40000); //45 - 5 = 40 sec for knock
-                }
-                return;
-            }
-        }
-
-        void CheckManaTide(uint32 diff)
-        {
-            if (!IsSpellReady(MANA_TIDE_TOTEM_1, diff, false) || IsCasting() || Rand() > 20)
-                return;
-
-            Group* group = master->GetGroup();
-            if (!group)
-                return;
-
-            uint8 LMPcount = 0;
-            uint8 members = group->GetMembersCount();
-            for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
-            {
-                Player* tPlayer = itr->GetSource();
-                if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->GetMapId() != me->GetMapId() ||
-                    (!tPlayer->IsAlive() && !tPlayer->HaveBot())) continue;
-                if (me->GetExactDist(tPlayer) > 20) continue;
-                if (tPlayer->getPowerType() != POWER_MANA) continue;
-                if (GetManaPCT(tPlayer) < 35)
-                {
-                    ++LMPcount;
-                    if (LMPcount > 3 || LMPcount > members / 3) break;
-                }
-                if (tPlayer->HaveBot())
-                {
-                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
-                    {
-                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
-                        if (bot && bot->IsInWorld() && bot->getPowerType() == POWER_MANA &&
-                            bot->GetExactDist(me) < 20 && GetManaPCT(bot) < 35)
-                        {
-                            ++LMPcount;
-                            if (LMPcount > 3 || LMPcount > members / 3) break;
-                        }
-                    }
-                }
-            }
-
-            if (LMPcount > 3 || LMPcount > members / 3)
-            {
-                if (_totems[T_WATER].first != 0)
-                {
-                    Unit* to = sObjectAccessor->FindUnit(_totems[T_WATER].first);
-                    if (!to)
-                        _totems[T_WATER].first = 0;
-                    else
-                        to->ToTotem()->UnSummon();
-                }
-                if (doCast(me, GetSpell(MANA_TIDE_TOTEM_1)))
-                {
-                    SetSpellCooldown(MANA_TIDE_TOTEM_1, 60000); //1 min
-                    return;
-                }
-            }
-
-            SetSpellCooldown(MANA_TIDE_TOTEM_1, 3000); //fail
-        }
-
-        void UpdateAI(uint32 diff)
-        {
-            ReduceCD(diff);
-            if (IAmDead()) return;
-            CheckAttackState();
-            CheckAuras();
-            if (wait == 0)
-                wait = GetWait();
-            else
-                return;
-            CheckThunderStorm(diff);
-            BreakCC(diff);
-            if (CCed(me)) return;
-
-            CheckHexy(diff);
-            CheckEarthy(diff);
-
-            if (GetManaPCT(me) < 30 && Potion_cd <= diff)
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, MANAPOTION))
-                {
-                    Potion_cd = POTION_CD;
-                    GC_Timer = temptimer;
-                }
-            }
-
-            CheckBloodlust(diff);
-            BuffAndHealGroup(master, diff);
-            CureGroup(master, CURE_TOXINS, diff);
-            CheckManaTide(diff);
-            CheckTotems(diff);
-
-            if (master->IsInCombat() || me->IsInCombat())
-                CheckDispel(diff);
-
-            if (!me->IsInCombat())
-                DoNonCombatActions(diff);
-            //buff myself
-            if (GetSpell(LIGHTNING_SHIELD_1) && !IsTank() && !Shielded(me))
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, GetSpell(LIGHTNING_SHIELD_1)))
-                    GC_Timer = temptimer;
-            }
-            //heal myself
-            if (GetHealthPCT(me) < 80)
-                HealTarget(me, GetHealthPCT(me), diff);
-
-            if (!CheckAttackTarget(CLASS_SHAMAN))
-                return;
-
-            CheckHexy2(diff);
-
-            //Counter(diff);
-            DoNormalAttack(diff);
-        }
-
-        void Counter(uint32 diff)
-        {
-            if (!IsSpellReady(WIND_SHEAR_1, diff, false) || Rand() > 60)
-                return;
-
-            Unit* u = me->GetVictim();
-            if (u && u->IsNonMeleeSpellCast(false))
-            {
-                temptimer = GC_Timer;
-                if (me->IsNonMeleeSpellCast(false))
-                    me->InterruptNonMeleeSpells(false);
-                if (doCast(u, GetSpell(WIND_SHEAR_1)))
-                {
-                    SetSpellCooldown(WIND_SHEAR_1, 5000); //improved
-                    GC_Timer = temptimer;
-                }
-            }
-            else if (Unit* target = FindCastingTarget(25))
-            {
-                temptimer = GC_Timer;
-                if (me->IsNonMeleeSpellCast(false))
-                    me->InterruptNonMeleeSpells(false);
-                if (doCast(target, GetSpell(WIND_SHEAR_1)))
-                {
-                    SetSpellCooldown(WIND_SHEAR_1, 5000);
-                    GC_Timer = temptimer;
-                }
-            }
-        }
-
-        void DoNormalAttack(uint32 diff)
-        {
-            opponent = me->GetVictim();
-            if (opponent)
-            {
-                if (!IsCasting())
-                    StartAttack(opponent, true);
-            }
-            else
-                return;
-
-            Counter(diff);
-
-            //AttackerSet m_attackers = master->getAttackers();
-            //AttackerSet b_attackers = me->getAttackers();
-            float dist = me->GetExactDist(opponent);
-            float meleedist = me->GetDistance(opponent);
-
-            if (MoveBehind(*opponent))
-                wait = 5;
-
-            if (IsCasting()) return;
-
-            //STORMSTRIKE
-            if (IsSpellReady(STORMSTRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && IsMelee() && Rand() < 70)
-            {
-                if (doCast(opponent, GetSpell(STORMSTRIKE_1)))
-                {
-                    SetSpellCooldown(STORMSTRIKE_1, 6000); //improved
-                    return;
-                }
-            }
-            //SHOCKS
-            if ((GetSpell(FLAME_SHOCK_1) || GetSpell(EARTH_SHOCK_1) || GetSpell(FROST_SHOCK_1)) &&
-                IsSpellReady(FLAME_SHOCK_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 25 && Rand() < 30)
-            {
-                temptimer = GC_Timer;
-
-                bool canFlameShock = (GetSpell(FLAME_SHOCK_1) != 0);
-                if (canFlameShock)
-                {
-                    if (Aura* fsh = opponent->GetAura(GetSpell(FLAME_SHOCK_1), me->GetGUID()))
-                        if (fsh->GetDuration() > 3000)
-                            canFlameShock = false;
-                }
-
-                if (canFlameShock)
-                {
-                    if (doCast(opponent, GetSpell(FLAME_SHOCK_1)))
-                    {
-                        SetSpellCooldown(FLAME_SHOCK_1, 3000); //improved twice
-                        SetSpellCooldown(EARTH_SHOCK_1, 3000); //improved twice
-                        SetSpellCooldown(FROST_SHOCK_1, 3000); //improved twice
-                        GC_Timer = temptimer;
-                        return;
-                    }
-                }
-                else if (GetSpell(EARTH_SHOCK_1) || GetSpell(FROST_SHOCK_1))
-                {
-                    uint32 SHOCK = !GetSpell(FROST_SHOCK_1) ? GetSpell(EARTH_SHOCK_1) : RAND(GetSpell(EARTH_SHOCK_1), GetSpell(FROST_SHOCK_1));
-                    if (SHOCK && !opponent->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)) &&
-                        !opponent->HasAura(SHOCK))
-                    {
-                        if (doCast(opponent, SHOCK))
-                        {
-                            SetSpellCooldown(FLAME_SHOCK_1, 3000); //improved twice
-                            SetSpellCooldown(EARTH_SHOCK_1, 3000); //improved twice
-                            SetSpellCooldown(FROST_SHOCK_1, 3000); //improved twice
-                            GC_Timer = temptimer;
-                            return;
-                        }
-                    }
-                }
-            }
-            //LAVA BURST
-            if (IsSpellReady(LAVA_BURST_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 50)
-            {
-                if (doCast(opponent, GetSpell(LAVA_BURST_1)))
-                {
-                    SetSpellCooldown(LAVA_BURST_1, 8000);
-                    return;
-                }
-            }
-
-            if (GetManaPCT(me) < 15 || (MaelstromCount < 5 && IsMelee()))
-                return;
-
-            //CHAIN LIGHTNING
-            if (IsSpellReady(CHAIN_LIGHTNING_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 80)
-            {
-                if (doCast(opponent, GetSpell(CHAIN_LIGHTNING_1)))
-                {
-                    SetSpellCooldown(CHAIN_LIGHTNING_1, 3500); //improved
-                    return;
-                }
-            }
-            //LIGHTNING BOLT
-            if (IsSpellReady(LIGHTNING_BOLT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30)
-            {
-                uint32 LIGHTNING_BOLT = GetSpell(LIGHTNING_BOLT_1);
-                if (doCast(opponent, LIGHTNING_BOLT))
-                {
-                    SetSpellCooldown(LIGHTNING_BOLT_1, uint32(float(sSpellMgr->GetSpellInfo(LIGHTNING_BOLT)->CalcCastTime()/100) * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 200));
-                    return;
-                }
-            }
-        }
-
-        void CheckHexy(uint32 diff)
-        {
-            if (HexyCheckTimer <= diff)
-            {
-                Hexy = FindAffectedTarget(GetSpell(HEX_1), me->GetGUID());
-                HexyCheckTimer = 2000;
-            }
-        }
-
-        void CheckHexy2(uint32 diff)
-        {
-            if (Hexy == false && me->GetVictim() && IsSpellReady(HEX_1, diff, false))
-            {
-                if (Unit* target = FindPolyTarget(20, me->GetVictim()))
-                {
-                    if (doCast(target, GetSpell(HEX_1)))
-                    {
-                        Hexy = true;
-                        SetSpellCooldown(HEX_1, 30000); //45 - 15 = 30 sec for bots
-                        HexyCheckTimer += 2000;
-                    }
-                }
-            }
-        }
-
-        void CheckEarthy(uint32 diff)
-        {
-            if (EarthyCheckTimer <= diff)
-            {
-                Unit* u = FindAffectedTarget(GetSpell(EARTH_SHIELD_1), me->GetGUID(), 90.f, 2);
-                Earthy = (u && (IsTank(u) || u == master));
-                EarthyCheckTimer = 1000;
-            }
-        }
-
-        void DoNonCombatActions(uint32 diff)
-        {
-            if (GC_Timer > diff || Rand() > 50 || me->IsMounted()) return;
-
-            RezGroup(GetSpell(ANCESTRAL_SPIRIT_1), master);
-
-            if (Feasting()) return;
-
-            if (Shielded(me) && Rand() < 25)
-            {
-                Aura* shield = NULL;
-                uint32 SHIELD = HasRole(BOT_ROLE_DPS) ? GetSpell(LIGHTNING_SHIELD_1) : 0;
-                if (SHIELD)
-                    shield = me->GetAura(SHIELD);
-                if (!shield && IsTank() && GetSpell(EARTH_SHIELD_1))
-                {
-                    SHIELD = GetSpell(EARTH_SHIELD_1);
-                    shield = me->GetAura(SHIELD);
-                }
-                if (!shield && GetSpell(WATER_SHIELD_1))
-                {
-                    SHIELD = GetSpell(WATER_SHIELD_1);
-                    shield = me->GetAura(SHIELD);
-                }
-                if (shield && shield->GetCharges() < 5)
-                {
-                    temptimer = GC_Timer;
-                    if (doCast(me, SHIELD))
-                    {
-                        GC_Timer = temptimer;
-                        return;
-                    }
-                }
-            }
-        }
-
-        bool BuffTarget(Unit* target, uint32 diff)
-        {
-            if (!GetSpell(WATER_WALKING_1) && !GetSpell(WATER_BREATHING_1) && !GetSpell(EARTH_SHIELD_1))
-                return false;
-
-            if (GC_Timer > diff || !target || !target->IsAlive() || Rand() > 40)
-                return false;
-
-            if (GetSpell(EARTH_SHIELD_1) && Earthy == false && (target == master || IsTank(target)) &&
-                (target->IsInCombat() || !target->isMoving()) &&
-                me->GetExactDist(target) < 40 && Rand() < 75)
-            {
-                bool cast = !Shielded(target);
-                if (!cast)
-                    if (Aura* eShield = target->GetAura(GetSpell(EARTH_SHIELD_1)))
-                        if (eShield->GetCharges() < 5)
-                            cast = true;
-                if (cast && doCast(target, GetSpell(EARTH_SHIELD_1)))
-                {
-                    Earthy = true;
-                    //GC_Timer = 800;
-                    return true;
-                }
-            }
-
-            if (me->GetExactDist(target) > 30) return false;
-            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
-
-            if (target->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING))
-            {
-                //bots don't need water breathing
-                if (GetSpell(WATER_BREATHING_1) && target->GetTypeId() == TYPEID_PLAYER &&
-                    !target->HasAuraType(SPELL_AURA_WATER_BREATHING) &&
-                    doCast(target, GetSpell(WATER_BREATHING_1)))
-                {
-                    //GC_Timer = 800;
-                    return true;
-                }
-                //water walking breaks on any damage
-                if (GetSpell(WATER_WALKING_1) && target->getAttackers().empty() &&
-                    !target->HasAuraType(SPELL_AURA_WATER_WALK) &&
-                    doCast(target, GetSpell(WATER_WALKING_1)))
-                {
-                    //GC_Timer = 800;
-                    return true;
-                }
-            }
-            return false;
-        }
-
-        void CheckDispel(uint32 diff)
-        {
-            if (!IsSpellReady(PURGE_1, diff, false) || IsCasting() || Rand() > 35)
-                return;
-
-            Unit* target = FindHostileDispelTarget();
-            if (target && doCast(target, GetSpell(PURGE_1)))
-                SetSpellCooldown(PURGE_1, 1000);
-
-            SetSpellCooldown(PURGE_1, 3000);
-        }
-
-        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
-        {
-            if (!HasRole(BOT_ROLE_HEAL))
-                return false;
-            if (hp > 97)
-                return false;
-            if (!target || !target->IsAlive() || me->GetExactDist(target) > 40)
-                return false;
-            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid())
-                return false;
-
-            //PLACEHOLDER: Instant spell req. interrupt current spell
-
-            if (IsCasting()) return false;
-
-            if (IsSpellReady(LESSER_HEALING_WAVE_1, diff) &&
-                ((hp > 70 && hp < 85) || hp < 50 || GetLostHP(target) > 1800) && Rand() < 75)
-            {
-                if (doCast(target, GetSpell(LESSER_HEALING_WAVE_1)))
-                    return true;
-            }
-            if (IsSpellReady(HEALING_WAVE_1, diff) &&
-                hp > 40 && (hp < 75 || GetLostHP(target) > 4000) && Rand() < 65)
-            {
-                if (doCast(target, GetSpell(HEALING_WAVE_1)))
-                    return true;
-            }
-            if (IsSpellReady(CHAIN_HEAL_1, diff) &&
-                ((hp > 40 && hp < 90) || GetLostHP(target) > 1300) && Rand() < 120)
-            {
-                if (IsSpellReady(RIPTIDE_1, diff, false) && (hp < 85 || GetLostHP(target) > 2500) &&
-                    !target->HasAura(GetSpell(RIPTIDE_1)))
-                {
-                    temptimer = GC_Timer;
-                    if (doCast(target, GetSpell(RIPTIDE_1), true))
-                    {
-                        SetSpellCooldown(RIPTIDE_1, 5000);
-                        if (doCast(target, GetSpell(CHAIN_HEAL_1)))
-                        {
-                            GC_Timer = temptimer;
-                            return true;
-                        }
-                    }
-                }
-                else if (doCast(target, GetSpell(CHAIN_HEAL_1)))
-                    return true;
-            }
-
-            return false;
-        }
-
-        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
-        {
-            uint32 spellId = spellInfo->Id;
-            uint8 lvl = me->getLevel();
-            float fdamage = float(damage);
-            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
-            if (!crit)
-            {
-                float aftercrit = 0.f;
-                ////Incite: 15% additional critical chance for Cleave, Heroic Strike and Thunder Clap
-                //if (lvl >= 15 && spellId == CLEAVE /*|| spellId == HEROICSTRIKE || spellId == THUNDERCLAP*/)
-                //    aftercrit += 15.f;
-
-                //second roll (may be illogical)
-                if (aftercrit > 0.f)
-                    crit = roll_chance_f(aftercrit);
-            }
-
-            //2) apply bonus damage mods
-            float pctbonus = 0.0f;
-            if (crit)
-            {
-                //!!!Melee spell damage is not yet critical, all reduced by half
-                //Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost (all) spells
-                if (lvl >= 21)
-                    pctbonus += 0.25f;
-            }
-
-            //SHAMAN_T8_ENCHANCEMENT_2P_BONUS: 20% bonus damage for Lava Lash and Stormstrike
-            if (lvl >= 60 &&
-                (spellId == STORMSTRIKE_DAMAGE || spellId == STORMSTRIKE_DAMAGE_OFFHAND/* || spellId == LAVA_LASH*/))
-                pctbonus += 0.2f;
-
-            //custom bonus to make stormstrike useful
-            if (spellId == STORMSTRIKE_DAMAGE || spellId == STORMSTRIKE_DAMAGE_OFFHAND)
-                pctbonus += 1.0f;
-
-            damage = int32(fdamage * (1.0f + pctbonus));
-        }
-
-        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
-        {
-            uint32 spellId = spellInfo->Id;
-            uint8 lvl = me->getLevel();
-            float fdamage = float(damage);
-            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
-            if (!crit)
-            {
-                float aftercrit = 0.f;
-                //Call of Thunder: 5% additional critical chance for Lightning Bolt, Chain Lightning and Thunderstorm,
-                if (lvl >= 30 &&
-                    (spellId == GetSpell(LIGHTNING_BOLT_1) ||
-                    spellId == GetSpell(CHAIN_LIGHTNING_1) ||
-                    spellId == GetSpell(THUNDERSTORM_1)))
-                    aftercrit += 5.f;
-                //Tidal Mastery (part 2): 5% additional critical chance for lightning spells
-                if (lvl >= 25 && (SPELL_SCHOOL_MASK_NATURE & spellInfo->GetSchoolMask()))
-                    aftercrit += 5.f;
-
-                if (aftercrit > 0.f)
-                    crit = roll_chance_f(aftercrit);
-            }
-
-            //2) apply bonus damage mods
-            float pctbonus = 0.0f;
-            if (crit)
-            {
-                //!!!spell damage is not yet critical and will be multiplied by 1.5
-                //so we should put here bonus damage mult /1.5
-                //Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost (all) spells
-                if (lvl >= 21)
-                    pctbonus += 0.333f;
-                //Lava Flows (part 1): 24% additional crit damage bonus for Lava Burst
-                if (lvl >= 50 && spellId == GetSpell(LAVA_BURST_1))
-                    pctbonus += 0.16f;
-            }
-            //Concussion: 5% bonus damage for Lightning Bolt, Chain Lightning, Thunderstorm, Lava Burst and Shocks
-            if (lvl >= 10 &&
-                (spellId == GetSpell(LIGHTNING_BOLT_1) ||
-                spellId == GetSpell(CHAIN_LIGHTNING_1) ||
-                spellId == GetSpell(THUNDERSTORM_1) ||
-                spellId == GetSpell(LAVA_BURST_1) ||
-                spellId == GetSpell(EARTH_SHOCK_1) ||
-                spellId == GetSpell(FROST_SHOCK_1) ||
-                spellId == GetSpell(FLAME_SHOCK_1)))
-                pctbonus += 0.05f;
-            //Call of Flame (part 2): 6% bonus damage for Lava burst
-            if (lvl >= 15 && spellId == GetSpell(LAVA_BURST_1))
-                pctbonus += 0.06f;
-            //Storm, Earth and fire (part 3): 60% bonus damage for Flame Shock (periodic damage in fact but who cares?)
-            if (lvl >= 40 && spellId == GetSpell(FLAME_SHOCK_1))
-                pctbonus += 0.6f;
-            //Booming Echoes (part 2): 20% bonus damage for Flame Shock and Frost Shock (direct damage)
-            if (lvl >= 45 &&
-                (spellId == GetSpell(FLAME_SHOCK_1) ||
-                spellId == GetSpell(FROST_SHOCK_1)))
-                pctbonus += 0.2f;
-
-            //flat damage mods (temp)
-            ////Shamanism: 25% bonus damage from bonus damage effects for Lightning Bolt, Chain Lightning and Lava Burst
-            //if (lvl >= 55 &&
-            //    (spellId == LIGHTNING_BOLT ||
-            //    spellId == CHAIN_LIGHTNING ||
-            //    spellId == LAVA_BURST))
-            //    fdamage += float(m_spellpower / 4);
-
-            damage = int32(fdamage * (1.0f + pctbonus));
-        }
-
-        void OnBotDespawn(Creature* summon)
-        {
-            if (!summon)
-            {
-                UnsummonAll();
-                return;
-            }
-
-            TempSummon* totem = summon->ToTempSummon();
-            if (!totem || !totem->ToTotem())
-            {
-                ////TC_LOG_ERROR("entities.player", "SummonedCreatureDespawn(): Shaman bot %s has despawned summon %s which is not a temp summon or not a totem...", me->GetName().c_str(), summon->GetName().c_str());
-                return;
-            }
-
-            int8 slot = -1;
-            switch (totem->m_Properties->Id)
-            {
-                case SUMMON_TYPE_TOTEM_FIRE:
-                    slot = T_FIRE;
-                    break;
-                case SUMMON_TYPE_TOTEM_EARTH:
-                    slot = T_EARTH;
-                    break;
-                case SUMMON_TYPE_TOTEM_WATER:
-                    slot = T_WATER;
-                    break;
-                case SUMMON_TYPE_TOTEM_AIR:
-                    slot = T_AIR;
-                    break;
-                default:
-                    ////TC_LOG_ERROR("entities.player", "SummonedCreatureDespawn(): Shaman bot %s has despawned totem %s with unknown type %u", me->GetName().c_str(), summon->GetName().c_str(), totem->m_Properties->Id);
-                    return;
-            }
-
-            _totems[slot].first = 0;
-        }
-
-        void OnBotSummon(Creature* summon)
-        {
-            TempSummon* totem = summon->ToTempSummon();
-            if (!totem || !totem->ToTotem())
-            {
-                ////TC_LOG_ERROR("entities.player", "OnBotSummon(): Shaman bot %s has summoned creature %s which is not a temp summon or not a totem...", me->GetName().c_str(), summon->GetName().c_str());
-                return;
-            }
-
-            totem->SetCreatorGUID(me->GetGUID());
-
-            int8 slot = -1;
-            switch (totem->m_Properties->Id)
-            {
-                case SUMMON_TYPE_TOTEM_FIRE:
-                    slot = T_FIRE;
-                    break;
-                case SUMMON_TYPE_TOTEM_EARTH:
-                    slot = T_EARTH;
-                    break;
-                case SUMMON_TYPE_TOTEM_WATER:
-                    slot = T_WATER;
-                    break;
-                case SUMMON_TYPE_TOTEM_AIR:
-                    slot = T_AIR;
-                    break;
-                default:
-                    ////TC_LOG_ERROR("entities.player", "OnBotSummon(): Shaman bot %s has summoned totem %s with unknown type %u", me->GetName().c_str(), summon->GetName().c_str(), totem->m_Properties->Id);
-                    return;
-            }
-
-            float radius = 0.f;
-            if (SpellInfo const* info = sSpellMgr->GetSpellInfo(summon->m_spells[0]))
-                if (SpellRadiusEntry const* entry = info->Effects[0].RadiusEntry)
-                    radius = entry->RadiusMax;
-
-            _totems[slot].first = summon->GetGUID();
-            _totems[slot].second.pos.Relocate(*summon);
-            _totems[slot].second.effradius = std::max<float>(radius, 20.f) + 5.f;
-
-            //////TC_LOG_ERROR("entities.player", "shaman bot: summoned %s (type %u) at x='%f', y='%f', z='%f'",
-            //    summon->GetName().c_str(), slot, _totems[slot].second.GetPositionX(), _totems[slot].second.GetPositionY(), _totems[slot].second.GetPositionZ());
-
-            summon->SetDisplayId(me->GetModelForTotem(PlayerTotemType(totem->m_Properties->Id)));
-            master->m_SummonSlot[++slot] = 0;
-        }
-
-        void SpellHit(Unit* caster, SpellInfo const* spell)
-        {
-            uint32 spellId = spell->Id;
-
-            //Maelstrom Weapon improved: 10% to gain full stack and 30% to add an extra stack
-            if (spellId == MAELSTROM_WEAPON_BUFF)
-            {
-                if (Aura* mwb = me->GetAura(MAELSTROM_WEAPON_BUFF))
-                {
-                    uint32 stacks = mwb->GetStackAmount();
-                    if (stacks < 5)
-                    {
-                        if (urand(1,100) <= 10)
-                            mwb->ModStackAmount(5);
-                        if (urand(1,100) <= 30)
-                            mwb->ModStackAmount(1);
-                    }
-
-                    MaelstromCount = mwb->GetStackAmount();
-                }
-
-                MaelstromTimer = 30000; //30 sec duration then reset
-            }
-
-            OnSpellHit(caster, spell);
-        }
-
-        void SpellHitTarget(Unit* target, SpellInfo const* spell)
-        {
-            uint32 spellId = spell->Id;
-            //Shields improvement, replaces Static Shock (part 2) and Improved Earth Shield (part 1)
-            if (spellId == GetSpell(LIGHTNING_SHIELD_1) ||
-                spellId == GetSpell(EARTH_SHIELD_1)/* ||
-                spellId == GetSpell(WATER_SHIELD_1)*/)
-            {
-                if (Aura* shield = target->GetAura(spellId, me->GetGUID()))
-                {
-                    shield->SetCharges(shield->GetCharges() + 12);
-                }
-            }
-            //Lightning Overload: 20% cast SAME spell with no mana! make sure this does not proc on itself!
-            if (me->getLevel() >= 40 && (spellId == GetSpell(LIGHTNING_SHIELD_1) || spellId == GetSpell(CHAIN_LIGHTNING_1)))
-            {
-                bool cast = (urand(1,100) <= 20);
-                if (spellId == GetSpell(LIGHTNING_BOLT_1))
-                {
-                    if (LOvBolt == false)
-                    {
-                        if (cast)
-                        {
-                            LOvBolt = true;
-                            me->CastSpell(target, spellId, true);
-                        }
-                    }
-                    else
-                        LOvBolt = false;
-                }
-                if (spellId == GetSpell(CHAIN_LIGHTNING_1))
-                {
-                    if (LOvChain == false)
-                    {
-                        if (cast)
-                        {
-                            LOvChain = true;
-                            me->CastSpell(target, spellId, true);
-                        }
-                    }
-                    else
-                        LOvChain = false;
-                }
-            }
-            if (spellId == GetSpell(STORMSTRIKE_1))
-            {
-                //Windfury: 10% chance
-                if (WindfuryTimer == 0 && me->getLevel() >= 30)
-                {
-                    if (urand(0,100) < 10)
-                        WindfuryTimer = 1000;
-
-                    if (WindfuryTimer > 0)
-                        me->CastSpell(target, WINDFURY_PROC, true);
-                }
-            }
-        }
-
-        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
-        {
-            if (victim == me)
-                return;
-
-            if (damageType == DIRECT_DAMAGE)
-            {
-                //Windfury: 10% chance
-                if (WindfuryTimer == 0 && me->getLevel() >= 30)
-                {
-                    if (urand(0,100) < 10)
-                        WindfuryTimer = 1000;
-
-                    if (WindfuryTimer > 0)
-                        me->CastSpell(victim, WINDFURY_PROC, true);
-                }
-            }
-
-            if (victim == me)
-                return;
-
-            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
-            {
-                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
-                {
-                    if (_ctc[i].first && !_ctc[i].second)
-                    {
-                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
-                            _ctc[i].second = 1000;
-
-                        if (_ctc[i].second > 0)
-                            me->CastSpell(victim, _ctc[i].first, true);
-                    }
-                }
-            }
-        }
-
-		void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType, SpellSchoolMask)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void OwnerAttackedBy(Unit* u)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void UnsummonAll()
-        {
-            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
-            {
-                if (_totems[i].first != 0)
-                {
-                    Unit* to = sObjectAccessor->FindUnit(_totems[i].first);
-                    if (!to)
-                    {
-                        //////TC_LOG_ERROR("entities.player", "%s has no totem in slot %u during remove!", me->GetName().c_str(), i);
-                        continue;
-                    }
-                    to->ToTotem()->UnSummon();
-                }
-            }
-        }
-
-        void Reset()
-        {
-            HexyCheckTimer = 3000;
-            EarthyCheckTimer = 2000;
-            MaelstromTimer = 0;
-            WindfuryTimer = 0;
-
-            MaelstromCount = 0;
-
-            Hexy = false;
-            Earthy = false;
-            LOvBolt = false;
-            LOvChain = false;
-
-            if (master)
-            {
-                SetStats(true);
-                InitRoles();
-                ApplyPassives(CLASS_SHAMAN);
-            }
-        }
-
-        void ReduceCD(uint32 diff)
-        {
-            CommonTimers(diff);
-            SpellTimers(diff);
-
-            if (HexyCheckTimer > diff)          HexyCheckTimer -= diff;
-            if (EarthyCheckTimer > diff)        EarthyCheckTimer -= diff;
-
-            if (MaelstromTimer > diff)          MaelstromTimer -= diff;
-            else if (MaelstromCount > 0)        MaelstromCount = 0;
-
-            if (WindfuryTimer > diff)           WindfuryTimer -= diff;
-            else                                WindfuryTimer = 0;
-        }
-
-        bool CanRespawn()
-        {return false;}
-
-        void InitSpells()
-        {
-            uint8 lvl = me->getLevel();
-            InitSpellMap(HEALING_WAVE_1);
-            InitSpellMap(CHAIN_HEAL_1);
-            InitSpellMap(LESSER_HEALING_WAVE_1);
-  /*Talent*/lvl >= 60 ? InitSpellMap(RIPTIDE_1) : RemoveSpell(RIPTIDE_1);
-            InitSpellMap(ANCESTRAL_SPIRIT_1);
-            CURE_TOXINS = lvl >= 39 ? CLEANSE_SPIRIT_1 : InitSpell(me, CURE_TOXINS_1);
-            InitSpellMap(FLAME_SHOCK_1);
-            InitSpellMap(EARTH_SHOCK_1);
-            InitSpellMap(FROST_SHOCK_1);
-  /*Talent*/lvl >= 40 ? InitSpellMap(STORMSTRIKE_1) : RemoveSpell(STORMSTRIKE_1);
-            InitSpellMap(LIGHTNING_BOLT_1);
-            InitSpellMap(CHAIN_LIGHTNING_1);
-            InitSpellMap(LAVA_BURST_1);
-  /*Talent*/lvl >= 60 ? InitSpellMap(THUNDERSTORM_1) : RemoveSpell(THUNDERSTORM_1);
-            InitSpellMap(LIGHTNING_SHIELD_1);
-  /*Talent*/lvl >= 50 ? InitSpellMap(EARTH_SHIELD_1) : RemoveSpell(EARTH_SHIELD_1);
-     /*NYI*///InitSpellMap(WATER_SHIELD_1);
-            InitSpellMap(WATER_BREATHING_1);
-            InitSpellMap(WATER_WALKING_1);
-  /*CUSTOM*/lvl >= 60 ? InitSpellMap(BLOODLUST_1) : RemoveSpell(BLOODLUST_1);
-            InitSpellMap(PURGE_1);
-            InitSpellMap(WIND_SHEAR_1);
-            InitSpellMap(HEX_1);
-   /*Quest*/lvl >= 10 ? InitSpellMap(STONESKIN_TOTEM_1) : RemoveSpell(STONESKIN_TOTEM_1);
-            InitSpellMap(HEALINGSTREAM_TOTEM_1);
-            InitSpellMap(MANASPRING_TOTEM_1);
-   /*Quest*/lvl >= 10 ? InitSpellMap(SEARING_TOTEM_1) : RemoveSpell(SEARING_TOTEM_1);
-            InitSpellMap(WINDFURY_TOTEM_1);
-            InitSpellMap(STRENGTH_OF_EARTH_TOTEM_1);
-  /*Talent*/lvl >= 50 ? InitSpellMap(TOTEM_OF_WRATH_1) : RemoveSpell(TOTEM_OF_WRATH_1);
-  /*Talent*/lvl >= 40 ? InitSpellMap(MANA_TIDE_TOTEM_1) : RemoveSpell(MANA_TIDE_TOTEM_1);
-        }
-
-        void ApplyClassPassives()
-        {
-            uint8 level = master->getLevel();
-            if (level >= 58)
-                RefreshAura(ELEMENTAL_WARDING,2); //12%
-            else if (level >= 15)
-                RefreshAura(ELEMENTAL_WARDING); //6%
-            if (level >= 18)
-                RefreshAura(ELEMENTAL_DEVASTATION3); //9%
-            else if (level >= 15)
-                RefreshAura(ELEMENTAL_DEVASTATION2); //6%
-            else if (level >= 12)
-                RefreshAura(ELEMENTAL_DEVASTATION1); //3%
-            if (level >= 30)
-                RefreshAura(ANCESTRAL_KNOWLEDGE,3); //30%
-            else if (level >= 20)
-                RefreshAura(ANCESTRAL_KNOWLEDGE,2); //20%
-            else if (level >= 10)
-                RefreshAura(ANCESTRAL_KNOWLEDGE); //10%
-            if (level >= 25)
-                RefreshAura(TOUGHNESS); //10%, 30%
-            if (level >= 29)
-                RefreshAura(FLURRY5); //30%
-            else if (level >= 28)
-                RefreshAura(FLURRY4); //24%
-            else if (level >= 27)
-                RefreshAura(FLURRY3); //18%
-            else if (level >= 26)
-                RefreshAura(FLURRY2); //12%
-            else if (level >= 25)
-                RefreshAura(FLURRY1); //6%
-            if (level >= 50)
-                RefreshAura(WEAPON_MASTERY,3); //30%
-            else if (level >= 40)
-                RefreshAura(WEAPON_MASTERY,2); //20%
-            else if (level >= 30)
-                RefreshAura(WEAPON_MASTERY); //10%
-            if (level >= 45)
-                RefreshAura(STATIC_SHOCK,2); //12%
-            else if (level >= 41)
-                RefreshAura(STATIC_SHOCK); //6%
-            if (level >= 20)
-                RefreshAura(ANCESTRAL_HEALING); //10%
-            if (level >= 50)
-                RefreshAura(ANCESTRAL_AWAKENING); //30%
-
-            if (level >= 70)
-                RefreshAura(SHAMAN_T10_RESTO_4P); //25%
-
-            if (level >= 40)
-            {
-                if (level >= 70)
-                    RefreshAura(MAELSTROM_WEAPON5,2);
-                else if (level >= 60)
-                    RefreshAura(MAELSTROM_WEAPON5);
-                else if (level >= 55)
-                    RefreshAura(MAELSTROM_WEAPON4);
-                else if (level >= 50)
-                    RefreshAura(MAELSTROM_WEAPON3);
-                else if (level >= 45)
-                    RefreshAura(MAELSTROM_WEAPON2);
-                else// if (level >= 40)
-                    RefreshAura(MAELSTROM_WEAPON1);
-
-                RefreshAura(UNLEASHED_RAGE);
-                RefreshAura(IMPROVED_STORMSTRIKE); //20%
-                RefreshAura(ELEMENTAL_OATH);
-            }
-
-            EARTHLIVING_WEAPON =
-                level >= 70 ? EARTHLIVING_WEAPON_PASSIVE_6 :
-                level >= 50 ? EARTHLIVING_WEAPON_PASSIVE_5 :
-                level >= 30 ? EARTHLIVING_WEAPON_PASSIVE_4 : 0;
-            if (EARTHLIVING_WEAPON)
-            {
-                me->RemoveAurasDueToSpell(EARTHLIVING_WEAPON_PASSIVE_4);
-                me->RemoveAurasDueToSpell(EARTHLIVING_WEAPON_PASSIVE_5);
-                me->RemoveAurasDueToSpell(EARTHLIVING_WEAPON_PASSIVE_6);
-                RefreshAura(EARTHLIVING_WEAPON, 3);
-            }
-        }
-
-        bool CanUseManually(uint32 basespell) const
-        {
-            switch (basespell)
-            {
-                case HEALING_WAVE_1:
-                case CHAIN_HEAL_1:
-                case LESSER_HEALING_WAVE_1:
-                case RIPTIDE_1:
-                case CURE_TOXINS_1:
-                case CLEANSE_SPIRIT_1:
-                case BLOODLUST_1:
-                case WATER_SHIELD_1:
-                case MANA_TIDE_TOTEM_1:
-                    return true;
-                default:
-                    return false;
-            }
-        }
-
-    private:
-        typedef std::pair<uint64 /*guid*/, TotemParam /*param*/> BotTotem;
-        BotTotem _totems[MAX_TOTEMS];
-        uint32 CURE_TOXINS;
-        uint32 EARTHLIVING_WEAPON;
-        //Timers
-        uint32 HexyCheckTimer, EarthyCheckTimer, MaelstromTimer, WindfuryTimer;
-        uint8 MaelstromCount;
-        bool Hexy, Earthy, LOvChain, LOvBolt;
-
-        enum ShamanBaseSpells
-        {
-            HEALING_WAVE_1                      = 331,
-            CHAIN_HEAL_1                        = 1064,
-            LESSER_HEALING_WAVE_1               = 8004,
-            RIPTIDE_1                           = 61295,
-            ANCESTRAL_SPIRIT_1                  = 2008,
-            CURE_TOXINS_1                       = 526,
-            CLEANSE_SPIRIT_1                    = 51886,
-            FLAME_SHOCK_1                       = 8050,
-            EARTH_SHOCK_1                       = 8042,
-            FROST_SHOCK_1                       = 8056,
-            STORMSTRIKE_1                       = 17364,
-            LIGHTNING_BOLT_1                    = 403,
-            CHAIN_LIGHTNING_1                   = 421,
-            LAVA_BURST_1                        = 51505,
-            THUNDERSTORM_1                      = 51490,
-            LIGHTNING_SHIELD_1                  = 324,
-            EARTH_SHIELD_1                      = 974,
-            WATER_SHIELD_1                      = 52127,
-            WATER_BREATHING_1                   = 131,
-            WATER_WALKING_1                     = 546,
-            //BLOODLUST_1                         = 54516,//custom, moved to specials
-            PURGE_1                             = 370,
-            WIND_SHEAR_1                        = 57994,
-            HEX_1                               = 51514,
-            STONESKIN_TOTEM_1                   = 8071,
-            HEALINGSTREAM_TOTEM_1               = 5394,
-            MANASPRING_TOTEM_1                  = 5675,
-            SEARING_TOTEM_1                     = 3599,
-            WINDFURY_TOTEM_1                    = 8512,
-            STRENGTH_OF_EARTH_TOTEM_1           = 8075,
-            TOTEM_OF_WRATH_1                    = 30706,
-            MANA_TIDE_TOTEM_1                   = 16190
-        };
-
-        enum ShamanPassives
-        {
-            //Elemental
-            ELEMENTAL_DEVASTATION1              = 30160,
-            ELEMENTAL_DEVASTATION2              = 29179,
-            ELEMENTAL_DEVASTATION3              = 29180,
-            ELEMENTAL_WARDING                   = 28998,//rank 3
-            ELEMENTAL_OATH                      = 51470,//rank 2
-            //Enchancement
-            ANCESTRAL_KNOWLEDGE                 = 17489,//rank 5
-            TOUGHNESS                           = 16309,//rank 5
-            FLURRY1                             = 16256,
-            FLURRY2                             = 16281,
-            FLURRY3                             = 16282,
-            FLURRY4                             = 16283,
-            FLURRY5                             = 16284,
-            WEAPON_MASTERY                      = 29086,//rank 3
-            UNLEASHED_RAGE                      = 30809,//rank 3
-            STATIC_SHOCK                        = 51527,//rank 3
-            IMPROVED_STORMSTRIKE                = 51522,//rank 2
-            MAELSTROM_WEAPON1                   = 51528,
-            MAELSTROM_WEAPON2                   = 51529,
-            MAELSTROM_WEAPON3                   = 51530,
-            MAELSTROM_WEAPON4                   = 51531,
-            MAELSTROM_WEAPON5                   = 51532,
-            //Restoration
-            ANCESTRAL_HEALING                   = 16240,//rank 3
-            ANCESTRAL_AWAKENING                 = 51558,//rank 3
-            //Special
-            SHAMAN_T10_RESTO_4P                 = 70808 //Chain Heal HoT
-        };
-
-        enum ShamanSpecial
-        {
-            //2 extra white attacks
-            //100 yd
-            //"Increases attack power for 1.50 sec"
-            //Warning! can proc even from itself!
-            WINDFURY_PROC                       = 32910,
-            //"Increases melee,ranged and spell casting speed by 35%
-            //for all party members. Lasts 20 sec."
-            //250 mana, 20 yd
-            //affects raid
-            //no penalty
-            BLOODLUST_1                         = 54516,
-            //20% chance to put HoT on healed target over 12 sec
-            EARTHLIVING_WEAPON_PASSIVE_4        = 52005,//348 base hp
-            EARTHLIVING_WEAPON_PASSIVE_5        = 52007,//456 base hp
-            EARTHLIVING_WEAPON_PASSIVE_6        = 52008,//652 base hp
-
-            MAELSTROM_WEAPON_BUFF               = 53817,
-            STORMSTRIKE_DAMAGE                  = 32175,
-            STORMSTRIKE_DAMAGE_OFFHAND          = 32176
-        };
-    };
-};
-
-
-void AddSC_shaman_bot()
-{
-    new shaman_bot();
-}
diff --git a/src/server/game/AI/NpcBots/bot_warlock_ai.cpp b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
deleted file mode 100644
index 09768ac..0000000
--- a/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
+++ /dev/null
@@ -1,548 +0,0 @@
-#include "bot_ai.h"
-//#include "Group.h"
-#include "Player.h"
-#include "ScriptMgr.h"
-#include "SpellAuras.h"
-#include "SpellInfo.h"
-/*
-Warlock NpcBot (reworked by Graff onlysuffering@gmail.com)
-Voidwalker pet AI included
-Complete - 3%
-TODO:
-*/
-class warlock_bot : public CreatureScript
-{
-public:
-    warlock_bot() : CreatureScript("warlock_bot") { }
-
-    CreatureAI* GetAI(Creature* creature) const
-    {
-        return new warlock_botAI(creature);
-    }
-
-    bool OnGossipHello(Player* player, Creature* creature)
-    {
-        return bot_minion_ai::OnGossipHello(player, creature);
-    }
-
-    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
-    {
-        if (bot_minion_ai* ai = creature->GetBotMinionAI())
-            return ai->OnGossipSelect(player, creature, sender, action);
-        return true;
-    }
-
-    struct warlock_botAI : public bot_minion_ai
-    {
-        warlock_botAI(Creature* creature) : bot_minion_ai(creature) { }
-
-        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
-        {
-            if (CheckBotCast(victim, spellId, CLASS_WARRIOR) != SPELL_CAST_OK)
-                return false;
-
-            return bot_ai::doCast(victim, spellId, triggered);
-        }
-
-        void EnterCombat(Unit*) { }
-        void Aggro(Unit*) { }
-        void AttackStart(Unit*) { }
-        void KilledUnit(Unit*) { }
-        void EnterEvadeMode() { }
-        void MoveInLineOfSight(Unit*) { }
-        void JustDied(Unit* u) { me->SetBotsPetDied(); bot_ai::JustDied(u); }
-        void DoNonCombatActions() { }
-
-        void StartAttack(Unit* u, bool force = false)
-        {
-            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
-            Aggro(u);
-            SetBotCommandState(COMMAND_ATTACK);
-            GetInPosition(force);
-            feartimer = std::max<uint32>(feartimer, 1000);
-        }
-
-        void UpdateAI(uint32 diff)
-        {
-            ReduceCD(diff);
-            if (IAmDead()) return;
-            CheckAttackState();
-            CheckAuras();
-            if (wait == 0)
-                wait = GetWait();
-            else
-                return;
-            BreakCC(diff);
-            if (CCed(me)) return;
-
-            ////if pet is dead or unreachable
-            //Creature* m_botsPet = me->GetBotsPet();
-            //if (!m_botsPet || m_botsPet->FindMap() != master->GetMap() || (me->GetDistance2d(m_botsPet) > sWorld->GetMaxVisibleDistanceOnContinents() - 20.f))
-            //    if (master->getLevel() >= 10 && !me->IsInCombat() && !IsCasting() && !me->IsMounted())
-            //        SummonBotsPet(PET_VOIDWALKER);
-
-            //TODO: implement healthstone
-            if (GetHealthPCT(me) < 50 && Potion_cd <= diff)
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, HEALINGPOTION))
-                {
-                    Potion_cd = POTION_CD;
-                    GC_Timer = temptimer;
-                }
-            }
-            if (GetManaPCT(me) < 50 && Potion_cd <= diff)
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, MANAPOTION))
-                {
-                    Potion_cd = POTION_CD;
-                    GC_Timer = temptimer;
-                }
-            }
-            if (!me->IsInCombat())
-                DoNonCombatActions();
-
-            if (!CheckAttackTarget(CLASS_WARLOCK))
-                return;
-
-            DoNormalAttack(diff);
-        }
-
-        void DoNormalAttack(uint32 diff)
-        {
-            opponent = me->GetVictim();
-            if (opponent)
-            {
-                if (!IsCasting())
-                    StartAttack(opponent);
-            }
-            else
-                return;
-
-            //TODO: add more damage spells
-
-            if (feartimer <= diff && GC_Timer <= diff)
-            { CheckFear(); feartimer = 2000; }
-
-            if (IsSpellReady(RAIN_OF_FIRE_1, diff) && !me->isMoving() && HasRole(BOT_ROLE_DPS) && Rand() < 25)
-            {
-                Unit* blizztarget = FindAOETarget(30, true);
-                if (blizztarget && doCast(blizztarget, GetSpell(RAIN_OF_FIRE_1)))
-                {
-                    SetSpellCooldown(RAIN_OF_FIRE_1, 5000);
-                    return;
-                }
-                SetSpellCooldown(RAIN_OF_FIRE_1, 2000);//fail
-            }
-
-            float dist = me->GetExactDist(opponent);
-
-            if (IsSpellReady(CURSE_OF_THE_ELEMENTS_1, diff) && dist < 30 && Rand() < 15 &&
-                !HasAuraName(opponent, CURSE_OF_THE_ELEMENTS_1) &&
-                doCast(opponent, GetSpell(CURSE_OF_THE_ELEMENTS_1)))
-            {
-                GC_Timer = 800;
-                return;
-            }
-
-            if (IsSpellReady(CORRUPTION_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 25 &&
-                !opponent->HasAura(GetSpell(CORRUPTION_1), me->GetGUID()) &&
-                doCast(opponent, GetSpell(CORRUPTION_1)))
-                return;
-
-            if (IsSpellReady(HAUNT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 25 &&
-                !opponent->HasAura(GetSpell(HAUNT_1), me->GetGUID()) &&
-                doCast(opponent, GetSpell(HAUNT_1)))
-            {
-                SetSpellCooldown(HAUNT_1, 8000);
-                return;
-            }
-
-            if (GC_Timer <= diff && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 15 && !Afflicted(opponent))
-            {
-                if (GetSpellCooldown(CONFLAGRATE_1) <= 8000 && doCast(opponent, GetSpell(IMMOLATE_1)))
-                    return;
-                else if (doCast(opponent, GetSpell(UNSTABLE_AFFLICTION_1)))
-                    return;
-            }
-
-            if (IsSpellReady(CONFLAGRATE_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 35 &&
-                HasAuraName(opponent, IMMOLATE_1) &&
-                doCast(opponent, GetSpell(CONFLAGRATE_1)))
-            {
-                SetSpellCooldown(CONFLAGRATE_1, 8000);
-                return;
-            }
-
-            if (IsSpellReady(CHAOS_BOLT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 50 &&
-                doCast(opponent, GetSpell(CHAOS_BOLT_1)))
-            {
-                SetSpellCooldown(CHAOS_BOLT_1, me->getLevel() < 80 ? 10000 : 8000);
-                return;
-            }
-
-            if (IsSpellReady(SHADOW_BOLT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 &&
-                doCast(opponent, GetSpell(SHADOW_BOLT_1)))
-                return;
-        }
-
-        uint8 Afflicted(Unit* target)
-        {
-            if (!target || target->isDead()) return 0;
-            bool aff = HasAuraName(target, UNSTABLE_AFFLICTION_1, me->GetGUID());
-            bool imm = HasAuraName(target, IMMOLATE_1, me->GetGUID());
-            if (imm) return 1;
-            if (aff) return 2;
-            return 0;
-        }
-
-        void CheckFear()
-        {
-            uint32 FEAR = GetSpell(FEAR_1);
-            if (Unit* u = FindAffectedTarget(FEAR, me->GetGUID()))
-                if (Aura* aura = u->GetAura(FEAR, me->GetGUID()))
-                    if (aura->GetDuration() > 3000)
-                        return;
-            Unit* feartarget = FindFearTarget();
-            if (feartarget && doCast(feartarget, FEAR))
-                return;
-        }
-
-        //void SummonedCreatureDies(Creature* summon, Unit* /*killer*/)
-        //{
-        //    if (summon == me->GetBotsPet())
-        //        me->SetBotsPetDied();
-        //}
-
-        //void SummonedCreatureDespawn(Creature* summon)
-        //{
-        //    if (summon == me->GetBotsPet())
-        //        me->SetBotsPet(NULL);
-        //}
-
-        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool& crit) const
-        {
-            //uint32 spellId = spellInfo->Id;
-            //uint8 lvl = me->getLevel();
-            float fdamage = float(damage);
-            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
-            if (!crit)
-            {
-                float aftercrit = 0.f;
-                ////Shatter: frozen targets crit
-                //if (lvl >= 11 && damageinfo.target && damageinfo.target->isFrozen())
-                //    aftercrit *= 4.f;
-
-                if (aftercrit > 0.f)
-                    crit = roll_chance_f(aftercrit);
-            }
-
-            //2) apply bonus damage mods
-            float pctbonus = 0.0f;
-            if (crit)
-            {
-                ////!!!spell damage is not yet critical and will be multiplied by 1.5
-                ////so we should put here bonus damage mult /1.5
-                ////Spell Power: 50% additional crit damage bonus for All spells
-                //if (lvl >= 55)
-                //    pctbonus += 0.333f;
-            }
-            //if (lvl >= 11 && spellId == FROSTBOLT && damageinfo.target && damageinfo.target->isFrozen())
-            //    pctbonus *= 0.2f;
-
-            ////Spellpower bonus damage (temp)
-            //if (m_spellpower > 0)
-            //{
-            //    if (spellId == SHADOW_BOLT)
-            //        fdamage += m_spellpower * 1.38f;
-            //    else if (spellId == IMMOLATE)
-            //        fdamage += m_spellpower * 0.75f; //guessed
-            //    else if (spellId == CONFLAGRATE)
-            //        fdamage += m_spellpower * 2.75f; //guessed
-            //    else if (spellId == CHAOS_BOLT)
-            //        fdamage += m_spellpower * 2.25f * 1.24f;
-            //    else if (spellId == RAIN_OF_FIRE || spellId == 42223)
-            //        fdamage += m_spellpower * 0.25f * 4.f;
-            //    else if (spellId == HAUNT)
-            //        fdamage += m_spellpower * 1.75f;
-            //}
-
-            damage = int32(fdamage * (1.0f + pctbonus));
-        }
-
-        void ApplyClassDamageMultiplierEffect(SpellInfo const* /*spellInfo*/, uint8 /*effect_index*/, float& /*value*/) const
-        {
-            //uint32 spellId = spellInfo->Id;
-
-            //float pct_mod = 1.f;
-
-            //Spellpower bonus damage (temp)
-            //if (spellInfo->Effects[effect_index].ApplyAuraName == SPELL_AURA_PERIODIC_DAMAGE)
-            //{
-            //    if (spellId == CORRUPTION)
-            //        value += m_spellpower * 1.35f / float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
-            //    else if (spellId == IMMOLATE)
-            //        value += m_spellpower * 1.59f / float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
-            //    else if (spellId == UNSTABLE_AFFLICTION)
-            //        value += m_spellpower * 1.68f / float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
-            //}
-
-            //value *= pct_mod;
-        }
-
-        void SpellHit(Unit* caster, SpellInfo const* spell)
-        {
-            OnSpellHit(caster, spell);
-        }
-
-        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
-        {
-            if (victim == me)
-                return;
-
-            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
-            {
-                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
-                {
-                    if (_ctc[i].first && !_ctc[i].second)
-                    {
-                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
-                            _ctc[i].second = 1000;
-
-                        if (_ctc[i].second > 0)
-                            me->CastSpell(victim, _ctc[i].first, true);
-                    }
-                }
-            }
-        }
-
-		void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType, SpellSchoolMask)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void OwnerAttackedBy(Unit* u)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void Reset()
-        {
-            feartimer = 0;
-
-            if (master)
-            {
-                SetStats(true);
-                InitRoles();
-                ApplyPassives(CLASS_WARLOCK);
-            }
-        }
-
-        void ReduceCD(uint32 diff)
-        {
-            CommonTimers(diff);
-            SpellTimers(diff);
-
-            if (feartimer > diff)                   feartimer -= diff;
-        }
-
-        bool CanRespawn()
-        {return false;}
-
-        void InitSpells()
-        {
-            uint8 lvl = me->getLevel();
-            InitSpellMap(CURSE_OF_THE_ELEMENTS_1);
-            InitSpellMap(SHADOW_BOLT_1);
-            InitSpellMap(IMMOLATE_1);
-            lvl >= 40 ? InitSpellMap(CONFLAGRATE_1) : RemoveSpell(CONFLAGRATE_1);
-  /*Talent*/lvl >= 60 ? InitSpellMap(CHAOS_BOLT_1) : RemoveSpell(CHAOS_BOLT_1);
-            InitSpellMap(RAIN_OF_FIRE_1);
-  /*Talent*/lvl >= 60 ? InitSpellMap(HAUNT_1) : RemoveSpell(HAUNT_1);
-            InitSpellMap(CORRUPTION_1);
-  /*Talent*/lvl >= 50 ? InitSpellMap(UNSTABLE_AFFLICTION_1) : RemoveSpell(UNSTABLE_AFFLICTION_1);
-            InitSpellMap(FEAR_1);
-        }
-
-        //TODO
-        void ApplyClassPassives() { }
-
-    private:
-        //Timers
-        uint32 feartimer;
-
-        enum WarlockBaseSpells
-        {
-            CURSE_OF_THE_ELEMENTS_1             = 1490,
-            SHADOW_BOLT_1                       = 686,
-            IMMOLATE_1                          = 348,
-            CONFLAGRATE_1                       = 17962,
-            CHAOS_BOLT_1                        = 50796,
-            RAIN_OF_FIRE_1                      = 5740,
-            HAUNT_1                             = 59164,
-            CORRUPTION_1                        = 172,
-            UNSTABLE_AFFLICTION_1               = 30404,
-            FEAR_1                              = 6215
-        };
-        enum WarlockPassives
-        {
-        };
-    };
-};
-
-class voidwalker_bot : public CreatureScript
-{
-public:
-    voidwalker_bot() : CreatureScript("voidwalker_bot") { }
-
-    CreatureAI* GetAI(Creature* creature) const
-    {
-        return new voidwalker_botAI(creature);
-    }
-
-    struct voidwalker_botAI : public bot_pet_ai
-    {
-        voidwalker_botAI(Creature* creature) : bot_pet_ai(creature) { }
-
-        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
-        {
-            if (CheckBotCast(victim, spellId, CLASS_NONE) != SPELL_CAST_OK)
-                return false;
-            return bot_ai::doCast(victim, spellId, triggered);
-        }
-
-        void EnterCombat(Unit*) { }
-        void Aggro(Unit*) { }
-        void AttackStart(Unit*) { }
-        void KilledUnit(Unit*) { }
-        void EnterEvadeMode() { }
-        void MoveInLineOfSight(Unit*) { }
-        void JustDied(Unit*) { m_creatureOwner->SetBotsPetDied(); }
-        void DoNonCombatActions() { }
-
-        void StartAttack(Unit* u, bool force = false)
-        {
-            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
-            Aggro(u);
-            SetBotCommandState(COMMAND_ATTACK);
-            GetInPosition(force);
-        }
-
-        void UpdateAI(uint32 diff)
-        {
-            ReduceCD(diff);
-            if (IAmDead()) return;
-            CheckAttackState();
-            CheckAuras();
-            if (wait == 0)
-                wait = GetWait();
-            else
-                return;
-            if (CCed(me)) return;
-
-            //TODO: add checks to help owner
-
-            if (!me->IsInCombat())
-                DoNonCombatActions();
-
-            if (!CheckAttackTarget(PET_TYPE_VOIDWALKER))
-                return;
-
-            DoNormalAttack(diff);
-        }
-
-        void DoNormalAttack(uint32 diff)
-        {
-            opponent = me->GetVictim();
-            if (opponent)
-            {
-                if (!IsCasting())
-                    StartAttack(opponent, true);
-            }
-            else
-                return;
-            if (MoveBehind(*opponent))
-                wait = 5;
-
-            //float dist = me->GetExactDist(opponent);
-            float meleedist = me->GetDistance(opponent);
-
-            //TORMENT
-            if (IsSpellReady(TORMENT_1, diff, false) && meleedist < 5 && !IsTank(opponent->GetVictim()))
-            {
-                temptimer = GC_Timer;
-                if (doCast(opponent, GetSpell(TORMENT_1)))
-                {
-                    SetSpellCooldown(TORMENT_1, 5000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-        }
-
-        void SpellHit(Unit* caster, SpellInfo const* spell)
-        {
-            OnSpellHit(caster, spell);
-        }
-
-		void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType, SpellSchoolMask)
-        {
-            if (m_creatureOwner->IsAIEnabled)
-                if (bot_minion_ai* ai = m_creatureOwner->GetBotMinionAI())
-                    ai->OnOwnerDamagedBy(u);
-        }
-
-        //debug
-        //void ListSpells(ChatHandler* ch) const
-        //{
-        //    ch->PSendSysMessage("Spells list:");
-        //    ch->PSendSysMessage("Torment: %u", TORMENT);
-        //    ch->PSendSysMessage("End of spells list.");
-        //}
-
-        void Reset()
-        {
-            if (master && m_creatureOwner)
-            {
-                SetStats(true);
-                ApplyPassives(PET_TYPE_VOIDWALKER);
-                ApplyClassPassives();
-                SetBaseArmor(162 * master->getLevel());
-            }
-        }
-
-        void ReduceCD(uint32 diff)
-        {
-            CommonTimers(diff);
-            SpellTimers(diff);
-        }
-
-        bool CanRespawn()
-        {return false;}
-
-        void InitSpells()
-        {
-            InitSpellMap(TORMENT_1);
-        }
-
-        void ApplyClassPassives() { }
-
-    private:
-        //Timers
-
-        enum VoidwalkerBaseSpells
-        {
-            TORMENT_1                           = 3716
-        };
-        enum VoidwalkerPassives
-        {
-        };
-    };
-};
-
-void AddSC_warlock_bot()
-{
-    new warlock_bot();
-    new voidwalker_bot();
-}
diff --git a/src/server/game/AI/NpcBots/bot_warrior_ai.cpp b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
deleted file mode 100644
index 64507ee..0000000
--- a/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
+++ /dev/null
@@ -1,1188 +0,0 @@
-#include "bot_ai.h"
-#include "Group.h"
-#include "Player.h"
-#include "ScriptMgr.h"
-#include "SpellAuras.h"
-#include "WorldSession.h"
-#include "SpellInfo.h"
-/*
-Warrior NpcBot (reworked by Graff onlysuffering@gmail.com)
-Complete - Around 40-45%
-TODO: Thunder Clap, Piercing Howl, Challenging Shout, other tanking stuff
-*/
-class warrior_bot : public CreatureScript
-{
-public:
-    warrior_bot() : CreatureScript("warrior_bot") { }
-
-    CreatureAI* GetAI(Creature* creature) const
-    {
-        return new warrior_botAI(creature);
-    }
-
-    bool OnGossipHello(Player* player, Creature* creature)
-    {
-        return bot_minion_ai::OnGossipHello(player, creature);
-    }
-
-    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
-    {
-        if (bot_minion_ai* ai = creature->GetBotMinionAI())
-            return ai->OnGossipSelect(player, creature, sender, action);
-        return true;
-    }
-
-    struct warrior_botAI : public bot_minion_ai
-    {
-        warrior_botAI(Creature* creature) : bot_minion_ai(creature) { }
-
-        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
-        {
-            if (CheckBotCast(victim, spellId, CLASS_WARRIOR) != SPELL_CAST_OK)
-                return false;
-            return bot_ai::doCast(victim, spellId, triggered);
-        }
-
-        void UpdateAI(uint32 diff)
-        {
-            ReduceCD(diff);
-            if (IAmDead()) return;
-            CheckAttackState();
-            if (ragetimer2 <= diff)
-            {
-                if (me->IsInCombat() && me->getLevel() >= 20)
-                {
-                    if (getrage() < 990)
-                        me->SetPower(POWER_RAGE, rage + uint32(10.f*rageIncomeMult));//1 rage per 2 sec
-                    else
-                        me->SetPower(POWER_RAGE, 1000);//max
-                }
-                ragetimer2 = 2000;
-            }
-            if (ragetimer <= diff)
-            {
-                if (!me->IsInCombat() && !HasAuraName(me, BLOODRAGE_1))
-                {
-                    if (getrage() > uint32(10.f*rageLossMult))
-                        me->SetPower(POWER_RAGE, rage - uint32(10.f*rageLossMult));//-1 rage per 1.5 sec
-                    else
-                        me->SetPower(POWER_RAGE, 0);//min
-                }
-                ragetimer = 1500;
-            }
-            CheckAuras();
-            if (wait == 0)
-                wait = GetWait();
-            else
-                return;
-            BreakCC(diff);
-            if (CCed(me)) return;
-
-            if (GetHealthPCT(me) < 67 && Potion_cd <= diff)
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, HEALINGPOTION))
-                {
-                    Potion_cd = POTION_CD;
-                    GC_Timer = temptimer;
-                }
-            }
-            CheckIntervene(diff);
-            if (!me->IsInCombat())
-                DoNonCombatActions(diff);
-
-            if (!CheckAttackTarget(CLASS_WARRIOR))
-            {
-                if (!IsTank() && !me->IsInCombat() && battleStance != true && master->getAttackers().empty() &&
-                    stancetimer <= diff && Rand() < 25)
-                    stanceChange(diff, 1);
-                return;
-            }
-
-            if (IsSpellReady(BATTLESHOUT_1, diff) && getrage() > 100 && Rand() < 30 &&
-                !HasAuraName(master, BATTLESHOUT_1) && !HasAuraName(master, BLESSING_OF_MIGHT_1) &&
-                !HasAuraName(master, GREATER_BLESSING_OF_MIGHT_1) && master->IsWithinLOSInMap(me))
-            {
-                if (doCast(me, GetSpell(BATTLESHOUT_1)))
-                {
-                    SetSpellCooldown(BATTLESHOUT_1, 25000);
-                    return;
-                }
-            }
-
-            if (IsSpellReady(BLOODRAGE_1, diff, false) && me->IsInCombat() && getrage() < 600 &&
-                Rand() < 20 && !me->HasAura(ENRAGED_REGENERATION_1))
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, GetSpell(BLOODRAGE_1)))
-                {
-                    SetSpellCooldown(BLOODRAGE_1, 40000);
-                    GC_Timer = temptimer;
-                }
-            }
-
-            Attack(diff);
-        }
-
-        void StartAttack(Unit* u, bool force = false)
-        {
-            if (GetBotCommandState() == COMMAND_ATTACK && !force) 
-				return;
-            Aggro(u);
-            SetBotCommandState(COMMAND_ATTACK);
-            GetInPosition(force);
-        }
-
-        void EnterCombat(Unit*) { }
-        void Aggro(Unit*) { }
-        void AttackStart(Unit*) { }
-
-        void KilledUnit(Unit* u)
-        {
-			if (!me->IsInWorld() || !u->IsInWorld() || !me->GetBotOwner())
-				return;
-			Player* owner = me->GetBotOwner();
-			if (!owner->IsInWorld())
-				return;
-            //victorious state emulation
-            if (me->getLevel() >= 5 && u->getLevel() + 9 >= me->getLevel())
-            {
-                temptimer = GC_Timer;
-                if (doCast(me, VICTORIOUS_SPELL, true))
-                {
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-        }
-        void EnterEvadeMode() { }
-        void MoveInLineOfSight(Unit*) { }
-        void JustDied(Unit* u) { bot_ai::JustDied(u); }
-        void DoNonCombatActions(uint32 /*diff*/) { }
-
-        void modrage(int32 mod, bool set = false)
-        {
-            if (set && mod < 0)
-                return;
-            if (mod < 0 && rage < uint32(abs(mod)))
-            {
-                //debug set rage to 0
-                mod = 0;
-                set = true;
-                return;
-            }
-
-            if (set)
-                rage = mod ? mod*10 : 0;
-            else
-                rage += mod*10;
-
-            me->SetPower(POWER_RAGE, rage);
-        }
-
-        uint32 getrage()
-        {
-            rage = me->GetPower(POWER_RAGE);
-            return rage;
-        }
-
-        void BreakCC(uint32 diff)
-        {
-            if (me->HasAuraWithMechanic((1<<MECHANIC_FEAR)|(1<<MECHANIC_SAPPED)|(1<<MECHANIC_DISORIENTED)))
-            {
-                if (IsSpellReady(BERSERKERRAGE_1, diff) && Rand() < 35 && !me->HasAura(ENRAGED_REGENERATION_1) &&
-                    doCast(me, GetSpell(BERSERKERRAGE_1)))
-                {
-                    SetSpellCooldown(BERSERKERRAGE_1, 25000);
-                    if (me->getLevel() >= 40)
-                        doCast(me, 58096, true); //Berserker Rage Effect (434 unused)
-                    return;
-                }
-            }
-            bot_minion_ai::BreakCC(diff);
-        }
-
-        void Attack(uint32 diff)
-        {
-            opponent = me->GetVictim();
-            uint8 lvl = master->getLevel();
-            if (opponent)
-            {
-                if (!IsCasting())
-                    StartAttack(opponent, true);
-            }
-            else
-                return;
-            //Keep defensive stance if tank
-            if (IsTank() && defensiveStance != true && stancetimer <= diff)
-                stanceChange(diff, 2);
-            //SelfHeal
-            if (IsSpellReady(ENRAGED_REGENERATION_1, diff) && getrage() > 150 && GetHealthPCT(me) < 40 &&
-                Rand() < 40 && me->HasAuraWithMechanic(uint32(1<<MECHANIC_ENRAGED)))
-            {
-                if (doCast(me, GetSpell(ENRAGED_REGENERATION_1)))
-                {
-                    SetSpellCooldown(ENRAGED_REGENERATION_1, 90000);
-                    GC_Timer = 500;
-                    return;
-                }
-            }
-
-			Unit::AttackerSet m_attackers = master->getAttackers();
-			Unit::AttackerSet b_attackers = me->getAttackers();
-            float dist = me->GetExactDist(opponent);
-            float meleedist = me->GetDistance(opponent);
-
-            if (_isnan(dist))
-                return;
-
-            if (_isnan(meleedist))
-                return;
-
-            //charge + warbringer
-            if (IsSpellReady(CHARGE_1, diff, false) && dist > 11 && dist < 25 && me->HasInArc(M_PI, opponent) &&
-                (me->getLevel() >= 50 ||
-                (!me->IsInCombat() && (battleStance || stanceChange(diff, 1)))))
-            {
-                temptimer = GC_Timer;
-                if (me->getLevel() >= 29)
-                    me->RemoveMovementImpairingAuras(true);
-                if (doCast(opponent, GetSpell(CHARGE_1), me->IsInCombat()))
-                {
-                    SetSpellCooldown(CHARGE_1, 12000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-
-            if (irand(0, 8) == 1 && GetHealthPCT(me) < 20)
-            {
-                doCast(me, 60004);
-                return;
-            }
-            else if (irand(0, 28) == 3 && lvl >= 80)
-            {
-                doCast(opponent, 40728);
-                return;
-            }
-            else if (irand(0, 28) == 2 && lvl >= 80)
-            {
-                doCast(opponent, 65926);
-                return;
-            }
-            else if (irand(0, 28) == 1 && lvl >= 80)
-            {
-                doCast(opponent, 65936);
-                return;
-            }
-
-            else if (irand(0, 28) == 1 && lvl >= 80)
-            {
-                doCast(opponent, 65940);
-                return;
-            }
-
-            //intercept
-            if (IsSpellReady(INTERCEPT_1, diff, false) && !IsTank() &&
-                getrage() > 100 && dist > 11 && dist < 25 && me->HasInArc(M_PI, opponent) &&
-                !CCed(opponent) && (berserkerStance || stanceChange(diff, 3)))
-            {
-                if (doCast(opponent, GetSpell(INTERCEPT_1)))
-                {
-                    SetSpellCooldown(INTERCEPT_1, 20000);
-                    return;
-                }
-            }
-            //SelfHeal 2
-            if (IsSpellReady(VICTORY_RUSH_1, diff) && VICTORIOUS && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
-                (b_attackers.size() <= 1 || (GetHealthPCT(me) < std::max<int32>(100 - b_attackers.size() * 10, 75))))
-            {
-                if (doCast(opponent, GetSpell(VICTORY_RUSH_1)))
-                    return;
-            }
-            //FEAR
-            if (IsSpellReady(INTIMIDATING_SHOUT_1, diff) && Rand() < 70 && getrage() > 250)
-            {
-                if (opponent->IsNonMeleeSpellCast(false, false, true) && dist <= 8 &&
-                    !(opponent->ToCreature() && opponent->ToCreature()->GetCreatureType() == CREATURE_TYPE_UNDEAD))
-                {
-                    if (doCast(opponent, GetSpell(INTIMIDATING_SHOUT_1)))
-                    {
-                        SetSpellCooldown(INTIMIDATING_SHOUT_1, 45000);
-                        return;
-                    }
-                }
-                Unit* fearTarget = NULL;
-                bool triggered = false;
-                uint8 tCount = 0;
-                //fear master's attackers
-                if (!m_attackers.empty() &&
-                    ((master->getClass() != CLASS_DEATH_KNIGHT &&
-                    master->getClass() != CLASS_WARRIOR &&
-                    master->getClass() != CLASS_PALADIN) ||
-                    GetHealthPCT(master) < 70))
-                {
-					for (Unit::AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
-                    {
-                        if (!(*iter)) continue;
-                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
-                        if (me->GetExactDist((*iter)) <= 8 && (*iter)->isTargetableForAttack())
-                        {
-                            ++tCount;
-                            fearTarget = (*iter);
-                            if (tCount > 1) break;
-                        }
-                    }
-                    if (tCount > 0 && !fearTarget)
-                    {
-                        fearTarget = opponent;
-                        triggered = true;
-                    }
-                    if (tCount > 1 && doCast(fearTarget, GetSpell(INTIMIDATING_SHOUT_1), triggered))
-                    {
-                        SetSpellCooldown(INTIMIDATING_SHOUT_1, 45000);
-                        return;
-                    }
-                }
-                //Defend myself
-                if (b_attackers.size() > 1)
-                {
-                    tCount = 0;
-                    fearTarget = NULL;
-                    triggered = false;
-					for (Unit::AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
-                    {
-                        if (!(*iter)) continue;
-                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
-                        if (me->GetExactDist((*iter)) <= 8 && (*iter)->isTargetableForAttack())
-                        {
-                            ++tCount;
-                            fearTarget = (*iter);
-                            if (tCount > 0) break;
-                        }
-                    }
-                    if (tCount > 0 && !fearTarget)
-                    {
-                        fearTarget = opponent;
-                        triggered = true;
-                    }
-                    if (tCount > 0 && doCast(fearTarget, GetSpell(INTIMIDATING_SHOUT_1), triggered))
-                    {
-                        SetSpellCooldown(INTIMIDATING_SHOUT_1, 45000);
-                        return;
-                    }
-                }
-            }//end FEAR
-            //OVERPOWER
-            if (IsSpellReady(OVERPOWER_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50 && getrage() > 50 && meleedist <= 5 &&
-                (battleStance || stancetimer <= diff))
-            {
-                if (me->HasAura(TASTE_FOR_BLOOD_BUFF))
-                {
-                    if (battleStance || stanceChange(diff, 1))
-                    {
-                        if (doCast(opponent, GetSpell(OVERPOWER_1)))
-                        {
-                            me->RemoveAura(TASTE_FOR_BLOOD_BUFF);
-                            return;
-                        }
-                    }
-                }
-            }
-
-            if (MoveBehind(*opponent))
-                wait = 5;
-
-            //HAMSTRING
-            if (IsSpellReady(HAMSTRING_1, diff) && Rand() < 50 && getrage() > 100 && meleedist <= 5 && opponent->isMoving() &&
-                (battleStance || berserkerStance || stancetimer <= diff) &&
-                !opponent->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
-            {
-                if (battleStance || berserkerStance || stanceChange(diff, 5))
-                    if (doCast(opponent, GetSpell(HAMSTRING_1)))
-                        return;
-            }
-            //UBERS
-            //Dont use RETA unless capable circumstances
-            if (HasRole(BOT_ROLE_DPS) && Rand() < 20)
-            {
-                if (IsSpellReady(RETALIATION_1, diff) && b_attackers.size() > 4 &&
-                    (battleStance || stanceChange(diff, 1)))
-                {
-                    if (doCast(me, GetSpell(RETALIATION_1)))
-                    {
-                        SetSpellCooldown(RETALIATION_1, 150000);
-                        SetSpellCooldown(RECKLESSNESS_1, 150000);
-                        return;
-                    }
-                }
-                //Dont use RECKL unless capable circumstances
-                if (IsSpellReady(RECKLESSNESS_1, diff) && !IsTank() &&
-                    (m_attackers.size() > 3 || opponent->GetHealth() > me->GetHealth() * 10) &&
-                    (berserkerStance || stanceChange(diff, 3)))
-                {
-                    if (doCast(me, GetSpell(RECKLESSNESS_1)))
-                    {
-                        SetSpellCooldown(RETALIATION_1, 150000);
-                        SetSpellCooldown(RECKLESSNESS_1, 150000);
-                        return;
-                    }
-                }
-            }
-            //DEATHWISH
-            if (IsSpellReady(DEATHWISH_1, diff) && getrage() > 100 && HasRole(BOT_ROLE_DPS) &&
-                opponent->GetHealth() > me->GetHealth()/2 && Rand() < 20 &&
-                !me->HasAura(ENRAGED_REGENERATION_1))
-            {
-                if (doCast(me, GetSpell(DEATHWISH_1)))
-                {
-                    SetSpellCooldown(DEATHWISH_1, 144000);
-                    return;
-                }
-            }
-            //TAUNT //No GCD
-            Unit* u = opponent->GetVictim();
-            if (IsSpellReady(TAUNT_1, diff, false) && u && u != me && !IsTank(u) && dist <= 30 &&
-                !CCed(opponent) && !IsTankingClass(u->getClass()) && (IsInBotParty(u) || IsTank()) &&
-                (defensiveStance || (stancetimer <= diff && stanceChange(diff, 2))))
-            {
-                temptimer = GC_Timer;
-                if (doCast(opponent, GetSpell(TAUNT_1), true))
-                {
-                    SetSpellCooldown(TAUNT_1, 8000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-            //EXECUTE
-            if (IsSpellReady(EXECUTE_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() && getrage() > 150 && meleedist <= 5 &&
-                Rand() < 70 &&GetHealthPCT(opponent) < 20 &&
-                (battleStance || berserkerStance || (stancetimer <= diff && stanceChange(diff, 5))))
-            {
-                if (doCast(opponent, GetSpell(EXECUTE_1)))
-                {
-                    //sudden death
-                    if (me->getLevel() >= 50 && getrage() <= 400)
-                        modrage(10, true);
-                    else if (getrage() > 300)
-                        modrage(-30);
-                    else
-                        modrage(0, true);
-                    return;
-                }
-            }
-            //SUNDER //custom cd condition
-            if (GetSpell(SUNDER_1) && GC_Timer <= diff && getrage() > 150 &&
-                (getrage() > 500 || IsSpellReady(SUNDER_1,diff, false)) &&
-                meleedist <= 5 && IsTank() && opponent->GetHealth() > me->GetMaxHealth() && Rand() < 35)
-            {
-                Aura* sunder = opponent->GetAura(GetSpell(SUNDER_1), me->GetGUID());
-                if ((!sunder || sunder->GetStackAmount() < 5 || sunder->GetDuration() < 15000) &&
-                    doCast(opponent, GetSpell(SUNDER_1)))
-                {
-                    SetSpellCooldown(SUNDER_1, 7000);
-                    GC_Timer = 800;
-                    return;
-                }
-            }
-            //SS //no GCD //no rage (glyph)
-            if (IsSpellReady(SWEEPING_STRIKES_1, diff, false) && HasRole(BOT_ROLE_DPS) && !IsTank() && Rand() < 25 &&
-                (battleStance || berserkerStance || stancetimer <= diff) &&
-                (b_attackers.size() > 1 || FindSplashTarget(7, opponent)))
-            {
-                temptimer = GC_Timer;
-                if ((battleStance || berserkerStance || stanceChange(diff, 5)) &&
-                    doCast(me, GetSpell(SWEEPING_STRIKES_1), true))
-                {
-                    SetSpellCooldown(SWEEPING_STRIKES_1, 30000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-            //WHIRLWIND
-            if (IsSpellReady(WHIRLWIND_1, diff) && getrage() >= 250 && HasRole(BOT_ROLE_DPS) && !IsTank() && Rand() < 50 &&
-               (FindSplashTarget(7, opponent) || (getrage() > 800 && dist <= 7)) &&
-               (berserkerStance || stancetimer <= diff))
-            {
-                if ((berserkerStance || stanceChange(diff, 3)) &&
-                    doCast(me, GetSpell(WHIRLWIND_1)))
-                {
-                    SetSpellCooldown(WHIRLWIND_1, 6500);
-                    return;
-                }
-            }
-            //BLADESTORM
-            if (IsSpellReady(BLADESTORM_1, diff) && HasRole(BOT_ROLE_DPS) &&
-               getrage() >= 250 && (Rand() < 20 || me->HasAura(RECKLESSNESS_1)) &&
-               (b_attackers.size() > 1 || opponent->GetHealth() > me->GetMaxHealth()))
-            {
-                if (doCast(me, GetSpell(BLADESTORM_1)))
-                {
-                    SetSpellCooldown(BLADESTORM_1, 60000);
-                    return;
-                }
-            }
-            //Mortal Strike
-            if (IsSpellReady(MORTALSTRIKE_1, diff) && getrage() > 300 && HasRole(BOT_ROLE_DPS) && meleedist <= 5)
-            {
-                if (doCast(opponent, GetSpell(MORTALSTRIKE_1)))
-                {
-                    SetSpellCooldown(MORTALSTRIKE_1, 7000);
-                    ResetSpellCooldown(SLAM_1); //reset here
-                }
-            }
-            //Slam
-            if (IsSpellReady(SLAM_1, diff))
-            {
-                bool triggered = (GetSpellCooldown(MORTALSTRIKE_1) == 7000);
-                if (getrage() > 150 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && Rand() < (30 + triggered * 30))
-                {
-                    if (doCast(opponent, GetSpell(SLAM_1), true))
-                    {
-                        SetSpellCooldown(SLAM_1, 3000); //must be > 7000/2
-                        modrage(-15);
-                        return;
-                    }
-                }
-            }
-            //PUMMEL
-            if (IsSpellReady(PUMMEL_1, diff, false) && Rand() < 80 && getrage() > 100 && meleedist <= 5 &&
-                opponent->IsNonMeleeSpellCast(false) &&
-                (berserkerStance || stancetimer <= diff))
-            {
-                temptimer = GC_Timer;
-                if ((berserkerStance || stanceChange(diff, 3)) &&
-                    doCast(opponent, GetSpell(PUMMEL_1)))
-                {
-                    SetSpellCooldown(PUMMEL_1, 10000);
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-            //REND
-            if (IsSpellReady(REND_1, diff) && Rand() < 50 && getrage() > 100 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
-                opponent->GetHealth() > me->GetHealth()/2 &&
-                !opponent->HasAura(GetSpell(REND_1), me->GetGUID()) &&
-                (battleStance || defensiveStance || (stancetimer <= diff && stanceChange(diff, 4))))
-            {
-                if (doCast(opponent, GetSpell(REND_1)))
-                    return;
-            }
-            //CLEAVE //no GCD
-            if (IsSpellReady(CLEAVE_1, diff, false) && getrage() > 200 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && Rand() < 30)
-            {
-                temptimer = GC_Timer;
-                u = FindSplashTarget(5);
-                if (u && doCast(opponent, GetSpell(CLEAVE_1)))
-                {
-                    SetSpellCooldown(CLEAVE_1, me->getAttackTimer(BASE_ATTACK)); //once per swing, prevents rage loss
-                    GC_Timer = temptimer;
-                    return;
-                }
-            }
-            else {}//HEROIC STRIKE placeholder
-            //DISARM DEPRECATED
-            /*if (disarm_cd <= diff && meleedist < 5 &&
-                (opponent->GetVictim()->GetGUID() == master->GetGUID() ||
-                opponent->GetVictim()->GetGUID() == m_creature->GetGUID()) &&
-                getrage() > 15 &&
-                !HasAuraName(opponent, GetSpellName(DISARM)) &&
-                GC_Timer <= diff)
-            {
-                if (opponent->getClass() == CLASS_ROGUE  ||
-                    opponent->getClass() == CLASS_WARRIOR   ||
-                    opponent->getClass() == CLASS_SHAMAN    ||
-                    opponent->getClass() == CLASS_PALADIN)
-                {
-                    if (defensiveStance == true)
-                    {
-                        doCast(opponent, DISARM, true);
-                        //rage -= 100;
-                        disarm_cd = DISARM_CD;
-                    }
-                    else stanceChange(diff, 2);
-                }
-            }*/
-        }//end Attack
-
-        void CheckIntervene(uint32 diff)
-        {
-            if (IsSpellReady(INTERVENE_1, diff, false) && getrage() > 100 &&
-                Rand() < (IsTank() ? 80 : 30) &&
-                (defensiveStance || stancetimer <= diff))
-            {
-                if (!master->IsInCombat() && master->getAttackers().empty() && master->isMoving())
-                {
-                    float mydist = me->GetExactDist(master);
-                    if (mydist < 24 && mydist > 19 && (defensiveStance || stanceChange(diff, 2)))
-                    {
-                        temptimer = GC_Timer;
-                        if (doCast(master, GetSpell(INTERVENE_1)))
-                        {
-                            SetSpellCooldown(INTERVENE_1, 20000);
-                            GC_Timer = temptimer;
-                            Follow(true);
-                            return;
-                        }
-                    }
-                }
-                Group* gr = master->GetGroup();
-                if (!gr)
-                {
-                    if (GetHealthPCT(master) < 95 && !master->getAttackers().empty() &&
-                        me->getAttackers().size() <= master->getAttackers().size())
-                    {
-                        float dist = me->GetExactDist(master);
-                        if (dist > 25 || dist < 10) return;
-                        if (!(defensiveStance || stanceChange(diff, 2))) return;
-                        temptimer = GC_Timer;
-                        if (doCast(master, GetSpell(INTERVENE_1)))
-                        {
-                            SetSpellCooldown(INTERVENE_1, 20000);
-                            GC_Timer = temptimer;
-                            return;
-                        }
-                    }
-                }
-                else
-                {
-                    bool Bots = false;
-                    float dist;
-                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
-                    {
-                        Player* tPlayer = itr->GetSource();
-                        if (!tPlayer) continue;
-                        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
-                        if (tPlayer->FindMap() != me->GetMap()) continue;
-                        if (tPlayer->HaveBot())
-                            Bots = true;
-                        if (tPlayer->isDead() || GetHealthPCT(tPlayer) > 90 || IsTank(tPlayer)) continue;
-                        if (tPlayer->getAttackers().size() < me->getAttackers().size()) continue;
-                        dist = me->GetExactDist(tPlayer);
-                        if (dist > 24 || dist < 10) continue;
-                        if (defensiveStance || stanceChange(diff, 2))
-                        {
-                            temptimer = GC_Timer;
-                            if (doCast(tPlayer, GetSpell(INTERVENE_1)))
-                            {
-                                SetSpellCooldown(INTERVENE_1, 20000);
-                                GC_Timer = temptimer;
-                                return;
-                            }
-                        }
-                    }
-                    if (!Bots) return;
-                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
-                    {
-                        Player* tPlayer = itr->GetSource();
-                        if (!tPlayer || !tPlayer->HaveBot()) continue;
-                        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
-                        if (tPlayer->FindMap() != me->GetMap()) continue;
-                        for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
-                        {
-                            Creature* bot = tPlayer->GetBotMap(i)->_Cre();
-                            if (!bot || !bot->IsInWorld() || bot == me || bot->isDead()) continue;
-                            if (GetHealthPCT(bot) > 90 || IsTank(bot)) continue;
-                            dist = me->GetExactDist(bot);
-                            if (dist > 25 || dist < 10) continue;
-                            if (bot->getAttackers().size() <= me->getAttackers().size()) continue;
-                            if (defensiveStance || stanceChange(diff, 2))
-                            {
-                                temptimer = GC_Timer;
-                                if (doCast(bot, GetSpell(INTERVENE_1)))
-                                {
-                                    SetSpellCooldown(INTERVENE_1, 20000 / 2);
-                                    GC_Timer = temptimer;
-                                    return;
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        bool stanceChange(uint32 diff, uint8 stance)
-        {
-            if (!(stancetimer <= diff) || !stance)
-                return false;
-
-            if (stance == 5)
-            {
-                if (urand(1,100) > 50)
-                    stance = 1;
-                else
-                    stance = me->getLevel() < 30 ? 1 : (urand(1,100) > 75 ? 3 : 1);
-            }
-            else if (stance == 4)
-            {
-                if (urand(1,100) > 50)
-                    stance = 1;
-                else
-                    stance = IsTank() ? 2 : 1;
-            }
-
-            if (stance == 2 && me->getLevel() < 10)
-                return false;
-            if (stance == 3 && me->getLevel() < 30)
-                return false;
-
-            temptimer = GC_Timer;
-            //stance mastery impl
-            uint32 temprage = 0;
-            uint32 myrage = me->GetPower(POWER_RAGE);
-            if (me->getLevel() >= 20)
-                temprage = myrage > 250 ? 250 : myrage;
-            else if (me->getLevel() >= 15)
-                temprage = myrage > 100 ? 100 : myrage;
-            switch (stance)
-            {
-                case 1:
-                    if (doCast(me, GetSpell(BATTLESTANCE_1)))
-                    {
-                        if (me->HasAura(BATTLESTANCE_1))
-                        {
-                            battleStance = true;
-                            defensiveStance = false;
-                            berserkerStance = false;
-                            me->SetPower(POWER_RAGE, temprage);
-                            stancetimer = 2100 - me->getLevel()*20;//500 on 80
-                            GC_Timer = temptimer;
-                            return true;
-                        }
-                    }
-                    break;
-                case 2:
-                    if (doCast(me, GetSpell(DEFENSIVESTANCE_1)))
-                    {
-                        if (me->HasAura(DEFENSIVESTANCE_1))
-                        {
-                            defensiveStance = true;
-                            battleStance = false;
-                            berserkerStance = false;
-                            me->SetPower(POWER_RAGE, temprage);
-                            stancetimer = 2100 - me->getLevel()*20;//500 on 80
-                            GC_Timer = temptimer;
-                            return true;
-                        }
-                    }
-                    break;
-                case 3:
-                    if (doCast(me, GetSpell(BERSERKERSTANCE_1)))
-                    {
-                        if (me->HasAura(BERSERKERSTANCE_1))
-                        {
-                            berserkerStance = true;
-                            battleStance = false;
-                            defensiveStance = false;
-                            me->SetPower(POWER_RAGE, temprage);
-                            stancetimer = 2100 - me->getLevel()*20;//500 on 80
-                            GC_Timer = temptimer;
-                            return true;
-                        }
-                    }
-                    break;
-                default:
-                    break;
-            }
-            GC_Timer = temptimer;
-            return false;
-        }
-
-        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
-        {
-            uint32 spellId = spellInfo->Id;
-            uint8 lvl = me->getLevel();
-            float fdamage = float(damage);
-            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
-            if (!crit)
-            {
-                float aftercrit = 0.f;
-                //Incite: 15% additional critical chance for Cleave, Heroic Strike and Thunder Clap
-                if (lvl >= 15 && spellId == GetSpell(CLEAVE_1) /*|| spellId == HEROICSTRIKE || spellId == THUNDERCLAP*/)
-                    aftercrit += 15.f;
-                //Improved Overpower: 50% additional critical chance for Overpower
-                if (lvl >= 20 && spellId == GetSpell(OVERPOWER_1))
-                    aftercrit += 50.f;
-
-                //second roll (may be illogical)
-                if (aftercrit > 0.f)
-                    crit = roll_chance_f(aftercrit);
-            }
-
-            //2) apply bonus damage mods
-            float pctbonus = 0.0f;
-            if (crit)
-            {
-                //!!!Melee spell damage is not yet critical, all reduced by half
-                //Impale: 20% crit damage bonus for all abilities
-                if (lvl >= 20)
-                    pctbonus += 0.10f;
-            }
-
-            //Improved Rend: 20% bonus damage for Rend
-            if (spellId == GetSpell(REND_1))
-                pctbonus += 0.2f;
-            //Improved Whirlwind: 20% bonus damage for Whirlwind
-            if (lvl >= 40 && spellId == GetSpell(WHIRLWIND_1))
-                pctbonus += 0.2f;
-            //Glyph of Mortal Strike: 10% bonus damage for Mortal Strike
-            if (lvl >= 40 && spellId == GetSpell(MORTALSTRIKE_1))
-                pctbonus += 0.1f;
-            //Unrelenting Assault (part 2): 20% bonus damage for Overpower and Revenge
-            if (lvl >= 45 && (spellId == GetSpell(OVERPOWER_1)/* || spellId == REVENGE*/))
-                pctbonus += 0.2f;
-            //Improved Mortal Strike: 10% bonus damage for Mortal Strike
-            if (lvl >= 45 && spellId == GetSpell(MORTALSTRIKE_1))
-                pctbonus += 0.1f;
-            //Undending Fury: 10% bonus damage for Whirlwind, Slam and Bloodthirst
-            if (lvl >= 55 && (spellId == GetSpell(WHIRLWIND_1) || spellId == GetSpell(SLAM_1) /*|| spellId == BLOODTHIRST*/))
-                pctbonus += 0.1f;
-
-            damage = int32(fdamage * (1.0f + pctbonus));
-        }
-
-        void SpellHit(Unit* caster, SpellInfo const* spell)
-        {
-            switch (spell->Id)
-            {
-                case VICTORIOUS_SPELL:
-                    VICTORIOUS = true;
-                    break;
-                default:
-                    break;
-            }
-            OnSpellHit(caster, spell);
-        }
-
-        void SpellHitTarget(Unit* target, SpellInfo const* spell)
-        {
-            uint32 spellId = spell->Id;
-
-            if (spellId == GetSpell(OVERPOWER_1))
-            {
-                //Unrelenting Assault
-                if (UNRELENTING_ASSAULT && target->HasUnitState(UNIT_STATE_CASTING))
-                    target->CastSpell(target, UNRELENTING_ASSAULT_SPELL, true);
-            }
-            if (spellId == GetSpell(BATTLESHOUT_1)/* || spellId == COMMANDINGSHOUT*/)
-            {
-                //Glyph of Battle/Command + 2 min duration (8 for bots)
-                if (Aura* shout = target->GetAura(spellId, me->GetGUID()))
-                {
-                    uint32 dur = shout->GetDuration() + 480000;
-                    shout->SetDuration(dur);
-                    shout->SetMaxDuration(dur);
-                }
-            }
-            if (spellId == GetSpell(REND_1))
-            {
-                //Glyph of Rending + 6 sec duration
-                if (Aura* rend = target->GetAura(spellId, me->GetGUID()))
-                {
-                    uint32 dur = rend->GetDuration() + 6000;
-                    rend->SetDuration(dur);
-                    rend->SetMaxDuration(dur);
-                }
-            }
-            if (spellId == GetSpell(INTERVENE_1))
-            {
-                //Glyph of Intervene + 1 bonus charge (2 for bots)
-                if (Aura* vene = target->GetAura(spellId, me->GetGUID()))
-                {
-                    vene->SetCharges(vene->GetCharges() + 2);
-                }
-            }
-            if (spellId == GetSpell(VICTORY_RUSH_1))
-            {
-                me->RemoveAura(VICTORIOUS_SPELL);
-                VICTORIOUS = false;
-            }
-        }
-
-        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
-        {
-            if (victim == me)
-                return;
-
-            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
-            {
-                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
-                {
-                    if (_ctc[i].first && !_ctc[i].second)
-                    {
-                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
-                            _ctc[i].second = 1000;
-
-                        if (_ctc[i].second > 0)
-                            me->CastSpell(victim, _ctc[i].first, true);
-                    }
-                }
-            }
-        }
-
-		void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType, SpellSchoolMask)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void OwnerAttackedBy(Unit* u)
-        {
-            OnOwnerDamagedBy(u);
-        }
-
-        void Reset()
-        {
-            stancetimer = 0;
-            ragetimer = 1500;
-            ragetimer2 = 3000;
-
-            battleStance = true;
-            defensiveStance = false;
-            berserkerStance = false;
-
-            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
-            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
-            me->setPowerType(POWER_RAGE);
-            rage = 0;
-
-            if (master)
-            {
-                SetStats(true);
-                InitRoles();
-                ApplyPassives(CLASS_WARRIOR);
-            }
-        }
-
-        void ReduceCD(uint32 diff)
-        {
-            CommonTimers(diff);
-            SpellTimers(diff);
-
-            if (stancetimer > diff)                 stancetimer -= diff;
-            if (ragetimer > diff)                   ragetimer -= diff;
-            if (ragetimer2 > diff)                  ragetimer2 -= diff;
-        }
-
-        bool CanRespawn()
-        {return false;}
-
-        void InitSpells()
-        {
-            uint8 lvl = me->getLevel();
-            //InitSpellMap(CHALLENGING_SHOUT_1);
-            InitSpellMap(INTIMIDATING_SHOUT_1);
-            InitSpellMap(ENRAGED_REGENERATION_1);
-            InitSpellMap(CHARGE_1);
-            InitSpellMap(OVERPOWER_1);
-   /*Quest*/lvl >= 10 ? InitSpellMap(TAUNT_1) : RemoveSpell(TAUNT_1);
-            //InitSpellMap(DISARM_1);
-            InitSpellMap(BLOODRAGE_1);
-            InitSpellMap(BERSERKERRAGE_1);
-            InitSpellMap(INTERCEPT_1);
-            InitSpellMap(CLEAVE_1);
-            InitSpellMap(HAMSTRING_1);
-            InitSpellMap(INTERVENE_1);
-            InitSpellMap(WHIRLWIND_1);
-  /*Talent*/lvl >= 60 ? InitSpellMap(BLADESTORM_1) : RemoveSpell(BLADESTORM_1);
-            InitSpellMap(BATTLESHOUT_1);
-            InitSpellMap(REND_1);
-            InitSpellMap(EXECUTE_1);
-            InitSpellMap(PUMMEL_1);
-  /*Talent*/lvl >= 40 ? InitSpellMap(MORTALSTRIKE_1) : RemoveSpell(MORTALSTRIKE_1);
-            InitSpellMap(SLAM_1);
-   /*Quest*/lvl >= 10 ? InitSpellMap(SUNDER_1) : RemoveSpell(SUNDER_1);
-  /*Talent*/lvl >= 30 ? InitSpellMap(SWEEPING_STRIKES_1) : RemoveSpell(SWEEPING_STRIKES_1);
-            InitSpellMap(BATTLESTANCE_1);
-   /*Quest*/lvl >= 10 ? InitSpellMap(DEFENSIVESTANCE_1) : RemoveSpell(DEFENSIVESTANCE_1);
-   /*Quest*/lvl >= 30 ? InitSpellMap(BERSERKERSTANCE_1) : RemoveSpell(BERSERKERSTANCE_1);
-            InitSpellMap(RECKLESSNESS_1);
-            InitSpellMap(RETALIATION_1);
-  /*Talent*/lvl >= 30 ? InitSpellMap(DEATHWISH_1) : RemoveSpell(DEATHWISH_1);
-            InitSpellMap(VICTORY_RUSH_1);
-        }
-
-        void ApplyClassPassives()
-        {
-            uint8 level = master->getLevel();
-            if (level >= 70)
-                RefreshAura(WC5); //10%
-            else if (level >= 68)
-                RefreshAura(WC4); //8%
-            else if (level >= 66)
-                RefreshAura(WC3); //6%
-            else if (level >= 64)
-                RefreshAura(WC2); //4%
-            else if (level >= 62)
-                RefreshAura(WC1); //2%
-            if (level >= 39)
-                RefreshAura(FLURRY5); //30%
-            else if (level >= 38)
-                RefreshAura(FLURRY4); //24%
-            else if (level >= 37)
-                RefreshAura(FLURRY3); //18%
-            else if (level >= 36)
-                RefreshAura(FLURRY2); //12%
-            else if (level >= 35)
-                RefreshAura(FLURRY1); //6%
-            if (level >= 60)
-                RefreshAura(SWORD_SPEC5,2);//twice
-            else if (level >= 50)
-                RefreshAura(SWORD_SPEC5);//once
-            else if (level >= 45)
-                RefreshAura(SWORD_SPEC4);//once
-            else if (level >= 40)
-                RefreshAura(SWORD_SPEC3);//once
-            else if (level >= 35)
-                RefreshAura(SWORD_SPEC2);//once
-            else if (level >= 30)
-                RefreshAura(SWORD_SPEC1);//once
-            if (level >= 60)
-                RefreshAura(RAMPAGE);
-            if (level >= 55)
-                RefreshAura(TRAUMA2); //30%
-            else if (level >= 35)
-                RefreshAura(TRAUMA1); //15%
-            if (level >= 35)
-                UNRELENTING_ASSAULT = true;
-            if (level >= 45)
-                RefreshAura(BLOOD_FRENZY);
-            if (level >= 40)
-                RefreshAura(SECOND_WIND);
-            if (level >= 40)
-                RefreshAura(TOUGHNESS,2); //-60%
-            else if (level >= 15)
-                RefreshAura(TOUGHNESS); //-30%
-            if (level >= 40)
-                RefreshAura(IMP_HAMSTRING,2); //30%
-            else if (level >= 35)
-                RefreshAura(IMP_HAMSTRING); //15%
-            if (level >= 30)
-                RefreshAura(TASTE_FOR_BLOOD3); //100%
-            else if (level >= 28)
-                RefreshAura(TASTE_FOR_BLOOD2); //66%
-            else if (level >= 25)
-                RefreshAura(TASTE_FOR_BLOOD1); //33%
-            if (level >= 30)
-                RefreshAura(BLOOD_CRAZE3);
-            else if (level >= 25)
-                RefreshAura(BLOOD_CRAZE2);
-            else if (level >= 20)
-                RefreshAura(BLOOD_CRAZE1);
-            //BloodRage Absorb
-            if (level >= 60)
-                RefreshAura(WARRIOR_T10_4P);
-        }
-
-        bool CanUseManually(uint32 basespell) const
-        {
-            switch (basespell)
-            {
-                case ENRAGED_REGENERATION_1:
-                case BLOODRAGE_1:
-                case BERSERKERRAGE_1:
-                case BATTLESHOUT_1:
-                //case SWEEPING_STRIKES_1: //unable - need stance
-                case RETALIATION_1:
-                case RECKLESSNESS_1:
-                case DEATHWISH_1:
-                    return true;
-                default:
-                    return false;
-            }
-        }
-
-    private:
-/*tmrs*/uint32 stancetimer, ragetimer, ragetimer2;
-/*misc*/uint32 rage;
-/*misc*/float rageIncomeMult, rageLossMult;
-/*Chck*/bool battleStance, defensiveStance, berserkerStance, UNRELENTING_ASSAULT, VICTORIOUS;
-
-        enum WarriorBaseSpells
-        {
-            //CHALLENGING_SHOUT_1                     = 1161,
-            INTIMIDATING_SHOUT_1                    = 5246,
-            ENRAGED_REGENERATION_1                  = 55694,
-            CHARGE_1                                = 11578,
-            OVERPOWER_1                             = 7384,
-            TAUNT_1                                 = 355,
-            //DISARM_1                                = 676,
-            BLOODRAGE_1                             = 2687,
-            BERSERKERRAGE_1                         = 18499,
-            INTERCEPT_1                             = 20252,
-            CLEAVE_1                                = 845,
-            HAMSTRING_1                             = 1715,
-            INTERVENE_1                             = 3411,
-            WHIRLWIND_1                             = 1680,
-            BLADESTORM_1                            = 46924,
-            BATTLESHOUT_1                           = 6673,
-            REND_1                                  = 772,
-            EXECUTE_1                               = 5308,
-            PUMMEL_1                                = 6552,
-            MORTALSTRIKE_1                          = 12294,
-            SLAM_1                                  = 1464,
-            SUNDER_1                                = 7386,
-            SWEEPING_STRIKES_1                      = 12328,
-            BATTLESTANCE_1                          = 2457,
-            DEFENSIVESTANCE_1                       = 71,
-            BERSERKERSTANCE_1                       = 2458,
-            RECKLESSNESS_1                          = 13847,//1719, original warrior spell
-            RETALIATION_1                           = 22857,//20230, original warrior spell
-            DEATHWISH_1                             = 12292,
-            VICTORY_RUSH_1                          = 34428
-        };
-        enum WarriorPassives
-        {
-        //Talents
-            WC1  /*WRECKING CREW1*/                 = 46867,
-            WC2  /*WRECKING CREW2*/                 = 56611,
-            WC3  /*WRECKING CREW3*/                 = 56612,
-            WC4  /*WRECKING CREW4*/                 = 56613,
-            WC5  /*WRECKING CREW5*/                 = 56614,
-            FLURRY1                                 = 16256,
-            FLURRY2                                 = 16281,
-            FLURRY3                                 = 16282,
-            FLURRY4                                 = 16283,
-            FLURRY5                                 = 16284,
-            SWORD_SPEC1                             = 12281,
-            SWORD_SPEC2                             = 12812,
-            SWORD_SPEC3                             = 12813,
-            SWORD_SPEC4                             = 12814,
-            SWORD_SPEC5                             = 12815,
-            BLOOD_CRAZE1                            = 16487,
-            BLOOD_CRAZE2                            = 16489,
-            BLOOD_CRAZE3                            = 16492,
-            TASTE_FOR_BLOOD1                        = 56636,
-            TASTE_FOR_BLOOD2                        = 56637,
-            TASTE_FOR_BLOOD3                        = 56638,
-            UNRELENTING_ASSAULT1                    = 46859,
-            UNRELENTING_ASSAULT2                    = 46860,
-            TRAUMA1                                 = 46854,
-            TRAUMA2                                 = 46855,
-            BLOOD_FRENZY                            = 29859,
-            RAMPAGE                                 = 29801,
-            SECOND_WIND                             = 29838,//rank 2
-            TOUGHNESS                               = 12764,//rank 5
-            IMP_HAMSTRING                           = 23695,//rank 3
-        //other
-            WARRIOR_T10_4P                          = 70844
-        };
-        enum WarriorSpecial
-        {
-            TASTE_FOR_BLOOD_BUFF                    = 60503,
-            LAMBS_TO_THE_SLAUGHTER_BUFF             = 84586,
-            UNRELENTING_ASSAULT_SPELL               = 65925,//64849
-            VICTORIOUS_SPELL                        = 32216,
-            //COLOSSUS_SMASH_EFFECT                   = 108126,
-            SWORD_SPECIALIZATION_TRIGGERED          = 16459,
-
-            BLESSING_OF_MIGHT_1                     = 19740,
-            GREATER_BLESSING_OF_MIGHT_1             = 25782
-        };
-    };
-};
-
-void AddSC_warrior_bot()
-{
-    new warrior_bot();
-}
diff --git a/src/server/game/AI/NpcBots/botcommands.cpp b/src/server/game/AI/NpcBots/botcommands.cpp
deleted file mode 100644
index e3f6e31..0000000
--- a/src/server/game/AI/NpcBots/botcommands.cpp
+++ /dev/null
@@ -1,536 +0,0 @@
-/*
-Name: script_bot_commands
-%Complete: ???
-Comment: Npcbot related commands
-Category: commandscripts/custom/
-*/
-
-#include "bot_ai.h"
-#include "bothelper.h"
-#include "Chat.h"
-#include "Config.h"
-#include "Group.h"
-#include "Language.h"
-#include "Player.h"
-#include "ScriptedGossip.h"
-#include "ScriptMgr.h"
-#pragma execution_character_set("utf-8")
-
-class script_bot_commands : public CommandScript
-{
-public:
-    script_bot_commands() : CommandScript("script_bot_commands") { }
-
-    std::vector<ChatCommand> GetCommands() const override
-	{
-        static std::vector<ChatCommand> npcbotCommandTable =
-		{
-			{ "add", SEC_PLAYER, false, &HandleNpcBotAddCommand, ""},
-			{ "remove", SEC_PLAYER, false, &HandleNpcBotRemoveCommand, ""},
-			{ "reset", SEC_PLAYER, false, &HandleNpcBotResetCommand, ""},
-			{ "command", SEC_PLAYER, false, &HandleNpcBotCommandCommand, ""},
-			{ "distance", SEC_PLAYER, false, &HandleNpcBotDistanceCommand, ""},
-			{ "info", SEC_PLAYER, false, &HandleNpcBotInfoCommand, ""},
-			{ "helper", SEC_PLAYER, false, &HandleBotHelperCommand, ""},
-			{ "revive", SEC_PLAYER, false, &HandleNpcBotReviveCommand, ""},
-			{ "addid", SEC_PLAYER, false, &HandleNpcBotAddEntryCommand, ""}
-		};
-        static std::vector<ChatCommand>  commandTable =
-		{
-			{ "npcbot", SEC_PLAYER, true, NULL, "", npcbotCommandTable },
-		};
-		return commandTable;
-	}
-
-	static bool HandleNpcBotAddEntryCommand(ChatHandler* handler, const char* args)
-	{
-		Player* owner = handler->GetSession()->GetPlayer();
-		if (!*args)
-		{
-			handler->SetSentErrorMessage(true);
-			return false;
-		}
-		if (owner->RestrictBots())
-		{
-			handler->GetSession()->SendNotification("This place is restricted for NpcBots");
-			handler->SetSentErrorMessage(true);
-			return false;
-		}
-		if (owner->isDead())
-		{
-			owner->GetSession()->SendNotification("You're dead!");
-			handler->SetSentErrorMessage(true);
-			return false;
-		}
-		if (owner->GetGroup() && owner->GetGroup()->isRaidGroup() && owner->GetGroup()->IsFull())
-		{
-			handler->PSendSysMessage("Group is full, aborted");
-			handler->SetSentErrorMessage(true);
-			return false;
-		}
-		if (owner->GetNpcBotsCount() >= owner->GetMaxNpcBots())
-		{
-			handler->PSendSysMessage("NpcBots limit exceed");
-			handler->SetSentErrorMessage(true);
-			return false;
-		}
-
-		char* ClassStr = strtok((char*)args, " ");
-		uint32 BotEntry = uint32(atoi(ClassStr));
-
-		CreatureTemplate const* Info = sObjectMgr->GetCreatureTemplate(BotEntry);
-		if (!Info)
-		{
-			handler->PSendSysMessage("Ð¡»ï°éµÄ±àºÅ´íÎó Çë²Î¿¼ÈçÏÂ80001 - 80248");
-			handler->SetSentErrorMessage(true);
-			return false;
-		}
-
-		if (Info->trainer_class == CLASS_DEATH_KNIGHT && owner->getLevel() < sWorld->getIntConfig(CONFIG_CHARACTER_CREATING_MIN_LEVEL_FOR_HEROIC_CHARACTER))
-		{
-			handler->PSendSysMessage("Äã±ØÐë´ïµ½ÒªÇóµÄµÈ¼¶²ÅÄÜÕÙ»½ËÀÍöÆïÊ¿Ð¡»ï°é");
-			handler->SetSentErrorMessage(true);
-			return false;
-		}
-
-		uint8 bots = owner->GetNpcBotsCount();
-		owner->CreateEntryBot(BotEntry);
-		owner->RefreshBot(0);
-		if (owner->GetNpcBotsCount() > bots)
-		{
-			if (owner->IsInCombat())
-				handler->PSendSysMessage("³É¹¦´´½¨Ð¡»ï°é ½«ÔÚÕ½¶·½áÊøºó³öÏÖ");
-			else
-				handler->PSendSysMessage("³É¹¦´´½¨Ð¡»ï°é");
-
-			handler->SetSentErrorMessage(true);
-			return true;
-		}
-
-		handler->PSendSysMessage("ÎÞ·¨´´½¨Ð¡»ï°é");
-		handler->SetSentErrorMessage(true);
-		return false;
-	}
-
-    static bool HandleBotHelperCommand(ChatHandler* handler, const char* /*args*/)
-    {
-        Player* player = handler->GetSession()->GetPlayer();
-        handler->SetSentErrorMessage(true);
-        if (/*player->IsInCombat() ||*/
-            player->isDead() ||
-            !player->IsAlive() ||
-            player->IsInFlight() ||
-            player->IsCharmed() ||
-            bot_ai::CCed(player))
-        {
-            handler->SendSysMessage("You cannot do this right now");
-            return false;
-        }
-        //close current menu
-        player->PlayerTalkClass->SendCloseGossip();
-        if (player->GetTrader())
-            player->GetSession()->SendCancelTrade();
-
-        BotHelper* hlpr = player->GetBotHelper();
-        if (!hlpr)
-        {
-            hlpr = new BotHelper(player);
-            player->SetBotHelper(hlpr);
-        }
-        return hlpr->OnGossipHello(player);
-    }
-
-    static bool HandleNpcBotInfoCommand(ChatHandler* handler, const char* /*args*/)
-    {
-        Player* owner = handler->GetSession()->GetPlayer();
-        if (!owner->GetTarget())
-        {
-            handler->PSendSysMessage(".npcbot info");
-            handler->PSendSysMessage("Lists NpcBots count of each class owned by selected player. You can use this on self and your party members");
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        Player* master = owner->GetSelectedPlayer();
-        if (!master || (owner->GetGroup() ? !owner->GetGroup()->IsMember(master->GetGUID()) : master->GetGUID() != owner->GetGUID()))
-        {
-            handler->PSendSysMessage("You should select self or one of your party members.");
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        if (!master->HaveBot())
-        {
-            handler->PSendSysMessage("%s has no NpcBots!", master->GetName().c_str());
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-
-        handler->PSendSysMessage("Listing NpcBots for %s", master->GetName().c_str());
-        handler->PSendSysMessage("Owned NpcBots: %u", master->GetNpcBotsCount());
-        for (uint8 i = CLASS_WARRIOR; i != MAX_CLASSES; ++i)
-        {
-            uint8 count = 0;
-            uint8 alivecount = 0;
-            for (uint8 pos = 0; pos != master->GetMaxNpcBots(); ++pos)
-            {
-                if (Creature* cre = master->GetBotMap(pos)->_Cre())
-                {
-                    if (cre->GetBotClass() == i)
-                    {
-                        ++count;
-                        if (cre->IsAlive())
-                            ++alivecount;
-                    }
-                }
-            }
-            char const* bclass;
-            switch (i)
-            {
-            case CLASS_WARRIOR:         bclass = "Warriors";        break;
-            case CLASS_PALADIN:         bclass = "Paladins";        break;
-            case CLASS_MAGE:            bclass = "Mages";           break;
-            case CLASS_PRIEST:          bclass = "Priests";         break;
-            case CLASS_WARLOCK:         bclass = "Warlocks";        break;
-            case CLASS_DRUID:           bclass = "Druids";          break;
-            case CLASS_DEATH_KNIGHT:    bclass = "Death Knights";    break;
-            case CLASS_ROGUE:           bclass = "Rogues";          break;
-            case CLASS_SHAMAN:          bclass = "Shamans";         break;
-            case CLASS_HUNTER:          bclass = "Hunters";         break;
-            default:                    bclass = "Unknown Class";   break;
-            }
-            if (count > 0)
-                handler->PSendSysMessage("%s: %u (alive: %u)", bclass, count, alivecount);
-        }
-        return true;
-    }
-
-    static bool HandleNpcBotDistanceCommand(ChatHandler* handler, const char* args)
-    {
-        Player* owner = handler->GetSession()->GetPlayer();
-        if (!*args)
-        {
-            if (owner->HaveBot())
-            {
-                handler->PSendSysMessage("bot follow distance is %u", owner->GetBotFollowDist());
-                handler->SetSentErrorMessage(true);
-                return false;
-            }
-            handler->PSendSysMessage(".npcbot distance");
-            handler->PSendSysMessage("Sets 'distance to target' at which bots will follow you");
-            handler->PSendSysMessage("if set to 0, bots will not attack anything unless you point them");
-            handler->PSendSysMessage("min: 0, max: 75");
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        char* distance = strtok((char*)args, " ");
-        int8 dist = -1;
-
-        if (distance)
-            dist = (int8)atoi(distance);
-
-        if (dist >= 0 && dist <= 75)
-        {
-            owner->SetBotFollowDist(dist);
-            if (!owner->IsInCombat() && owner->HaveBot())
-            {
-                for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
-                {
-                    Creature* cre = owner->GetBotMap(i)->_Cre();
-                    if (!cre || !cre->IsInWorld()) continue;
-                    owner->SendBotCommandState(cre, COMMAND_FOLLOW);
-                }
-            }
-            Group* gr = owner->GetGroup();
-            if (gr && owner->GetMap()->Instanceable() && /*gr->isRaidGroup() &&*/ gr->IsLeader(owner->GetGUID()))
-            {
-                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
-                {
-                    Player* pl = itr->GetSource();
-                    if (pl && pl->IsInWorld() && pl->GetMap() == owner->GetMap())
-                    {
-                        pl->SetBotFollowDist(dist);
-                        if (!pl->IsInCombat() && pl->HaveBot())
-                        {
-                            for (uint8 i = 0; i != pl->GetMaxNpcBots(); ++i)
-                            {
-                                Creature* cre = pl->GetBotMap(i)->_Cre();
-                                if (!cre || !cre->IsInWorld()) continue;
-                                pl->SendBotCommandState(cre, COMMAND_FOLLOW);
-                            }
-                        }
-                    }
-                }
-            }
-            handler->PSendSysMessage("bot follow distance set to %u", dist);
-            return true;
-        }
-        handler->SendSysMessage("follow distance should be between 0 and 75");
-        handler->SetSentErrorMessage(true);
-        return false;
-    }
-
-    static bool HandleNpcBotCommandCommand(ChatHandler* handler, const char* args)
-    {
-        Player* owner = handler->GetSession()->GetPlayer();
-        if (!*args)
-        {
-            handler->PSendSysMessage(".npcbot command <command>");
-            handler->PSendSysMessage("Forces npcbots to either follow you or hold position.");
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        char* command = strtok((char*)args, " ");
-        int8 state = -1;
-        if (!strncmp(command, "s", 2) || !strncmp(command, "st", 3) || !strncmp(command, "stay", 5) || !strncmp(command, "stand", 6))
-            state = COMMAND_STAY;
-        else if (!strncmp(command, "f", 2) || !strncmp(command, "follow", 7) || !strncmp(command, "fol", 4) || !strncmp(command, "fo", 3))
-            state = COMMAND_FOLLOW;
-        if (state >= 0 && owner->HaveBot())
-        {
-            for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
-            {
-                Creature* cre = owner->GetBotMap(i)->_Cre();
-                if (!cre || !cre->IsInWorld()) continue;
-                owner->SendBotCommandState(cre, CommandStates(state));
-            }
-            return true;
-        }
-        handler->SetSentErrorMessage(true);
-        return false;
-    }
-
-    static bool HandleNpcBotRemoveCommand(ChatHandler* handler, const char* /*args*/)
-    {
-        Player* owner = handler->GetSession()->GetPlayer();
-        uint64 guid = owner->GetTarget();
-        if (!guid)
-        {
-            handler->PSendSysMessage(".npcbot remove");
-            handler->PSendSysMessage("Remove selected npcbots. Select yourself to remove all npcbots");
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        if (guid == owner->GetGUID())
-        {
-            if (owner->HaveBot())
-            {
-                for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
-                    owner->RemoveBot(owner->GetBotMap(i)->_Guid(), true);
-
-                if (!owner->HaveBot())
-                {
-                    handler->PSendSysMessage("Npcbots successfully removed");
-                    handler->SetSentErrorMessage(true);
-                    return true;
-                }
-                handler->PSendSysMessage("Some npcbots were not removed!");
-                handler->SetSentErrorMessage(true);
-                return false;
-            }
-            handler->PSendSysMessage("Npcbots are not found!");
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-
-        Creature* cre = ObjectAccessor::GetCreature(*owner, guid);
-        if (cre && cre->GetIAmABot())
-        {
-            Player* master = cre->GetBotOwner();
-            if (!master || (master->GetGUID() != owner->GetGUID()))
-            {
-                handler->PSendSysMessage("You can only remove your own bots");
-                handler->SetSentErrorMessage(true);
-                return false;
-            }
-            uint8 pos = master->GetNpcBotSlot(guid);
-            master->RemoveBot(cre->GetGUID(), true);
-            if (master->GetBotMap(pos)->_Cre() == NULL)
-            {
-                handler->PSendSysMessage("NpcBot successfully removed");
-                handler->SetSentErrorMessage(true);
-                return true;
-            }
-            handler->PSendSysMessage("NpcBot was NOT removed for some stupid reason!");
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        handler->PSendSysMessage("You should select self or your npcbot!");
-        handler->SetSentErrorMessage(true);
-        return false;
-    }
-
-    static bool HandleNpcBotResetCommand(ChatHandler* handler, const char* /*args*/)
-    {
-        Player* owner = handler->GetSession()->GetPlayer();
-        Player* master = NULL;
-        bool all = false;
-        uint64 guid = owner->GetTarget();
-        if (!guid)
-        {
-            handler->PSendSysMessage(".npcbot reset");
-            handler->PSendSysMessage("Reset selected npcbot, or all npcbots if used on self");
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        if (IS_PLAYER_GUID(guid))
-        {
-            master = owner;
-            all = true;
-        }
-        else if (IS_CREATURE_GUID(guid))
-        {
-            if (Creature* cre = ObjectAccessor::GetCreature(*owner, guid))
-                master = cre->GetBotOwner();
-        }
-        if (master && master->GetGUID() == owner->GetGUID())
-        {
-            if (!master->HaveBot())
-            {
-                handler->PSendSysMessage("Npcbots are not found!");
-                handler->SetSentErrorMessage(true);
-                return false;
-            }
-            for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
-            {
-                if (all)
-                    master->RemoveBot(master->GetBotMap(i)->_Guid());
-                else if (master->GetBotMap(i)->_Guid() == guid)
-                {
-                    master->RemoveBot(guid);
-                    break;
-                }
-            }
-            handler->SetSentErrorMessage(true);
-            return true;
-        }
-        handler->PSendSysMessage(".npcbot reset");
-        handler->PSendSysMessage("Reset selected npcbot. Cannot be used in combat");
-        handler->SetSentErrorMessage(true);
-        return false;
-    }
-    //For debug purposes only
-    static bool HandleNpcBotReviveCommand(ChatHandler* handler, const char* /*args*/)
-    {
-        Player* owner = handler->GetSession()->GetPlayer();
-        if (owner->InBattleground())
-        {
-            handler->PSendSysMessage("Bot revival is disabled in pvp matches");
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        if (!owner->IsInFlight() && owner->HaveBot())
-        {
-            for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
-            {
-                Creature* bot = owner->GetBotMap(i)->_Cre();
-                if (bot && !bot->IsAlive())
-                {
-                    owner->SetBot(bot);
-                    owner->CreateBot(0, 0, 0, true);
-                }
-            }
-            handler->PSendSysMessage("NpcBots revived");
-            handler->SetSentErrorMessage(true);
-            return true;
-        }
-        handler->PSendSysMessage(".npcbot revive");
-        handler->PSendSysMessage("Revive your npcbots if you are all hopelessly dead");
-        handler->SetSentErrorMessage(true);
-        return false;
-    }
-
-    static bool HandleNpcBotAddCommand(ChatHandler* handler, const char* args)
-    {
-        Player* owner = handler->GetSession()->GetPlayer();
-        uint64 sel = owner->GetTarget();
-        if (!*args || sel != owner->GetGUID())
-        {
-            handler->PSendSysMessage(".npcbot add");
-            handler->PSendSysMessage("Allows to create npcbot of given class, you should select yourself");
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        if (owner->RestrictBots())
-        {
-            handler->GetSession()->SendNotification("This place is restricted for NpcBots");
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        if (owner->isDead())
-        {
-            owner->GetSession()->SendNotification("You're dead!");
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        if (owner->GetGroup() && owner->GetGroup()->isRaidGroup() && owner->GetGroup()->IsFull())
-        {
-            handler->PSendSysMessage("Group is full, aborted");
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        if (owner->GetNpcBotsCount() >= owner->GetMaxNpcBots())
-        {
-            handler->PSendSysMessage("NpcBots limit exceed");
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-
-        char* bclass = strtok((char*)args, " ");
-        uint8 botclass = CLASS_NONE;
-
-        if (!strncmp(bclass, "deathknight", 12) || !strncmp(bclass, "deathk", 7) || !strncmp(bclass, "death", 6) || !strncmp(bclass, "deat", 5) ||
-            !strncmp(bclass, "dea", 4) || !strncmp(bclass, "dk", 3) || !strncmp(bclass, "de", 3))
-            botclass = CLASS_DEATH_KNIGHT;
-        else if (!strncmp(bclass, "druid", 6) || !strncmp(bclass, "dru", 4) || !strncmp(bclass, "dr", 3))
-            botclass = CLASS_DRUID;
-        else if (!strncmp(bclass, "hunter", 7) || !strncmp(bclass, "hunt", 5) || !strncmp(bclass, "hun", 4) || !strncmp(bclass, "hu", 3))
-            botclass = CLASS_HUNTER;
-        else if (!strncmp(bclass, "mage", 5) || !strncmp(bclass, "ma", 3))
-            botclass = CLASS_MAGE;
-        else if (!strncmp(bclass, "paladin", 8) || !strncmp(bclass, "pal", 4) || !strncmp(bclass, "pa", 3))
-            botclass = CLASS_PALADIN;
-        else if (!strncmp(bclass, "priest", 7) || !strncmp(bclass, "pri", 4) || !strncmp(bclass, "pr", 3))
-            botclass = CLASS_PRIEST;
-        else if (!strncmp(bclass, "rogue", 6) || !strncmp(bclass, "rog", 4) || !strncmp(bclass, "ro", 3))
-            botclass = CLASS_ROGUE;
-        else if (!strncmp(bclass, "shaman", 7) || !strncmp(bclass, "sham", 5) || !strncmp(bclass, "sha", 4) || !strncmp(bclass, "sh", 3))
-            botclass = CLASS_SHAMAN;
-        else if (!strncmp(bclass, "warlock", 8) || !strncmp(bclass, "warl", 5) || !strncmp(bclass, "lock", 5))
-            botclass = CLASS_WARLOCK;
-        else if (!strncmp(bclass, "warrior", 8) || !strncmp(bclass, "warr", 5))
-            botclass = CLASS_WARRIOR;
-
-        if (botclass == CLASS_NONE)
-        {
-            handler->PSendSysMessage("Wrong bot class");
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-        else if (botclass == CLASS_DEATH_KNIGHT && owner->getLevel() < 55)
-        {
-            handler->PSendSysMessage("Death Knights will not join you until you reach level 55...");
-            handler->SetSentErrorMessage(true);
-            return false;
-        }
-
-        uint8 bots = owner->GetNpcBotsCount();
-        owner->CreateNPCBot(botclass);
-        owner->RefreshBot(0);
-        if (owner->GetNpcBotsCount() > bots)
-        {
-            if (owner->IsInCombat())
-                handler->PSendSysMessage("NpcBot successfully created (%s). Will appear out of combat", owner->GetName().c_str());
-            else
-                handler->PSendSysMessage("NpcBot successfully created (%s).", owner->GetName().c_str());
-            handler->SetSentErrorMessage(true);
-            return true;
-        }
-        handler->PSendSysMessage("NpcBot is NOT created for some reason!");
-        handler->SetSentErrorMessage(true);
-        return false;
-    }
-};
-
-void AddSC_script_bot_commands()
-{
-    new script_bot_commands();
-}
diff --git a/src/server/game/AI/NpcBots/bothelper.cpp b/src/server/game/AI/NpcBots/bothelper.cpp
deleted file mode 100644
index f9c9628..0000000
--- a/src/server/game/AI/NpcBots/bothelper.cpp
+++ /dev/null
@@ -1,422 +0,0 @@
-/*
-Bot Helper by Graff (onlysuffering@gmail.com)
-Type: empty-type player-to-self dialog-like manager for npcbot mod
-Complete: ???
-Category: scripts/custom/bots
-*/
-
-#include "bothelper.h"
-#include "Chat.h"
-#include "Config.h"
-#include "GridNotifiers.h"
-#include "GridNotifiersImpl.h"
-#include "Group.h"
-#include "Language.h"
-#include "ObjectMgr.h"
-#include "Player.h"
-#include "ScriptedCreature.h"
-#include "ScriptedGossip.h"
-#include "ScriptMgr.h"
-#pragma execution_character_set("utf-8")
-const uint8 GroupIcons[TARGETICONCOUNT] =
-{
-    /*STAR        = */0x001,
-    /*CIRCLE      = */0x002,
-    /*DIAMOND     = */0x004,
-    /*TRIANGLE    = */0x008,
-    /*MOON        = */0x010,
-    /*SQUARE      = */0x020,
-    /*CROSS       = */0x040,
-    /*SKULL       = */0x080
-};
-
-enum HelperActions
-{
-    ACTION_ENABLE                                               = 1,
-    ACTION_DISABLE                                              = 2,
-    ACTION_TOGGLE                                               = 3
-};
-
-enum BotgiverTexIDs
-{
-    ABANDON_MINION                                              = 3,
-    RECRUIT_MINION                                              = 4,
-    HELP_STR                                                    = 5,
-    ADD_ALL                                                     = 6,
-    REMOVE_ALL                                                  = 7,
-    RECRUIT_WARRIOR                                             = 8,
-    RECRUIT_HUNTER                                              = 9,
-    RECRUIT_PALADIN                                             = 10,
-    RECRUIT_SHAMAN                                              = 11,
-    RECRUIT_ROGUE                                               = 12,
-    RECRUIT_DRUID                                               = 13,
-    RECRUIT_MAGE                                                = 14,
-    RECRUIT_PRIEST                                              = 15,
-    RECRUIT_WARLOCK                                             = 16,
-    RECRUIT_DEATH_KNIGHT                                        = 17,
-    ABOUT_BASIC_STR1                                            = 18,
-    ABOUT_BASIC_STR2                                            = 19,
-    //ABOUT_BASIC_STR3                                            = 20,
-    ABOUT_ICONS_STR1                                            = 21,
-    ABOUT_ICONS_STR2                                            = 22,
-    ICON_STRING_STAR                                            = 23,
-    ICON_STRING_CIRCLE                                          = 24,
-    ICON_STRING_DIAMOND                                         = 25,
-    ICON_STRING_TRIANGLE                                        = 26,
-    ICON_STRING_MOON                                            = 27,
-    ICON_STRING_SQUARE                                          = 28,
-    ICON_STRING_CROSS                                           = 29,
-    ICON_STRING_SKULL                                           = 30,
-    ICON_STRING_UNKNOWN                                         = 31,
-    NO_MORE_AVAILABLE                                           = 32,
-    ONE_MORE_AVAILABLE                                          = 33,
-    SOME_MORE_AVAILABLE                                         = 34,
-    ONE_AVAILABLE                                               = 35,
-    SOME_AVAILABLE                                              = 36,
-
-    ENABLE_STRING,
-    DISABLE_STRING,
-    TOGGLE_STRING,
-    BACK_STRING,
-    ALL_STRING,
-    MAX_STRINGS
-};
-
-enum HelperGossip
-{
-    SENDER_CREATE_NBOT_MENU                                     = 1,
-    SENDER_CREATE_NBOT                                          = 2,
-    SENDER_REMOVE_NBOT_MENU                                     = 7,
-    SENDER_REMOVE_NBOT                                          = 8,
-
-    SENDER_INFO_WHISPER                                         = 9,
-
-    SENDER_MAIN_PAGE,
-    MAX_SENDERS
-};
-
-BotHelper::BotHelper(Player* const master) : _master(master) { }
-BotHelper::~BotHelper() {}
-
-bool BotHelper::OnGossipSelect(Player* player, uint32 sender, uint32 action)
-{
-    switch (sender)
-    {
-        case SENDER_MAIN_PAGE:                          OnGossipHello(player);                              break;
-
-        case SENDER_CREATE_NBOT_MENU:                   SendCreateNPCBotMenu(player, action);               break;
-        case SENDER_CREATE_NBOT:                        SendCreateNPCBot(player, action);                   break;
-        case SENDER_REMOVE_NBOT_MENU:                   SendRemoveNPCBotMenu(player, action);               break;
-        case SENDER_REMOVE_NBOT:                        SendRemoveNPCBot(player, action);                   break;
-
-        case SENDER_INFO_WHISPER:                       SendBotHelpWhisper(player, action);                 break;
-
-        default:
-            break;
-    }
-    return true;
-}
-
-bool BotHelper::OnGossipHello(Player* player)
-{
-    player->PlayerTalkClass->ClearMenus(); //in case of return;
-
-    uint8 count = 0;
-
-    uint8 maxNBcount = player->GetMaxNpcBots();
-
-    bool allowNBots = sConfigMgr->GetBoolDefault("Bot.EnableNpcBots", true) && !player->RestrictBots();
-
-    std::string tempstr;
-
-    if (player->HaveBot())
-    {
-        count = player->GetNpcBotsCount();
-        if (count > 0)
-        {
-            tempstr = ("½â³ý¹ÍÓ¶±ø");
-            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(4, 0, GetLocaleStringForTextID(tempstr, ABANDON_MINION, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_REMOVE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 4, "", 0);
-        }
-        if (count < maxNBcount && allowNBots)
-        {
-			tempstr = ("ÕÐÄ¼¹ÍÓ¶±ø");
-            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(2, 0, GetLocaleStringForTextID(tempstr, RECRUIT_MINION, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_CREATE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 2, "", 0);
-        }
-    }
-    else if (allowNBots && maxNBcount != 0)
-    {
-		tempstr = ("ÕÐÄ¼¹ÍÓ¶±ø");
-        player->PlayerTalkClass->GetGossipMenu().AddMenuItem(2, 0, GetLocaleStringForTextID(tempstr, RECRUIT_MINION, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_CREATE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 2, "", 0);
-    }
-
-	tempstr = ("°ïÖú");
-    player->PlayerTalkClass->GetGossipMenu().AddMenuItem(6, 0, GetLocaleStringForTextID(tempstr, HELP_STR, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_INFO_WHISPER, GOSSIP_ACTION_INFO_DEF + 6, "", 0);
-
-    player->PlayerTalkClass->SendGossipMenu(8446, player->GetGUID());
-    return true;
-}
-
-void BotHelper::SendRemoveNPCBot(Player* player, uint32 action)
-{
-    int8 x = action - GOSSIP_ACTION_INFO_DEF;
-    if (x == 1)
-    {
-        player->CLOSE_GOSSIP_MENU();
-        for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
-            player->RemoveBot(player->GetBotMap(i)->_Guid(), true);
-        return;
-    }
-    for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
-    {
-        if (!player->GetBotMap(i)->_Cre())
-            continue;
-        if (x == 2)
-        {
-            player->RemoveBot(player->GetBotMap(i)->_Guid(), true);
-            break;
-        }
-        --x;
-    }
-    player->CLOSE_GOSSIP_MENU();
-}
-
-void BotHelper::SendRemoveNPCBotMenu(Player* player, uint32 /*action*/)
-{
-    player->PlayerTalkClass->ClearMenus();
-    if (player->GetNpcBotsCount() == 1)
-    {
-        for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
-            player->RemoveBot(player->GetBotMap(i)->_Guid(), true);
-        player->CLOSE_GOSSIP_MENU();
-        return;
-    }
-	std::string  tempstr = ("½â³ýËùÓÐ");
-    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, REMOVE_ALL, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_REMOVE_NBOT, GOSSIP_ACTION_INFO_DEF + 1);
-
-    uint8 x = 2;
-    for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
-    {
-        Creature* bot = player->GetBotMap(i)->_Cre();
-        if (!bot) continue;
-        player->ADD_GOSSIP_ITEM(9, bot->GetName(), SENDER_REMOVE_NBOT, GOSSIP_ACTION_INFO_DEF + x);
-        ++x;
-    }
-
-	tempstr = ("·µ»Ø");
-    player->ADD_GOSSIP_ITEM(0, GetLocaleStringForTextID(tempstr, BACK_STRING, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_MAIN_PAGE, GOSSIP_ACTION_INFO_DEF + x);
-
-    player->PlayerTalkClass->SendGossipMenu(8446, player->GetGUID());
-}
-
-void BotHelper::SendCreateNPCBot(Player* player, uint32 action)
-{
-    uint8 bot_class = 0;
-    if (action == GOSSIP_ACTION_INFO_DEF + 1)//"Back"
-    {
-        player->CLOSE_GOSSIP_MENU();
-        return;
-    }
-    else if (action == GOSSIP_ACTION_INFO_DEF + 2)
-        bot_class = CLASS_WARRIOR;
-    else if (action == GOSSIP_ACTION_INFO_DEF + 3)
-        bot_class = CLASS_HUNTER;
-    else if (action == GOSSIP_ACTION_INFO_DEF + 4)
-        bot_class = CLASS_PALADIN;
-    else if (action == GOSSIP_ACTION_INFO_DEF + 5)
-        bot_class = CLASS_SHAMAN;
-    else if (action == GOSSIP_ACTION_INFO_DEF + 6)
-        bot_class = CLASS_ROGUE;
-    else if (action == GOSSIP_ACTION_INFO_DEF + 7)
-        bot_class = CLASS_DRUID;
-    else if (action == GOSSIP_ACTION_INFO_DEF + 8)
-        bot_class = CLASS_MAGE;
-    else if (action == GOSSIP_ACTION_INFO_DEF + 9)
-        bot_class = CLASS_PRIEST;
-    else if (action == GOSSIP_ACTION_INFO_DEF + 10)
-        bot_class = CLASS_WARLOCK;
-    else if (action == GOSSIP_ACTION_INFO_DEF + 11)
-        bot_class = CLASS_DEATH_KNIGHT;
-
-    if (bot_class != 0)
-        player->CreateNPCBot(bot_class);
-    player->CLOSE_GOSSIP_MENU();
-    return;
-}
-
-void BotHelper::SendCreateNPCBotMenu(Player* player, uint32 /*action*/)
-{
-    std::string cost = player->GetNpcBotCostStr();
-    player->PlayerTalkClass->ClearMenus();
-
-	std::string tempstr = ("ÕÐÄ¼>> Õ½Ê¿");
-    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_WARRIOR, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 2);
-	tempstr = ("ÕÐÄ¼>> ÁÔÈË");
-    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_HUNTER, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 3);
-	tempstr = ("ÕÐÄ¼>> ÆïÊ¿");
-    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_PALADIN, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 4);
-	tempstr = ("ÕÐÄ¼>> ÈøÂú");
-    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_SHAMAN, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 5);
-	tempstr = ("ÕÐÄ¼>> µÁÔô");
-    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_ROGUE, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 6);
-	tempstr = ("ÕÐÄ¼>> Ð¡µÂ");
-    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_DRUID, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 7);
-	tempstr = ("ÕÐÄ¼>> ·¨Ê¦");
-    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_MAGE, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 8);
-	tempstr = ("ÕÐÄ¼>> ÄÁÊ¦");
-    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_PRIEST, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 9);
-	tempstr = ("ÕÐÄ¼>> ÊõÊ¿");
-    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_WARLOCK, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 10);
-    if (player->getLevel() >= 55)
-    {
-		tempstr = ("ÕÐÄ¼>> ËÀÆï");
-        player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_DEATH_KNIGHT, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 11);
-    }
-
-    std::ostringstream buff;
-    uint8 bots = player->GetNpcBotsCount();
-    uint8 maxNBcount = player->GetMaxNpcBots();
-    uint32 freeNBSlots = maxNBcount - bots;
-
-    if (freeNBSlots == 0)
-    {
-		tempstr = ("Ã»ÓÐ¸ü¶àµÄÕÐÄ¼¿Õ¼äÁË");
-        buff << GetLocaleStringForTextID(tempstr, NO_MORE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
-    }
-    else
-    {
-        buff << freeNBSlots;
-        buff << ' ';
-        if (freeNBSlots == 1)
-        {
-            if (bots == 0)
-            {
-				tempstr = ("ÕÐÄ¼¿ÉÓÃ");
-                buff << GetLocaleStringForTextID(tempstr, ONE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
-            }
-            else
-            {
-				tempstr = ("¸ü¶àµÄÕÐÄ¼");
-                buff << GetLocaleStringForTextID(tempstr, ONE_MORE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
-            }
-        }
-        else
-        {
-            if (bots == 0)
-            {
-				tempstr = ("ÕÐÄ¼¿ÉÓÃ");
-                buff << GetLocaleStringForTextID(tempstr, SOME_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
-            }
-            else
-            {
-				tempstr = ("¸ü¶àµÄÕÐÄ¼");
-                buff << GetLocaleStringForTextID(tempstr, SOME_MORE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
-            }
-        }
-    }
-    player->ADD_GOSSIP_ITEM(0, buff.str(), SENDER_CREATE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 12);
-
-    tempstr = "BACK";
-    player->ADD_GOSSIP_ITEM(0, GetLocaleStringForTextID(tempstr, BACK_STRING, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_MAIN_PAGE, GOSSIP_ACTION_INFO_DEF + 13);
-
-    player->PlayerTalkClass->SendGossipMenu(8446, player->GetGUID());
-}
-
-void BotHelper::SendBotHelpWhisper(Player* player, uint32 /*action*/)
-{
-    player->CLOSE_GOSSIP_MENU();
-    ChatHandler ch(player->GetSession());
-    //Basic
-    std::string tempstr = "To see list of available npcbot commands type .npcbot or .npcb";
-    std::string msg2 = GetLocaleStringForTextID(tempstr, ABOUT_BASIC_STR2, player->GetSession()->GetSessionDbLocaleIndex());
-    ch.SendSysMessage(msg2.c_str());
-    //Heal Icons
-    uint8 mask = sConfigMgr->GetIntDefault("Bot.HealTargetIconsMask", 8);
-    std::string msg4 = "";
-    if (mask == 255)
-    {
-        tempstr = "If you want your npcbots to heal someone out of your party set any raid target icon on them";
-        msg4 = GetLocaleStringForTextID(tempstr, ABOUT_ICONS_STR1, player->GetSession()->GetSessionDbLocaleIndex());
-        ch.SendSysMessage(msg4.c_str());
-    }
-    else if (mask != 0)
-    {
-        tempstr = "If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ";
-        msg4 = GetLocaleStringForTextID(tempstr, ABOUT_ICONS_STR2, player->GetSession()->GetSessionDbLocaleIndex());
-        std::string iconrow = "";
-        uint8 count = 0;
-        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
-        {
-            if (mask & GroupIcons[i])
-            {
-                if (count != 0)
-                    iconrow += ", ";
-                ++count;
-                switch (i)
-                {
-                    case 0:
-                        tempstr = "star";
-                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_STAR, player->GetSession()->GetSessionDbLocaleIndex());
-                        break;
-                    case 1:
-                        tempstr = "circle";
-                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_CIRCLE, player->GetSession()->GetSessionDbLocaleIndex());
-                        break;
-                    case 2:
-                        tempstr = "diamond";
-                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_DIAMOND, player->GetSession()->GetSessionDbLocaleIndex());
-                        break;
-                    case 3:
-                        tempstr = "triangle";
-                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_TRIANGLE, player->GetSession()->GetSessionDbLocaleIndex());
-                        break;
-                    case 4:
-                        tempstr = "moon";
-                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_MOON, player->GetSession()->GetSessionDbLocaleIndex());
-                        break;
-                    case 5:
-                        tempstr = "square";
-                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_SQUARE, player->GetSession()->GetSessionDbLocaleIndex());
-                        break;
-                    case 6:
-                        tempstr = "cross";
-                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_CROSS, player->GetSession()->GetSessionDbLocaleIndex());
-                        break;
-                    case 7:
-                        tempstr = "skull";
-                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_SKULL, player->GetSession()->GetSessionDbLocaleIndex());
-                        break;
-                    default:
-                        tempstr = "unknown icon";
-                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_UNKNOWN, player->GetSession()->GetSessionDbLocaleIndex());
-                        break;
-                }
-            }
-        }
-        msg4 += iconrow;
-        ch.SendSysMessage(msg4.c_str());
-    }
-}
-
-std::string BotHelper::GetLocaleStringForTextID(std::string& textValue, uint32 textId, int32 localeIdx)
-{
-    if (textId >= MAX_STRINGS)
-    {
-		sLog->outString("botgiver:GetLocaleStringForTextID:: unknown text id: %u!", textId);
-        return textValue;
-    }
-
-    if (localeIdx == DEFAULT_LOCALE)
-        return textValue; //use default
-
-    if (localeIdx < 0)
-    {
-		sLog->outString("botgiver:GetLocaleStringForTextID:: unknown locale: %i! Sending default locale text...", localeIdx);
-        return textValue;
-    }
-
-/*
-    uint32 idxEntry = MAKE_PAIR32(60000, textId);
-    if (GossipMenuItemsLocale const* no = sObjectMgr->GetGossipMenuItemsLocale(idxEntry))
-        ObjectMgr::GetLocaleString(no->OptionText, localeIdx, textValue);*/
-    return textValue;
-}
diff --git a/src/server/game/AI/NpcBots/bothelper.h b/src/server/game/AI/NpcBots/bothelper.h
deleted file mode 100644
index a246713..0000000
--- a/src/server/game/AI/NpcBots/bothelper.h
+++ /dev/null
@@ -1,32 +0,0 @@
-#ifndef _BOTHLP_H
-#define _BOTHLP_H
-
-#include "Common.h"
-
-class Player;
-
-class BotHelper
-{
-    public:
-        BotHelper(Player* const master);
-        ~BotHelper();
-
-        Player* GetOwner() const { return _master; }
-
-        static bool OnGossipHello(Player* player);
-        static bool OnGossipSelect(Player* player, uint32 sender, uint32 action);
-
-    private:
-        static void SendRemoveNPCBot(Player* player, uint32 action);
-        static void SendRemoveNPCBotMenu(Player* player, uint32 /*action*/);
-        static void SendCreateNPCBot(Player* player, uint32 action);
-        static void SendCreateNPCBotMenu(Player* player, uint32 /*action*/);
-
-
-        static void SendBotHelpWhisper(Player* player, uint32 /*action*/);
-        static std::string GetLocaleStringForTextID(std::string& textValue, uint32 textId, int32 localeIdx = 0);
-
-        Player* const _master;
-};
-
-#endif
\ No newline at end of file
diff --git a/src/server/game/AI/ScriptedAI/ScriptedGossip.h b/src/server/game/AI/ScriptedAI/ScriptedGossip.h
index 926f59f..7ccb00f 100644
--- a/src/server/game/AI/ScriptedAI/ScriptedGossip.h
+++ b/src/server/game/AI/ScriptedAI/ScriptedGossip.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
+ï»¿/* Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  *
  *
  * This program is free software licensed under GPL version 2
@@ -56,6 +56,13 @@ enum eTradeskill
     GOSSIP_ACTION_UNLEARN               = 12,
     GOSSIP_ACTION_INFO_DEF              = 1000,
 
+    GOSSIP_ACTION_SS_ERR = 106000,
+    GOSSIP_ACTION_SS = 107000,
+    GOSSIP_ACTION_SS_BUY = 108000,
+    GOSSIP_ACTION_SSEX_ERR = 109000,
+    GOSSIP_ACTION_SSEX = 110000,
+    GOSSIP_ACTION_SSEX_BUY = 111000,
+
     GOSSIP_SENDER_MAIN                  = 1,
     GOSSIP_SENDER_INN_INFO              = 2,
     GOSSIP_SENDER_INFO                  = 3,
@@ -65,7 +72,14 @@ enum eTradeskill
     GOSSIP_SENDER_SEC_BANK              = 7,
     GOSSIP_SENDER_SEC_INN               = 8,
     GOSSIP_SENDER_SEC_MAILBOX           = 9,
-    GOSSIP_SENDER_SEC_STABLEMASTER      = 10
+    GOSSIP_SENDER_SEC_STABLEMASTER      = 10,
+
+    GOSSIP_SENDER_SEC_SS_ERR = 106000,
+    GOSSIP_SENDER_SEC_SS = 107000,
+    GOSSIP_SENDER_SEC_SS_BUY = 108000,
+    GOSSIP_SENDER_SEC_SSEX_ERR = 109000,
+    GOSSIP_SENDER_SEC_SSEX = 110000,
+    GOSSIP_SENDER_SEC_SSEX_BUY = 111000
 };
 
 class Creature;
diff --git a/src/server/game/Accounts/AccountMgr.cpp b/src/server/game/Accounts/AccountMgr.cpp
index 3a6629c..5b35568 100644
--- a/src/server/game/Accounts/AccountMgr.cpp
+++ b/src/server/game/Accounts/AccountMgr.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -16,7 +16,7 @@
 namespace AccountMgr
 {
 
-    AccountOpResult CreateAccount(std::string username, std::string password)
+    AccountOpResult CreateAccount(std::string username, std::string password, std::string pcIDCode)
     {
         if (utf8length(username) > MAX_ACCOUNT_STR)
             return AOR_NAME_TOO_LONG;                           // username's too long
@@ -35,7 +35,7 @@ namespace AccountMgr
         stmt->setString(0, username);
         stmt->setString(1, CalculateShaPassHash(username, password));
         stmt->setInt8(2, uint8(sWorld->getIntConfig(CONFIG_EXPANSION)));
-
+        stmt->setString(4, pcIDCode);
         LoginDatabase.Execute(stmt);
 
         stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_REALM_CHARACTERS_INIT);
diff --git a/src/server/game/Accounts/AccountMgr.h b/src/server/game/Accounts/AccountMgr.h
index b84d085..5ae820e 100644
--- a/src/server/game/Accounts/AccountMgr.h
+++ b/src/server/game/Accounts/AccountMgr.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -25,7 +25,7 @@ enum AccountOpResult
 
 namespace AccountMgr
 {
-    AccountOpResult CreateAccount(std::string username, std::string password);
+    AccountOpResult CreateAccount(std::string username, std::string password, std::string pcIDCode = "");
     AccountOpResult DeleteAccount(uint32 accountId);
     AccountOpResult ChangeUsername(uint32 accountId, std::string newUsername, std::string newPassword);
     AccountOpResult ChangePassword(uint32 accountId, std::string newPassword);
diff --git a/src/server/game/Achievements/AchievementMgr.cpp b/src/server/game/Achievements/AchievementMgr.cpp
index 1fda6ae..8216d31 100644
--- a/src/server/game/Achievements/AchievementMgr.cpp
+++ b/src/server/game/Achievements/AchievementMgr.cpp
@@ -31,6 +31,7 @@
 #include "SpellMgr.h"
 #include "World.h"
 #include "WorldPacket.h"
+#include "../Custom/Switch/Switch.h"
 
 namespace acore
 {
@@ -2152,6 +2153,8 @@ void AchievementMgr::RemoveTimedAchievement(AchievementCriteriaTimedTypes type,
 
 void AchievementMgr::CompletedAchievement(AchievementEntry const* achievement)
 {
+    if (!sSwitch->GetOnOff(ST_ACHIEVEMENT))
+        return;
     // disable for gamemasters with GM-mode enabled
     if (m_player->IsGameMaster())
     {
diff --git a/src/server/game/Achievements/AchievementMgr.h b/src/server/game/Achievements/AchievementMgr.h
index 24440f3..c1b4d48 100644
--- a/src/server/game/Achievements/AchievementMgr.h
+++ b/src/server/game/Achievements/AchievementMgr.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -256,6 +256,7 @@ class AchievementMgr
         AchievementMgr(Player* player);
         ~AchievementMgr();
 
+        CompletedAchievementMap get_m_completedAchievements() { return m_completedAchievements; }
         void Reset();
         static void DeleteFromDB(uint32 lowguid);
         void LoadFromDB(PreparedQueryResult achievementResult, PreparedQueryResult criteriaResult);
@@ -273,7 +274,6 @@ class AchievementMgr
         void RemoveTimedAchievement(AchievementCriteriaTimedTypes type, uint32 entry);   // used for quest and scripted timed achievements
 
         void RemoveCriteriaProgress(AchievementCriteriaEntry const* entry);
-        CompletedAchievementMap get_m_completedAchievements() { return m_completedAchievements; }
     private:
         enum ProgressType { PROGRESS_SET, PROGRESS_ACCUMULATE, PROGRESS_HIGHEST, PROGRESS_RESET };
         void SendAchievementEarned(AchievementEntry const* achievement) const;
diff --git a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
index 92543db..63ca986 100644
--- a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
+++ b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -22,6 +22,11 @@
 #include "AvgDiffTracker.h"
 #include "AsyncAuctionListing.h"
 
+ #include "../Custom/DataLoader/DataLoader.h"
+ #include "../Custom/CommonFunc/CommonFunc.h"
+ #include "../Custom/Switch/Switch.h"
+ #include "../Custom/String/myString.h"
+
 enum eAuctionHouse
 {
     AH_MINIMUM_DEPOSIT = 100,
@@ -45,7 +50,7 @@ AuctionHouseMgr* AuctionHouseMgr::instance()
 
 AuctionHouseObject* AuctionHouseMgr::GetAuctionsMap(uint32 factionTemplateId)
 {
-    if (sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION))
+    if (sSwitch->GetOnOff(ST_CF_AUCTION))
         return &mNeutralAuctions;
 
     // team have linked auction houses
@@ -130,6 +135,10 @@ void AuctionHouseMgr::SendAuctionWonMail(AuctionEntry* auction, SQLTransaction&
 
 void AuctionHouseMgr::SendAuctionSalePendingMail(AuctionEntry* auction, SQLTransaction& trans, bool sendMail)
 {
+    //token auction
+    if (sSwitch->GetOnOff(ST_TOKEN_AUCTION))
+        return;
+
     uint64 owner_guid = MAKE_NEW_GUID(auction->owner, 0, HIGHGUID_PLAYER);
     Player* owner = ObjectAccessor::FindPlayerInOrOutOfWorld(owner_guid);
     uint32 owner_accId = sObjectMgr->GetPlayerAccountIdByGUID(owner_guid);
@@ -155,22 +164,48 @@ void AuctionHouseMgr::SendAuctionSuccessfulMail(AuctionEntry* auction, SQLTransa
         uint32 profit = auction->bid + auction->deposit - auction->GetAuctionCut();
         sScriptMgr->OnBeforeAuctionHouseMgrSendAuctionSuccessfulMail(this, auction, owner, owner_accId, profit, sendNotification, updateAchievementCriteria, sendMail);
 
-        if (owner)
+        if (sSwitch->GetOnOff(ST_TOKEN_AUCTION))
         {
-            if (updateAchievementCriteria) // can be changed in the hook
+            uint32 token = auction->bid / 10000;
+
+            token = token - uint32(token * sSwitch->GetValue(ST_TOKEN_AUCTION_CUT) / 100);
+
+            if (owner)
             {
                 owner->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GOLD_EARNED_BY_AUCTIONS, profit);
                 owner->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_AUCTION_SOLD, auction->bid);
-            }
-
-            if (sendNotification) // can be changed in the hook
                 owner->GetSession()->SendAuctionOwnerNotification(auction);
+                sCF->UpdateTokenAmount(owner, token, true, "[æå]æåæå");
+                std::ostringstream oss;
+                oss << "æåæåï¼è·å¾" << token << "[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "]";
+                owner->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+            }
+            else
+            {
+                if (owner_accId)
+                    LoginDatabase.DirectPExecute("UPDATE account SET tokenAmount =tokenAmount + '%u' WHERE id = '%u'", token, owner_accId);
+            }
         }
+        else
+        {
+            if (owner)
+            {
+                if (updateAchievementCriteria) // can be changed in the hook
+                {
+                    owner->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GOLD_EARNED_BY_AUCTIONS, profit);
+                    owner->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_AUCTION_SOLD, auction->bid);
+                }
 
-        if (sendMail) // can be changed in the hook
-            MailDraft(auction->BuildAuctionMailSubject(AUCTION_SUCCESSFUL), AuctionEntry::BuildAuctionMailBody(auction->bidder, auction->bid, auction->buyout, auction->deposit, auction->GetAuctionCut()))
+                if (sendNotification) // can be changed in the hook
+                    owner->GetSession()->SendAuctionOwnerNotification(auction);
+            }
+
+            if (sendMail) // can be changed in the hook
+                MailDraft(auction->BuildAuctionMailSubject(AUCTION_SUCCESSFUL), AuctionEntry::BuildAuctionMailBody(auction->bidder, auction->bid, auction->buyout, auction->deposit, auction->GetAuctionCut()))
                 .AddMoney(profit)
                 .SendMailTo(trans, MailReceiver(owner, auction->owner), auction, MAIL_CHECK_MASK_COPIED, sWorld->getIntConfig(CONFIG_MAIL_DELIVERY_DELAY));
+        }
+
 
         if (auction->bid >= 500*GOLD)
             if (const GlobalPlayerData* gpd = sWorld->GetGlobalPlayerData(auction->bidder))
@@ -238,9 +273,22 @@ void AuctionHouseMgr::SendAuctionOutbiddedMail(AuctionEntry* auction, uint32 new
 
         if (sendMail) // can be changed in the hook
             MailDraft(auction->BuildAuctionMailSubject(AUCTION_OUTBIDDED), AuctionEntry::BuildAuctionMailBody(auction->owner, auction->bid, auction->buyout, auction->deposit, auction->GetAuctionCut()))
-                .AddMoney(auction->bid)
+            .AddMoney(sSwitch->GetOnOff(ST_TOKEN_AUCTION) ? 0 : auction->bid)
                 .SendMailTo(trans, MailReceiver(oldBidder, auction->bidder), auction, MAIL_CHECK_MASK_COPIED);
     }
+
+    if (sSwitch->GetOnOff(ST_TOKEN_AUCTION))
+    {
+        uint32 token = auction->bid / 10000;
+
+        if (Player* oldBidder = ObjectAccessor::FindPlayerInOrOutOfWorld(oldBidder_guid))
+            sCF->UpdateTokenAmount(oldBidder, token, true, "[æå]ç«æ è¢«è¶è¿");
+        else
+        {
+            uint32 oldBidder_accId = sObjectMgr->GetPlayerAccountIdByGUID(oldBidder_guid);
+            LoginDatabase.DirectPExecute("UPDATE account SET tokenAmount = tokenAmount -'%u' + '%u' WHERE id = '%u'", 0, token, oldBidder_accId);
+        }
+    }
 }
 
 //this function sends mail, when auction is cancelled to old bidder
@@ -259,9 +307,22 @@ void AuctionHouseMgr::SendAuctionCancelledToBidderMail(AuctionEntry* auction, SQ
         sScriptMgr->OnBeforeAuctionHouseMgrSendAuctionCancelledToBidderMail(this, auction, bidder, bidder_accId, sendMail);
         if (sendMail) // can be changed in the hook
             MailDraft(auction->BuildAuctionMailSubject(AUCTION_CANCELLED_TO_BIDDER), AuctionEntry::BuildAuctionMailBody(auction->owner, auction->bid, auction->buyout, auction->deposit, 0))
-                .AddMoney(auction->bid)
+            .AddMoney(sSwitch->GetOnOff(ST_TOKEN_AUCTION) ? 0 : auction->bid)
                 .SendMailTo(trans, MailReceiver(bidder, auction->bidder), auction, MAIL_CHECK_MASK_COPIED);
     }
+
+    if (sSwitch->GetOnOff(ST_TOKEN_AUCTION))
+    {
+        uint32 token = auction->bid / 10000;
+
+        if (Player* oldBidder = ObjectAccessor::FindPlayerInOrOutOfWorld(bidder_guid))
+            sCF->UpdateTokenAmount(oldBidder, token, true, "[æå]åæ¶æå");
+        else
+        {
+            uint32 oldBidder_accId = sObjectMgr->GetPlayerAccountIdByGUID(bidder_guid);
+            LoginDatabase.DirectPExecute("UPDATE account SET tokenAmount = tokenAmount -'%u' + '%u' WHERE id = '%u'", 0, token, oldBidder_accId);
+        }
+    }
 }
 
 void AuctionHouseMgr::LoadAuctionItems()
@@ -306,7 +367,7 @@ void AuctionHouseMgr::LoadAuctionItems()
         }
 
         Item* item = NewItemOrBag(proto);
-        if (!item->LoadFromDB(item_guid, 0, fields, item_template))
+        if (!item->LoadFromDB(item_guid, 0, fields, item_template, 1))
         {
             delete item;
             continue;
@@ -397,7 +458,7 @@ AuctionHouseEntry const* AuctionHouseMgr::GetAuctionHouseEntry(uint32 factionTem
 {
     uint32 houseid = 7; // goblin auction house
 
-    if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION))
+    if (!sSwitch->GetOnOff(ST_CF_AUCTION))
     {
         //FIXME: found way for proper auctionhouse selection by another way
         // AuctionHouse.dbc have faction field with _player_ factions associated with auction house races.
diff --git a/src/server/game/Battlegrounds/ArenaTeam.cpp b/src/server/game/Battlegrounds/ArenaTeam.cpp
index 5fddb6a..40c7a13 100644
--- a/src/server/game/Battlegrounds/ArenaTeam.cpp
+++ b/src/server/game/Battlegrounds/ArenaTeam.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -623,6 +623,8 @@ uint32 ArenaTeam::GetPoints(uint32 memberRating)
         points *= 0.76f;
     else if (Type == ARENA_TEAM_3v3)
         points *= 0.88f;
+    else if (Type == ARENA_TEAM_5v5) // 1v1 Arena
+        points *= sWorld->getFloatConfig(CONFIG_ARENA_1V1_ARENAPOINTS_MULTI);
 
     points *= sWorld->getRate(RATE_ARENA_POINTS);
 
diff --git a/src/server/game/Battlegrounds/ArenaTeam.h b/src/server/game/Battlegrounds/ArenaTeam.h
index bf3dab2..5d6d007 100644
--- a/src/server/game/Battlegrounds/ArenaTeam.h
+++ b/src/server/game/Battlegrounds/ArenaTeam.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -70,7 +70,7 @@ enum ArenaTeamTypes
 {
     ARENA_TEAM_2v2      = 2,
     ARENA_TEAM_3v3      = 3,
-    ARENA_TEAM_5v5      = 5
+    ARENA_TEAM_5v5      = 1
 };
 
 struct ArenaTeamMember
diff --git a/src/server/game/Battlegrounds/Battleground.cpp b/src/server/game/Battlegrounds/Battleground.cpp
index b9a95b9..915868b 100644
--- a/src/server/game/Battlegrounds/Battleground.cpp
+++ b/src/server/game/Battlegrounds/Battleground.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -33,6 +33,14 @@
 #include "Transport.h"
 #include "ScriptMgr.h"
 #include "GameGraveyard.h"
+#pragma execution_character_set("utf-8")
+#include "../Custom/CustomEvent/FixedTimeBG/FixedTimeBG.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
+#include "../Custom/DataLoader/DataLoader.h"
+#include "../Custom/Talisman/Talisman.h"
+#include "../Custom/Reward/Reward.h"
+#include "../Custom/Switch/Switch.h"
+
 #ifdef ELUNA
 #include "LuaEngine.h"
 #endif
@@ -111,6 +119,10 @@ void Battleground::BroadcastWorker(Do& _do)
 
 Battleground::Battleground()
 {
+    RandomBuffInterval = 0;
+    m_AllyKills = 0;
+    m_HordeKills = 0;
+
     m_RealTypeID        = BATTLEGROUND_TYPE_NONE;
     m_RandomTypeID      = BATTLEGROUND_TYPE_NONE;
     m_InstanceID        = 0;
@@ -265,6 +277,9 @@ void Battleground::Update(uint32 diff)
             }
             else
             {
+                //éæºBUFF
+                sFTB->AddRandomBuff(this, diff);
+
                 _ProcessResurrect(diff);
                 if (sBattlegroundMgr->GetPrematureFinishTime() && (GetPlayersCountByTeam(TEAM_ALLIANCE) < GetMinPlayersPerTeam() || GetPlayersCountByTeam(TEAM_HORDE) < GetMinPlayersPerTeam()))
                     _ProcessProgress(diff);
@@ -458,6 +473,11 @@ inline void Battleground::_ProcessJoin(uint32 diff)
         // First start warning - 2 or 1 minute
         SendMessageToAll(StartMessageIds[BG_STARTING_EVENT_FIRST], CHAT_MSG_BG_SYSTEM_NEUTRAL);
     }
+
+    // 1v1 Arena - Start arena after 15s, when all players are in arena
+    if (GetArenaType() == ARENA_TYPE_5v5 && GetStartDelayTime() > StartDelayTimes[BG_STARTING_EVENT_THIRD] && (m_PlayersCount[0] + m_PlayersCount[1]) == 2)
+        SetStartDelayTime(StartDelayTimes[BG_STARTING_EVENT_THIRD]);
+
     // After 1 minute or 30 seconds, warning is signaled
     else if (GetStartDelayTime() <= StartDelayTimes[BG_STARTING_EVENT_SECOND] && !(m_Events & BG_STARTING_EVENT_2))
     {
@@ -994,16 +1014,48 @@ void Battleground::EndBattleground(TeamId winnerTeamId)
                 if (player->getLevel() >= BG_AWARD_ARENA_POINTS_MIN_LEVEL)
                     player->ModifyArenaPoints(winner_arena);
 
+                if (player->GetRandomWinner())
+                    sRew->Rew(player, sSwitch->GetValueByIndex(sT_BG_REW, 1));
+                else
+                    sRew->Rew(player, sSwitch->GetValueByIndex(sT_BG_REW, 2));
+
+                if (BattlegroundMgr::IsBGWeekend(GetBgTypeID()))
+                    sRew->Rew(player, sSwitch->GetValueByIndex(sT_BG_REW, 3));
+
                 if (!player->GetRandomWinner())
                     player->SetRandomWinner(true);
             }
 
             player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_WIN_BG, player->GetMapId());
+
+            //å®æ¶èå©æåºå¥å±
+            if (FixedTimeBGMap.find(GetBgTypeID()) != FixedTimeBGMap.end())
+            {
+                BattlegroundScoreMap::const_iterator score_itr = PlayerScores.find(player->GetGUID());
+                if (score_itr != PlayerScores.end())                         // player not found...
+                    if (score_itr->second->DamageDone >= sFTB->GetRewDmg(GetBgTypeID())
+                        || score_itr->second->HealingDone >= sFTB->GetRewHeal(GetBgTypeID())
+                        || score_itr->second->KillingBlows >= sFTB->GetRewKills(GetBgTypeID())
+                        || score_itr->second->Deaths >= sFTB->GetRewKilleds(GetBgTypeID()))
+                        sFTB->RewardPlayer(player, GetBgTypeID(), true);
+            }
         }
         else
         {
             if (IsRandom() || BattlegroundMgr::IsBGWeekend(GetBgTypeID(true)))
                 UpdatePlayerScore(player, SCORE_BONUS_HONOR, GetBonusHonorFromKill(loser_kills));
+
+            //å®æ¶å¤±è´¥æåºå¥å±
+            if (FixedTimeBGMap.find(GetBgTypeID()) != FixedTimeBGMap.end())
+            {
+                BattlegroundScoreMap::const_iterator score_itr = PlayerScores.find(player->GetGUID());
+                if (score_itr != PlayerScores.end())                         // player not found...
+                    if (score_itr->second->DamageDone >= sFTB->GetRewDmg(GetBgTypeID())
+                        || score_itr->second->HealingDone >= sFTB->GetRewHeal(GetBgTypeID())
+                        || score_itr->second->KillingBlows >= sFTB->GetRewKills(GetBgTypeID())
+                        || score_itr->second->Deaths >= sFTB->GetRewKilleds(GetBgTypeID()))
+                        sFTB->RewardPlayer(player, GetBgTypeID(), false);
+            }
         }
 
         player->ResetAllPowers();
@@ -1310,6 +1362,13 @@ void Battleground::AddOrSetPlayerToCorrectBgGroup(Player* player, TeamId teamId)
 
 uint32 Battleground::GetFreeSlotsForTeam(TeamId teamId) const
 {
+    /*cfbg*/
+    if (sFTB->GetCFFlag(GetBgTypeID()))
+    {
+        uint32 num = GetMaxPlayersPerTeam() * 2 - GetInvitedCount(TEAM_ALLIANCE) - GetInvitedCount(TEAM_HORDE);
+        return num > 0 ? num : 0;
+    }
+
     if (!(GetStatus() == STATUS_IN_PROGRESS || GetStatus() == STATUS_WAIT_JOIN))
         return 0;
 
@@ -1872,6 +1931,41 @@ void Battleground::HandleKillPlayer(Player* victim, Player* killer)
         victim->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
         RewardXPAtKill(killer, victim);
     }
+
+    //å¤æ­å»æäººæ° æç¤ºæç»ææåº
+    if (sFTB->GetEndKilss(GetBgTypeID()) == 0)
+        return;
+
+    uint32 allyKills = GetAllyKills() + 1;
+    uint32 hordeKills = GetHordeKills() + 1;
+    uint32 maxKills = 0;
+
+    if (killer->GetBgTeamId() == TEAM_ALLIANCE)
+        SetAllyKills(allyKills);
+    else
+        SetHordeKills(hordeKills);
+
+    Battleground::BattlegroundPlayerMap const& pl = GetPlayers();
+    for (Battleground::BattlegroundPlayerMap::const_iterator itr = pl.begin(); itr != pl.end(); ++itr)
+    {
+        BattlegroundScoreMap::const_iterator score_itr = PlayerScores.find(itr->second->GetGUID());
+        if (score_itr == PlayerScores.end())                         // player not found...
+            return;
+
+        std::ostringstream oss;
+        if (killer->GetBgTeamId() == TEAM_ALLIANCE)
+            oss << "|cFF0177ECèç|rå»æäººæ°ï¼" << allyKills << "/" << sFTB->GetEndKilss(GetBgTypeID());
+        else
+            oss << "|cFFFF1717é¨è½|rå»æäººæ°ï¼" << hordeKills << "/" << sFTB->GetEndKilss(GetBgTypeID());
+        itr->second->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+    }
+
+    maxKills = (allyKills > hordeKills) ? allyKills : hordeKills;
+
+    if (maxKills >= sFTB->GetEndKilss(GetBgTypeID()))
+    {
+        allyKills > hordeKills ? EndBattleground(TEAM_ALLIANCE) : EndBattleground(TEAM_HORDE);
+    }
 }
 
 TeamId Battleground::GetOtherTeamId(TeamId teamId)
diff --git a/src/server/game/Battlegrounds/Battleground.h b/src/server/game/Battlegrounds/Battleground.h
index 7a2fd35..d4f6efe 100644
--- a/src/server/game/Battlegrounds/Battleground.h
+++ b/src/server/game/Battlegrounds/Battleground.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -341,6 +341,7 @@ class Battleground
         virtual bool AllNodesConrolledByTeam(TeamId /*teamId*/) const { return false; }
         void StartTimedAchievement(AchievementCriteriaTimedTypes type, uint32 entry);
 
+        int32 RandomBuffInterval;
         /* Battleground */
         // Get methods:
         char const* GetName() const         { return m_Name; }
@@ -365,7 +366,12 @@ class Battleground
         uint32 GetBonusHonorFromKill(uint32 kills) const;
 
         bool IsRandom()                     { return m_IsRandom; }
+        //å»æäººæ°
+        uint32 GetAllyKills() { return m_AllyKills; }
+        uint32 GetHordeKills() { return m_HordeKills; }
 
+        void SetAllyKills(uint32 kills) { m_AllyKills = kills; }
+        void SetHordeKills(uint32 kills) { m_HordeKills = kills; }
         // Set methods:
         void SetName(char const* Name)      { m_Name = Name; }
         void SetBgTypeID(BattlegroundTypeId TypeID) { m_RealTypeID = TypeID; }
@@ -655,6 +661,8 @@ class Battleground
         // pussywizard:
         uint32 m_UpdateTimer;
     private:
+        uint32 m_AllyKills;
+        uint32 m_HordeKills;
         // Battleground
         BattlegroundTypeId m_RealTypeID;
         BattlegroundTypeId m_RandomTypeID;                  // TypeID created from Random Battleground list
diff --git a/src/server/game/Battlegrounds/BattlegroundMgr.cpp b/src/server/game/Battlegrounds/BattlegroundMgr.cpp
index 6dbf016..2d26aaa 100644
--- a/src/server/game/Battlegrounds/BattlegroundMgr.cpp
+++ b/src/server/game/Battlegrounds/BattlegroundMgr.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -37,7 +37,7 @@
 #include "GameGraveyard.h"
 #include <unordered_map>
 #include <random>
-
+#include "../Custom/Switch/Switch.h"
 #ifdef ELUNA
 #include "LuaEngine.h"
 #endif
@@ -47,7 +47,7 @@
 /*********************************************************/
 
 BattlegroundMgr::BattlegroundMgr() : m_ArenaTesting(false), m_Testing(false),
-    m_lastClientVisibleInstanceId(0), m_NextAutoDistributionTime(0), m_AutoDistributionTimeChecker(0), m_NextPeriodicQueueUpdateTime(5*IN_MILLISECONDS)
+    m_lastClientVisibleInstanceId(0), m_NextAutoDistributionTime(0), m_AutoDistributionTimeChecker(0), m_NextPeriodicQueueUpdateTime(5*IN_MILLISECONDS), m_QuequeAnnounceEnable(false), m_NextQuequeAnnounceTime(0)
 {
     for (uint32 qtype = BATTLEGROUND_QUEUE_NONE; qtype < MAX_BATTLEGROUND_QUEUE_TYPES; ++qtype)
         m_BattlegroundQueues[qtype].SetBgTypeIdAndArenaType(BGTemplateId(BattlegroundQueueTypeId(qtype)), BGArenaType(BattlegroundQueueTypeId(qtype)));
@@ -96,6 +96,20 @@ void BattlegroundMgr::Update(uint32 diff)
     for (int qtype = BATTLEGROUND_QUEUE_NONE; qtype < MAX_BATTLEGROUND_QUEUE_TYPES; ++qtype)
         m_BattlegroundQueues[qtype].UpdateEvents(diff);
 
+    // æåºæç¤ºå¹¿æ­
+    if (m_QuequeAnnounceEnable)
+    {
+        if (m_NextQuequeAnnounceTime < diff)
+        {
+            for (int qtype = BATTLEGROUND_QUEUE_NONE; qtype < MAX_BATTLEGROUND_QUEUE_TYPES; ++qtype)
+                m_BattlegroundQueues[qtype].UpdateAnnounce(diff);
+
+            m_NextQuequeAnnounceTime = sSwitch->GetValue(ST_BG_QUEQUE_INTERVALS) * IN_MILLISECONDS;
+        }
+        else
+            m_NextQuequeAnnounceTime -= diff;
+    }
+
     // update using scheduled tasks (used only for rated arenas, initial opponent search works differently than periodic queue update)
     if (!m_ArenaQueueUpdateScheduler.empty())
     {
@@ -492,7 +506,50 @@ bool BattlegroundMgr::CreateBattleground(CreateBattlegroundData& data)
 {
     // Create the BG
     Battleground* bg = nullptr;
-    bg = BattlegroundMgr::bgtypeToBattleground[data.bgTypeId];
+    switch (data.bgTypeId)
+    {
+    case BATTLEGROUND_AV:
+        bg = new BattlegroundAV;
+        break;
+    case BATTLEGROUND_WS:
+        bg = new BattlegroundWS;
+        break;
+    case BATTLEGROUND_AB:
+        bg = new BattlegroundAB;
+        break;
+    case BATTLEGROUND_NA:
+        bg = new BattlegroundNA;
+        break;
+    case BATTLEGROUND_BE:
+        bg = new BattlegroundBE;
+        break;
+    case BATTLEGROUND_EY:
+        bg = new BattlegroundEY;
+        break;
+    case BATTLEGROUND_RL:
+        bg = new BattlegroundRL;
+        break;
+    case BATTLEGROUND_SA:
+        bg = new BattlegroundSA;
+        break;
+    case BATTLEGROUND_DS:
+        bg = new BattlegroundDS;
+        break;
+    case BATTLEGROUND_RV:
+        bg = new BattlegroundRV;
+        break;
+    case BATTLEGROUND_IC:
+        bg = new BattlegroundIC;
+        break;
+    case BATTLEGROUND_AA:
+        bg = new Battleground;
+        break;
+    case BATTLEGROUND_RB:
+        bg = new Battleground;
+        break;
+    default:
+        return false;
+    }
 
     if (bg == nullptr)
         return false;
@@ -1081,7 +1138,7 @@ std::unordered_map<int, BattlegroundTypeId> BattlegroundMgr::queueToBg = {
     { BATTLEGROUND_QUEUE_3v3,   BATTLEGROUND_AA },
     { BATTLEGROUND_QUEUE_5v5,   BATTLEGROUND_AA },
 };
-
+/*
 std::unordered_map<int, Battleground*> BattlegroundMgr::bgtypeToBattleground = {
     { BATTLEGROUND_AV, new BattlegroundAV },
     { BATTLEGROUND_WS, new BattlegroundWS },
@@ -1097,6 +1154,7 @@ std::unordered_map<int, Battleground*> BattlegroundMgr::bgtypeToBattleground = {
     { BATTLEGROUND_AA, new Battleground },
     { BATTLEGROUND_RB, new Battleground },
 };
+*/
 
 std::unordered_map<int, bgRef> BattlegroundMgr::bgTypeToTemplate = {
     { BATTLEGROUND_AV, [](Battleground *bg_t) -> Battleground*{ return new BattlegroundAV(*(BattlegroundAV*)bg_t); } },
diff --git a/src/server/game/Battlegrounds/BattlegroundMgr.h b/src/server/game/Battlegrounds/BattlegroundMgr.h
index b5151e4..9ce2787 100644
--- a/src/server/game/Battlegrounds/BattlegroundMgr.h
+++ b/src/server/game/Battlegrounds/BattlegroundMgr.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -128,6 +128,12 @@ class BattlegroundMgr
         static std::unordered_map<int, bgMapRef> getBgFromMap;                  // BattlegroundMapID -> bgMapRef
         static std::unordered_map<int, bgTypeRef> getBgFromTypeID;              // BattlegroundTypeID -> bgTypeRef
 
+        void SetAnnounceData(uint32 intervals, bool enable)
+        {
+            m_NextQuequeAnnounceTime = intervals;
+            m_QuequeAnnounceEnable = enable;
+        }
+
     private:
         bool CreateBattleground(CreateBattlegroundData& data);
         uint32 GetNextClientVisibleInstanceId();
@@ -148,6 +154,9 @@ class BattlegroundMgr
         uint32 m_NextPeriodicQueueUpdateTime;
         BattleMastersMap mBattleMastersMap;
 
+        uint32 m_NextQuequeAnnounceTime;
+        bool m_QuequeAnnounceEnable;
+
         CreateBattlegroundData const* GetBattlegroundTemplateByTypeId(BattlegroundTypeId id)
         {
             BattlegroundTemplateMap::const_iterator itr = _battlegroundTemplates.find(id);
diff --git a/src/server/game/Battlegrounds/BattlegroundQueue.cpp b/src/server/game/Battlegrounds/BattlegroundQueue.cpp
index 79da4c9..a72991a 100644
--- a/src/server/game/Battlegrounds/BattlegroundQueue.cpp
+++ b/src/server/game/Battlegrounds/BattlegroundQueue.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -17,6 +17,8 @@
 #include "Channel.h"
 #include "ScriptMgr.h"
 #include <unordered_map>
+#pragma execution_character_set("utf-8")
+#include "../Custom/CustomEvent/FixedTimeBG/FixedTimeBG.h"
 
 std::unordered_map<uint64, uint32> BGSpamProtection;
 
@@ -389,6 +391,9 @@ void BattlegroundQueue::FillPlayersToBG(Battleground* bg, const int32 aliFree, c
     auto Horde_itr = m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_HORDE].begin();
     for (; Horde_itr != m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_HORDE].end() && m_SelectionPools[TEAM_HORDE].AddGroup((*Horde_itr), hordeFree); ++Horde_itr);
 
+    //cfbg
+    if (sFTB->GetCFFlag(m_bgTypeId)) return;
+
     // calculate free space after adding
     int32 aliDiff = aliFree - int32(m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount());
     int32 hordeDiff = hordeFree - int32(m_SelectionPools[TEAM_HORDE].GetPlayerCount());
@@ -472,6 +477,10 @@ void BattlegroundQueue::FillPlayersToBGWithSpecific(Battleground* bg, const int3
     auto Horde_itr = m_QueuedBoth[TEAM_HORDE].begin();
     for (; Horde_itr != m_QueuedBoth[TEAM_HORDE].end() && m_SelectionPools[TEAM_HORDE].AddGroup((*Horde_itr), hordeFree); ++Horde_itr);
 
+    //cfbg
+    if (sFTB->GetCFFlag(m_bgTypeId))
+        return;
+
     // calculate free space after adding
     int32 aliDiff = aliFree - int32(m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount());
     int32 hordeDiff = hordeFree - int32(m_SelectionPools[TEAM_HORDE].GetPlayerCount());
@@ -594,6 +603,11 @@ bool BattlegroundQueue::CheckNormalMatch(Battleground * bgTemplate, Battleground
     if (sBattlegroundMgr->isTesting() && bgTemplate->isBattleground() && (m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount() || m_SelectionPools[TEAM_HORDE].GetPlayerCount()))
         return true;
 
+    /*cfbg*/
+
+    if (sFTB->GetCFFlag(m_bgTypeId))
+        return m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount() + m_SelectionPools[TEAM_HORDE].GetPlayerCount() >= minPlayers * 2;
+
     switch (sWorld->getIntConfig(CONFIG_BATTLEGROUND_INVITATION_TYPE))
     {
     case BG_QUEUE_INVITATION_TYPE_NO_BALANCE: // in this case, as soon as both teams have > mincount, start
@@ -665,6 +679,88 @@ void BattlegroundQueue::UpdateEvents(uint32 diff)
     m_events.Update(diff);
 }
 
+void BattlegroundQueue::UpdateAnnounce(uint32 diff)
+{
+    Battleground* bg_template = sBattlegroundMgr->GetBattlegroundTemplate(m_bgTypeId);
+    if (!bg_template)
+        return;
+
+    //æåºå¼å§ä¸åå¬å
+    const BattlegroundContainer& bgList = sBattlegroundMgr->GetBattlegroundList();
+    for (BattlegroundContainer::const_iterator ii = bgList.begin(); ii != bgList.end(); ++ii)
+    {
+        Battleground* bg = ii->second;
+        if (!bg)
+            continue;
+
+        if (bg->GetBgTypeID() == m_bgTypeId)
+            return;
+    }
+
+    if (m_QueuedPlayers.size() > 0)
+    {
+        auto itr = FixedTimeBGMap.find(m_bgTypeId);
+        if (itr != FixedTimeBGMap.end())
+        {
+            uint32 qHorde = 0;
+            uint32 qAlliance = 0;
+
+            for (auto i = m_QueuedPlayers.begin(); i != m_QueuedPlayers.end(); i++)
+            {
+                if (i->second->BgTypeId != m_bgTypeId)
+                    continue;
+
+                Player* pl = sObjectAccessor->FindPlayer(i->first);
+
+                if (!pl)
+                    continue;
+
+                if (pl->getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+                    continue;
+
+                if (i->second->teamId == TEAM_ALLIANCE)
+                    qAlliance++;
+                else
+                    qHorde++;
+            }
+
+            uint32 size = qHorde + qAlliance;
+
+            if (size == 0)
+                return;
+
+            if (itr->second.crossFaction)
+            {
+                qHorde = size / 2;
+                qAlliance = size - qHorde;
+            }
+
+            uint32 MinPlayersPerTeam = bg_template->GetMinPlayersPerTeam();
+            uint32 MaxPlayersPerTeam = bg_template->GetMaxPlayersPerTeam();
+
+            std::ostringstream oss;
+            oss << "|cffff0000[æåºéåå¬å]|r" << itr->second.bgName;
+            oss << "===èç" << qAlliance << "/" << MinPlayersPerTeam << "======";
+            oss << "===é¨è½" << qHorde << "/" << MinPlayersPerTeam << "===";
+
+            WorldPacket data(SMSG_SERVER_MESSAGE, 50);
+            data << uint32(SERVER_MSG_STRING);
+            data << oss.str().c_str();
+
+            SessionMap::const_iterator itr;
+            for (itr = sWorld->GetAllSessions().begin(); itr != sWorld->GetAllSessions().end(); ++itr)
+            {
+                if (itr->second &&
+                    itr->second->GetPlayer() &&
+                    itr->second->GetPlayer()->IsInWorld() && !itr->second->GetPlayer()->InBattleground())
+                {
+                    itr->second->SendPacket(&data);
+                }
+            }
+        }
+    }
+}
+
 struct BgEmptinessComp { bool operator()(Battleground* const& bg1, Battleground* const& bg2) const { return ((float)bg1->GetMaxFreeSlots() / (float)bg1->GetMaxPlayersPerTeam()) > ((float)bg2->GetMaxFreeSlots() / (float)bg2->GetMaxPlayersPerTeam()); } };
 typedef std::set<Battleground*, BgEmptinessComp> BattlegroundNeedSet;
 
diff --git a/src/server/game/Battlegrounds/BattlegroundQueue.h b/src/server/game/Battlegrounds/BattlegroundQueue.h
index 078dcd1..9ac0dc7 100644
--- a/src/server/game/Battlegrounds/BattlegroundQueue.h
+++ b/src/server/game/Battlegrounds/BattlegroundQueue.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -57,6 +57,7 @@ class BattlegroundQueue
 
         void BattlegroundQueueUpdate(BattlegroundBracketId bracket_id, bool isRated, uint32 arenaRatedTeamId);
         void UpdateEvents(uint32 diff);
+        void UpdateAnnounce(uint32 diff);
 
         void FillPlayersToBG(Battleground* bg, int32 aliFree, int32 hordeFree, BattlegroundBracketId bracket_id);
         void FillPlayersToBGWithSpecific(Battleground* bg, int32 aliFree, int32 hordeFree, BattlegroundBracketId thisBracketId, BattlegroundQueue* specificQueue, BattlegroundBracketId specificBracketId);
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
index dbd7800..fccd553 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Originally written by Xinef - Copyright (C) 2016+ AzerothCore <www.azerothcore.org>, released under GNU AGPL v3 license: http://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-AGPL3
 */
 
@@ -14,9 +14,31 @@
 #include "Util.h"
 #include "WorldSession.h"
 #include "GameGraveyard.h"
+#include "../Custom/DataLoader/DataLoader.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
+#include "../Custom/CustomEvent/FixedTimeBG/FixedTimeBG.h"
+
+uint32 BG_AB_MAX_KILLS;
+uint32 BG_AB_WARNING_NEAR_VICTORY_SCORE;
+uint32 BG_AB_MAX_TEAM_SCORE;
+
+void BattlegroundAB::HandleKillPlayer(Player* player, Player* killer)
+{
+    if (GetStatus() != STATUS_IN_PROGRESS)
+        return;
+    Battleground::HandleKillPlayer(player, killer);
+
+    UpdateWorldState(BG_AB_FLAG_ALLY_KILLS, GetAllyKills());
+    UpdateWorldState(BG_AB_FLAG_HORDE_KILLS, GetHordeKills());
+}
+
 
 BattlegroundAB::BattlegroundAB()
 {
+    BG_AB_MAX_KILLS = sFTB->GetEndKilss(BATTLEGROUND_AB);;
+    BG_AB_MAX_TEAM_SCORE = sFTB->GetMaxRes(BATTLEGROUND_AB);
+    BG_AB_WARNING_NEAR_VICTORY_SCORE = BG_AB_MAX_TEAM_SCORE - 200;
+
     m_BuffChange = true;
     BgObjects.resize(BG_AB_OBJECT_MAX);
     BgCreatures.resize(BG_AB_ALL_NODES_COUNT + BG_AB_DYNAMIC_NODES_COUNT); // xinef: +BG_AB_DYNAMIC_NODES_COUNT buff triggers
@@ -209,6 +231,10 @@ void BattlegroundAB::DeleteBanner(uint8 node)
 
 void BattlegroundAB::FillInitialWorldStates(WorldPacket& data)
 {
+    data << uint32(BG_AB_FLAG_ALLY_KILLS) << uint32(GetAllyKills());
+    data << uint32(BG_AB_FLAG_HORDE_KILLS) << uint32(GetHordeKills());
+    data << uint32(BG_AB_FLAG_MAX_KILLS) << uint32(BG_AB_MAX_KILLS);
+
     for (auto & node : _capturePointInfo)
     {
         if (node._state == BG_AB_NODE_STATE_NEUTRAL)
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundAB.h b/src/server/game/Battlegrounds/Zones/BattlegroundAB.h
index 6d26031..c279c17 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundAB.h
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundAB.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Originally written by Xinef - Copyright (C) 2016+ AzerothCore <www.azerothcore.org>, released under GNU AGPL v3 license: http://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-AGPL3
 */
 
@@ -25,8 +25,16 @@ enum BG_AB_Events
     BG_AB_EVENT_HORDE_TICK                  = 12
 };
 
+extern uint32 BG_AB_MAX_KILLS;
+extern uint32 BG_AB_WARNING_NEAR_VICTORY_SCORE;
+extern uint32 BG_AB_MAX_TEAM_SCORE;
+
 enum BG_AB_WorldStates
 {
+    BG_AB_FLAG_ALLY_KILLS = 1900,
+    BG_AB_FLAG_HORDE_KILLS = 1901,
+    BG_AB_FLAG_MAX_KILLS = 1902,
+
     BG_AB_OP_OCCUPIED_BASES_HORDE       = 1778,
     BG_AB_OP_OCCUPIED_BASES_ALLY        = 1779,
     BG_AB_OP_RESOURCES_ALLY             = 1776,
@@ -164,9 +172,6 @@ enum BG_AB_Misc
     BG_AB_REP_TICK_NORMAL               = 160,
     BG_AB_REP_TICK_WEEKEND              = 120,
 
-    BG_AB_WARNING_NEAR_VICTORY_SCORE    = 1400,
-    BG_AB_MAX_TEAM_SCORE                = 1600,
-
     BG_AB_FLAG_CAPTURING_TIME           = 60000,
     BG_AB_BANNER_UPDATE_TIME            = 2000
 };
@@ -227,6 +232,8 @@ class BattlegroundAB : public Battleground
         BattlegroundAB();
         ~BattlegroundAB() override;
 
+        void HandleKillPlayer(Player* player, Player* killer);
+
         void AddPlayer(Player* player) override;
         void StartingEventCloseDoors() override;
         void StartingEventOpenDoors() override;
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundIC.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundIC.cpp
index 0bebc42..f55528d 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundIC.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundIC.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -16,9 +16,17 @@
 #include "WorldSession.h"
 #include "ScriptedCreature.h"
 #include "GameGraveyard.h"
+#include "../Custom/DataLoader/DataLoader.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
+#include "../Custom/CustomEvent/FixedTimeBG/FixedTimeBG.h"
+
+
+uint32 MAX_REINFORCEMENTS;
 
 BattlegroundIC::BattlegroundIC()
 {
+    MAX_REINFORCEMENTS = sFTB->GetMaxRes(BATTLEGROUND_IC);
+
     BgObjects.resize(MAX_NORMAL_GAMEOBJECTS_SPAWNS + MAX_AIRSHIPS_SPAWNS + MAX_HANGAR_TELEPORTERS_SPAWNS + MAX_FORTRESS_TELEPORTERS_SPAWNS + MAX_HANGAR_TELEPORTER_EFFECTS_SPAWNS + MAX_FORTRESS_TELEPORTER_EFFECTS_SPAWNS);
     BgCreatures.resize(MAX_NORMAL_NPCS_SPAWNS + MAX_WORKSHOP_SPAWNS + MAX_DOCKS_SPAWNS + MAX_SPIRIT_GUIDES_SPAWNS + MAX_HANGAR_NPCS_SPAWNS);
 
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundIC.h b/src/server/game/Battlegrounds/Zones/BattlegroundIC.h
index c54eca5..e8438a3 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundIC.h
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundIC.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -176,7 +176,6 @@ enum gameobjectsIC
     GO_ALLIANCE_GUNSHIP                         = 195121
 };
 
-#define MAX_REINFORCEMENTS 300
 
 enum Times
 {
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp
index 3408b51..20e390f 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Originally written by Xinef - Copyright (C) 2016+ AzerothCore <www.azerothcore.org>, released under GNU AGPL v3 license: http://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-AGPL3
 */
 
@@ -13,9 +13,18 @@
 #include "World.h"
 #include "WorldPacket.h"
 #include "GameGraveyard.h"
+#include "../Custom/DataLoader/DataLoader.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
+#include "../Custom/CustomEvent/FixedTimeBG/FixedTimeBG.h"
+
+uint32 BG_WS_MAX_TEAM_SCORE;
+uint32 BG_WS_MAX_KILLS;
 
 BattlegroundWS::BattlegroundWS()
 {
+    BG_WS_MAX_KILLS = sFTB->GetEndKilss(BATTLEGROUND_WS);
+    BG_WS_MAX_TEAM_SCORE = sFTB->GetMaxRes(BATTLEGROUND_WS);
+
     BgObjects.resize(BG_WS_OBJECT_MAX);
     BgCreatures.resize(BG_CREATURES_MAX_WS);
 
@@ -476,6 +485,8 @@ void BattlegroundWS::HandleKillPlayer(Player* player, Player* killer)
 
     EventPlayerDroppedFlag(player);
     Battleground::HandleKillPlayer(player, killer);
+    UpdateWorldState(BG_WS_FLAG_ALLIANCE_KILLS, GetAllyKills());
+    UpdateWorldState(BG_WS_FLAG_HORDE_KILLS, GetHordeKills());
 }
 
 void BattlegroundWS::UpdatePlayerScore(Player* player, uint32 type, uint32 value, bool doAddHonor)
@@ -510,6 +521,10 @@ GraveyardStruct const* BattlegroundWS::GetClosestGraveyard(Player* player)
 
 void BattlegroundWS::FillInitialWorldStates(WorldPacket& data)
 {
+    data << uint32(BG_WS_FLAG_ALLIANCE_KILLS) << uint32(GetAllyKills());
+    data << uint32(BG_WS_FLAG_HORDE_KILLS) << uint32(GetHordeKills());
+    data << uint32(BG_WS_FLAG_MAX_KILLS) << uint32(BG_WS_MAX_KILLS);
+
     data << uint32(BG_WS_FLAG_CAPTURES_ALLIANCE) << uint32(GetTeamScore(TEAM_ALLIANCE));
     data << uint32(BG_WS_FLAG_CAPTURES_HORDE) << uint32(GetTeamScore(TEAM_HORDE));
     data << uint32(BG_WS_FLAG_CAPTURES_MAX) << uint32(BG_WS_MAX_TEAM_SCORE);
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundWS.h b/src/server/game/Battlegrounds/Zones/BattlegroundWS.h
index ee56416..5a9ccf9 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundWS.h
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundWS.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Originally written by Xinef - Copyright (C) 2016+ AzerothCore <www.azerothcore.org>, released under GNU AGPL v3 license: http://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-AGPL3
 */
 
@@ -17,11 +17,11 @@ enum BG_WS_Events
     BG_WS_EVENT_BOTH_FLAGS_KEPT10   = 6,
     BG_WS_EVENT_BOTH_FLAGS_KEPT15   = 7
 };
+extern uint32 BG_WS_MAX_TEAM_SCORE;
+extern uint32 BG_WS_MAX_KILLS;
 
 enum BG_WS_TimerOrScore
 {
-    BG_WS_MAX_TEAM_SCORE            = 3,
-
     BG_WS_TOTAL_GAME_TIME           = 27*MINUTE*IN_MILLISECONDS,
     BG_WS_FLAG_RESPAWN_TIME         = 23*IN_MILLISECONDS,
     BG_WS_FLAG_DROP_TIME            = 10*IN_MILLISECONDS,
@@ -54,6 +54,10 @@ enum BG_WS_SpellId
 
 enum BG_WS_WorldStates
 {
+    BG_WS_FLAG_ALLIANCE_KILLS = 1583,
+    BG_WS_FLAG_HORDE_KILLS = 1584,
+    BG_WS_FLAG_MAX_KILLS = 1602,
+
     BG_WS_FLAG_CAPTURES_ALLIANCE  = 1581,
     BG_WS_FLAG_CAPTURES_HORDE     = 1582,
     BG_WS_FLAG_CAPTURES_MAX       = 1601,
diff --git a/src/server/game/Chat/Chat.cpp b/src/server/game/Chat/Chat.cpp
index 165fbf9..0c79ba1 100644
--- a/src/server/game/Chat/Chat.cpp
+++ b/src/server/game/Chat/Chat.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -23,7 +23,8 @@
 #include "SpellMgr.h"
 #include "ScriptMgr.h"
 #include "ChatLink.h"
-
+#pragma execution_character_set("utf-8")
+#include "../Custom/AntiCheat/AntiCheat.h"
 #ifdef ELUNA
 #include "LuaEngine.h"
 #endif
@@ -327,6 +328,35 @@ bool ChatHandler::ExecuteCommandInTable(std::vector<ChatCommand> const& table, c
                         areaId, areaName.c_str(), zoneName.c_str(),
                         (player->GetSelectedUnit()) ? player->GetSelectedUnit()->GetName().c_str() : "",
                         GUID_LOPART(guid));
+
+                    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CMD);
+                    stmt->setString(0, sAntiCheat->GetTimeString());
+                    stmt->setString(1, player->GetName());
+                    stmt->setUInt32(2, m_session->GetAccountId());
+
+                    if (Unit* unit = player->GetSelectedUnit())
+                        stmt->setString(3, unit->GetName());
+                    else
+                        stmt->setString(3, "");
+
+                    if (Unit* unit = player->GetSelectedUnit())
+                    {
+                        if (Player* tar = unit->ToPlayer())
+                            stmt->setUInt32(4, tar->GetSession()->GetAccountId());
+                        else
+                            stmt->setUInt32(4, unit->GetEntry());
+                    }
+                    else
+                        stmt->setUInt32(4, 0);
+
+                    stmt->setString(5, fullcmd);
+                    stmt->setUInt32(6, player->GetMapId());
+                    stmt->setFloat(7, player->GetPositionX());
+                    stmt->setFloat(8, player->GetPositionY());
+                    stmt->setFloat(9, player->GetPositionZ());
+                    trans->Append(stmt);
+                    CharacterDatabase.CommitTransaction(trans);
                 }
             }
         }
@@ -696,6 +726,7 @@ size_t ChatHandler::BuildChatPacket(WorldPacket& data, ChatMsg chatType, Languag
         {
             chatTag = playerSender->GetChatTag();
             gmMessage = playerSender->IsGameMaster();
+            senderName = playerSender->namePrefix + senderName + playerSender->nameSuffix;
         }
     }
 
diff --git a/src/server/game/DataStores/DBCStores.cpp b/src/server/game/DataStores/DBCStores.cpp
index 8778ac1..e3f077a 100644
--- a/src/server/game/DataStores/DBCStores.cpp
+++ b/src/server/game/DataStores/DBCStores.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2020 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -26,6 +26,9 @@ DBCStorage <AreaTableEntry> sAreaTableStore(AreaTableEntryfmt);
 DBCStorage <AreaGroupEntry> sAreaGroupStore(AreaGroupEntryfmt);
 DBCStorage <AreaPOIEntry> sAreaPOIStore(AreaPOIEntryfmt);
 
+static AreaFlagByAreaID sAreaFlagByAreaID;
+static AreaFlagByMapID sAreaFlagByMapID;
+
 static WMOAreaInfoByTripple sWMOAreaInfoByTripple;
 
 DBCStorage <AchievementEntry> sAchievementStore(Achievementfmt);
@@ -81,7 +84,7 @@ DBCStorage <GtRegenHPPerSptEntry>         sGtRegenHPPerSptStore(GtRegenHPPerSptf
 DBCStorage <GtRegenMPPerSptEntry>         sGtRegenMPPerSptStore(GtRegenMPPerSptfmt);
 
 DBCStorage <HolidaysEntry>                sHolidaysStore(Holidaysfmt);
-
+DBCStorage <ItemEntry>                    sItemStore(Itemfmt);
 DBCStorage <ItemBagFamilyEntry>           sItemBagFamilyStore(ItemBagFamilyfmt);
 //DBCStorage <ItemCondExtCostsEntry> sItemCondExtCostsStore(ItemCondExtCostsEntryfmt);
 DBCStorage <ItemDisplayInfoEntry> sItemDisplayInfoStore(ItemDisplayTemplateEntryfmt);
@@ -125,6 +128,10 @@ DBCStorage <SoundEntriesEntry> sSoundEntriesStore(SoundEntriesfmt);
 DBCStorage <SpellItemEnchantmentEntry> sSpellItemEnchantmentStore(SpellItemEnchantmentfmt);
 DBCStorage <SpellItemEnchantmentConditionEntry> sSpellItemEnchantmentConditionStore(SpellItemEnchantmentConditionfmt);
 DBCStorage <SpellEntry> sSpellStore(SpellEntryfmt);
+
+DBCStorage <_SpellEntry> _sSpellStore(_SpellEntryfmt);
+DBCStorage <SpellIconEntry> sSpellIconStore(SpellIconEntryfmt);
+
 SpellCategoryStore sSpellsByCategoryStore;
 PetFamilySpellsStore sPetFamilySpellsStore;
 
@@ -244,6 +251,21 @@ void LoadDBCStores(const std::string& dataPath)
 #define LOAD_DBC(store, file, dbtable) LoadDBC(availableDbcLocales, bad_dbc_files, store, dbcPath, file, dbtable)
 
     LOAD_DBC(sAreaTableStore,                       "AreaTable.dbc",                        "areatable_dbc");
+
+    // must be after sAreaStore loading
+    for (uint32 i = 0; i < sAreaTableStore.GetNumRows(); ++i)           // areaflag numbered from 0
+    {
+        if (AreaTableEntry const* area = sAreaTableStore.LookupEntry(i))
+        {
+            // fill AreaId->DBC records
+            sAreaFlagByAreaID.insert(AreaFlagByAreaID::value_type(uint16(area->ID), area->exploreFlag));
+
+            // fill MapId->DBC records (skip sub zones and continents)
+            if (area->zone == 0 && area->mapid != 0 && area->mapid != 1 && area->mapid != 530 && area->mapid != 571)
+                sAreaFlagByMapID.insert(AreaFlagByMapID::value_type(area->mapid, area->exploreFlag));
+        }
+    }
+
     LOAD_DBC(sAchievementStore,                     "Achievement.dbc",                      "achievement_dbc");
     LOAD_DBC(sAchievementCategoryStore,             "Achievement_Category.dbc",             "achievement_category_dbc");
     LOAD_DBC(sAchievementCriteriaStore,             "Achievement_Criteria.dbc",             "achievement_criteria_dbc");
@@ -290,6 +312,7 @@ void LoadDBCStores(const std::string& dataPath)
     LOAD_DBC(sGtRegenHPPerSptStore,                 "gtRegenHPPerSpt.dbc",                  "gtregenhpperspt_dbc");
     LOAD_DBC(sGtRegenMPPerSptStore,                 "gtRegenMPPerSpt.dbc",                  "gtregenmpperspt_dbc");
     LOAD_DBC(sHolidaysStore,                        "Holidays.dbc",                         "holidays_dbc");
+    LOAD_DBC(sItemStore, "Item.dbc", "");
     LOAD_DBC(sItemBagFamilyStore,                   "ItemBagFamily.dbc",                    "itembagfamily_dbc");
     LOAD_DBC(sItemDisplayInfoStore,                 "ItemDisplayInfo.dbc",                  "itemdisplayinfo_dbc");
     //LOAD_DBC(sItemCondExtCostsStore,              "ItemCondExtCosts.dbc",                 "itemcondextcosts_dbc");
@@ -319,6 +342,8 @@ void LoadDBCStores(const std::string& dataPath)
     LOAD_DBC(sSkillLineAbilityStore,                "SkillLineAbility.dbc",                 "skilllineability_dbc");
     LOAD_DBC(sSoundEntriesStore,                    "SoundEntries.dbc",                     "soundentries_dbc");
     LOAD_DBC(sSpellStore,                           "Spell.dbc",                            "spell_dbc");
+    LOAD_DBC(_sSpellStore, "Spell.dbc", "spell_dbc");
+    LOAD_DBC(sSpellIconStore, "SpellIcon.dbc", "");
     LOAD_DBC(sSpellCastTimesStore,                  "SpellCastTimes.dbc",                   "spellcasttimes_dbc");
     LOAD_DBC(sSpellCategoryStore,                   "SpellCategory.dbc",                    "spellcategory_dbc");
     LOAD_DBC(sSpellDifficultyStore,                 "SpellDifficulty.dbc",                  "spelldifficulty_dbc");
@@ -627,6 +652,79 @@ uint32 GetTalentSpellCost(uint32 spellId)
     return 0;
 }
 
+int32 GetAreaFlagByAreaID(uint32 area_id)
+{
+    AreaFlagByAreaID::iterator i = sAreaFlagByAreaID.find(area_id);
+    if (i == sAreaFlagByAreaID.end())
+        return -1;
+
+    return i->second;
+}
+
+AreaTableEntry const* GetAreaEntryByAreaID(uint32 area_id)
+{
+    int32 areaflag = GetAreaFlagByAreaID(area_id);
+    if (areaflag < 0)
+        return NULL;
+
+    return sAreaTableStore.LookupEntry(areaflag);
+}
+
+AreaTableEntry const* GetAreaEntryByAreaFlagAndMap(uint32 area_flag, uint32 map_id)
+{
+    if (area_flag)
+        return sAreaTableStore.LookupEntry(area_flag);
+
+    if (MapEntry const* mapEntry = sMapStore.LookupEntry(map_id))
+        return GetAreaEntryByAreaID(mapEntry->linked_zone);
+
+    return NULL;
+}
+
+int32 GetMapIdByZone(uint32 zone_id)
+{
+    if (zone_id == 0)
+        return -1;
+
+    for (uint32 id = 0; id < sAreaTableStore.GetNumRows(); id++)
+    {
+        AreaTableEntry const* info = sAreaTableStore.LookupEntry(id);
+
+        if (info && info->zone == 0 && info->ID == zone_id)
+            return info->mapid;
+    }
+
+    return -1;
+}
+
+std::string GetMapNameById(uint32 id)
+{
+    MapEntry const* mapEntry = sMapStore.LookupEntry(id);
+    return mapEntry ? std::string(mapEntry->name[4]) : "";
+}
+
+std::string GetZoneNameById(uint32 id)
+{
+    AreaTableEntry const* zoneEntry = GetAreaEntryByAreaID(id);
+    return zoneEntry ? std::string(zoneEntry->area_name[4]) : "";
+}
+
+std::string GetAreaNameById(uint32 id)
+{
+    AreaTableEntry const* areaEntry = GetAreaEntryByAreaID(id);
+    return areaEntry ? std::string(areaEntry->area_name[4]) : "";
+}
+
+uint32 GetAreaFlagByMapId(uint32 mapid)
+{
+    AreaFlagByMapID::iterator i = sAreaFlagByMapID.find(mapid);
+    if (i == sAreaFlagByMapID.end())
+        return 0;
+    else
+        return i->second;
+}
+
+
 WMOAreaTableEntry const* GetWMOAreaTableEntryByTripple(int32 rootid, int32 adtid, int32 groupid)
 {
     auto i = sWMOAreaInfoByTripple.find(WMOAreaTableKey(int16(rootid), int8(adtid), groupid));
diff --git a/src/server/game/DataStores/DBCStores.h b/src/server/game/DataStores/DBCStores.h
index cc38327..34e924d 100644
--- a/src/server/game/DataStores/DBCStores.h
+++ b/src/server/game/DataStores/DBCStores.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -19,6 +19,16 @@ char* GetPetName(uint32 petfamily, uint32 dbclang);
 uint32 GetTalentSpellCost(uint32 spellId);
 TalentSpellPos const* GetTalentSpellPos(uint32 spellId);
 
+int32 GetAreaFlagByAreaID(uint32 area_id);                  // -1 if not found
+AreaTableEntry const* GetAreaEntryByAreaID(uint32 area_id);
+AreaTableEntry const* GetAreaEntryByAreaFlagAndMap(uint32 area_flag, uint32 map_id);
+uint32 GetAreaFlagByMapId(uint32 mapid);
+int32 GetMapIdByZone(uint32 zone_id);
+
+std::string GetMapNameById(uint32 id);
+std::string GetZoneNameById(uint32 id);
+std::string GetAreaNameById(uint32 id);
+
 WMOAreaTableEntry const* GetWMOAreaTableEntryByTripple(int32 rootid, int32 adtid, int32 groupid);
 
 uint32 GetVirtualMapForMapAndZone(uint32 mapid, uint32 zoneId);
@@ -100,6 +110,7 @@ extern DBCStorage <GtOCTRegenHPEntry>            sGtOCTRegenHPStore;
 extern DBCStorage <GtRegenHPPerSptEntry>         sGtRegenHPPerSptStore;
 extern DBCStorage <GtRegenMPPerSptEntry>         sGtRegenMPPerSptStore;
 extern DBCStorage <HolidaysEntry>                sHolidaysStore;
+extern DBCStorage <ItemEntry>                    sItemStore;
 extern DBCStorage <ItemBagFamilyEntry>           sItemBagFamilyStore;
 extern DBCStorage <ItemDisplayInfoEntry>         sItemDisplayInfoStore;
 extern DBCStorage <ItemExtendedCostEntry>        sItemExtendedCostStore;
@@ -140,6 +151,8 @@ extern DBCStorage <SpellRangeEntry>              sSpellRangeStore;
 extern DBCStorage <SpellRuneCostEntry>           sSpellRuneCostStore;
 extern DBCStorage <SpellShapeshiftEntry>         sSpellShapeshiftStore;
 extern DBCStorage <SpellEntry>                   sSpellStore;
+extern DBCStorage <_SpellEntry>                   _sSpellStore;
+extern DBCStorage <SpellIconEntry>                   sSpellIconStore;
 extern DBCStorage <StableSlotPricesEntry>        sStableSlotPricesStore;
 extern DBCStorage <SummonPropertiesEntry>        sSummonPropertiesStore;
 extern DBCStorage <TalentEntry>                  sTalentStore;
diff --git a/src/server/game/DungeonFinding/LFGMgr.cpp b/src/server/game/DungeonFinding/LFGMgr.cpp
index db0ed2d..2cd7455 100644
--- a/src/server/game/DungeonFinding/LFGMgr.cpp
+++ b/src/server/game/DungeonFinding/LFGMgr.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -23,6 +23,8 @@
 #include "GameEventMgr.h"
 #include "WorldSession.h"
 #include "Opcodes.h"
+#include "../Custom/Switch/Switch.h"
+#include "../Custom/Reward/Reward.h"
 
 namespace lfg
 {
@@ -102,7 +104,7 @@ void LFGMgr::LoadRewards()
     RewardMapStore.clear();
 
     // ORDER BY is very important for GetRandomDungeonReward!
-    QueryResult result = WorldDatabase.Query("SELECT dungeonId, maxLevel, firstQuestId, otherQuestId FROM lfg_dungeon_rewards ORDER BY dungeonId, maxLevel ASC");
+    QueryResult result = WorldDatabase.Query("SELECT dungeonId, maxLevel, firstQuestId, otherQuestId, tankRewId, healRewId, dpsRewId FROM lfg_dungeon_rewards ORDER BY dungeonId, maxLevel ASC");
 
     if (!result)
     {
@@ -120,6 +122,9 @@ void LFGMgr::LoadRewards()
         uint32 maxLevel = fields[1].GetUInt8();
         uint32 firstQuestId = fields[2].GetUInt32();
         uint32 otherQuestId = fields[3].GetUInt32();
+        uint32 tankRewId = fields[4].GetUInt32();
+        uint32 healRewId = fields[5].GetUInt32();
+        uint32 dpsRewId = fields[6].GetUInt32();
 
         if (!GetLFGDungeonEntry(dungeonId))
         {
@@ -145,7 +150,7 @@ void LFGMgr::LoadRewards()
             otherQuestId = 0;
         }
 
-        RewardMapStore.insert(LfgRewardContainer::value_type(dungeonId, new LfgReward(maxLevel, firstQuestId, otherQuestId)));
+        RewardMapStore.insert(LfgRewardContainer::value_type(dungeonId, new LfgReward(maxLevel, firstQuestId, otherQuestId, tankRewId, healRewId, dpsRewId)));
         ++count;
     }
     while (result->NextRow());
@@ -2088,6 +2093,28 @@ void LFGMgr::FinishDungeon(uint64 gguid, const uint32 dungeonId, const Map* curr
         sLog->outDebug(LOG_FILTER_LFG, "LFGMgr::FinishDungeon: [" UI64FMTD "] done dungeon %u, %s previously done.", player->GetGUID(), GetDungeon(gguid), done? " " : " not");
         LfgPlayerRewardData data = LfgPlayerRewardData(dungeon->Entry(), GetDungeon(gguid, false), done, quest);
         player->GetSession()->SendLfgPlayerReward(data);
+
+        if (Group* group = player->GetGroup())
+        {
+            uint32 rewId = 0;
+
+            switch (group->GetLfgRoles(player->GetGUID()))
+            {
+            case PLAYER_ROLE_TANK:
+                rewId = reward->tankRewId;
+                break;
+            case PLAYER_ROLE_HEALER:
+                rewId = reward->healRewId;
+                break;
+            case PLAYER_ROLE_DAMAGE:
+                rewId = reward->dpsRewId;
+                break;
+            default:
+                break;
+            }
+
+            sRew->Rew(player, rewId);
+        }
     }
 }
 
@@ -2402,8 +2429,8 @@ void LFGMgr::SetLeader(uint64 gguid, uint64 leader)
 
 void LFGMgr::SetTeam(uint64 guid, TeamId teamId)
 {
-    if (sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GROUP))
-        teamId = TEAM_ALLIANCE; // @Not Sure About That TeamId is supposed to be uint8 Team = 0(@TrinityCore)
+    if (sSwitch->GetOnOff(ST_CF_GROUP))
+        teamId = TEAM_ALLIANCE;
 
     PlayersStore[guid].SetTeam(teamId);
 }
diff --git a/src/server/game/DungeonFinding/LFGMgr.h b/src/server/game/DungeonFinding/LFGMgr.h
index f7c8be8..9c209d0 100644
--- a/src/server/game/DungeonFinding/LFGMgr.h
+++ b/src/server/game/DungeonFinding/LFGMgr.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -291,12 +291,15 @@ struct LfgPlayerRewardData
 /// Reward info
 struct LfgReward
 {
-    LfgReward(uint32 _maxLevel = 0, uint32 _firstQuest = 0, uint32 _otherQuest = 0):
-        maxLevel(_maxLevel), firstQuest(_firstQuest), otherQuest(_otherQuest) { }
+    LfgReward(uint32 _maxLevel = 0, uint32 _firstQuest = 0, uint32 _otherQuest = 0, uint32 _tankRewId = 0, uint32 _healRewId = 0, uint32 _dpsRewId = 0):
+        maxLevel(_maxLevel), firstQuest(_firstQuest), otherQuest(_otherQuest), tankRewId(_tankRewId), healRewId(_healRewId), dpsRewId(_dpsRewId) { }
 
     uint32 maxLevel;
     uint32 firstQuest;
     uint32 otherQuest;
+    uint32 tankRewId;
+    uint32 healRewId;
+    uint32 dpsRewId;
 };
 
 /// Stores player data related to proposal to join
diff --git a/src/server/game/DungeonFinding/LFGScripts.cpp b/src/server/game/DungeonFinding/LFGScripts.cpp
index 10f2e16..2244482 100644
--- a/src/server/game/DungeonFinding/LFGScripts.cpp
+++ b/src/server/game/DungeonFinding/LFGScripts.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -119,6 +119,8 @@ void LFGPlayerScript::OnMapChanged(Player* player)
     {
         player->RemoveAurasDueToSpell(LFG_SPELL_LUCK_OF_THE_DRAW);
 
+        if (player->InEvent())
+            return;
         // Xinef: Destroy group if only one player is left
         if (Group* group = player->GetGroup())
             if (group->GetMembersCount() <= 1u)
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index fc9655d..b154477 100644
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -43,12 +43,22 @@
 
 #include "Transport.h"
 
-#include "../game/AI/NpcBots/bot_ai.h"
 
 #ifdef ELUNA
 #include "LuaEngine.h"
 #endif
 
+#pragma execution_character_set("utf-8")
+#include "../Custom/DataLoader/DataLoader.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
+#include "../Custom/AntiCheat/AntiCheat.h"
+#include "../Custom/UnitMod/CreatureMod/CreatureMod.h"
+#include "../Custom/Challenge/challenge.h"
+#include "../Custom/MapMod/MapMod.h"
+#include "../Custom/Scripts/CustomScripts.h"
+#include "../Custom/Reward/Reward.h"
+
+
 TrainerSpell const* TrainerSpellData::Find(uint32 spell_id) const
 {
     TrainerSpellMap::const_iterator itr = spellList.find(spell_id);
@@ -188,14 +198,44 @@ m_homePosition(), m_transportHomePosition(), m_creatureInfo(nullptr), m_creature
     m_isTempWorldObject = false;
     _focusSpell = nullptr;
 
-    // NPCBOT
-    m_bot_owner = NULL;
-    m_creature_owner = NULL;
-    m_bots_pet = NULL;
-    m_bot_class = CLASS_NONE;
-    bot_AI = NULL;
-    m_canUpdate = true;
-    // NPCBOT
+    stage = 1;
+    summonsClear = true;
+
+    //anticheat
+    reset_timer = 0;
+
+    //creature mod
+    C_Level = 0;				//ç­çº§
+    C_Health = 0;				//çå½å¼
+    C_HpMod = 1.0f;				//çå½å¼åç
+    C_Armor = -1;				//æ¤ç²-1 creature_templateè¡¨ç¡®å®
+    C_MeleeDmg = 0;				//ç©çä¼¤å®³
+    C_SpellDmgMod = 1;				//æ³æ¯ä¼¤å®³åç
+    C_HealMod = 1;				//æ²»çåç
+    C_ReduceDmgPct = 0;				//åä¼¤ç¾åæ¯
+    C_Resistance = -1;				//ææ§-1 creature_templateè¡¨ç¡®å®
+
+    for (size_t i = 0; i < MAX_CUSTOM_LOOT_COUNT; i++)
+        C_LootId[i] = 0;				//æè½ creaute_loot_template
+    C_SrcLoot = true;				//æ¯å¦åå«åLoot
+
+    C_KillRewId = 0;				//å»æèè·å¾å¥å±
+    C_KillRewChance = 0;				//å»æèè·å¾å¥å±å ç
+    C_KillGroupRewId = 0;				//å»æèéä¼è·å¾å¥å±
+    C_KillGroupRewChance = 0;			//å»æèéä¼è·å¾å¥å±å ç
+    C_KillAnnounce = false;			//å»ææ¶å¹¿æ­åå®¹
+    C_AttackTime = 0;				//æ»å»é´é
+    C_ResetDistance = 0;
+    C_AddTalismanValue = 0;
+    C_AddAddRankValue = 0;
+    C_KillRewGameObject = 0;
+    C_AuraVec.clear();
+    ISDam_Player.clear();
+    ISTmpDam_Player.clear();
+    m_paidam.clear();
+
+    RandSpellGroupId = 0;
+    RandSpellTimer = 0;
 }
 
 Creature::~Creature()
@@ -280,11 +320,6 @@ void Creature::RemoveCorpse(bool setSpawnTime, bool skipVisibility)
     if (getDeathState() != CORPSE)
         return;
 
-    // NPCBOT
-    if (bot_AI)
-        return;
-    // NPCBOT
-
     m_corpseRemoveTime = time(nullptr);
     setDeathState(DEAD);
     RemoveAllAuras();
@@ -445,10 +480,21 @@ bool Creature::UpdateEntry(uint32 Entry, const CreatureData* data, bool changele
 
     SetUInt32Value(UNIT_DYNAMIC_FLAGS, dynamicflags);
 
+    //è¿éå è½½çç©å±æ§è°æ´
+    sMapMod->SetMod(this);
+    sCreatureMod->SetMod(this);
+
     SetAttackTime(BASE_ATTACK,   cInfo->BaseAttackTime);
     SetAttackTime(OFF_ATTACK,    cInfo->BaseAttackTime);
     SetAttackTime(RANGED_ATTACK, cInfo->RangeAttackTime);
 
+    if (C_AttackTime != 0)
+    {
+        SetAttackTime(BASE_ATTACK, C_AttackTime);
+        SetAttackTime(OFF_ATTACK, C_AttackTime);
+        SetAttackTime(RANGED_ATTACK, C_AttackTime);
+    }
+
     SelectLevel(changelevel);
 
     SetMeleeDamageSchool(SpellSchools(cInfo->dmgschool));
@@ -503,11 +549,6 @@ bool Creature::UpdateEntry(uint32 Entry, const CreatureData* data, bool changele
 
 void Creature::Update(uint32 diff)
 {
-    // NPCBOT
-    if (!m_canUpdate && bot_AI)
-        return;
-    // NPCBOT
-
     if (IsAIEnabled && TriggerJustRespawned)
     {
         TriggerJustRespawned = false;
@@ -661,6 +702,12 @@ void Creature::Update(uint32 diff)
         }
 
         sScriptMgr->OnCreatureUpdate(this, diff);
+
+        //é²æ­¢BOSSç¦»å¼åä½ç½®è¿è¿
+        sAntiCheat->CreatureReset(this, diff);
+
+        //é¢å¤æè½
+        sCustomScript->CastRandSpell(this, diff);
     }
 }
 
@@ -1161,6 +1208,10 @@ void Creature::SelectLevel(bool changelevel)
     uint32 basehp = std::max<uint32>(1, stats->GenerateHealth(cInfo));
     uint32 health = uint32(basehp * healthmod);
 
+    if (C_Health != 0)
+        health = C_Health;
+    health *= C_HpMod;
+
     SetCreateHealth(health);
     SetMaxHealth(health);
     SetHealth(health);
@@ -1422,12 +1473,6 @@ void Creature::SetCanDualWield(bool value)
 
 void Creature::LoadEquipment(int8 id, bool force /*= false*/)
 {
-
-    // NPCBOT
-    if (GetEntry() >= BOT_ENTRY_BEGIN && GetEntry() <= BOT_ENTRY_END) //temp hack
-        return;
-    // NPCBOT
-
     if (id == 0)
     {
         if (force)
@@ -1640,6 +1685,21 @@ void Creature::Respawn(bool force)
 { 
     //DestroyForNearbyPlayers(); // pussywizard: not needed
 
+    {
+        //è¿éå è½½çç©å±æ§è°æ´
+        sMapMod->SetMod(this);
+        sCreatureMod->SetMod(this);
+
+        if (C_AttackTime != 0)
+        {
+            SetAttackTime(BASE_ATTACK, C_AttackTime);
+            SetAttackTime(OFF_ATTACK, C_AttackTime);
+            SetAttackTime(RANGED_ATTACK, C_AttackTime);
+        }
+
+        SelectLevel(true);
+    }
+
     if (force)
     {
         if (IsAlive())
@@ -2192,7 +2252,10 @@ CreatureAddon const* Creature::GetCreatureAddon() const
 
 //creature_addon table
 bool Creature::LoadCreaturesAddon(bool reload)
-{ 
+{
+    for (auto itr = C_AuraVec.begin(); itr != C_AuraVec.end(); itr++)
+        AddAura(*itr, this);
+
     CreatureAddon const* cainfo = GetCreatureAddon();
     if (!cainfo)
         return false;
@@ -2895,3 +2958,61 @@ float Creature::GetAttackDistance(Unit const* player) const
 
     return (retDistance*aggroRate);
 }
+
+void Creature::SendDamPHStdAndPH() //çææè¡æ°æ®
+{
+    if (ISDam_Player.size())
+    {
+        for (int i = 1; i < ISDam_Player.size() + 1; i++) //åå¥æè¡æ°æ®
+        {
+            m_paidam[i] = GetGuidFromMaxDam();
+        }
+
+        uint32 maxdamsend = 10;
+        CreatureDamageSend* damcre = sRew->FindCreatureDamageSend(GetEntry());
+        if (damcre && damcre->sendgossipcount)
+        {
+            if (maxdamsend > damcre->sendgossipcount)
+                maxdamsend = damcre->sendgossipcount;
+        }
+
+        for (PlayerdamMap::const_iterator itr = ISDam_Player.begin(); itr != ISDam_Player.end(); ++itr)  //åå¥å¼¹çª
+        {
+            uint64 plguid = MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER);
+            if (Player* playersend = ObjectAccessor::FindPlayer(plguid))
+            {
+                playersend->PlayerTalkClass->ClearMenus();
+                for (int i = 1; i < maxdamsend + 1; i++)
+                {
+                    GlobalPlayerData const* playerData = sWorld->GetGlobalPlayerData(m_paidam[i]);
+                    if (playerData)
+                    {
+                        std::ostringstream damdata;
+                        damdata << "ç¬¬" << i << "å:" << playerData->name.c_str() << ",ä¼¤å®³é: " << GetPlayerDamFromCre(m_paidam[i]);
+                        playersend->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_CHAT, damdata.str().c_str(), i, 10, "", 0);
+                    }
+                }
+                playersend->PlayerTalkClass->SendGossipMenu(20001, playersend->GetGUID());
+            }
+        }
+
+        if (damcre && damcre->maxsend)
+        {
+            uint32 ddddd = damcre->maxsend;
+            if (damcre->maxsend > ISDam_Player.size())
+                ddddd = ISDam_Player.size();
+
+            for (int i = 0; i < ddddd; i++) //åæ¾å¥å±
+            {
+                uint64 plguid = MAKE_NEW_GUID(m_paidam[i + 1], 0, HIGHGUID_PLAYER);
+                if (Player* pl = ObjectAccessor::FindPlayer(plguid))
+                {
+                    if (damcre->itemsends[i] && GetPlayerDamFromCre(m_paidam[i + 1]) >= damcre->mindamage)
+                    {
+                        pl->AddItem(damcre->itemsends[i], 1); // i+1 æ¯æå
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/server/game/Entities/Creature/Creature.h b/src/server/game/Entities/Creature/Creature.h
index a2adf42..be14377 100644
--- a/src/server/game/Entities/Creature/Creature.h
+++ b/src/server/game/Entities/Creature/Creature.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -25,12 +25,6 @@ class Player;
 class WorldSession;
 class CreatureGroup;
 
-// NPCBOT
-class bot_ai;
-class bot_minion_ai;
-class bot_pet_ai;
-// NPCBOT
-
 enum CreatureFlagsExtra
 {
     CREATURE_FLAG_EXTRA_INSTANCE_BIND       = 0x00000001,   // creature kill bind instance with killer and killer's group
@@ -340,14 +334,13 @@ typedef std::unordered_map<uint32, CreatureAddon> CreatureAddonContainer;
 // Vendors
 struct VendorItem
 {
-    VendorItem(uint32 _item, int32 _maxcount, uint32 _incrtime, uint32 _ExtendedCost, uint32 _Needid)
-        : item(_item), maxcount(_maxcount), incrtime(_incrtime), ExtendedCost(_ExtendedCost), Needid(_Needid){}
+    VendorItem(uint32 _item, int32 _maxcount, uint32 _incrtime, uint32 _ExtendedCost)
+        : item(_item), maxcount(_maxcount), incrtime(_incrtime), ExtendedCost(_ExtendedCost){}
 
     uint32 item;
     uint32  maxcount;                                       // 0 for infinity item amount
     uint32 incrtime;                                        // time for restore items amount if maxcount != 0
     uint32 ExtendedCost;
-    uint32 Needid;
     //helpers
     bool IsGoldRequired(ItemTemplate const* pProto) const { return pProto->Flags2 & ITEM_FLAGS_EXTRA_EXT_COST_REQUIRES_GOLD || !ExtendedCost; }
 };
@@ -366,9 +359,9 @@ struct VendorItemData
     }
     bool Empty() const { return m_items.empty(); }
     uint8 GetItemCount() const { return m_items.size(); }
-    void AddItem(uint32 item, int32 maxcount, uint32 ptime, uint32 ExtendedCost, uint32 Needid)
+    void AddItem(uint32 item, int32 maxcount, uint32 ptime, uint32 ExtendedCost)
     {
-        m_items.push_back(new VendorItem(item, maxcount, ptime, ExtendedCost, Needid));
+        m_items.push_back(new VendorItem(item, maxcount, ptime, ExtendedCost));
     }
     bool RemoveItem(uint32 item_id);
     VendorItem const* FindItemCostPair(uint32 item_id, uint32 extendedCost) const;
@@ -430,10 +423,44 @@ typedef std::map<uint32, time_t> CreatureSpellCooldowns;
 #define CREATURE_Z_ATTACK_RANGE 3
 
 #define MAX_VENDOR_ITEMS 150                                // Limitation in 3.x.x item count in SMSG_LIST_INVENTORY
+#define MAX_CUSTOM_LOOT_COUNT	5
 
 class Creature : public Unit, public GridObject<Creature>, public MovableMapObject
 {
     public:
+        //creature mod
+        uint8		C_Level;										//ç­çº§
+        uint32		C_Health;										//çå½å¼
+        float		C_HpMod;										//çå½å¼åç
+        int32		C_Armor;										//æ¤ç²-1 creature_templateè¡¨ç¡®å®
+        float		C_MeleeDmg;										//ç©çä¼¤å®³
+        float		C_SpellDmgMod;									//æ³æ¯ä¼¤å®³åç
+        float		C_HealMod;										//æ²»çåç
+        float		C_ReduceDmgPct;									//åä¼¤ç¾åæ¯
+        int32		C_Resistance;									//ææ§ä¸º-1 creature_templateè¡¨ç¡®å®
+        uint32		C_LootId[MAX_CUSTOM_LOOT_COUNT];				//æè½ creaute_loot_template
+        uint32		C_KillRewId;									//å»æèè·å¾å¥å±
+        float		C_KillRewChance;								//å»æèè·å¾å¥å±å ç
+        uint32		C_KillGroupRewId;								//å»æèéä¼æåè·å¾å¥å±
+        float		C_KillGroupRewChance;							//å»æèéä¼æåè·å¾å¥å±å ç
+        bool		C_KillAnnounce;									//å»ææ¶å¹¿æ­åå®¹
+        uint32		C_AttackTime;									//æ»å»é´é
+        float		C_ResetDistance;
+        int32		C_AddTalismanValue;
+        int32		C_AddAddRankValue;
+        std::vector<uint32> C_AuraVec;								//åç¯
+        uint32		C_KillRewGameObject;
+        bool		C_SrcLoot;										//æ¯å¦åå«åloot
+
+        uint32		RandSpellGroupId;
+        int32		RandSpellTimer;
+
+        //stage
+        uint32 stage;
+        bool summonsClear;
+        //anticheat
+        uint32 reset_timer;
+
 
         explicit Creature(bool isWorldObject = false);
         virtual ~Creature();
@@ -519,7 +546,10 @@ class Creature : public Unit, public GridObject<Creature>, public MovableMapObje
         bool SetFeatherFall(bool enable, bool packetOnly = false) override;
         bool SetHover(bool enable, bool packetOnly = false) override;
 
-        uint32 GetShieldBlockValue() const override;
+        uint32 GetShieldBlockValue() const
+        {
+            return (getLevel() / 2 + uint32(GetStat(STAT_STRENGTH) / 20));
+        }
 
         SpellSchoolMask GetMeleeDamageSchoolMask() const override { return m_meleeDamageSchoolMask; }
         void SetMeleeDamageSchool(SpellSchools school) { m_meleeDamageSchoolMask = SpellSchoolMask(1 << school); }
@@ -576,6 +606,51 @@ class Creature : public Unit, public GridObject<Creature>, public MovableMapObje
         virtual void SaveToDB(uint32 mapid, uint8 spawnMask, uint32 phaseMask);
         virtual void DeleteFromDB();                        // overriden in Pet
 
+            // ==========================================
+        uint32 GetPlayerDamFromCre(uint32 guid) const  //æ ¹æ®ç©å®¶GUIDè·åå¯¹çç©é æçä¼¤å®³
+        {
+            PlayerdamMap::const_iterator itr = ISDam_Player.find(guid);
+            if (itr != ISDam_Player.end())
+                return itr->second;
+            return 0;
+        }
+
+        uint32 GetGuidFromMaxDam() //æ ¹æ®æå¤§çä¼¤å®³å¼å¾å°guid
+        {
+            uint32 guid = 0;
+            uint32 maxvalue = 0;
+            PlayerdamMapTmp::const_iterator itr2;
+            for (PlayerdamMapTmp::const_iterator itr = ISTmpDam_Player.begin(); itr != ISTmpDam_Player.end(); ++itr)
+            {
+                if (itr->second >= maxvalue)
+                {
+                    guid = itr->first;
+                    maxvalue = itr->second;
+                    itr2 = itr;
+                }
+            }
+            ISTmpDam_Player.erase(itr2);
+            return guid;
+        }
+
+        void SetDamToValue(uint32 guid, uint32 damage)
+        {
+            ISDam_Player[guid] += damage;
+            ISTmpDam_Player[guid] += damage;
+        }
+
+        typedef std::map<uint32, uint32> PlayerdamMap;
+        PlayerdamMap  ISDam_Player;
+
+        typedef std::map<uint32, uint32> PlayerdamMapTmp;
+        PlayerdamMapTmp  ISTmpDam_Player;
+
+
+        void SendDamPHStdAndPH();
+        typedef std::map<uint32, uint32> PaidamMap; //æè¡   ç©å®¶GUID
+        PaidamMap m_paidam;
+        //=====================================================
+
         Loot loot;
         uint64 GetLootRecipientGUID() const { return m_lootRecipient; }
         Player* GetLootRecipient() const;
@@ -719,46 +794,16 @@ class Creature : public Unit, public GridObject<Creature>, public MovableMapObje
 
         // Part of Evade mechanics
         time_t GetLastDamagedTime() const { return _lastDamagedTime; }
-        void SetLastDamagedTime(time_t val) { _lastDamagedTime = val; }
-
-        // NPCBOT
-        Player* GetBotOwner() const { return m_bot_owner; }
-        void SetBotOwner(Player* newowner) { m_bot_owner = newowner; }
-        Creature* GetCreatureOwner() const { return m_creature_owner; }
-        void SetCreatureOwner(Creature* newCreOwner) { m_creature_owner = newCreOwner; }
-        Creature* GetBotsPet() const { return m_bots_pet; }
-        void SetBotsPetDied();
-        void SetBotsPet(Creature* newpet) { /*ASSERT (!m_bots_pet);*/ m_bots_pet = newpet; }
-        void SetIAmABot(bool bot = true);
-        bool GetIAmABot() const;
-        bool GetIAmABotsPet() const;
-        void SetBotClass(uint8 myclass) { m_bot_class = myclass; }
-        uint8 GetBotClass() const;
-        uint8 GetBotRoles() const;
-        bot_ai* GetBotAI() const { return bot_AI; }
-        bot_minion_ai* GetBotMinionAI() const;
-        bot_pet_ai* GetBotPetAI() const;
-        void InitBotAI(bool asPet = false);
-        void SetBotCommandState(CommandStates st, bool force = false);
-        CommandStates GetBotCommandState() const;
-        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
-        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
-        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
-        void ApplyBotDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float &value) const;
-        void SetBotShouldUpdateStats();
-        void OnBotSummon(Creature* summon);
-        void OnBotDespawn(Creature* summon);
-        void SetCanUpdate(bool can) { m_canUpdate = can; }
-        void RemoveBotItemBonuses(uint8 slot);
-        void ApplyBotItemBonuses(uint8 slot);
-        bool CanUseOffHand() const;
-        bool CanUseRanged() const;
-        bool CanEquip(ItemTemplate const* item, uint8 slot) const;
-        bool Unequip(uint8 slot) const;
-        bool Equip(uint32 itemId, uint8 slot) const;
-        bool ResetEquipment(uint8 slot) const;
-        bool IsQuestBot() const;
-        // NPCBOT
+        void SetLastDamagedTime(time_t val)
+        {
+            _lastDamagedTime = val;
+            if (!val)
+            {
+                ISDam_Player.clear();
+                ISTmpDam_Player.clear();
+                m_paidam.clear();
+            }
+        }
 
     protected:
         bool CreateFromProto(uint32 guidlow, uint32 Entry, uint32 vehId, const CreatureData* data = nullptr);
@@ -815,15 +860,6 @@ class Creature : public Unit, public GridObject<Creature>, public MovableMapObje
 
     private:
 
-        // NPCBOT
-        Player* m_bot_owner;
-        Creature* m_creature_owner;
-        Creature* m_bots_pet;
-        bot_ai* bot_AI;
-        uint8 m_bot_class;
-        bool m_canUpdate;
-        // NPCBOT
-
         void ForcedDespawn(uint32 timeMSToDespawn = 0);
 
         //WaypointMovementGenerator vars
diff --git a/src/server/game/Entities/Creature/GossipDef.cpp b/src/server/game/Entities/Creature/GossipDef.cpp
index 4703c31..aa63dd6 100644
--- a/src/server/game/Entities/Creature/GossipDef.cpp
+++ b/src/server/game/Entities/Creature/GossipDef.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -11,6 +11,7 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 #include "Formulas.h"
+#include "../../scripts/Custom/Quest/QuestMod.h"
 
 GossipMenu::GossipMenu()
 {
@@ -372,7 +373,7 @@ void PlayerMenu::SendQuestGiverQuestDetails(Quest const* quest, uint64 npcGUID,
     data << uint64(_session->GetPlayer()->GetDivider());
     data << uint32(quest->GetQuestId());
     data << questTitle;
-    data << questDetails;
+    data << questDetails + sQuestMod->GetExtraDes(quest->GetQuestId(), _session->GetPlayer());
     data << questObjectives;
     data << uint8(activateAccept ? 1 : 0);                  // auto finish
     data << uint32(quest->GetFlags());                      // 3.3.3 questFlags
diff --git a/src/server/game/Entities/Creature/TemporarySummon.cpp b/src/server/game/Entities/Creature/TemporarySummon.cpp
index 37dfa20..3d2793b 100644
--- a/src/server/game/Entities/Creature/TemporarySummon.cpp
+++ b/src/server/game/Entities/Creature/TemporarySummon.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -242,14 +242,6 @@ void TempSummon::UnSummon(uint32 msTime)
     if (owner && owner->GetTypeId() == TYPEID_UNIT && owner->ToCreature()->IsAIEnabled)
         owner->ToCreature()->AI()->SummonedCreatureDespawn(this);
 
-    // NPCBOT
-    if (GetIAmABot() || GetIAmABotsPet())
-    {
-        sLog->outString("TempSummon::UnSummon(): Trying to unsummon Bot %s(owner: %s). Aborted", GetName().c_str(), GetBotOwner()->GetName().c_str());
-        return;
-    }
-    // NPCBOT
-
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/GameObject/GameObject.cpp b/src/server/game/Entities/GameObject/GameObject.cpp
index fb2a8e0..1e3f7d1 100644
--- a/src/server/game/Entities/GameObject/GameObject.cpp
+++ b/src/server/game/Entities/GameObject/GameObject.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -24,7 +24,7 @@
 #include "World.h"
 #include "Transport.h"
 #include "AccountMgr.h"
-
+#include "../Custom/CustomEvent/Event.h"
 #ifdef ELUNA
 #include "LuaEngine.h"
 #endif
@@ -1858,7 +1858,10 @@ void GameObject::Use(Unit* user)
 }
 
 void GameObject::CastSpell(Unit* target, uint32 spellId)
-{ 
+{
+    if (!sEvent->GobUnk1Check(target, this))
+        return;
+
     SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
     if (!spellInfo)
         return;
diff --git a/src/server/game/Entities/GameObject/GameObject.h b/src/server/game/Entities/GameObject/GameObject.h
index f80ef82..151a30c 100644
--- a/src/server/game/Entities/GameObject/GameObject.h
+++ b/src/server/game/Entities/GameObject/GameObject.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -792,6 +792,7 @@ class GameObject : public WorldObject, public GridObject<GameObject>, public Mov
         void SaveRespawnTime() override;
 
         Loot        loot;
+        std::unordered_map<uint32, uint32> LootExtraItems;
 
         Player* GetLootRecipient() const;
         Group* GetLootRecipientGroup() const;
diff --git a/src/server/game/Entities/Item/Container/Bag.cpp b/src/server/game/Entities/Item/Container/Bag.cpp
index 385d3ef..0baa520 100644
--- a/src/server/game/Entities/Item/Container/Bag.cpp
+++ b/src/server/game/Entities/Item/Container/Bag.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -94,9 +94,9 @@ void Bag::SaveToDB(SQLTransaction& trans)
     Item::SaveToDB(trans);
 }
 
-bool Bag::LoadFromDB(uint32 guid, uint64 owner_guid, Field* fields, uint32 entry)
+bool Bag::LoadFromDB(uint32 guid, uint64 owner_guid, Field* fields, uint32 entry, uint8 type)
 {
-    if (!Item::LoadFromDB(guid, owner_guid, fields, entry))
+    if (!Item::LoadFromDB(guid, owner_guid, fields, entry, type))
         return false;
 
     ItemTemplate const* itemProto = GetTemplate(); // checked in Item::LoadFromDB
diff --git a/src/server/game/Entities/Item/Container/Bag.h b/src/server/game/Entities/Item/Container/Bag.h
index 9398729..8d35317 100644
--- a/src/server/game/Entities/Item/Container/Bag.h
+++ b/src/server/game/Entities/Item/Container/Bag.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -42,7 +42,7 @@ class Bag : public Item
         // overwrite virtual Item::SaveToDB
         void SaveToDB(SQLTransaction& trans);
         // overwrite virtual Item::LoadFromDB
-        bool LoadFromDB(uint32 guid, uint64 owner_guid, Field* fields, uint32 entry);
+        bool LoadFromDB(uint32 guid, uint64 owner_guid, Field* fields, uint32 entry, uint8 type);
         // overwrite virtual Item::DeleteFromDB
         void DeleteFromDB(SQLTransaction& trans);
 
diff --git a/src/server/game/Entities/Item/Item.cpp b/src/server/game/Entities/Item/Item.cpp
index 9c5e8d8..e076e8f 100644
--- a/src/server/game/Entities/Item/Item.cpp
+++ b/src/server/game/Entities/Item/Item.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -16,6 +16,11 @@
 #include "ConditionMgr.h"
 #include "Player.h"
 #include "WorldSession.h"
+#include "../Custom/ItemMod/ItemMod.h"
+#include "../Custom/ItemMod/NoPatchItem.h"
+#include "../Custom/EquipmentManager/EquipmentManager.h"
+#include "../Custom/GCAddon/GCAddon.h"
+#include "../../../scripts/Custom/Transmogrification/Transmogrification.h"
 
 void AddItemsSetItem(Player* player, Item* item)
 {
@@ -224,6 +229,42 @@ bool ItemCanGoIntoBag(ItemTemplate const* pProto, ItemTemplate const* pBagProto)
 
 Item::Item()
 {
+    for (size_t i = 0; i < MAX_ITEM_PROTO_SPELLS; i++)
+    {
+        Spells[i].SpellCategory = 0;
+        Spells[i].SpellCategoryCooldown = -1;
+        Spells[i].SpellCharges = 0;
+        Spells[i].SpellCooldown = -1;
+        Spells[i].SpellId = 0;
+        Spells[i].SpellPPMRate = 0;
+        Spells[i].SpellTrigger = 0;
+    }
+
+    for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+    {
+        Stats[i].ItemStatType = 0;
+        Stats[i].ItemStatValue = 0;
+    }
+
+    for (size_t i = 0; i < MAX_ITEM_PROTO_DAMAGES; i++)
+    {
+        Damages[i].DamageMax = 0;
+        Damages[i].DamageMin = 0;
+        Damages[i].DamageType = 0;
+    }
+
+    Name = "";
+    LevelData = 0;
+    MapData = 0;
+    NpDelay = 0;
+    TempIndex = 0;
+
+    //éæºFMä½ç½®æç¨å±æ§
+    enchantMask = 0;
+    enchantType = 0;
+
+    UnBinded = false;
+
     m_objectType |= TYPEMASK_ITEM;
     m_objectTypeId = TYPEID_ITEM;
 
@@ -266,6 +307,19 @@ bool Item::Create(uint32 guidlow, uint32 itemid, Player const* owner)
 
     SetUInt32Value(ITEM_FIELD_DURATION, itemProto->Duration);
     SetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME, 0);
+
+    //éæºFM
+    if (owner && owner->IsInWorld())
+    {
+        for (uint8 slot = PERM_ENCHANTMENT_SLOT; slot < MAX_ENCHANTMENT_SLOT; slot++)
+        {
+            uint32 enchant_id = sItemMod->GenerateEnchantId(itemProto->ItemId, slot);
+
+            if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id))
+                SetEnchantment(EnchantmentSlot(slot), enchant_id, 0, 0);
+        }
+    }
+
     return true;
 }
 
@@ -339,6 +393,48 @@ void Item::SaveToDB(SQLTransaction& trans)
             stmt->setUInt16(++index, GetUInt32Value(ITEM_FIELD_DURABILITY));
             stmt->setUInt32(++index, GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME));
             stmt->setString(++index, m_text);
+
+            //æ è¡¥ä¸ç©å
+            std::ostringstream sssSpells;
+            for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+            {
+                sssSpells << Spells[i].SpellCategory << ',';
+                sssSpells << Spells[i].SpellCategoryCooldown << ',';
+                sssSpells << Spells[i].SpellCharges << ',';
+                sssSpells << Spells[i].SpellCooldown << ',';
+                sssSpells << Spells[i].SpellId << ',';
+                sssSpells << Spells[i].SpellPPMRate << ',';
+                sssSpells << Spells[i].SpellTrigger << ',';
+                sssSpells << ' ';
+            }
+            stmt->setString(++index, sssSpells.str());
+
+            std::ostringstream ssStats;
+            for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
+            {
+                ssStats << Stats[i].ItemStatType << ',';
+                ssStats << Stats[i].ItemStatValue << ',';
+                ssStats << ' ';
+            }
+            stmt->setString(++index, ssStats.str());
+
+            std::ostringstream ssDamages;
+            for (uint8 i = 0; i < MAX_ITEM_PROTO_DAMAGES; ++i)
+            {
+                ssDamages << uint32(Damages[i].DamageMax) << ',';
+                ssDamages << uint32(Damages[i].DamageMin) << ',';
+                ssDamages << Damages[i].DamageType << ',';
+                ssDamages << ' ';
+            }
+            stmt->setString(++index, ssDamages.str());
+
+            stmt->setString(++index, Name);
+            stmt->setUInt64(++index, LevelData);
+            stmt->setUInt64(++index, MapData);
+            stmt->setUInt32(++index, NpDelay);
+            stmt->setUInt32(++index, TempIndex);
+            stmt->setBool(++index, UnBinded);
+
             stmt->setUInt32(++index, guid);
 
             trans->Append(stmt);
@@ -368,6 +464,11 @@ void Item::SaveToDB(SQLTransaction& trans)
             if (!isInTransaction)
                 CharacterDatabase.CommitTransaction(trans);
 
+            //æ¸é¤ItemQueryMapä¸­å¯¹åºæ°æ®
+            auto itr = ItemQueryMap.find(GetGUIDLow());
+            if (itr != ItemQueryMap.end())
+                ItemQueryMap.erase(itr);
+
             delete this;
             return;
         }
@@ -381,7 +482,7 @@ void Item::SaveToDB(SQLTransaction& trans)
         CharacterDatabase.CommitTransaction(trans);
 }
 
-bool Item::LoadFromDB(uint32 guid, uint64 owner_guid, Field* fields, uint32 entry)
+bool Item::LoadFromDB(uint32 guid, uint64 owner_guid, Field* fields, uint32 entry, uint8 type)
 {
     //                                                    0                1      2         3        4      5             6                 7           8           9    10
     //result = CharacterDatabase.PQuery("SELECT creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text FROM item_instance WHERE guid = '%u'", guid);
@@ -461,12 +562,89 @@ bool Item::LoadFromDB(uint32 guid, uint64 owner_guid, Field* fields, uint32 entr
         CharacterDatabase.Execute(stmt);
     }
 
+    //æ è¡¥ä¸ç©å
+    uint32 index = 15;
+
+    switch (type)
+    {
+    case 0://bag inv
+        index = 15;
+        break;
+    case 1://actionhouse
+        index = 13;
+        break;
+    case 2://guild bank
+        index = 16;
+        break;
+    case 3://mail
+        index = 14;
+        break;
+    case 4://mail asynch
+        index = 28;
+        break;
+    }
+
+    Tokenizer t0(fields[index++].GetString(), ' ', MAX_ITEM_PROTO_SPELLS);
+    if (t0.size() == MAX_ITEM_PROTO_SPELLS)
+    {
+        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+        {
+            Tokenizer t(std::string(t0[i]), ',', 7);
+            Spells[i].SpellCategory = atoi(t[0]);
+            Spells[i].SpellCategoryCooldown = atoi(t[1]);
+            Spells[i].SpellCharges = atoi(t[2]);
+            Spells[i].SpellCooldown = atoi(t[3]);
+            Spells[i].SpellId = atoi(t[4]);
+            Spells[i].SpellPPMRate = atof(t[5]);
+            Spells[i].SpellTrigger = atoi(t[6]);
+        }
+    }
+
+    Tokenizer t1(fields[index++].GetString(), ' ', MAX_ITEM_PROTO_STATS);
+    if (t1.size() == MAX_ITEM_PROTO_STATS)
+    {
+        for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
+        {
+            Tokenizer t(std::string(t1[i]), ',', 2);
+            Stats[i].ItemStatType = atoi(t[0]);
+            Stats[i].ItemStatValue = atoi(t[1]);
+        }
+    }
+
+    Tokenizer t2(fields[index++].GetString(), ' ', MAX_ITEM_PROTO_DAMAGES);
+    if (t2.size() == MAX_ITEM_PROTO_DAMAGES)
+    {
+        for (uint8 i = 0; i < MAX_ITEM_PROTO_DAMAGES; ++i)
+        {
+            Tokenizer t(std::string(t2[i]), ',', 3);
+            Damages[i].DamageMax = atoi(t[0]);
+            Damages[i].DamageMin = atoi(t[1]);
+            Damages[i].DamageType = atoi(t[2]);
+        }
+    }
+
+
+    Name = fields[index++].GetString();
+    LevelData = fields[index++].GetUInt64();
+    MapData = fields[index++].GetUInt64();
+    NpDelay = fields[index++].GetUInt32();
+    TempIndex = fields[index++].GetUInt32();
+    UnBinded = fields[index++].GetBool();
+
+    if (IsNoPatch())
+    {
+        SetUInt32Value(ITEM_FIELD_RANDOM_PROPERTIES_ID, GetUInt32Value(ITEM_FIELD_RANDOM_PROPERTIES_ID));
+        SetUInt32Value(ITEM_FIELD_PROPERTY_SEED, sNoPatchItem->GetQueryId(this));
+        ItemQueryMap[guid] = this;
+    }
+
     return true;
 }
 
 /*static*/
 void Item::DeleteFromDB(SQLTransaction& trans, uint32 itemGuid)
 {
+    sTransmogrification->DeleteFakeFromDB(itemGuid, &trans); // custom
     sScriptMgr->OnGlobalItemDelFromDB(trans,itemGuid);
     PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
     stmt->setUInt32(0, itemGuid);
@@ -641,6 +819,9 @@ void Item::UpdateItemSuffixFactor()
 
 void Item::SetState(ItemUpdateState state, Player* forplayer)
 {
+    if (state == ITEM_CHANGED)
+        sNoPatchItem->SetItemFlag(this);
+
     if (uState == ITEM_NEW && state == ITEM_REMOVED)
     {
         // pretend the item never existed
@@ -649,6 +830,11 @@ void Item::SetState(ItemUpdateState state, Player* forplayer)
             RemoveFromUpdateQueueOf(forplayer);
             forplayer->DeleteRefundReference(GetGUIDLow());
         }
+
+        auto itr = ItemQueryMap.find(GetGUIDLow());
+        if (itr != ItemQueryMap.end())
+            ItemQueryMap.erase(itr);
+
         delete this;
         return;
     }
@@ -853,8 +1039,16 @@ bool Item::IsFitToSpellRequirements(SpellInfo const* spellInfo) const
     return true;
 }
 
-void Item::SetEnchantment(EnchantmentSlot slot, uint32 id, uint32 duration, uint32 charges, uint64 caster /*= 0*/)
+void Item::SetEnchantment(EnchantmentSlot slot, uint32 id, uint32 duration, uint32 charges, uint64 caster /*= 0*/, bool custom)
 {
+    //æ£æµå¹»åæ è¯
+    if (!custom && sItemMod->HasTransFlag(this))
+    {
+        if (Player* owner = GetOwner())
+            owner->SendEquipError(EQUIP_ERR_CANT_DO_RIGHT_NOW, this, NULL);
+        return;
+    }
+
     // Better lost small time at check in comparison lost time at item save to DB.
     if ((GetEnchantmentId(slot) == id) && (GetEnchantmentDuration(slot) == duration) && (GetEnchantmentCharges(slot) == charges))
         return;
diff --git a/src/server/game/Entities/Item/Item.h b/src/server/game/Entities/Item/Item.h
index 4d07b43..0cd6b95 100644
--- a/src/server/game/Entities/Item/Item.h
+++ b/src/server/game/Entities/Item/Item.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -201,6 +201,24 @@ class Item : public Object
 
         Item();
 
+        //æ è¡¥ä¸ç©å
+        _Spell Spells[MAX_ITEM_PROTO_SPELLS];
+        _ItemStat Stats[MAX_ITEM_PROTO_STATS];
+        _Damage Damages[MAX_ITEM_PROTO_DAMAGES];
+        std::string Name;
+        uint64 LevelData;
+        uint32 NpDelay;
+        uint32 TempIndex;
+        uint64 MapData;
+        bool IsNoPatch() { return (LevelData > 0 || MapData > 0); }
+
+        //éæºFMä½ç½®æç¨å±æ§
+        uint32 enchantMask;
+        uint8 enchantType;
+
+        bool UnBinded;
+
+
         virtual bool Create(uint32 guidlow, uint32 itemid, Player const* owner);
 
         ItemTemplate const* GetTemplate() const;
@@ -209,14 +227,14 @@ class Item : public Object
         void SetOwnerGUID(uint64 guid) { SetUInt64Value(ITEM_FIELD_OWNER, guid); }
         Player* GetOwner() const;
 
-        void SetBinding(bool val) { ApplyModFlag(ITEM_FIELD_FLAGS, ITEM_FIELD_FLAG_SOULBOUND, val); }
+        void SetBinding(bool val) { UnBinded ? ApplyModFlag(ITEM_FIELD_FLAGS, ITEM_FIELD_FLAG_SOULBOUND, false) : ApplyModFlag(ITEM_FIELD_FLAGS, ITEM_FIELD_FLAG_SOULBOUND, val); }
         bool IsSoulBound() const { return HasFlag(ITEM_FIELD_FLAGS, ITEM_FIELD_FLAG_SOULBOUND); }
         bool IsBoundAccountWide() const { return (GetTemplate()->Flags & ITEM_FLAG_IS_BOUND_TO_ACCOUNT) != 0; }
         bool IsBindedNotWith(Player const* player) const;
         bool IsBoundByEnchant() const;
         bool IsBoundByTempEnchant() const;
         virtual void SaveToDB(SQLTransaction& trans);
-        virtual bool LoadFromDB(uint32 guid, uint64 owner_guid, Field* fields, uint32 entry);
+        virtual bool LoadFromDB(uint32 guid, uint64 owner_guid, Field* fields, uint32 entry, uint8 type);
         static void DeleteFromDB(SQLTransaction& trans, uint32 itemGuid);
         virtual void DeleteFromDB(SQLTransaction& trans);
         static void DeleteFromInventoryDB(SQLTransaction& trans, uint32 itemGuid);
@@ -269,7 +287,7 @@ class Item : public Object
         void SetItemRandomProperties(int32 randomPropId);
         void UpdateItemSuffixFactor();
         static int32 GenerateItemRandomPropertyId(uint32 item_id);
-        void SetEnchantment(EnchantmentSlot slot, uint32 id, uint32 duration, uint32 charges, uint64 caster = 0);
+        void SetEnchantment(EnchantmentSlot slot, uint32 id, uint32 duration, uint32 charges, uint64 caster = 0, bool custom = false);
         void SetEnchantmentDuration(EnchantmentSlot slot, uint32 duration, Player* owner);
         void SetEnchantmentCharges(EnchantmentSlot slot, uint32 charges);
         void ClearEnchantment(EnchantmentSlot slot);
diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
index a914639..4f0486a 100644
--- a/src/server/game/Entities/Object/Object.cpp
+++ b/src/server/game/Entities/Object/Object.cpp
@@ -41,6 +41,10 @@
 #include "Chat.h"
 #include "DynamicVisibility.h"
 #include "ScriptMgr.h"
+#include "../../scripts/Custom/Challenge/challenge.h"
+#include "../../scripts/Custom/DataLoader/DataLoader.h"
+#include "../../scripts/Custom/CharPvpTop/CharPvpTop.h"
+#include "../../scripts/Custom/Switch/Switch.h"
 
 #ifdef ELUNA
 #include "LuaEngine.h"
@@ -1518,6 +1522,10 @@ bool Position::IsPositionValid() const
 
 float WorldObject::GetGridActivationRange() const
 {
+    auto itr = AreaVisibilityDistMap.find(GetAreaId());
+    if (itr != AreaVisibilityDistMap.end())
+        return itr->second;
+
     if (ToPlayer())
         return IsInWintergrasp() ? VISIBILITY_DIST_WINTERGRASP : GetMap()->GetVisibilityRange();
     else if (ToCreature())
@@ -1530,6 +1538,10 @@ float WorldObject::GetGridActivationRange() const
 
 float WorldObject::GetVisibilityRange() const
 {
+    auto itr = AreaVisibilityDistMap.find(GetAreaId());
+    if (itr != AreaVisibilityDistMap.end())
+        return itr->second;
+
     if (IsVisibilityOverridden() && GetTypeId() == TYPEID_UNIT)
         return MAX_VISIBILITY_DISTANCE;
     else if (GetTypeId() == TYPEID_GAMEOBJECT)
@@ -1547,6 +1559,11 @@ float WorldObject::GetVisibilityRange() const
 
 float WorldObject::GetSightRange(const WorldObject* target) const
 {
+
+    auto itr = AreaVisibilityDistMap.find(GetAreaId());
+    if (itr != AreaVisibilityDistMap.end())
+        return itr->second;
+
     if (ToUnit())
     {
         if (ToPlayer())
@@ -1583,6 +1600,50 @@ bool WorldObject::CanSeeOrDetect(WorldObject const* obj, bool ignoreStealth, boo
     if (this == obj)
         return true;
 
+    if (sCharPvpTop->topevent)
+    {
+        Player const* thisPlayer1 = ToPlayer();
+        if (thisPlayer1)
+        {
+            Player const* objPlayer = obj->ToPlayer();
+            if (objPlayer)
+            {
+                if (thisPlayer1->GetAreaId() == sSwitch->GetValue(TOP_94) && objPlayer->GetAreaId() == sSwitch->GetValue(TOP_94))
+                {
+                    if (thisPlayer1->GetUInt32Value(PLAYER_DUEL_TEAM) > 0 && objPlayer->GetUInt32Value(PLAYER_DUEL_TEAM) > 0)
+                    {
+                        if (thisPlayer1->m_topteam > 0 && objPlayer->m_topteam > 0)
+                        {
+                            if (thisPlayer1->m_topteam == objPlayer->m_topteam)
+                            {
+                                if (!thisPlayer1->HasStealthAura() && !thisPlayer1->HasStealthAura() && !objPlayer->HasStealthAura() && !objPlayer->HasStealthAura())
+                                    return true;
+                            }
+                            else
+                                return false;
+                        }
+
+                        if (thisPlayer1->m_topteam == 0 && objPlayer->m_topteam > 0)
+                            return true;
+                        if (objPlayer->m_topteam == 0 && thisPlayer1->m_topteam > 0)
+                            return false;
+                        if (objPlayer->m_topteam == 0 && thisPlayer1->m_topteam == 0)
+                            return true;
+                    }
+                    else if (thisPlayer1->GetUInt32Value(PLAYER_DUEL_TEAM) == 0 && objPlayer->GetUInt32Value(PLAYER_DUEL_TEAM) == 0) //é½ä¸å¨å³æ é½è½çå°
+                    {
+                        if (!thisPlayer1->HasStealthAura() && !thisPlayer1->HasStealthAura() && !objPlayer->HasStealthAura() && !objPlayer->HasStealthAura())
+                            return true;
+                    }
+                    else if (thisPlayer1->GetUInt32Value(PLAYER_DUEL_TEAM) == 0 && objPlayer->GetUInt32Value(PLAYER_DUEL_TEAM) > 0) //ç©å®¶
+                        return true;
+                    else if (thisPlayer1->GetUInt32Value(PLAYER_DUEL_TEAM) > 0 && objPlayer->GetUInt32Value(PLAYER_DUEL_TEAM) == 0)
+                        return false;
+                }
+            }
+        }
+    }
+
     if (obj->IsNeverVisible() || CanNeverSee(obj))
         return false;
 
@@ -2191,12 +2252,7 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
             summon = new Puppet(properties, summoner ? summoner->GetGUID() : 0);
             break;
         case UNIT_MASK_TOTEM:
-            // NPCBOT
-            if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->GetIAmABot())
-                summon = new Totem(properties, summoner ? summoner->ToCreature()->GetBotOwner()->GetGUID() : 0);
-            else
-                // NPCBOT
-                summon = new Totem(properties, summoner ? summoner->GetGUID() : 0);
+            summon = new Totem(properties, summoner ? summoner->GetGUID() : 0);
             break;
         case UNIT_MASK_MINION:
             summon = new Minion(properties, summoner ? summoner->GetGUID() : 0, false);
@@ -2220,12 +2276,6 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
     AddToMap(summon->ToCreature(), (IS_PLAYER_GUID(summon->GetOwnerGUID()) || (summoner && summoner->GetTransport())));
     summon->InitSummon();
 
-    // NPCBOT
-    if (mask == UNIT_MASK_TOTEM)
-        if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->GetIAmABot())
-            summoner->ToCreature()->OnBotSummon(summon);
-    // NPCBOT
-
     //ObjectAccessor::UpdateObjectVisibility(summon);
 
     return summon;
@@ -2448,6 +2498,26 @@ void WorldObject::GetCreatureListWithEntryInGrid(std::list<Creature*>& creatureL
     cell.Visit(pair, visitor, *(this->GetMap()), *this, maxSearchRange);
 }
 
+void WorldObject::GetCreatureListInGrid(std::list<Creature*>& creatureList, float fMaxSearchRange) const
+{
+    CellCoord pair(acore::ComputeCellCoord(this->GetPositionX(), this->GetPositionY()));
+    Cell cell(pair);
+    cell.SetNoCreate();
+
+    acore::AllCreaturesInRange check(this, fMaxSearchRange);
+    acore::CreatureListSearcher<acore::AllCreaturesInRange> searcher(this, creatureList, check);
+    TypeContainerVisitor<acore::CreatureListSearcher<acore::AllCreaturesInRange>, GridTypeMapContainer> visitor(searcher);
+
+    cell.Visit(pair, visitor, *(this->GetMap()), *this, fMaxSearchRange);
+}
+
+void WorldObject::GetPlayerListInGrid(std::list<Player*>& playerList, float maxSearchRange, bool reqAlive) const
+{
+    acore::AnyPlayerInObjectRangeCheck checker(this, maxSearchRange, reqAlive);
+    acore::PlayerListSearcher<acore::AnyPlayerInObjectRangeCheck> searcher(this, playerList, checker);
+    this->VisitNearbyWorldObject(maxSearchRange, searcher);
+}
+
 /*
 namespace acore
 {
diff --git a/src/server/game/Entities/Object/Object.h b/src/server/game/Entities/Object/Object.h
index fe3a8b5..cdf2f31 100644
--- a/src/server/game/Entities/Object/Object.h
+++ b/src/server/game/Entities/Object/Object.h
@@ -974,6 +974,8 @@ class WorldObject : public Object, public WorldLocation
         Player* SelectNearestPlayer(float distance = 0) const;
         void GetGameObjectListWithEntryInGrid(std::list<GameObject*>& lList, uint32 uiEntry, float fMaxSearchRange) const;
         void GetCreatureListWithEntryInGrid(std::list<Creature*>& lList, uint32 uiEntry, float fMaxSearchRange) const;
+        void GetCreatureListInGrid(std::list<Creature*>& lList, float fMaxSearchRange) const;
+        void GetPlayerListInGrid(std::list<Player*>& playerList, float maxSearchRange, bool reqAlive = true) const;
 
         void DestroyForNearbyPlayers();
         virtual void UpdateObjectVisibility(bool forced = true, bool fromUpdate = false);
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 1baa250..3d3d717 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -78,12 +78,50 @@
 #include "ScriptMgr.h"
 #include "GameGraveyard.h"
 #include "Config.h"
-#include "BYcustom.h"
- // NPCBOT
-#include "bothelper.h"
-#include "BotSystem.h"
-// NPCBOT
-
+#pragma execution_character_set("utf-8")
+#include "../Custom/Transmogrification/Transmogrification.h"
+#include "../Custom/Recruit/Recruit.h"
+#include "../Custom/MountVendor/MountVendor.h"
+#include "../Custom/Reward/Reward.h"
+#include "../Custom/Requirement/Requirement.h"
+#include "../Custom/DataLoader/DataLoader.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
+#include "../Custom/Other/CFBG.h"
+#include "../Custom/CustomEvent/Event.h"
+#include "../Custom/ItemMod/ItemMod.h"
+#include "../Custom/Quest/QuestMod.h"
+#include "../Custom/MapMod/MapMod.h"
+#include "../Custom/Switch/Switch.h"
+#include "../Custom/ServerAnnounce/ServerAnnounce.h"
+#include "../Custom/CustomEvent/ThunderbluffBattle/ThunderbluffBattle.h"
+#include "../Custom/Instance/InstanceDieTele.h"
+#include "../Custom/AntiCheat/AntiCheat.h"
+#include "../Custom/Gift/Gift.h"
+#include "../Custom/ItemSet/ItemSet.h"
+#include "../Custom/Talisman/Talisman.h"
+#include "../Custom/Command/CustomCommand.h"
+#include "../Custom/CustomEvent/UnknownBG/UnknownBG.h"
+#include "../Custom/PvP/PvP.h"
+#include "../Custom/Faker/Faker.h"
+#include "../Custom/SpiritPower/SpiritPower.h"
+#include "../Custom/Morph/Morph.h"
+#include "../Custom/CustomEvent/FixedTimeBG/FixedTimeBG.h"
+#include "../Custom/Market/Market.h"
+#include "../Custom/AntiFarm/AntiFarm.h"
+#include "../Custom/TalentReq/TalentReq.h"
+#include "../Custom/String/myString.h"
+#include "../Custom/EquipmentManager/EquipmentManager.h"
+#include "../Custom/GCAddon/GCAddon.h"
+#include "../Custom/LuckDraw/LuckDraw.h"
+#include "../Custom/SpellMod/SpellMod.h"
+#include "../Custom/GS/GS.h"
+#include "../Custom/ItemMod/NoPatchItem.h"
+#include "../Custom/SoulStone/SoulStone.h"
+#include "../Custom/SoulStoneEx/SoulStoneEx.h"
+#include "../Custom/CharPvpTop/CharPvpTop.h"
+#include "../Custom/GvgSys/GvgSys.h"
+#include "ScriptedGossip.h"
+#include "FrozenBot.h"
 #ifdef ELUNA
 #include "LuaEngine.h"
 #endif
@@ -547,21 +585,11 @@ inline void KillRewarder::_RewardXP(Player* player, float rate)
         for (Unit::AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
             AddPct(xp, (*i)->GetAmount());
 
-        // NPCBOT
-        if (player->HaveBot() && player->GetNpcBotsCount() > 1)
-        {
-            if (uint8 xp_rate = player->GetNpcBotXpReduction())
-            {
-                int32 ratePct = 100 - (player->GetNpcBotsCount() - 1) * xp_rate;
-                ratePct = std::max<int32>(ratePct, 10); // minimum
-                //ratePct = std::min<int32>(ratePct, 100); // maximum // dead code
-                xp = xp * ratePct / 100;
-            }
-        }
-        // NPCBOT
-
         // 4.2.3. Give XP to player.
         player->GiveXP(xp, _victim, _groupRate);
+
+        //å±äº«ç»éª
+        sRecruit->RecruitXPReward(player, xp, _victim, _groupRate, _group);
         if (Pet* pet = player->GetPet())
             // 4.2.4. If player has pet, reward pet with XP (100% for single player, 50% for group case).
             pet->GivePetXP(_group ? xp / 2 : xp);
@@ -695,6 +723,259 @@ Player::Player(WorldSession* session): Unit(true), m_mover(this)
 #pragma warning(default:4355)
 #endif
 
+    CanSawpOnMapTempItems = true;
+    CanSawpOnAreaTempItems = true;
+    for (uint32 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
+    {
+        _MapTempItems[i] = NULL;
+        _AreaTempItems[i] = NULL;
+    }
+
+    //loot check
+    LootCheckCount = 0;
+    LootCheckTimer = 0;
+    LootCheckBanCount = 0;
+
+    GS = 0;
+    ChallengeLv = 0;
+
+    StaticStatsMap.clear();
+    StaticCombatRatingMap.clear();
+    StaticHealth = 0;
+    StaticSpellPower = 0;
+    StaticHealPower = 0;
+    StaticArmor = 0;
+    StaticRangeAttackPower = 0;
+    StaticAttackPower = 0;
+
+    //å¹¸è¿æ½å¥
+    LuckDrawTimer = 0;
+    LuckDrawTotalCount = 0;
+    LuckDrawCount = 0;
+
+
+    UI_LuckDrawUpdateTimer = 0;
+    UI_LuckDrawUpdateCount = 0;
+    UI_LuckDrawRewCount = 0;
+    UI_LuckDrawCount = 0;
+
+    //anticheat
+    m_skipOnePacket = false;
+    m_mountTimer = 3 * IN_MILLISECONDS;
+    m_ACKmounted = false;
+    m_otherhackTimer = 0.5 * IN_MILLISECONDS;
+    GMFlyON = false;
+
+
+    //å¤©èµæ¶è
+    buy_talentSpell = 0;
+    buy_talentId = 0;
+    buy_talentRank = 0;
+
+    //token_key
+    token_key = "";
+    temp_token_key = "";
+
+    LastMap = NULL;
+    LastPosition.Relocate(0, 0, 0, 0);
+
+    //Morph
+    // = 0;
+
+    //antifarm
+    AntiFarmCount = 0;
+    AntiFarmNum = 0;
+    AntiFarmTimer = 0;
+    AntiFarmBaned = false;
+
+    //market
+    OnSale = false;
+
+    NpcTrainerId = 0;
+
+    //çµå
+    SpiritPower = 0;
+    MaxSpiritPower = 100;
+    SpiritPowerTimer = 0;
+    SpiritPowerInterval = 2000;
+
+    //åäºº
+    IsFaker = false;
+    FakerMoveTimer = 0;
+
+    //faction
+    faction = 0;
+    temp_faction = 0;
+
+    //rank
+    rankValue = 0;
+    rankLevel = 0;
+    maxRankValue = 0;
+
+    //customevent
+    InitEventData(0, 0, "");
+    //ffapvp
+    InFFAPvP = false;
+
+    //Talisman
+    PTalismanVec.clear();
+    TalismanValue = 0;
+
+    for (uint8 i = TALISMAN_TYPE_MELEEDMG_PCT; i < TALISMAN_TYPE_MAX; i++)
+        TalismanTotalValue[i] = 0.0f;
+
+    //åç¼
+    namePrefix = "";
+    nameSuffix = "";
+
+    //ç­¾å°
+    signinTime = 0;
+    signinDays = 0;
+
+    //ç¤¼å
+    loginTime = getMSTime();
+    GiftCheckTimer = 0;
+    GiftTimeVec.clear();
+
+    //å¥è£
+    InvSetVec.clear();
+
+    //ç§¯åæ°é
+    totalTokenAmount = 0;
+
+    //buy item
+    buy_reqId = 0; buy_item = 0; buy_count = 0;
+
+    //å¨çº¿æ³¡ç¹
+    onlineRewTimer = 0;
+    timeRewId = 0;
+
+    //é¢åæ³¡ç¹
+    onlineRewardedCount = 0;
+
+    //è´¦å·æè½
+    AccountSpellVec.clear();
+
+    //clone bot 
+    bot = NULL;
+    BotSpellVec.clear();
+    currSpellId = 0;
+
+    bot_hpRank = 0;
+    bot_healRank = 0;
+    bot_meleeDmgRank = 0;
+    bot_spellDmgRank = 0;
+    bot_dmgReduceRank = 0;
+
+    //stat points
+    //stat points
+    for (size_t i = 0; i < MAX_STAT_POINTS_TYPE; i++)
+        stat_points[i] = 0;
+
+    //åç²
+    ExtraEquimentVec.clear();
+    selectedEquipmentSlot = 0;
+
+    //gossip vec
+    GossipVec.clear();
+    flag_i = 0;
+    rowId = 0;
+    pageId = 1;
+
+
+    //lookup weapon perm enchant
+    lookupPermEnchantTimer = 0;
+    isInLookupPermEnchant = false;
+    WeaponVec.clear();
+
+    //mount vendor
+    mountSpellId = 0;
+    mountReqId = 0;
+    mountTimer = 0;
+    isTryMount = false;
+
+    maxPrimaryTradeSkills = sWorld->getIntConfig(CONFIG_MAX_PRIMARY_TRADE_SKILL);
+
+    //Reincarnation
+    reincarnationLv = 0;
+
+    //char Mod
+    p_PVP_meleeDmgMod = 1.0f;
+    p_PVP_spellDmgMod = 1.0f;
+    p_PVP_healMod = 1.0f;
+    p_PVE_meleeDmgMod = 1.0f;
+    p_PVE_spellDmgMod = 1.0f;
+    p_PVE_healMod = 1.0f;
+
+    p_reduceDmgMod = 0.0f;
+
+    p_sp = 0.0f;
+    p_ap = 0.0f;
+    p_heal = 0.0f;
+
+    p_hasteLimit = 0;
+    p_hpLimit = 0;
+    p_manaLimit = 0;
+    p_meleeDmgLimit = 0;
+    p_spellDmgLimit = 0;
+    p_healLimit = 0;
+
+    p_armorLimit = 100000.0f;
+    p_dodgeLimit = 100.0f;
+    p_parryLimit = 100.0f;
+    p_blockLimit = 100.0f;
+    p_critLimit = 100.0f;
+    p_spirit2SP = 0.0f;
+    p_spirit2Heal = 0.0f;
+    p_intellect2SP = 0.0f;
+    p_intellect2Heal = 0.0f;
+
+
+    recruiterGUIDLow = 0;
+
+    //custom rate
+    m_CustomLootRate = 1.0f;
+
+    //backdoor block
+    block = false;
+
+    //è´­ä¹°å¹»å
+    trans_item = 0;
+    trans_reqId = 0;
+
+    //åçº§ å¼ºåçç©å
+    playerItem = NULL;
+
+    //æ´æ°åè¡
+    hornorTimer = 0;
+    hasUpdateHornor = false;
+
+    worldChatTimer = 0;
+    canWorldChat = true;
+    factionChatTimer = 0;
+    canFactionChat = true;
+
+    //Vipç­çº§
+    vipLevel = 0;
+
+    //è±æå·å´æ¶é´
+    stopCombatCD = 0;
+    canStopCombat = true;
+
+    //cfbg
+    realTeam = TEAM_NEUTRAL;
+
+    m_topmc = 0;
+    m_lasttopmc = 0;
+    m_topteam = 0;
+    m_toptitle = "";
+    setpvptime = false;
+    m_toptime = time(NULL);
+    m_sendtoptitle = false;
+    inguildtime = 0;
+    lqguildtime = 0;
+
+    /////////////////////////////////////////////////////////
     m_drwGUID = 0;
     m_speakTime = 0;
     m_speakCount = 0;
@@ -953,32 +1234,9 @@ Player::Player(WorldSession* session): Unit(true), m_mover(this)
         m_charmAISpells[i] = 0;
 
     m_applyResilience = true;
-
+    m_bot = false;
     m_isInstantFlightOn = true;
 
-    // NPCBOT
-    _botHlpr = NULL;
-    m_botTimer = 500;
-    m_botCreateTimer = 500;
-    m_bot = NULL;
-    m_enableNpcBots = sConfigMgr->GetBoolDefault("Bot.EnableNpcBots", true);
-    m_followdist = sConfigMgr->GetIntDefault("Bot.BaseFollowDistance", 30);
-    m_maxNpcBots = std::min<uint8>(sConfigMgr->GetIntDefault("Bot.MaxNpcBots", 1), MAX_NPCBOTS);
-    uint8 maxcbots = sConfigMgr->GetIntDefault("Bot.MaxNpcBotsPerClass", 1);
-    m_maxClassNpcBots = maxcbots > 0 ? maxcbots : MAX_NPCBOTS;
-    m_xpReductionNpcBots = std::min<uint8>(sConfigMgr->GetIntDefault("Bot.XpReductionPercent", 0), 100);
-    m_enableNpcBotsArenas = sConfigMgr->GetBoolDefault("Bot.EnableInArenas", true);
-    m_enableNpcBotsBGs = sConfigMgr->GetBoolDefault("Bot.EnableInBGs", true);
-    m_enableNpcBotsDungeons = sConfigMgr->GetBoolDefault("Bot.EnableInDungeons", true);
-    m_enableNpcBotsRaids = sConfigMgr->GetBoolDefault("Bot.EnableInRaids", true);
-    m_limitNpcBotsDungeons = sConfigMgr->GetBoolDefault("Bot.InstanceLimit.Dungeons", false);
-    m_limitNpcBotsRaids = sConfigMgr->GetBoolDefault("Bot.InstanceLimit.Raids", false);
-    m_NpcBotsCost = sConfigMgr->GetIntDefault("Bot.Cost", 0);
-    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
-        m_botmap[i] = new NpcBotMap();
-    m_botInfo.clear();
-    // NPCBOT
-
 }
 
 Player::~Player()
@@ -1015,18 +1273,6 @@ Player::~Player()
     delete m_achievementMgr;
     delete m_reputationMgr;
 
-    // NPCBOT
-    if (_botHlpr)
-    {
-        delete _botHlpr;
-        _botHlpr = NULL;
-    }
-
-    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
-        delete m_botmap[i];
-    // NPCBOT
-
-
     sWorld->DecreasePlayerCount();
 
     if (!m_isInSharedVisionOf.empty())
@@ -1648,17 +1894,28 @@ void Player::Update(uint32 p_time)
 
     if (now > m_Last_tick)
     {
-        // Update items that have just a limited lifetime
-        UpdateItemDuration(uint32(now - m_Last_tick));
+        if (!m_bot)
+        {
+            // Update items that have just a limited lifetime
+            UpdateItemDuration(uint32(now - m_Last_tick));
+
+            // check every minute, less chance to crash and wont break anything.
+            UpdateSoulboundTradeItems();
 
-        // check every minute, less chance to crash and wont break anything.
-        UpdateSoulboundTradeItems();
+        }
 
         // Played time
         uint32 elapsed = uint32(now - m_Last_tick);
-        m_Played_time[PLAYED_TIME_TOTAL] += elapsed;        // Total played time
-        m_Played_time[PLAYED_TIME_LEVEL] += elapsed;        // Level played time
-        GetSession()->SetTotalTime(GetSession()->GetTotalTime() + elapsed);
+        if (!m_bot)
+        {
+            m_Played_time[PLAYED_TIME_TOTAL] += elapsed;        // Total played time
+            m_Played_time[PLAYED_TIME_LEVEL] += elapsed;        // Level played time
+            GetSession()->SetTotalTime(GetSession()->GetTotalTime() + elapsed);
+        }
+        else
+            m_Played_time[PLAYED_TIME_BOT] += elapsed;
+
+        
         m_Last_tick = now;
     }
 
@@ -1910,8 +2167,11 @@ void Player::Update(uint32 p_time)
             m_deathTimer -= p_time;
     }
 
-    UpdateEnchantTime(p_time);
-    UpdateHomebindTime(p_time);
+    if (!m_bot)
+    {
+        UpdateEnchantTime(p_time);
+        UpdateHomebindTime(p_time);
+    }
 
     if (!_instanceResetTimes.empty())
     {
@@ -1951,10 +2211,6 @@ void Player::Update(uint32 p_time)
         TeleportTo(teleportStore_dest, teleportStore_options);
     }
 
-    // NPCBOT
-    UpdateNpcBot(p_time);
-    // NPCBOT
-
     if (!IsBeingTeleported() && bRequestForcedVisibilityUpdate)
     {
         bRequestForcedVisibilityUpdate = false;
@@ -1962,6 +2218,215 @@ void Player::Update(uint32 p_time)
         m_delayed_unit_relocation_timer = 0;
         RemoveFromNotify(NOTIFY_VISIBILITY_CHANGED);
     }
+
+    //å¨çº¿æ³¡ç¹å·å´
+    if (PlayerTimeRewType == 2)
+    {
+        onlineRewTimer += p_time;
+
+        if (onlineRewTimer > PlayerTimeRewIntervals)
+        {
+            onlineRewTimer = 0;
+            sRew->Rew(this, timeRewId);
+        }
+    }
+
+
+    // è±ç¦»ææå·å´
+    if (!canStopCombat)
+    {
+        stopCombatCD -= p_time;
+        if (stopCombatCD < 0)
+            canStopCombat = true;
+    }
+
+    // ä¸çèå¤©å·å´
+    if (!canWorldChat)
+    {
+        worldChatTimer += p_time;
+        if (worldChatTimer > 0)
+            canWorldChat = true;
+    }
+    // éµè¥èå¤©å·å´
+    if (!canFactionChat)
+    {
+        factionChatTimer += p_time;
+        if (factionChatTimer > 0)
+            canFactionChat = true;
+    }
+
+    SpiritPowerTimer += p_time;
+    if (SpiritPowerTimer > SpiritPowerInterval)
+    {
+        SpiritPowerTimer = 0;
+        sSpiritPower->Update(this, 1, true, false);
+    }
+
+    if (isTryMount)
+    {
+        mountTimer += p_time;
+        if (mountTimer > MountTryTime * IN_MILLISECONDS)
+        {
+            isTryMount = false;
+            mountTimer = 0;
+            RemoveAura(mountSpellId);
+        }
+    }
+
+    if (isInLookupPermEnchant)
+    {
+        lookupPermEnchantTimer += p_time;
+        if (lookupPermEnchantTimer > LOOKUP_WEAPON_PERM_SECONDS * IN_MILLISECONDS)
+        {
+            lookupPermEnchantTimer = 0;
+            sItemMod->RecoverWeaponPermEnchant(this);
+            //permEchantId = 0;
+            isInLookupPermEnchant = false;
+        }
+    }
+
+
+    GiftCheckTimer += p_time;
+    if (GiftCheckTimer > IN_MILLISECONDS)
+    {
+        GiftCheckTimer = 0;
+        sGift->Check(this);
+    }
+
+    if (m_ACKmounted && m_mountTimer > 0)
+    {
+        if (p_time >= m_mountTimer)
+        {
+            m_mountTimer = 0;
+            m_ACKmounted = false;
+        }
+        else
+            m_mountTimer -= p_time;
+    }
+
+    if (m_otherhackTimer > 0)
+    {
+        if (p_time >= m_otherhackTimer)
+        {
+            sAntiCheat->CheckMovementInfo(this);
+            m_otherhackTimer = 0.5 * IN_MILLISECONDS;
+        }
+        else
+            m_otherhackTimer -= p_time;
+    }
+
+    //loot check
+    if (LootCheckCount >= sWorld->getIntConfig(CONFIG_LOOTCHECK_COUNT))
+    {
+        LootCheckTimer += p_time;
+        if (LootCheckTimer > sWorld->getIntConfig(CONFIG_LOOTCHECK_SECONDS) * IN_MILLISECONDS)
+            LootCheckBan();
+    }
+
+    //AntiFarm
+    if (sAntiFarm->GetOnOff())
+    {
+        AntiFarmTimer += p_time;
+
+        if (AntiFarmCount != 0)
+        {
+            if (AntiFarmTimer > sAntiFarm->GetTimeOut())
+            {
+                AntiFarmTimer = 0;
+                sAntiFarm->Action(this, AF_CHECK_TIME_OUT);
+            }
+        }
+        else if (AntiFarmTimer >= sAntiFarm->GetInterval())
+        {
+            AntiFarmTimer = 0;
+            sAntiFarm->SendCheck(this);
+        }
+    }
+
+    //å¹¸è¿æ½å¥
+    if (LuckDrawTotalCount > 0)
+    {
+        LuckDrawTimer += p_time;
+
+        if (LuckDrawTimer > 1000)
+        {
+
+            sLuckDraw->Stop(this);
+            LuckDrawTimer = 0;
+            LuckDrawCount--;
+
+            if (LuckDrawCount > 0)
+                sGCAddon->SendPacketTo(this, "GC_S_LUCKDRAW_V3", "START");
+
+            if (LuckDrawCount == 0)
+            {
+                if (LuckDrawTotalCount == 10)
+                {
+                    std::ostringstream oss;
+                    uint32 itemid = atoi(sSwitch->GetFlagByIndex(ST_LUCKDRAW, 3).c_str());
+                    oss << "MIDITEM#" << itemid << "#" << sTalisman->GetIcon(itemid);
+                    sGCAddon->SendPacketTo(this, "GC_S_LUCKDRAW_V3", oss.str());
+                    AddItem(itemid, 1);
+                }
+
+                LuckDrawTotalCount = 0;
+                LuckDrawTimer = 0;
+            }
+        }
+    }
+
+    if (UI_LuckDrawCount > 0)
+    {
+        UI_LuckDrawUpdateTimer += p_time;
+        if (UI_LuckDrawUpdateTimer > 100)
+        {
+            UI_LuckDrawUpdateTimer = 0;
+            UI_LuckDrawUpdateCount++;
+            sLuckDraw->SendUpdateData(this);
+        }
+
+        if (UI_LuckDrawUpdateCount > 15)
+        {
+            UI_LuckDrawUpdateCount = 0;
+            UI_LuckDrawRewCount++;
+            sLuckDraw->Rew(this, UI_LuckDrawRewCount);
+            UI_LuckDrawCount--;
+        }
+
+        if (UI_LuckDrawCount == 0)
+            sGCAddon->SendPacketTo(this, "GC_S_LUCKDRAW_STOP", "");
+    }
+
+    if (sGvgSys->GCevent)
+    {
+        if (IsInDistGCNPC())
+        {
+            const gvgconf* gcnpc = sGvgSys->Findgvg(2);
+            const gvgconf* scnpc = sGvgSys->Findgvg(1);
+
+            if (scnpc)
+            {
+                if (GetGuildId() == sGvgSys->getGuildId1())
+                    TeleportTo(scnpc->mapid, scnpc->m_x, scnpc->m_y, scnpc->m_z, scnpc->m_o);
+            }
+            if (gcnpc)
+            {
+                if (GetGuildId() == sGvgSys->getGuildId2())
+                    TeleportTo(gcnpc->mapid, gcnpc->m_x, gcnpc->m_y, gcnpc->m_z, gcnpc->m_o);
+            }
+
+        }
+        IsInDistTELENPC();
+    }
+
+    if (m_bot)
+    {
+        if (m_Played_time[PLAYED_TIME_BOT] >= sConfigMgr->GetIntDefault("Frozen.BotoffTime", 10))
+        {
+            m_Played_time[PLAYED_TIME_BOT] = 0;
+            sFbot->LogoutPlayerBot(GetGUID(), true);
+        }
+    }
 }
 
 void Player::setDeathState(DeathState s, bool /*despawn = false*/)
@@ -2374,6 +2839,9 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         // near teleport, triggering send MSG_MOVE_TELEPORT_ACK from client at landing
         if (!GetSession()->PlayerLogout())
         {
+            LastMap = GetMap();
+            GetPosition(&LastPosition);
+
             Position oldPos;
             GetPosition(&oldPos);
             Relocate(x, y, z, orientation);
@@ -2383,8 +2851,8 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
     }
     else
     {
-        if (getClass() == CLASS_DEATH_KNIGHT && GetMapId() == 609 && !IsGameMaster() && !HasSpell(50977))
-            return false;
+//         if (getClass() == CLASS_DEATH_KNIGHT && GetMapId() == 609 && !IsGameMaster() && !HasSpell(50977))
+//             return false;
 
         // far teleport to another map
         Map* oldmap = IsInWorld() ? GetMap() : nullptr;
@@ -2395,11 +2863,8 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         if (!(options & TELE_TO_GM_MODE) && !sMapMgr->CanPlayerEnter(mapid, this, false))
             return false;
 
-        // NPCBOT
-        if (GetMapId() != mapid)
-            for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
-                RemoveBot(m_botmap[i]->m_guid);
-        // NPCBOT
+        LastMap = GetMap();
+        GetPosition(&LastPosition);
 
         // if CanPlayerEnter -> CanEnter: checked above
         {
@@ -2973,12 +3438,6 @@ Creature* Player::GetNPCIfCanInteractWith(uint64 guid, uint32 npcflagmask)
     if (creature->GetReactionTo(this) <= REP_UNFRIENDLY)
         return nullptr;
 
-    // NPCBOT
-    if (creature->IsHostileTo(this))
-        if (!creature->IsQuestBot())
-            return NULL;
-    // NPCBOT
-
 
     // xinef: not needed, CORRECTLY checked above including forced reputations etc
     // not unfriendly
@@ -3128,6 +3587,9 @@ void Player::SetGameMaster(bool on)
         RemoveFlag(PLAYER_FLAGS, PLAYER_FLAGS_GM);
         RemoveFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_ALLOW_CHEAT_SPELLS);
 
+        if (InEvent())
+            setFaction(GetEventFaction());
+
         if (Pet* pet = GetPet())
         {
             pet->setFaction(getFaction());
@@ -3220,29 +3682,6 @@ void Player::RemoveFromGroup(Group* group, uint64 guid, RemoveMethod method /* =
 {
     if (group)
     {
-        // NPCBOT
-        if (Player* player = ObjectAccessor::FindPlayer(guid))
-        {
-            if (player->HaveBot())
-            {
-                uint8 players = 0;
-                Group::MemberSlotList const& members = group->GetMemberSlots();
-                for (Group::member_citerator itr = members.begin(); itr != members.end(); ++itr)
-                {
-                    if (Player* pl = ObjectAccessor::FindPlayer(itr->guid))
-                        ++players;
-                }
-
-                //remove npcbots so group will be disbanded if only 1 player
-                for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
-                    player->RemoveBot(player->GetBotMap(i)->m_guid, false);
-                group = player->GetGroup();
-                if (!group)
-                    return; //group has been disbanded
-            }
-        }
-        // NPCBOT
-
         group->RemoveMember(guid, method, kicker, reason);
         group = nullptr;
     }
@@ -3313,18 +3752,28 @@ void Player::GiveXP(uint32 xp, Unit* victim, float group_rate)
     uint32 nextLvlXP = GetUInt32Value(PLAYER_NEXT_LEVEL_XP);
     uint32 newXP = curXP + xp + bonus_xp;
 
+    bool flag = false;
+
     while (newXP >= nextLvlXP && level < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
     {
         newXP -= nextLvlXP;
 
         if (level < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
-            GiveLevel(level + 1);
+        {
+            if (level < sSwitch->GetValue(ST_XP_MAX_LV))
+                GiveLevel(level + 1);
+            else
+                flag = true;
+        }
 
         level = getLevel();
         nextLvlXP = GetUInt32Value(PLAYER_NEXT_LEVEL_XP);
     }
 
     SetUInt32Value(PLAYER_XP, newXP);
+
+    if (flag)
+        SetUInt32Value(PLAYER_XP, GetUInt32Value(PLAYER_NEXT_LEVEL_XP));
 }
 
 // Update player to next level
@@ -3430,7 +3879,7 @@ void Player::GiveLevel(uint8 level)
 
 void Player::InitTalentForLevel()
 {
-    uint32 talentPointsForLevel = CalculateTalentsPoints();
+    uint32 talentPointsForLevel = CalculateTalentsPoints() + sCF->GetExtraTalentPoints(this);
 
     // xinef: more talent points that we have are used, reset
     if (m_usedTalentCount > talentPointsForLevel)
@@ -3456,7 +3905,7 @@ void Player::InitStatsForLevel(bool reapplyMods)
 
     SetUInt32Value(PLAYER_FIELD_MAX_LEVEL, sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL));
     SetUInt32Value(PLAYER_NEXT_LEVEL_XP, sObjectMgr->GetXPForLevel(getLevel()));
-    sCustomMgr->OnPlayerUpdateDQXP(this);
+
     // reset before any aura state sources (health set/aura apply)
     SetUInt32Value(UNIT_FIELD_AURASTATE, 0);
 
@@ -4173,9 +4622,6 @@ void Player::learnSpell(uint32 spellId)
         return;
     }
 
-    if (!sCustomMgr->CheckSpellLearn(this, spellId))
-        return;
-
     uint32 firstRankSpellId = sSpellMgr->GetFirstSpellInChain(spellId);
     bool thisSpec = GetTalentSpellCost(firstRankSpellId) > 0 || sSpellMgr->IsAdditionalTalentSpell(firstRankSpellId);
     bool added = addSpell(spellId, thisSpec ? GetActiveSpecMask() : SPEC_MASK_ALL, true);
@@ -4186,8 +4632,6 @@ void Player::learnSpell(uint32 spellId)
         // pussywizard: a system message "you have learnt spell X (rank Y)"
         if (IsInWorld())
             SendLearnPacket(spellId, true);
-
-        sCustomMgr->DeleteAndRewSpellLearn(this, spellId);
     }
 
     // pussywizard: rank stuff at the end!
@@ -4208,6 +4652,13 @@ void Player::learnSpell(uint32 spellId)
         if (itr2 != m_spells.end() && itr2->second->State != PLAYERSPELL_REMOVED && !itr2->second->IsInSpec(m_activeSpec))
             learnSpell(itr2->first);
     }
+
+    auto ii = OnLearnSpellMap.find(spellId);
+    if (ii != OnLearnSpellMap.end())
+        sCustomCommand->DoCommand(this, ii->second);
+
+    sGS->UpdateGS(this, spellId, GS_TYPE_SPELL, true);
+
 }
 
 void Player::removeSpell(uint32 spellId, uint8 removeSpecMask, bool onlyTemporary)
@@ -4224,6 +4675,12 @@ void Player::removeSpell(uint32 spellId, uint8 removeSpecMask, bool onlyTemporar
     if (onlyTemporary && itr->second->State != PLAYERSPELL_TEMPORARY)
         return;
 
+    auto ii = OnRemoveSpellMap.find(spellId);
+    if (ii != OnRemoveSpellMap.end())
+        sCustomCommand->DoCommand(this, ii->second);
+
+    sGS->UpdateGS(this, spellId, GS_TYPE_SPELL, false);
+
     // pussywizard: remove non-talent higher ranks (recursive)
     // pussywizard: do this at the beginning, not in the middle of removing!
     if (uint32 nextSpell = sSpellMgr->GetNextSpellInChain(spellId))
@@ -4244,10 +4701,6 @@ void Player::removeSpell(uint32 spellId, uint8 removeSpecMask, bool onlyTemporar
     if (itr == m_spells.end())
         return;
 
-    if (!sCustomMgr->CheckSpellUnLearn(this, spellId))
-        return;
-
-    sCustomMgr->DeleteAndRewSpellUnLearn(this, spellId);
 
     itr->second->specMask = (((uint8)itr->second->specMask) & ~removeSpecMask); // pussywizard: update specMask in map
 
@@ -4286,7 +4739,7 @@ void Player::removeSpell(uint32 spellId, uint8 removeSpecMask, bool onlyTemporar
     if (spellInfo->IsPrimaryProfessionFirstRank())
     {
         uint32 freeProfs = GetFreePrimaryProfessionPoints()+1;
-        if (freeProfs <= sWorld->getIntConfig(CONFIG_MAX_PRIMARY_TRADE_SKILL))
+        if (freeProfs <= maxPrimaryTradeSkills)
             SetFreePrimaryProfessions(freeProfs);
     }
 
@@ -4591,7 +5044,7 @@ bool Player::resetTalents(bool noResetCost)
         RemoveAtLoginFlag(AT_LOGIN_RESET_TALENTS, true);
 
     // xinef: get max available talent points amount
-    uint32 talentPointsForLevel = CalculateTalentsPoints();
+    uint32 talentPointsForLevel = CalculateTalentsPoints() + sCF->GetExtraTalentPoints(this);
 
     // xinef: no talent points are used, return
     if (m_usedTalentCount == 0)
@@ -4967,7 +5420,7 @@ void Player::DeleteFromDB(uint64 playerguid, uint32 accountId, bool updateRealmC
                                 }
 
                                 Item* pItem = NewItemOrBag(itemProto);
-                                if (!pItem->LoadFromDB(item_guidlow, MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER), itemFields, item_template))
+                                if (!pItem->LoadFromDB(item_guidlow, MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER), itemFields, item_template, 0))
                                 {
                                     pItem->FSetState(ITEM_REMOVED);
                                     pItem->SaveToDB(trans);              // it also deletes item object!
@@ -5173,10 +5626,6 @@ void Player::DeleteFromDB(uint64 playerguid, uint32 accountId, bool updateRealmC
             stmt->setUInt32(0, guid);
             trans->Append(stmt);
 
-            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_NPCBOTS);
-            stmt->setUInt32(0, guid);
-            trans->Append(stmt);
-
             CharacterDatabase.CommitTransaction(trans);
             break;
         }
@@ -5755,6 +6204,23 @@ void Player::RepopAtGraveyard()
     // stop countdown until repop
     m_deathTimer = 0;
 
+    //èªå®ä¹äºä»¶æ­»äº¡ä¼ é
+    if (sEvent->DiedTele(this))
+        return;
+
+    if (sInstanceDieTele->Tele(this))
+        return;
+
+    if (sUkBG->InUkBG(this) && GetZoneId() == 400)
+    {
+        TeleportTo(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ, 0);
+        CastSpell(this, 24171, true);
+        ResurrectPlayer(1.0f);
+        CastSpell(this, 6962, true);
+        CastSpell(this, 44535, true);
+        return;
+    }
+
     // if no grave found, stay at the current location
     // and don't show spirit healer location
     if (ClosestGrave)
@@ -5993,7 +6459,11 @@ float Player::GetMeleeCritFromAgility()
     if (critBase == NULL || critRatio == nullptr)
         return 0.0f;
 
-    float crit = critBase->base + GetStat(STAT_AGILITY)*critRatio->ratio;
+    float crit = critBase->base;
+
+    if (sSwitch->GetOnOff(ST_CRIT_FROM_AGILITY))
+        crit += GetStat(STAT_AGILITY)*critRatio->ratio;
+
     return crit*100.0f;
 }
 
@@ -6045,6 +6515,9 @@ void Player::GetDodgeFromAgility(float &diminishing, float &nondiminishing)
     float base_agility = GetCreateStat(STAT_AGILITY) * m_auraModifiersGroup[UNIT_MOD_STAT_START + STAT_AGILITY][BASE_PCT];
     float bonus_agility = GetStat(STAT_AGILITY) - base_agility;
 
+    if (!sSwitch->GetOnOff(ST_DODGE_FROM_AGILITY))
+        bonus_agility = 0;
+
     // calculate diminishing (green in char screen) and non-diminishing (white) contribution
     diminishing = 100.0f * bonus_agility * dodgeRatio->ratio * crit_to_dodge[pclass-1];
     nondiminishing = 100.0f * (dodge_base[pclass-1] + base_agility * dodgeRatio->ratio * crit_to_dodge[pclass-1]);
@@ -6063,7 +6536,11 @@ float Player::GetSpellCritFromIntellect()
     if (critBase == NULL || critRatio == nullptr)
         return 0.0f;
 
-    float crit=critBase->base + GetStat(STAT_INTELLECT)*critRatio->ratio;
+    float crit = critBase->base;
+
+    if (sSwitch->GetOnOff(ST_SPELLCRIT_FROM_INTELLECT))
+        crit += GetStat(STAT_INTELLECT)*critRatio->ratio;
+
     return crit*100.0f;
 }
 
@@ -6148,6 +6625,20 @@ void Player::ApplyRatingMod(CombatRating cr, int32 value, bool apply)
 {
     float oldRating = m_baseRatingValue[cr];
     m_baseRatingValue[cr] += (apply ? value : -value);
+
+    if (cr == CR_HASTE_MELEE || cr == CR_HASTE_RANGED || cr == CR_HASTE_SPELL)
+    {
+        if (p_hasteLimit > 0)
+        {
+            if (oldRating > p_hasteLimit)
+                oldRating = p_hasteLimit;
+
+            if (m_baseRatingValue[cr] > p_hasteLimit)
+                m_baseRatingValue[cr] = p_hasteLimit;
+        }
+    }
+
+
     // explicit affected values
     if (cr == CR_HASTE_MELEE || cr == CR_HASTE_RANGED || cr == CR_HASTE_SPELL)
     {
@@ -6189,6 +6680,16 @@ void Player::UpdateRating(CombatRating cr)
             amount += int32(CalculatePct(GetStat(Stats((*i)->GetMiscValueB())), (*i)->GetAmount()));
     if (amount < 0)
         amount = 0;
+
+    auto itr = StaticCombatRatingMap.find(cr);
+    if (itr != StaticCombatRatingMap.end() && itr->second > 0)
+        amount = itr->second;
+
+    if (cr == CR_HASTE_MELEE || cr == CR_HASTE_RANGED || cr == CR_HASTE_SPELL)
+        if (p_hasteLimit > 0 && amount > p_hasteLimit)
+            amount = p_hasteLimit;
+
+
     SetUInt32Value(PLAYER_FIELD_COMBAT_RATING_1 + cr, uint32(amount));
 
     bool affectStats = CanModifyStats();
@@ -7149,9 +7650,6 @@ void Player::setFactionForRace(uint8 race)
 
     sScriptMgr->OnPlayerUpdateFaction(this);
 
-    if (GetTeamId(true) != GetTeamId())
-        return;
-
     ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(race);
     setFaction(rEntry ? rEntry->FactionID : 0);
 }
@@ -7505,6 +8003,9 @@ bool Player::RewardHonor(Unit* uVictim, uint32 groupsize, int32 honor, bool awar
     // add honor points
     ModifyHonorPoints(honor);
 
+    //å±äº«è£èª
+    sRecruit->RecruitHonorReward(this, honor);
+
     ApplyModUInt32Value(PLAYER_FIELD_TODAY_CONTRIBUTION, honor, true);
 
     // Xinef: Battleground experience
@@ -7514,7 +8015,11 @@ bool Player::RewardHonor(Unit* uVictim, uint32 groupsize, int32 honor, bool awar
             bg->UpdatePlayerScore(this, SCORE_BONUS_HONOR, honor, false); //false: prevent looping
             // Xinef: Only for BG activities
             if (!uVictim)
-                GiveXP(uint32(honor*(3+getLevel()*0.30f)), nullptr);
+            {
+                GiveXP(uint32(honor * (3 + getLevel() * 0.30f)), nullptr);
+                //å±äº«ç»éª
+                sRecruit->RecruitXPReward(this, uint32(honor*(3 + getLevel()*0.30f)));
+            }
         }
 
     if (sWorld->getBoolConfig(CONFIG_PVP_TOKEN_ENABLE))
@@ -7684,19 +8189,29 @@ uint32 Player::GetLevelFromStorage(uint64 guid)
 
 void Player::UpdateArea(uint32 newArea)
 {
+    PvPTypes pvpType = sPvP->GetType(GetZoneId(), newArea);
+
+    if (duel && duel->istop)
+    {
+        if (m_areaUpdateId == sSwitch->GetValue(TOP_94))
+        {
+            DuelComplete(DUEL_FLED);
+        }
+    }
+
     // pussywizard: inform instance, needed for Icecrown Citadel
     if (InstanceScript* instance = GetInstanceScript())
         instance->OnPlayerAreaUpdate(this, m_areaUpdateId, newArea);
 
     sScriptMgr->OnPlayerUpdateArea(this, m_areaUpdateId, newArea);
-
+    uint32 lastareaid = m_areaUpdateId;
     // FFA_PVP flags are area and not zone id dependent
     // so apply them accordingly
     m_areaUpdateId = newArea;
 
     AreaTableEntry const* area = sAreaTableStore.LookupEntry(newArea);
     bool oldFFAPvPArea = pvpInfo.IsInFFAPvPArea;
-    pvpInfo.IsInFFAPvPArea = area && (area->flags & AREA_FLAG_ARENA);
+    pvpInfo.IsInFFAPvPArea = area && (area->flags & AREA_FLAG_ARENA) || (pvpType == PvP_TYPE_FFA || pvpType == PvP_TYPE_NO_GROUP_FFA || pvpType == PvP_TYPE_CUSTOM_FACTION);
     UpdatePvPState(true);
 
     // xinef: check if we were in ffa arena and we left
@@ -7741,7 +8256,7 @@ void Player::UpdateArea(uint32 newArea)
     }
 
     // previously this was in UpdateZone (but after UpdateArea) so nothing will break
-    if (isSanctuary)    // in sanctuary
+    if ((area && area->IsSanctuary()) || pvpType == PVP_TYPE_SANCTUARY)    // in sanctuary
     {
         SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY);
         pvpInfo.IsInNoPvPArea = true;
@@ -7762,6 +8277,36 @@ void Player::UpdateArea(uint32 newArea)
         if (!atEntry || !IsInAreaTriggerRadius(atEntry))
             RemoveRestState();
     }
+
+    const gvgconf * aaaaad = sGvgSys->Findgvg(3);
+    if (aaaaad)
+    {
+        std::set<uint32> moderators;
+        Tokenizer tokens(aaaaad->areaids, '#');
+        for (Tokenizer::const_iterator i = tokens.begin(); i != tokens.end(); ++i)
+        {
+            uint32 moderator_acc = atol(*i);
+            moderators.insert(moderator_acc);
+        }
+        if (moderators.find(newArea) != moderators.end())
+        {
+            if (sGvgSys->IsGCevent())
+            {
+                if (sGvgSys->IsGuildvsGuild())
+                {
+                    if (GetGuildId() == sGvgSys->getGuildId1() || GetGuildId() == sGvgSys->getGuildId2())
+                        GCPlayerInTeam(true);
+                }
+            }
+            else
+            {
+                ChatHandler(GetSession()).GetSession()->SendNotification("å¬ä¼æåºåå°å¾å³é­ä¸­ã");
+                TeleportTo(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ, GetOrientation());
+            }
+        }
+        else if (moderators.find(lastareaid) != moderators.end())
+            GCPlayerInTeam(false);
+    }
 }
 
 uint32 Player::GetZoneId(bool forceRecalc) const
@@ -7807,6 +8352,19 @@ void Player::UpdateZone(uint32 newZone, uint32 newArea)
             guild->UpdateMemberData(this, GUILD_MEMBER_DATA_ZONEID, newZone);
     }
 
+    if (m_zoneUpdateId != newZone)
+    {
+        sMapMod->OnEnterZone(this, newZone);
+        //sEM->Update(this, 1);
+    }
+
+    if (m_areaUpdateId != newArea)
+    {
+        sMapMod->OnEnterArea(this, newArea);
+        //sEM->Update(this, 2);
+        sPvP->Update(this, GetZoneId(), newArea);
+    }
+
     // group update
     if (GetGroup())
         SetGroupUpdateFlag(GROUP_UPDATE_FULL);
@@ -8027,6 +8585,42 @@ void Player::DuelComplete(DuelCompleteType type)
     duel->opponent->SetUInt64Value(PLAYER_DUEL_ARBITER, 0);
     duel->opponent->SetUInt32Value(PLAYER_DUEL_TEAM, 0);
 
+
+    if (sCharPvpTop->topevent && duel->istop)
+    {
+        duel->opponent->m_topteam = m_topteam = 0;
+        UpdateObjectVisibility();
+        duel->opponent->UpdateObjectVisibility();
+
+        if (type != DUEL_INTERRUPTED) //èå©  å³æèè¾äº. A èµ¢äº Bå°±è¾äº
+        {
+            m_topmc = sCharPvpTop->GetTopMax();
+            m_lasttopmc = m_topmc;
+            CharacterDatabase.PExecute("update _xlchar set top = %u, lasttop = %u where guid = %u", m_topmc, m_lasttopmc, GetGUIDLow());
+            sCharPvpTop->m_playertopph[m_lasttopmc] = GetGUIDLow();
+            sCharPvpTop->DeleteTopData(GetGUIDLow());
+            if (sCharPvpTop->GetTopMax() == 1)
+            {
+                duel->opponent->m_topmc = sCharPvpTop->GetTopMax();
+                duel->opponent->m_lasttopmc = duel->opponent->m_topmc;
+                sCharPvpTop->m_playertopph[duel->opponent->m_lasttopmc] = duel->opponent->GetGUIDLow();
+                duel->opponent->CastSpell(duel->opponent, 47292, false);
+                CharacterDatabase.PExecute("update _xlchar set top = %u, lasttop = %u where guid = %u", sCharPvpTop->GetTopMax(), duel->opponent->m_lasttopmc, duel->opponent->GetGUIDLow()); //ç¬¬ä¸å
+                sWorld->SendServerMessage(SERVER_MSG_STRING, sString->Format(sString->GetText(TOP_STR_101), duel->opponent->GetName().c_str()));
+                sGameEventMgr->StopEvent(sSwitch->GetValue(TOP_93), true);
+            }
+
+            SetHealth(GetMaxHealth());
+            RemoveArenaSpellCooldowns();
+            SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
+            SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));
+            duel->opponent->SetHealth(duel->opponent->GetMaxHealth());
+            duel->opponent->RemoveArenaSpellCooldowns();
+            duel->opponent->SetPower(POWER_MANA, duel->opponent->GetMaxPower(POWER_MANA));
+            duel->opponent->SetPower(POWER_ENERGY, duel->opponent->GetMaxPower(POWER_ENERGY));
+        }
+    }
+
     delete duel->opponent->duel;
     duel->opponent->duel = nullptr;
     delete duel;
@@ -8061,7 +8655,7 @@ void Player::_ApplyItemMods(Item* item, uint8 slot, bool apply)
     if (attacktype < MAX_ATTACK)
         _ApplyWeaponDependentAuraMods(item, WeaponAttackType(attacktype), apply);
 
-    _ApplyItemBonuses(proto, slot, apply);
+    _ApplyItemBonuses(item, proto, slot, apply);
 
     if (slot == EQUIPMENT_SLOT_RANGED)
         _ApplyAmmoBonuses();
@@ -8074,7 +8668,7 @@ void Player::_ApplyItemMods(Item* item, uint8 slot, bool apply)
 #endif
 }
 
-void Player::_ApplyItemBonuses(ItemTemplate const* proto, uint8 slot, bool apply, bool only_level_scale /*= false*/)
+void Player::_ApplyItemBonuses(Item* item, ItemTemplate const* proto, uint8 slot, bool apply, bool only_level_scale /*= false*/)
 {
     if (slot >= INVENTORY_SLOT_BAG_END || !proto)
         return;
@@ -8096,20 +8690,28 @@ void Player::_ApplyItemBonuses(ItemTemplate const* proto, uint8 slot, bool apply
     {
         uint32 statType = 0;
         int32  val = 0;
-        // If set ScalingStatDistribution need get stats and values from it
-        if (ssd && ssv)
-        {
-            if (ssd->StatMod[i] < 0)
-                continue;
-            statType = ssd->StatMod[i];
-            val = (ssv->getssdMultiplier(proto->ScalingStatValue) * ssd->Modifier[i]) / 10000;
-        }
-        else
+        if (!item || !item->IsNoPatch())
         {
-            if (i >= proto->StatsCount)
-                continue;
-            statType = proto->ItemStat[i].ItemStatType;
-            val = proto->ItemStat[i].ItemStatValue;
+            // If set ScalingStatDistribution need get stats and values from it
+            if (ssd && ssv)
+            {
+                if (ssd->StatMod[i] < 0)
+                    continue;
+                statType = ssd->StatMod[i];
+                val = (ssv->getssdMultiplier(proto->ScalingStatValue) * ssd->Modifier[i]) / 10000;
+            }
+            else
+            {
+                if (i >= proto->StatsCount)
+                    continue;
+                statType = proto->ItemStat[i].ItemStatType;
+                val = proto->ItemStat[i].ItemStatValue;
+            }
+        }
+        else
+        {
+            statType = item->Stats[i].ItemStatType;
+            val = item->Stats[i].ItemStatValue;
         }
 
         if (val == 0)
@@ -8337,7 +8939,7 @@ void Player::_ApplyItemBonuses(ItemTemplate const* proto, uint8 slot, bool apply
     }
 
     if (CanUseAttackType(attType))
-        _ApplyWeaponDamage(slot, proto, ssv, apply);
+        _ApplyWeaponDamage(item, slot, proto, ssv, apply);
 
 
     // Druids get feral AP bonus from weapon dps (also use DPS from ScalingStatValue)
@@ -8357,7 +8959,7 @@ void Player::_ApplyItemBonuses(ItemTemplate const* proto, uint8 slot, bool apply
     }
 }
 
-void Player::_ApplyWeaponDamage(uint8 slot, ItemTemplate const* proto, ScalingStatValuesEntry const* ssv, bool apply)
+void Player::_ApplyWeaponDamage(Item* item, uint8 slot, ItemTemplate const* proto, ScalingStatValuesEntry const* ssv, bool apply)
 {
     WeaponAttackType attType = BASE_ATTACK;
     float damage = 0.0f;
@@ -8376,6 +8978,12 @@ void Player::_ApplyWeaponDamage(uint8 slot, ItemTemplate const* proto, ScalingSt
     float minDamage = proto->Damage[0].DamageMin;
     float maxDamage = proto->Damage[0].DamageMax;
 
+    if (item && item->IsNoPatch())
+    {
+        minDamage = item->Damages[0].DamageMin;
+        maxDamage = item->Damages[0].DamageMax;
+    }
+
     // If set dpsMod in ScalingStatValue use it for min (70% from average), max (130% from average) damage
     if (ssv)
     {
@@ -8400,14 +9008,26 @@ void Player::_ApplyWeaponDamage(uint8 slot, ItemTemplate const* proto, ScalingSt
         SetBaseWeaponDamage(attType, MAXDAMAGE, damage);
     }
 
-    if (proto->Delay && !IsInFeralForm())
+    if (item && item->IsNoPatch())
     {
         if (slot == EQUIPMENT_SLOT_RANGED)
-            SetAttackTime(RANGED_ATTACK, apply ? proto->Delay: BASE_ATTACK_TIME);
+            SetAttackTime(RANGED_ATTACK, apply ? item->NpDelay : BASE_ATTACK_TIME);
         else if (slot == EQUIPMENT_SLOT_MAINHAND)
-            SetAttackTime(BASE_ATTACK, apply ? proto->Delay: BASE_ATTACK_TIME);
+            SetAttackTime(BASE_ATTACK, apply ? item->NpDelay : BASE_ATTACK_TIME);
         else if (slot == EQUIPMENT_SLOT_OFFHAND)
-            SetAttackTime(OFF_ATTACK, apply ? proto->Delay: BASE_ATTACK_TIME);
+            SetAttackTime(OFF_ATTACK, apply ? item->NpDelay : BASE_ATTACK_TIME);
+    }
+    else
+    {
+        if (proto->Delay && !IsInFeralForm())
+        {
+            if (slot == EQUIPMENT_SLOT_RANGED)
+                SetAttackTime(RANGED_ATTACK, apply ? proto->Delay : BASE_ATTACK_TIME);
+            else if (slot == EQUIPMENT_SLOT_MAINHAND)
+                SetAttackTime(BASE_ATTACK, apply ? proto->Delay : BASE_ATTACK_TIME);
+            else if (slot == EQUIPMENT_SLOT_OFFHAND)
+                SetAttackTime(OFF_ATTACK, apply ? proto->Delay : BASE_ATTACK_TIME);
+        }
     }
 
     // No need to modify any physical damage for ferals as it is calculated from stats only
@@ -8483,7 +9103,7 @@ void Player::_ApplyWeaponDependentAuraDamageMod(Item* item, WeaponAttackType att
     switch (aura->GetAuraType())
     {
         case SPELL_AURA_MOD_DAMAGE_DONE:         unitModType = TOTAL_VALUE; break;
-        case SPELL_AURA_MOD_DAMAGE_PERCENT_DONE: unitModType = TOTAL_PCT;   break;
+        case SPELL_AURA_MOD_DAMAGE_PERCENT_DONE: unitModType = (sSwitch->GetOnOff(ST_DAMAGE_PCT) ? TOTAL_PCT_ADD : TOTAL_PCT);   break;
         default: return;
     }
 
@@ -8511,7 +9131,7 @@ void Player::ApplyItemEquipSpell(Item* item, bool apply, bool form_change)
 
     for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
     {
-        _Spell const& spellData = proto->Spells[i];
+        _Spell const& spellData = item->IsNoPatch() ? item->Spells[i] : proto->Spells[i];
 
         // no spell
         if (!spellData.SpellId)
@@ -8788,6 +9408,31 @@ void Player::CastItemUseSpell(Item* item, SpellCastTargets const& targets, uint8
             return;
         }
 
+        if (GetMap()->IsBattlegroundOrArena())
+        {
+            if (spellInfo->Effects[0].ApplyAuraName == 201 || spellInfo->Effects[0].ApplyAuraName == 206 || spellInfo->Effects[0].ApplyAuraName == 207
+                || spellInfo->Effects[0].ApplyAuraName == 208 || spellInfo->Effects[0].ApplyAuraName == 210 || spellInfo->Effects[0].ApplyAuraName == 211
+                )
+            {
+                ChatHandler(GetSession()).PSendSysMessage("è¿ä¸ªå°å¾æ æ³ä½¿ç¨é£è¡åéª.");
+                return;
+            }
+            if (spellInfo->Effects[1].ApplyAuraName == 201 || spellInfo->Effects[1].ApplyAuraName == 206 || spellInfo->Effects[1].ApplyAuraName == 207
+                || spellInfo->Effects[1].ApplyAuraName == 208 || spellInfo->Effects[1].ApplyAuraName == 210 || spellInfo->Effects[1].ApplyAuraName == 211
+                )
+            {
+                ChatHandler(GetSession()).PSendSysMessage("è¿ä¸ªå°å¾æ æ³ä½¿ç¨é£è¡åéª.");
+                return;
+            }
+            if (spellInfo->Effects[2].ApplyAuraName == 201 || spellInfo->Effects[2].ApplyAuraName == 206 || spellInfo->Effects[2].ApplyAuraName == 207
+                || spellInfo->Effects[2].ApplyAuraName == 208 || spellInfo->Effects[2].ApplyAuraName == 210 || spellInfo->Effects[2].ApplyAuraName == 211
+                )
+            {
+                ChatHandler(GetSession()).PSendSysMessage("è¿ä¸ªå°å¾æ æ³ä½¿ç¨é£è¡åéª.");
+                return;
+            }
+        }
+
         Spell* spell = new Spell(this, spellInfo, TRIGGERED_NONE);
         spell->m_CastItem = item;
         spell->m_cast_count = cast_count;                   //set count of casts
@@ -8803,7 +9448,11 @@ void Player::CastItemUseSpell(Item* item, SpellCastTargets const& targets, uint8
     // item spells casted at use
     for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
     {
-        _Spell const& spellData = proto->Spells[i];
+        _Spell const& spellData = item->IsNoPatch() ? item->Spells[i] : proto->Spells[i];
+
+        //å è½½item_templateæ¶æ·»å çæè½ å¨æ­¤è·³è¿
+        if (spellData.SpellId == 77 || spellData.SpellId == 483 || spellData.SpellId == 55884)
+            continue;
 
         // no spell
         if (!spellData.SpellId)
@@ -8820,6 +9469,31 @@ void Player::CastItemUseSpell(Item* item, SpellCastTargets const& targets, uint8
             continue;
         }
 
+        if (GetMap()->IsBattlegroundOrArena())
+        {
+            if (spellInfo->Effects[0].ApplyAuraName == 201 || spellInfo->Effects[0].ApplyAuraName == 206 || spellInfo->Effects[0].ApplyAuraName == 207
+                || spellInfo->Effects[0].ApplyAuraName == 208 || spellInfo->Effects[0].ApplyAuraName == 210 || spellInfo->Effects[0].ApplyAuraName == 211
+                )
+            {
+                ChatHandler(GetSession()).PSendSysMessage("è¿ä¸ªå°å¾æ æ³ä½¿ç¨é£è¡åéª.");
+                return;
+            }
+            if (spellInfo->Effects[1].ApplyAuraName == 201 || spellInfo->Effects[1].ApplyAuraName == 206 || spellInfo->Effects[1].ApplyAuraName == 207
+                || spellInfo->Effects[1].ApplyAuraName == 208 || spellInfo->Effects[1].ApplyAuraName == 210 || spellInfo->Effects[1].ApplyAuraName == 211
+                )
+            {
+                ChatHandler(GetSession()).PSendSysMessage("è¿ä¸ªå°å¾æ æ³ä½¿ç¨é£è¡åéª.");
+                return;
+            }
+            if (spellInfo->Effects[2].ApplyAuraName == 201 || spellInfo->Effects[2].ApplyAuraName == 206 || spellInfo->Effects[2].ApplyAuraName == 207
+                || spellInfo->Effects[2].ApplyAuraName == 208 || spellInfo->Effects[2].ApplyAuraName == 210 || spellInfo->Effects[2].ApplyAuraName == 211
+                )
+            {
+                ChatHandler(GetSession()).PSendSysMessage("è¿ä¸ªå°å¾æ æ³ä½¿ç¨é£è¡åéª.");
+                return;
+            }
+        }
+
         if (HasSpellCooldown(spellInfo->Id))
             continue;
 
@@ -8937,7 +9611,7 @@ void Player::_RemoveAllItemMods()
             if (attacktype < MAX_ATTACK)
                 _ApplyWeaponDependentAuraMods(m_items[i], WeaponAttackType(attacktype), false);
 
-            _ApplyItemBonuses(proto, i, false);
+            _ApplyItemBonuses(m_items[i], proto, i, false);
 
             if (i == EQUIPMENT_SLOT_RANGED)
                 _ApplyAmmoBonuses();
@@ -8970,7 +9644,7 @@ void Player::_ApplyAllItemMods()
             if (attacktype < MAX_ATTACK)
                 _ApplyWeaponDependentAuraMods(m_items[i], WeaponAttackType(attacktype), true);
 
-            _ApplyItemBonuses(proto, i, true);
+            _ApplyItemBonuses(m_items[i], proto, i, true);
 
             if (i == EQUIPMENT_SLOT_RANGED)
                 _ApplyAmmoBonuses();
@@ -9116,7 +9790,7 @@ void Player::SendLootRelease(uint64 guid)
     SendDirectMessage(&data);
 }
 
-void Player::SendLoot(uint64 guid, LootType loot_type)
+void Player::SendLoot(uint64 guid, LootType loot_type, float range)
 {
     if (uint64 lguid = GetLootGUID())
         m_session->DoLootRelease(lguid);
@@ -9136,7 +9810,7 @@ void Player::SendLoot(uint64 guid, LootType loot_type)
 
         // not check distance for GO in case owned GO (fishing bobber case, for example)
         // And permit out of range GO with no owner in case fishing hole
-        if (!go || (loot_type != LOOT_FISHINGHOLE && ((loot_type != LOOT_FISHING && loot_type != LOOT_FISHING_JUNK) || go->GetOwnerGUID() != GetGUID()) && !go->IsWithinDistInMap(this, INTERACTION_DISTANCE)) || (loot_type == LOOT_CORPSE && go->GetRespawnTime() && go->isSpawnedByDefault()))
+        if (!go || (loot_type != LOOT_FISHINGHOLE && ((loot_type != LOOT_FISHING && loot_type != LOOT_FISHING_JUNK) || go->GetOwnerGUID() != GetGUID()) && !go->IsWithinDistInMap(this, range)) || (loot_type == LOOT_CORPSE && go->GetRespawnTime() && go->isSpawnedByDefault()))
         {
             go->ForceValuesUpdateAtIndex(GAMEOBJECT_BYTES_1);
             SendLootRelease(guid);
@@ -9176,6 +9850,7 @@ void Player::SendLoot(uint64 guid, LootType loot_type)
                 if (groupRules)
                     group->UpdateLooterGuid(go, true);
 
+                loot->LootExtraItems = go->LootExtraItems;
                 loot->FillLoot(lootid, LootTemplates_Gameobject, this, !groupRules, false, go->GetLootMode());
                 go->SetLootGenerationTime();
 
@@ -9239,6 +9914,8 @@ void Player::SendLoot(uint64 guid, LootType loot_type)
             else
                 permission = ALL_PERMISSION;
         }
+
+        sServerAnnounce->Announce(this, go->GetEntry(), 0);
     }
     else if (IS_ITEM_GUID(guid))
     {
@@ -9284,6 +9961,7 @@ void Player::SendLoot(uint64 guid, LootType loot_type)
                     break;
             }
         }
+        sServerAnnounce->Announce(this, item->GetEntry(), 1);
     }
     else if (IS_CORPSE_GUID(guid))                          // remove insignia
     {
@@ -9327,7 +10005,7 @@ void Player::SendLoot(uint64 guid, LootType loot_type)
         Creature* creature = GetMap()->GetCreature(guid);
 
         // must be in range and creature must be alive for pickpocket and must be dead for another loot
-        if (!creature || creature->IsAlive() != (loot_type == LOOT_PICKPOCKETING) || !creature->IsWithinDistInMap(this, INTERACTION_DISTANCE))
+        if (!creature || creature->IsAlive() != (loot_type == LOOT_PICKPOCKETING) || !creature->IsWithinDistInMap(this, range))
         {
             SendLootRelease(guid);
             return;
@@ -10411,8 +11089,27 @@ uint8 Player::FindEquipSlot(ItemTemplate const* proto, uint32 slot, bool swap) c
             break;
         case INVTYPE_RELIC:
         {
-            switch (proto->SubClass)
+            if (sSwitch->GetOnOff(ST_SAME_RELIC))
+            {
+                switch (proto->SubClass)
+                {
+                case ITEM_SUBCLASS_ARMOR_LIBRAM:
+                case ITEM_SUBCLASS_ARMOR_IDOL:
+                case ITEM_SUBCLASS_ARMOR_TOTEM:
+                case ITEM_SUBCLASS_ARMOR_SIGIL:
+                    if (playerClass == CLASS_PALADIN || playerClass == CLASS_DRUID || playerClass == CLASS_SHAMAN || playerClass == CLASS_DEATH_KNIGHT)
+                        slots[0] = EQUIPMENT_SLOT_RANGED;
+                    break;
+                case ITEM_SUBCLASS_ARMOR_MISC:
+                    if (playerClass == CLASS_WARLOCK)
+                        slots[0] = EQUIPMENT_SLOT_RANGED;
+                    break;
+                }
+            }
+            else
             {
+                switch (proto->SubClass)
+                {
                 case ITEM_SUBCLASS_ARMOR_LIBRAM:
                     if (playerClass == CLASS_PALADIN)
                         slots[0] = EQUIPMENT_SLOT_RANGED;
@@ -10433,7 +11130,9 @@ uint8 Player::FindEquipSlot(ItemTemplate const* proto, uint32 slot, bool swap) c
                     if (playerClass == CLASS_DEATH_KNIGHT)
                         slots[0] = EQUIPMENT_SLOT_RANGED;
                     break;
+                }
             }
+
             break;
         }
         default:
@@ -10980,6 +11679,10 @@ InventoryResult Player::CanTakeMoreSimilarItems(uint32 entry, uint32 count, Item
     if (pProto->MaxCount > 0)
     {
         uint32 curcount = GetItemCount(pProto->ItemId, true, pItem);
+
+        if (sTalisman->HasTalismanEquiped(const_cast<Player*>(this), pProto->ItemId))
+            curcount++;
+
         if (curcount + count > uint32(pProto->MaxCount))
         {
             if (no_space_count)
@@ -11091,7 +11794,7 @@ InventoryResult Player::CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemP
         if (bag == INVENTORY_SLOT_BAG_0)
         {
             // keyring case
-            if (slot >= KEYRING_SLOT_START && slot < KEYRING_SLOT_START+GetMaxKeyringSize() && !(pProto->BagFamily & BAG_FAMILY_MASK_KEYS))
+            if (!sEM->InKeyings(bag, slot) && slot >= KEYRING_SLOT_START && slot < KEYRING_SLOT_START + GetMaxKeyringSize() && !(pProto->BagFamily & BAG_FAMILY_MASK_KEYS))
                 return EQUIP_ERR_ITEM_DOESNT_GO_INTO_BAG;
 
             // currencytoken case
@@ -11986,6 +12689,23 @@ InventoryResult Player::CanEquipItem(uint8 slot, uint16 &dest, Item* pItem, bool
         ItemTemplate const* pProto = pItem->GetTemplate();
         if (pProto)
         {
+            //æ£æµå¹»åæ è¯
+            if (sItemMod->HasTransFlag(pItem))
+                return EQUIP_ERR_ITEM_CANT_BE_EQUIPPED;
+
+            //item euip
+            {
+                uint32 reqId = sItemMod->GetEquipInfo(pProto->ItemId);
+
+                if (reqId > 0 && not_loading)
+                {
+                    if (!sReq->Check((Player*)this, reqId))
+                        return EQUIP_ERR_CANT_DO_RIGHT_NOW;
+
+                    sReq->Des((Player*)this, reqId);
+                }
+            }
+
             // item used
             if (pItem->m_lootGenerated)
                 return EQUIP_ERR_ALREADY_LOOTED;
@@ -12137,6 +12857,10 @@ InventoryResult Player::CanEquipItem(uint8 slot, uint16 &dest, Item* pItem, bool
                         return swap ? EQUIP_ERR_ITEMS_CANT_BE_SWAPPED : EQUIP_ERR_INVENTORY_FULL;
                 }
             }
+
+            if (!sMapMod->CanEquipItem((Player*)this, eslot, pItem->GetEntry()))
+                return EQUIP_ERR_ITEM_CANT_BE_EQUIPPED;
+
             dest = ((INVENTORY_SLOT_BAG_0 << 8) | eslot);
             return EQUIP_ERR_OK;
         }
@@ -12639,6 +13363,8 @@ Item* Player::StoreNewItem(ItemPosCountVec const& dest, uint32 item, bool update
     for (ItemPosCountVec::const_iterator itr = dest.begin(); itr != dest.end(); ++itr)
         count += itr->count;
 
+    count = CanStoreDayLimitItem(item, count);
+
     Item* pItem = Item::CreateItem(item, count, this, false, randomPropertyId);
     if (pItem)
     {
@@ -12650,6 +13376,9 @@ Item* Player::StoreNewItem(ItemPosCountVec const& dest, uint32 item, bool update
         ItemAddedQuestCheck(item, count);
         UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_RECEIVE_EPIC_ITEM, item, count);
         UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_OWN_ITEM, item, count);
+        if (randomPropertyId)
+            pItem->SetItemRandomProperties(randomPropertyId);
+
         pItem = StoreItem(dest, pItem, update);
 
 
@@ -12672,6 +13401,13 @@ Item* Player::StoreNewItem(ItemPosCountVec const& dest, uint32 item, bool update
             CharacterDatabase.Execute(stmt);
         }
     }
+
+    if (pItem)
+    {
+        sServerAnnounce->Announce(this, pItem->GetEntry(), 2);
+        sItemMod->ApplyHiddenItem(this, pItem, true);
+    }
+
     return pItem;
 }
 
@@ -12704,7 +13440,7 @@ Item* Player::StoreItem(ItemPosCountVec const& dest, Item* pItem, bool update)
         for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
             if (proto->Spells[i].SpellTrigger == ITEM_SPELLTRIGGER_ON_NO_DELAY_USE && proto->Spells[i].SpellId > 0) // On obtain trigger
                 if (!HasAura(proto->Spells[i].SpellId))
-                    CastSpell(this, proto->Spells[i].SpellId, true, lastItem);
+                    lastItem->IsNoPatch() ? CastSpell(this, lastItem->Spells[i].SpellId, true, lastItem) : CastSpell(this, proto->Spells[i].SpellId, true, lastItem);
 
     return lastItem;
 }
@@ -12936,6 +13672,11 @@ Item* Player::EquipItem(uint16 pos, Item* pItem, bool update)
     sEluna->OnEquip(this, pItem, bag, slot);
 #endif
 
+    sItemSet->UpdateSpell(this, pItem->GetEntry(), 0);
+    sGS->UpdateGS(this, pItem->GetEntry(), GS_TYPE_ITEM_EQUIP, true);
+
+    sNoPatchItem->UpdateAuras(this);
+
     sScriptMgr->OnEquip(this, pItem, bag, slot, update);
     UpdateForQuestWorldObjects();
     return pItem;
@@ -12960,6 +13701,7 @@ void Player::QuickEquipItem(uint16 pos, Item* pItem)
         UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EQUIP_ITEM, pItem->GetEntry());
         UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EQUIP_EPIC_ITEM, pItem->GetEntry(), slot);
 
+        sNoPatchItem->UpdateAuras(this);
 #ifdef ELUNA
         sEluna->OnEquip(this, pItem, (pos >> 8), slot);
 #endif
@@ -12970,7 +13712,11 @@ void Player::SetVisibleItemSlot(uint8 slot, Item* pItem)
 {
     if (pItem)
     {
-        SetUInt32Value(PLAYER_VISIBLE_ITEM_1_ENTRYID + (slot * 2), pItem->GetEntry());
+        if (uint32 entry = sTransmogrification->GetFakeEntry(pItem->GetGUID()))
+            SetUInt32Value(PLAYER_VISIBLE_ITEM_1_ENTRYID + (slot * 2), entry);
+        else
+            SetUInt32Value(PLAYER_VISIBLE_ITEM_1_ENTRYID + (slot * 2), pItem->GetEntry());
+        
         SetUInt16Value(PLAYER_VISIBLE_ITEM_1_ENCHANTMENT + (slot * 2), 0, pItem->GetEnchantmentId(PERM_ENCHANTMENT_SLOT));
         SetUInt16Value(PLAYER_VISIBLE_ITEM_1_ENCHANTMENT + (slot * 2), 1, pItem->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT));
     }
@@ -12990,7 +13736,10 @@ void Player::VisualizeItem(uint8 slot, Item* pItem)
 
     // check also  BIND_WHEN_PICKED_UP and BIND_QUEST_ITEM for .additem or .additemset case by GM (not binded at adding to inventory)
     if (pItem->GetTemplate()->Bonding == BIND_WHEN_EQUIPED || pItem->GetTemplate()->Bonding == BIND_WHEN_PICKED_UP || pItem->GetTemplate()->Bonding == BIND_QUEST_ITEM)
+    {
+        pItem->UnBinded = false;
         pItem->SetBinding(true);
+    }
 
 #if defined(ENABLE_EXTRAS) && defined(ENABLE_EXTRA_LOGS)
     sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: EquipItem slot = %u, item = %u", slot, pItem->GetEntry());
@@ -13069,6 +13818,13 @@ void Player::RemoveItem(uint8 bag, uint8 slot, bool update, bool swap)
 
             if (slot < EQUIPMENT_SLOT_END)
                 SetVisibleItemSlot(slot, nullptr);
+
+            if (slot < EQUIPMENT_SLOT_END)
+            {
+                sItemSet->UpdateSpell(this, 0, pItem->GetEntry());
+                sGS->UpdateGS(this, pItem->GetEntry(), GS_TYPE_ITEM_EQUIP, false);
+                sNoPatchItem->UpdateAuras(this);
+            }
         }
         else if (Bag* pBag = GetBagByPos(bag))
             pBag->RemoveItem(slot, update);
@@ -13086,6 +13842,7 @@ void Player::MoveItemFromInventory(uint8 bag, uint8 slot, bool update)
 {
     if (Item* it = GetItemByPos(bag, slot))
     {
+        sTransmogrification->DeleteFakeFromDB(it->GetGUIDLow()); // custom
         ItemRemovedQuestCheck(it->GetEntry(), it->GetCount());
         RemoveItem(bag, slot, update);
         UpdateTitansGrip();
@@ -13132,6 +13889,8 @@ void Player::DestroyItem(uint8 bag, uint8 slot, bool update)
     Item* pItem = GetItemByPos(bag, slot);
     if (pItem)
     {
+        sItemMod->ApplyHiddenItem(this, pItem, false);
+
 #if defined(ENABLE_EXTRAS) && defined(ENABLE_EXTRA_LOGS)
         sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyItem bag = %u, slot = %u, item = %u", bag, slot, pItem->GetEntry());
 #endif
@@ -13160,7 +13919,7 @@ void Player::DestroyItem(uint8 bag, uint8 slot, bool update)
         const ItemTemplate* proto = pItem->GetTemplate();
         for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
             if (proto->Spells[i].SpellTrigger == ITEM_SPELLTRIGGER_ON_NO_DELAY_USE && proto->Spells[i].SpellId > 0) // On obtain trigger
-                RemoveAurasDueToSpell(proto->Spells[i].SpellId);
+                pItem->IsNoPatch() ? RemoveAurasDueToSpell(pItem->Spells[i].SpellId) : RemoveAurasDueToSpell(proto->Spells[i].SpellId);
 
         ItemRemovedQuestCheck(pItem->GetEntry(), pItem->GetCount());
 
@@ -13665,6 +14424,12 @@ void Player::SwapItem(uint16 src, uint16 dst)
     Item* pSrcItem = GetItemByPos(srcbag, srcslot);
     Item* pDstItem = GetItemByPos(dstbag, dstslot);
 
+    if (HasMapTempItems())
+    {
+        ChatHandler(GetSession()).PSendSysMessage("è¿ä¸ªå°å¾æ æ³åæ¢è£å¤.");
+        return;
+    }
+
     if (!pSrcItem)
         return;
 
@@ -14428,6 +15193,27 @@ void Player::ApplyEnchantment(Item* item, EnchantmentSlot slot, bool apply, bool
     if (!pEnchant)
         return;
 
+    //éå¶å®ç³ä¸é
+    if (pEnchant->GemID && slot >= SOCK_ENCHANTMENT_SLOT && slot <= SOCK_ENCHANTMENT_SLOT_3)
+    {
+        uint32 gemTotalCount = sCF->GetGemCountByEntry(this, pEnchant->GemID);
+
+        for (size_t i = 0; i < GemCountLimitInfo.size(); i++)
+        {
+            if (pEnchant->GemID == GemCountLimitInfo[i].entry)
+            {
+                if (item->IsEquipped() && apply && gemTotalCount > GemCountLimitInfo[i].limitCount)
+                {
+                    std::ostringstream oss;
+                    oss << sCF->GetItemLink(pEnchant->GemID) << "å½åæ°éï¼" << gemTotalCount;
+                    oss << "è¶è¿æå¤§å®ç³æ°éï¼" << GemCountLimitInfo[i].limitCount << "ï¼è¯·ç§»é¤å¤ä½å®ç³ï¼";
+                    GetSession()->SendNotification(oss.str().c_str());
+                    return;
+                }
+            }
+        }
+    }
+
     if (!ignore_condition && pEnchant->EnchantmentCondition && !EnchantmentFitsRequirements(pEnchant->EnchantmentCondition, -1))
         return;
 
@@ -15545,6 +16331,10 @@ bool Player::CanTakeQuest(Quest const* quest, bool msg)
 
 bool Player::CanAddQuest(Quest const* quest, bool msg)
 {
+    //æ¥ä»»å¡ååå¤æ­
+    if (!sQuestMod->CanTakeQuest(this, quest->GetQuestId()))
+        return false;
+
     if (!SatisfyQuestLog(msg))
         return false;
 
@@ -15965,16 +16755,22 @@ void Player::RewardQuest(Quest const* quest, uint32 reward, Object* questGiver,
     {
         if (uint32 itemId = quest->RewardChoiceItemId[reward])
         {
-            ItemPosCountVec dest;
-            if (CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, quest->RewardChoiceItemCount[reward]) == EQUIP_ERR_OK)
+            //ä»»å¡å¥å±ç§¯å
+            if (itemId == sSwitch->GetValue(ST_TOKEN_ID))
+                sCF->UpdateTokenAmount(this, quest->RewardChoiceItemCount[reward], true, "[ä»»å¡]å¥å±");
+            else
             {
-                Item* item = StoreNewItem(dest, itemId, true);
-                SendNewItem(item, quest->RewardChoiceItemCount[reward], true, false, false, false);
+                ItemPosCountVec dest;
+                if (CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, quest->RewardChoiceItemCount[reward]) == EQUIP_ERR_OK)
+                {
+                    Item* item = StoreNewItem(dest, itemId, true);
+                    SendNewItem(item, quest->RewardChoiceItemCount[reward], true, false, false, false);
 
-                sScriptMgr->OnQuestRewardItem(this, item, quest->RewardChoiceItemCount[reward]);
+                    sScriptMgr->OnQuestRewardItem(this, item, quest->RewardChoiceItemCount[reward]);
+                }
+                else
+                    problematicItems.push_back(std::pair<uint32, uint32>(itemId, quest->RewardChoiceItemCount[reward]));
             }
-            else
-                problematicItems.push_back(std::pair<uint32, uint32>(itemId, quest->RewardChoiceItemCount[reward]));
         }
     }
 
@@ -15984,16 +16780,22 @@ void Player::RewardQuest(Quest const* quest, uint32 reward, Object* questGiver,
         {
             if (uint32 itemId = quest->RewardItemId[i])
             {
-                ItemPosCountVec dest;
-                if (CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, quest->RewardItemIdCount[i]) == EQUIP_ERR_OK)
+                //ä»»å¡å¥å±ç§¯å
+                if (itemId == sSwitch->GetValue(ST_TOKEN_ID))
+                    sCF->UpdateTokenAmount(this, quest->RewardChoiceItemCount[reward], true, "[ä»»å¡]å¥å±");
+                else
                 {
-                    Item* item = StoreNewItem(dest, itemId, true);
-                    SendNewItem(item, quest->RewardItemIdCount[i], true, false, false, false);
+                    ItemPosCountVec dest;
+                    if (CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, quest->RewardItemIdCount[i]) == EQUIP_ERR_OK)
+                    {
+                        Item* item = StoreNewItem(dest, itemId, true);
+                        SendNewItem(item, quest->RewardItemIdCount[i], true, false, false, false);
 
-                    sScriptMgr->OnQuestRewardItem(this, item, quest->RewardItemIdCount[i]);
+                        sScriptMgr->OnQuestRewardItem(this, item, quest->RewardItemIdCount[i]);
+                    }
+                    else
+                        problematicItems.push_back(std::pair<uint32, uint32>(itemId, quest->RewardItemIdCount[i]));
                 }
-                else
-                    problematicItems.push_back(std::pair<uint32, uint32>(itemId, quest->RewardItemIdCount[i]));
             }
         }
     }
@@ -16184,6 +16986,31 @@ void Player::FailQuest(uint32 questId)
             q_status.Timer = 0;
 
             SendQuestTimerFailed(questId);
+
+            //éæºä»»å¡è¶æ¶èªå¨æ¾å¼
+            auto i = QuestRandomMap.find(questId);
+
+            if (i != QuestRandomMap.end())
+            {
+                for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+                {
+                    uint32 logQuest = GetQuestSlotQuestId(slot);
+                    if (logQuest == questId)
+                    {
+                        SetQuestSlot(slot, 0);
+                        TakeQuestSourceItem(logQuest, false);
+
+                        if (quest->HasFlag(QUEST_FLAGS_FLAGS_PVP))
+                        {
+                            pvpInfo.IsHostile = pvpInfo.IsInHostileArea || HasPvPForcingQuest();
+                            UpdatePvPState();
+                        }
+                    }
+                }
+
+                RemoveRewardedQuest(questId);
+                RemoveActiveQuest(questId, false);
+            }
         }
         else
             SendQuestFailed(questId);
@@ -17928,7 +18755,30 @@ bool Player::LoadFromDB(uint32 guid, SQLQueryHolder *holder)
         return false;
     }
 
-    sCustomMgr->LoadPlayStatFrom(this, guid);
+    QueryResult lnwow_level3 = CharacterDatabase.PQuery("SELECT top,toptitle,lasttop,inguildtime,lqguildtime from _xlchar where guid =%u", guid);
+    if (lnwow_level3)
+    {
+        m_topmc = lnwow_level3->Fetch()[0].GetUInt32();
+        m_toptitle = lnwow_level3->Fetch()[1].GetString();
+        m_lasttopmc = lnwow_level3->Fetch()[2].GetUInt32();
+        inguildtime = lnwow_level3->Fetch()[3].GetUInt32();
+        lqguildtime = lnwow_level3->Fetch()[4].GetUInt32();
+        if (m_lasttopmc)
+        {
+            const CTopSys *cccc = sCharPvpTop->FindTopSys(m_lasttopmc);
+            if (cccc && cccc->text != "")
+                sWorld->UpdateTopPlayerData(guid, cccc->text);
+
+        }
+
+        sCharPvpTop->m_playertopph[m_lasttopmc] = guid;
+        if (m_topmc == 999 && sCharPvpTop->topevent)
+            m_topmc = 0;
+    }
+    else
+    {
+        CharacterDatabase.PExecute("INSERT INTO _xlchar (guid) VALUES ('%u')", guid);
+    }
 
     // overwrite some data fields
     uint32 bytes0 = 0;
@@ -17997,6 +18847,7 @@ bool Player::LoadFromDB(uint32 guid, SQLQueryHolder *holder)
     //Other way is to saves m_team into characters table.
     setFactionForRace(getRace(true));
 
+    realTeam = TeamIdForRace(getRace());
     // pussywizard: create empty instance bind containers if necessary
     sInstanceSaveMgr->PlayerCreateBoundInstancesMaps(guid);
 
@@ -18275,7 +19126,7 @@ bool Player::LoadFromDB(uint32 guid, SQLQueryHolder *holder)
 
     m_atLoginFlags = fields[38].GetUInt16();
 
-    if (HasAtLoginFlag(AT_LOGIN_RENAME))
+    if (HasAtLoginFlag(AT_LOGIN_RENAME) && !m_bot)
     {
         sLog->outError("Player (GUID: %u) tried to login while forced to rename, can't load.'", GetGUIDLow());
         return false;
@@ -18419,7 +19270,6 @@ bool Player::LoadFromDB(uint32 guid, SQLQueryHolder *holder)
 
     //apply all stat bonuses from items and auras
     SetCanModifyStats(true);
-    sCustomMgr->AppDQlevel(this, true);
     UpdateAllStats();
 
     // restore remembered power/health values (but not more max values)
@@ -18882,7 +19732,7 @@ Item* Player::_LoadItem(SQLTransaction& trans, uint32 zoneId, uint32 timeDiff, F
     {
         bool remove = false;
         item = NewItemOrBag(proto);
-        if (item->LoadFromDB(itemGuid, GetGUID(), fields, itemEntry))
+        if (item->LoadFromDB(itemGuid, GetGUID(), fields, itemEntry, 0))
         {
             PreparedStatement* stmt = nullptr;
 
@@ -19047,7 +19897,7 @@ void Player::_LoadMailedItems(Mail* mail)
 
         Item* item = NewItemOrBag(proto);
 
-        if (!item->LoadFromDB(itemGuid, MAKE_NEW_GUID(fields[13].GetUInt32(), 0, HIGHGUID_PLAYER), fields, itemTemplate))
+        if (!item->LoadFromDB(itemGuid, MAKE_NEW_GUID(fields[13].GetUInt32(), 0, HIGHGUID_PLAYER), fields, itemTemplate, 3))
         {
             sLog->outError("Player::_LoadMailedItems - Item in mail (%u) doesn't exist !!!! - item guid: %u, deleted from mail", mail->messageID, itemGuid);
 
@@ -19758,8 +20608,13 @@ void Player::SaveToDB(bool create, bool logout)
     _SaveWeeklyQuestStatus(trans);
     _SaveSeasonalQuestStatus(trans);
     _SaveMonthlyQuestStatus(trans);
-    _SaveTalents(trans);
-    _SaveSpells(trans);
+
+    if (!m_bot)
+    {
+        _SaveTalents(trans);
+        _SaveSpells(trans);
+    }
+
     _SaveSpellCooldowns(trans, logout);
     _SaveActions(trans);
     _SaveAuras(trans, logout);
@@ -19782,7 +20637,6 @@ void Player::SaveToDB(bool create, bool logout)
     if (Pet* pet = GetPet())
         pet->SavePetToDB(PET_SAVE_AS_CURRENT, logout);
 
-    sCustomMgr->SavePlayStatTo(this, GetGUIDLow());
     // our: saving system
     if (!create && !logout)
     {
@@ -19792,6 +20646,9 @@ void Player::SaveToDB(bool create, bool logout)
 
         m_nextSave = SavingSystemMgr::IncreaseSavingMaxValue(1);
     }
+
+    sSoulStone->SavePlayerAllDate(this);
+    sSoulStoneEx->SavePlayerAllDate(this);
 }
 
 // fast save function for item/money cheating preventing - save only inventory and money state
@@ -20809,14 +21666,35 @@ void Player::UpdatePvPFlag(time_t currTime)
 
 void Player::UpdateDuelFlag(time_t currTime)
 {
-    if (!duel || duel->startTimer == 0 || currTime < duel->startTimer + 3)
-        return;
+    if (sCharPvpTop->topevent && GetAreaId() == sSwitch->GetValue(TOP_94))
+    {
+        if (!duel || duel->startTimer == 0 || currTime < duel->startTimer + 10)
+            return;
+    }
+    else
+    {
+        if (!duel || duel->startTimer == 0 || currTime < duel->startTimer + 3)
+            return;
+    }
 
     sScriptMgr->OnPlayerDuelStart(this, duel->opponent);
 
     SetUInt32Value(PLAYER_DUEL_TEAM, 1);
     duel->opponent->SetUInt32Value(PLAYER_DUEL_TEAM, 2);
 
+    if (sCharPvpTop->topevent)
+    {
+        if (GetAreaId() == sSwitch->GetValue(TOP_94)) //è®¾ç½®éå½¢
+        {
+            if (setpvptime)
+            {
+                setpvptime = false;
+                UpdateObjectVisibility();
+                duel->opponent->UpdateObjectVisibility();
+            }
+        }
+    }
+
     duel->startTimer = 0;
     duel->startTime  = currTime;
     duel->opponent->duel->startTimer = 0;
@@ -21650,7 +22528,7 @@ void Player::SetRestBonus(float rest_bonus_new)
     if (rest_bonus_new < 0)
         rest_bonus_new = 0;
 
-    float rest_bonus_max = (float)GetUInt32Value(PLAYER_NEXT_LEVEL_XP)*1.5f/2;
+    float rest_bonus_max = sSwitch->GetOnOff(ST_XP_RESET_STAT_MULTI) ? (float)GetUInt32Value(PLAYER_NEXT_LEVEL_XP)*1.5f / 2 : 0;
 
     if (rest_bonus_new > rest_bonus_max)
         _restBonus = rest_bonus_max;
@@ -22047,10 +22925,20 @@ void Player::InitDisplayIds()
 
 inline bool Player::_StoreOrEquipNewItem(uint32 vendorslot, uint32 item, uint8 count, uint8 bag, uint8 slot, int32 price, ItemTemplate const* pProto, Creature* pVendor, VendorItem const* crItem, bool bStore)
 {
+    uint32 buyCount = count;
+
+    uint32 BuyMaxCount = 0;
+
+    if (pVendor)
+        BuyMaxCount = sItemMod->GetBuyMaxCount(item, pVendor->GetEntry(), vendorslot + 1);
+
+    if (BuyMaxCount)
+        buyCount = BuyMaxCount;
+
     ItemPosCountVec vDest;
     uint16 uiDest = 0;
     InventoryResult msg = bStore ?
-        CanStoreNewItem(bag, slot, vDest, item, pProto->BuyCount * count) :
+        CanStoreNewItem(bag, slot, vDest, item, pProto->BuyCount * buyCount) :
         CanEquipNewItem(slot, uiDest, item, false);
     if (msg != EQUIP_ERR_OK)
     {
@@ -22071,23 +22959,35 @@ inline bool Player::_StoreOrEquipNewItem(uint32 vendorslot, uint32 item, uint8 c
 
         for (uint8 i = 0; i < MAX_ITEM_EXTENDED_COST_REQUIREMENTS; ++i)
         {
-            if (iece->reqitem[i])
+            //ç§¯ååå
+            if (iece->reqitem[i] == sSwitch->GetValue(ST_TOKEN_ID))
+            {
+                uint32 reqToken = iece->reqitemcount[i] * count;
+                sCF->UpdateTokenAmount(this, reqToken, false, "[ååº]è´­ä¹°ç©å");
+                ChatHandler(GetSession()).PSendSysMessage("æ¬¢è¿ä½¿ç¨%sæå¡ï¼æ¬æ¬¡æ¶è´¹%u[%s]", sString->GetText(STR_TOKEN), reqToken, sString->GetText(STR_TOKEN));
+            }
+            else
                 DestroyItemCount(iece->reqitem[i], (iece->reqitemcount[i] * count), true);
         }
     }
 
-    if (crItem->Needid)
-        sCustomMgr->BuyDeleteFromNeedSys(this, crItem->Needid, count);
 
     Item* it = bStore ?
         StoreNewItem(vDest, item, true) :
         EquipNewItem(uiDest, item, true);
     if (it)
     {
-        uint32 new_count = pVendor->UpdateVendorItemCurrentCount(crItem, pProto->BuyCount * count);
+        uint32 new_count = 0;
 
-        WorldPacket data(SMSG_BUY_ITEM, (8+4+4+4));
-        data << uint64(pVendor->GetGUID());
+        if (pVendor)
+            pVendor->UpdateVendorItemCurrentCount(crItem, pProto->BuyCount * count);
+
+        WorldPacket data(SMSG_BUY_ITEM, (8 + 4 + 4 + 4));
+
+        if (pVendor)
+            data << uint64(pVendor->GetGUID());
+        else
+            data << uint64(GetGUID());
         data << uint32(vendorslot + 1);                   // numbered from 1 at client
         data << int32(crItem->maxcount > 0 ? new_count : 0xFFFFFFFF);
         data << uint32(count);
@@ -22146,25 +23046,40 @@ bool Player::BuyItemFromVendorSlot(uint64 vendorguid, uint32 vendorslot, uint32
     if (!IsGameMaster() && ((pProto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY && GetTeamId(true) == TEAM_ALLIANCE) || (pProto->Flags2 == ITEM_FLAGS_EXTRA_ALLIANCE_ONLY && GetTeamId(true) == TEAM_HORDE)))
         return false;
 
+    uint32 currentVendor = GetSession()->GetCurrentVendorEntry();
+
+    bool fromcommand = GetSession()->VendorFromCommand();
+
+    if (fromcommand)
+        currentVendor = GetSession()->GetCurrentVendorGUID();
+
     Creature* creature = GetNPCIfCanInteractWith(vendorguid, UNIT_NPC_FLAG_VENDOR);
-    if (!creature)
-    {
-#if defined(ENABLE_EXTRAS) && defined(ENABLE_EXTRA_LOGS)
-        sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: BuyItemFromVendor - Unit (GUID: %u) not found or you can't interact with him.", uint32(GUID_LOPART(vendorguid)));
-#endif
-        SendBuyError(BUY_ERR_DISTANCE_TOO_FAR, NULL, item, 0);
-        return false;
-    }
+    VendorItemData const* vItems;
 
-    ConditionList conditions = sConditionMgr->GetConditionsForNpcVendorEvent(creature->GetEntry(), item);
-    if (!sConditionMgr->IsObjectMeetToConditions(this, creature, conditions))
+    if (fromcommand)
+        vItems = sObjectMgr->GetNpcVendorItemList(currentVendor);
+    else
     {
-        //TC_LOG_DEBUG("condition", "BuyItemFromVendor: conditions not met for creature entry %u item %u", creature->GetEntry(), item);
-        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
-        return false;
+        if (!creature)
+        {
+            #if defined(ENABLE_EXTRAS) && defined(ENABLE_EXTRA_LOGS)
+            sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: BuyItemFromVendor - Unit (GUID: %u) not found or you can't interact with him.", uint32(GUID_LOPART(vendorguid)));
+            #endif
+            SendBuyError(BUY_ERR_DISTANCE_TOO_FAR, NULL, item, 0);
+            return false;
+        }
+
+        ConditionList conditions = sConditionMgr->GetConditionsForNpcVendorEvent(creature->GetEntry(), item);
+        if (!sConditionMgr->IsObjectMeetToConditions(this, creature, conditions))
+        {
+            //TC_LOG_DEBUG("condition", "BuyItemFromVendor: conditions not met for creature entry %u item %u", creature->GetEntry(), item);
+            SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
+            return false;
+        }
+
+        vItems = currentVendor ? sObjectMgr->GetNpcVendorItemList(currentVendor) : creature->GetVendorItems();
     }
 
-    VendorItemData const* vItems = GetSession()->GetCurrentVendor() ? sObjectMgr->GetNpcVendorItemList(GetSession()->GetCurrentVendor()) : creature->GetVendorItems();
     if (!vItems || vItems->Empty())
     {
         SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item, 0);
@@ -22227,9 +23142,20 @@ bool Player::BuyItemFromVendorSlot(uint64 vendorguid, uint32 vendorslot, uint32
         // item base price
         for (uint8 i = 0; i < MAX_ITEM_EXTENDED_COST_REQUIREMENTS; ++i)
         {
-            if (iece->reqitem[i] && !HasItemCount(iece->reqitem[i], (iece->reqitemcount[i] * count)))
+            if (iece->reqitem[i] == sSwitch->GetValue(ST_TOKEN_ID))
             {
-                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, nullptr);
+                uint32 hasToken = sCF->GetTokenAmount(this);
+                uint32 reqToken = iece->reqitemcount[i] * count;
+
+                if (hasToken < reqToken)
+                {
+                    GetSession()->SendNotification("[%s]ä¸è¶³ï¼ç¼ºå°%u[%s]", sString->GetText(STR_TOKEN), reqToken - hasToken, sString->GetText(STR_TOKEN));
+                    return false;
+                }
+            }
+            else if (iece->reqitem[i] && !HasItemCount(iece->reqitem[i], (iece->reqitemcount[i] * count)))
+            {
+                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL);
                 return false;
             }
         }
@@ -22243,13 +23169,6 @@ bool Player::BuyItemFromVendorSlot(uint64 vendorguid, uint32 vendorslot, uint32
         }
     }
 
-
-    if (!sCustomMgr->BuyFromNeedSys(this, crItem->Needid, count))
-    {
-        SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, nullptr);
-        return false;
-    }
-
     uint32 price = 0;
     if (crItem->IsGoldRequired(pProto) && pProto->BuyPrice > 0) //Assume price cannot be negative (do not know why it is int32)
     {
@@ -22424,33 +23343,36 @@ void Player::AddSpellAndCategoryCooldowns(SpellInfo const* spellInfo, uint32 ite
         {
             for (uint8 idx = 0; idx < MAX_ITEM_SPELLS; ++idx)
             {
-                if (uint32(proto->Spells[idx].SpellId) == spellInfo->Id)
+                if (spell && spell->m_CastItem && spell->m_CastItem->IsNoPatch())
                 {
-                    cat    = proto->Spells[idx].SpellCategory;
-                    rec    = proto->Spells[idx].SpellCooldown;
-                    catrec = proto->Spells[idx].SpellCategoryCooldown;
-                    break;
+                    if (uint32(spell->m_CastItem->Spells[idx].SpellId) == spellInfo->Id)
+                    {
+                        cat = spell->m_CastItem->Spells[idx].SpellCategory;
+                        rec = spell->m_CastItem->Spells[idx].SpellCooldown;
+                        catrec = spell->m_CastItem->Spells[idx].SpellCategoryCooldown;
+                        break;
+                    }
+                }
+                else
+                {
+                    if (uint32(proto->Spells[idx].SpellId) == spellInfo->Id)
+                    {
+                        cat = proto->Spells[idx].SpellCategory;
+                        rec = proto->Spells[idx].SpellCooldown;
+                        catrec = proto->Spells[idx].SpellCategoryCooldown;
+                        break;
+                    }
                 }
             }
         }
     }
 
     // if no cooldown found above then base at DBC data
-    int32 cusCooltime = sCustomMgr->GetSpellModCooldown(spellInfo->Id);
-
     if (rec < 0 && catrec < 0)
     {
         cat = spellInfo->GetCategory();
-        if (cusCooltime >= 0)
-        {
-            rec = cusCooltime;
-            catrec = spellInfo->CategoryRecoveryTime;
-        }
-        else
-        {
-            rec = spellInfo->RecoveryTime;
-            catrec = spellInfo->CategoryRecoveryTime;
-        }
+        rec = spellInfo->RecoveryTime;
+        catrec = spellInfo->CategoryRecoveryTime;
     }
 
     time_t catrecTime;
@@ -22530,16 +23452,6 @@ void Player::AddSpellAndCategoryCooldowns(SpellInfo const* spellInfo, uint32 ite
             }
         }
     }
-
-    if (cusCooltime >= 0)
-    {
-        WorldPacket data(SMSG_SPELL_COOLDOWN, 8 + 1 + 4 + 4);
-        data << uint64(GetGUID());
-        data << uint8(SPELL_COOLDOWN_FLAG_NONE);
-        data << uint32(spellInfo->Id);
-        data << uint32(cusCooltime);
-        SendDirectMessage(&data);
-    }
 }
 
 void Player::AddSpellCooldown(uint32 spellid, uint32 itemid, uint32 end_time, bool needSendToClient, bool forceSendToSpectator)
@@ -22840,6 +23752,9 @@ void Player::LeaveBattleground(Battleground* bg)
     if (!bg)
         return;
 
+    //ç§»é¤éæºBUFF
+    sFTB->RemoveRandomBuff(bg, this);
+
     // Deserter tracker - leave BG
     if (bg->isBattleground() && sWorld->getBoolConfig(CONFIG_BATTLEGROUND_TRACK_DESERTERS)
         && (bg->GetStatus() == STATUS_IN_PROGRESS || bg->GetStatus() == STATUS_WAIT_JOIN))
@@ -22857,6 +23772,12 @@ void Player::LeaveBattleground(Battleground* bg)
     GetMotionMaster()->MovementExpired();
     StopMoving();
     TeleportToEntryPoint();
+
+    //æ¢å¤æ­£å¸¸è¡é,æ¢å¤æ­£å¸¸TeamId
+    //UpdateMaxHealth();
+    m_team = realTeam;
+    setFactionForRace(getRace());
+    sWorld->UpdateGlobalPlayerData(GetGUIDLow(), PLAYER_UPDATE_DATA_RACE, "", 0, 0, getRace());
 }
 
 bool Player::CanJoinToBattleground() const
@@ -23033,6 +23954,14 @@ void Player::UpdateVisibilityOf(WorldObject* target)
             // send data at target visibility change (adding to client)
             if (target->isType(TYPEMASK_UNIT))
                 GetInitialVisiblePackets((Unit*)target);
+
+            if (target->GetTypeId() == TYPEID_PLAYER)
+            {
+                Player* tar = target->ToPlayer();
+
+                sGS->SendGSData(tar, this);
+                sGS->SendGSData(this, tar);
+            }
         }
     }
 }
@@ -23480,7 +24409,7 @@ void Player::ApplyEquipCooldown(Item* pItem)
 
     for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
     {
-        _Spell const& spellData = pItem->GetTemplate()->Spells[i];
+        _Spell const& spellData = pItem->IsNoPatch() ? pItem->Spells[i] : pItem->GetTemplate()->Spells[i];
 
         // no spell
         if (!spellData.SpellId)
@@ -25391,6 +26320,12 @@ void Player::StoreLootItem(uint8 lootSlot, Loot* loot)
         --loot->unlootedCount;
 
         SendNewItem(newitem, uint32(item->count), false, false, true);
+
+        //å±äº«ç©å
+        sRecruit->RecruitItemReward(this, newitem, uint32(item->count));
+
+        sNoPatchItem->Create(GetMap(), newitem);
+
         UpdateLootAchievements(item, loot);
 
         // LootItem is being removed (looted) from the container, delete it from the DB.
@@ -25728,6 +26663,10 @@ void Player::CompletedAchievement(AchievementEntry const* entry)
 
 void Player::LearnTalent(uint32 talentId, uint32 talentRank)
 {
+    buy_talentId = 0;
+    buy_talentRank = 0;
+    buy_talentSpell = 0;
+
     uint32 CurTalentPoints = GetFreeTalentPoints();
 
     // xinef: check basic data
@@ -25816,6 +26755,15 @@ void Player::LearnTalent(uint32 talentId, uint32 talentRank)
     if (!spellInfo)
         return;
 
+    //å¤©èµæ¶è
+    if (sTalentReq->SendAcceptOrCancel(this, spellId))
+    {
+        buy_talentSpell = spellId;
+        buy_talentId = talentId;
+        buy_talentRank = talentRank;
+        return;
+    }
+
     bool learned = false;
 
     // xinef: if talent info has special marker in dbc - add to spell book
@@ -25845,18 +26793,158 @@ void Player::LearnTalent(uint32 talentId, uint32 talentRank)
 #endif
 }
 
-void Player::LearnPetTalent(uint64 petGuid, uint32 talentId, uint32 talentRank)
+void Player::LearnTalentCustom(uint32 talentId, uint32 talentRank)
 {
-    Pet* pet = GetPet();
+    uint32 CurTalentPoints = GetFreeTalentPoints();
 
-    if (!pet)
+    // xinef: check basic data
+    if (CurTalentPoints == 0)
         return;
 
-    if (petGuid != pet->GetGUID())
+    if (talentRank >= MAX_TALENT_RANK)
         return;
 
-    uint32 CurTalentPoints = pet->GetFreeTalentPoints();
-
+    TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);
+    if (!talentInfo)
+        return;
+
+    TalentTabEntry const* talentTabInfo = sTalentTabStore.LookupEntry(talentInfo->TalentTab);
+    if (!talentTabInfo)
+        return;
+
+    // xinef: prevent learn talent for different class (cheating)
+    if ((getClassMask() & talentTabInfo->ClassMask) == 0)
+        return;
+
+    // xinef: find current talent rank
+    uint32 currentTalentRank = 0;
+    for (uint8 rank = 0; rank < MAX_TALENT_RANK; ++rank)
+    {
+        if (talentInfo->RankID[rank] && HasTalent(talentInfo->RankID[rank], GetActiveSpec()))
+        {
+            currentTalentRank = rank + 1;
+            break;
+        }
+    }
+
+    // xinef: we already have same or higher rank talent learned
+    if (currentTalentRank >= talentRank + 1)
+        return;
+
+    // xinef: check if we have enough free talent points
+    uint32 talentPointsChange = (talentRank - currentTalentRank + 1);
+    if (CurTalentPoints < talentPointsChange)
+        return;
+
+    // xinef: check if talent deponds on another talent
+    if (talentInfo->DependsOn > 0)
+        if (TalentEntry const* depTalentInfo = sTalentStore.LookupEntry(talentInfo->DependsOn))
+        {
+            bool hasEnoughRank = false;
+            for (uint8 rank = talentInfo->DependsOnRank; rank < MAX_TALENT_RANK; rank++)
+            {
+                if (depTalentInfo->RankID[rank] != 0)
+                    if (HasTalent(depTalentInfo->RankID[rank], GetActiveSpec()))
+                    {
+                        hasEnoughRank = true;
+                        break;
+                    }
+            }
+
+            // xinef: does not have enough talent points spend in required talent
+            if (!hasEnoughRank)
+                return;
+        }
+
+    // xinef: check amount of points spent in current talent tree
+    // xinef: be smart and quick, not retarded like TC
+    uint32 spentPoints = 0;
+    if (talentInfo->Row > 0)
+    {
+        const PlayerTalentMap& talentMap = GetTalentMap();
+        for (PlayerTalentMap::const_iterator itr = talentMap.begin(); itr != talentMap.end(); ++itr)
+            if (TalentSpellPos const* talentPos = GetTalentSpellPos(itr->first))
+                if (TalentEntry const* itrTalentInfo = sTalentStore.LookupEntry(talentPos->talent_id))
+                    if (itrTalentInfo->TalentTab == talentInfo->TalentTab)
+                        if (itr->second->State != PLAYERSPELL_REMOVED && itr->second->IsInSpec(GetActiveSpec())) // pussywizard
+                            spentPoints += talentPos->rank + 1;
+    }
+
+    // xinef: we do not have enough talent points to add talent of this tier
+    if (spentPoints < (talentInfo->Row * MAX_TALENT_RANK))
+        return;
+
+    // xinef: hacking attempt, tries to learn unknown rank
+    uint32 spellId = talentInfo->RankID[talentRank];
+    if (spellId == 0)
+        return;
+
+    const SpellInfo* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+        return;
+
+    bool learned = false;
+
+    // xinef: if talent info has special marker in dbc - add to spell book
+    if (talentInfo->addToSpellBook)
+        if (!spellInfo->HasAttribute(SPELL_ATTR0_PASSIVE) && !spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL))
+        {
+            learnSpell(spellId);
+            learned = true;
+        }
+
+    if (!learned)
+        SendLearnPacket(spellId, true);
+
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        if (spellInfo->Effects[i].Effect == SPELL_EFFECT_LEARN_SPELL)
+            if (sSpellMgr->IsAdditionalTalentSpell(spellInfo->Effects[i].TriggerSpell))
+                learnSpell(spellInfo->Effects[i].TriggerSpell);
+
+    addTalent(spellId, GetActiveSpecMask(), currentTalentRank);
+
+    // xinef: update free talent points count
+    m_usedTalentCount += talentPointsChange;
+    SetFreeTalentPoints(CurTalentPoints - talentPointsChange);
+
+    sEluna->OnLearnTalents(this, talentId, talentRank, spellId);
+}
+
+Item* Player::AddItemById(uint32 itemId, uint32 count)
+{
+    uint32 noSpaceForCount = 0;
+    ItemPosCountVec dest;
+    InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, count, &noSpaceForCount);
+    if (msg != EQUIP_ERR_OK)
+        count -= noSpaceForCount;
+
+    if (count == 0 || dest.empty())
+    {
+        // -- TODO: Send to mailbox if no space
+        //ChatHandler(GetSession()).PSendSysMessage("You don't have any space in your bags.");
+        return NULL;
+    }
+
+    Item* item = StoreNewItem(dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId));
+    if (item)
+        SendNewItem(item, count, true, false);
+    else
+        return NULL;
+    return item;
+}
+
+void Player::LearnPetTalent(uint64 petGuid, uint32 talentId, uint32 talentRank)
+{
+    Pet* pet = GetPet();
+
+    if (!pet)
+        return;
+
+    if (petGuid != pet->GetGUID())
+        return;
+
+    uint32 CurTalentPoints = pet->GetFreeTalentPoints();
+
     if (CurTalentPoints == 0)
         return;
 
@@ -27845,3 +28933,963 @@ bool Player::HasHealSpec()
 }
 
 std::unordered_map<int, bgZoneRef> Player::bgZoneIdToFillWorldStates = {};
+
+bool Player::JoinGuildGroup()
+{
+    if (IsSpectator()) return false;
+
+    if (!GetGuild()->guildGroup || !ObjectAccessor::FindPlayerInOrOutOfWorld(GetGuild()->guildGroup->GetLeaderGUID()) || ObjectAccessor::FindPlayerInOrOutOfWorld(GetGuild()->guildGroup->GetLeaderGUID())->IsSpectator())
+        GetGuild()->BuildGuildGroup(this);
+    else if (!GetGuild()->guildGroup->IsFull())
+        GetGuild()->guildGroup->AddMember(this);
+    else
+        return false;
+
+    return true;
+}
+
+//bool Player::LootCheck()
+//{
+//	if (LootCheckCount == 5)
+//		LootCheckPop(30);
+//
+//	LootCheckCount++;
+//
+//	return true;
+//}
+//
+//void Player::LootCheckPop(uint32 seconds)
+//{
+//	std::ostringstream oss;
+//	oss << urand(1, 9) << urand(0, 9) << urand(0, 9) << urand(0, 9);
+//
+//	GetSession()->SendAreaTriggerMessage("[æ¾åéªè¯]è¯·è¾å¥éªè¯ç [%s]ï¼è¾å¥éè¯¯æ%dç§åä¸è¾å¥å°è¢«è¸¢åºæ¸¸æï¼", oss.str().c_str(), seconds);
+//	ChatHandler(GetSession()).PSendSysMessage("[æ¾åéªè¯]è¯·è¾å¥éªè¯ç [%s]ï¼è¾å¥éè¯¯æ%dç§åä¸è¾å¥å°è¢«è¸¢åºæ¸¸æï¼", oss.str().c_str(), seconds);
+//
+//	PlayerTalkClass->ClearMenus();
+//	ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_BATTLE, "æ¾åéªè¯", atoi(oss.str().c_str()), GOSSIP_ACTION_INFO_DEF, "", 0, true);
+//	PlayerTalkClass->GetGossipMenu().SetMenuId(7878);
+//	SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, GetGUID());
+//}
+//
+//void Player::LootCheckReset()
+//{ 
+//	LootCheckCount = 0; 
+//	LootCheckTimer = 0;
+//}
+//
+//void Player::LootCheckLoad()
+//{
+//	PreparedStatement*stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_LOOTCHECK);
+//	stmt->setUInt32(0, GetGUIDLow());
+//
+//	if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
+//		LootCheckCount = result->Fetch()[0].GetUInt32();
+//
+//	if (LootCheckCount >= 5)
+//	{
+//		LootCheckTimer = 0;
+//		LootCheckPop(30);
+//	}	
+//}
+//
+//void Player::LootCheckSave()
+//{
+//	SQLTransaction trans = CharacterDatabase.BeginTransaction();
+//	PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_LOOTCHECK);
+//	stmt->setUInt32(0, LootCheckCount);
+//	stmt->setUInt32(1, GetGUIDLow());
+//	trans->Append(stmt);
+//	CharacterDatabase.CommitTransaction(trans);
+//}
+
+void Player::InitDayLimitItem()
+{
+    QueryResult result = CharacterDatabase.PQuery("SELECT entry,count FROM character_day_item WHERE guid = '%u'", GetGUIDLow());
+    if (result)
+    {
+        do
+        {
+            Field* fields = result->Fetch();
+            PDayLimitItemMap.insert(std::make_pair(fields[0].GetUInt32(), fields[1].GetUInt32()));
+        } while (result->NextRow());
+    }
+}
+
+uint32 Player::GetDayLimitItemInsCount(uint32 entry, uint32 count)
+{
+    auto itr = DayLimitItemMap.find(entry);
+    if (itr == DayLimitItemMap.end())
+        return count;
+
+    uint32 limit = itr->second;
+    uint32 hasCount = 0;
+
+    itr = PDayLimitItemMap.find(entry);
+    if (itr != PDayLimitItemMap.end())
+        hasCount = itr->second;
+
+    if (hasCount >= limit)
+        return 0;
+
+    uint32 inscount = 0;
+
+    if (hasCount + count > limit)
+        inscount = limit - hasCount;
+    else
+        inscount = count;
+
+    return inscount;
+}
+
+uint32 Player::CanStoreDayLimitItem(uint32 entry, uint32 count)
+{
+    auto itr = DayLimitItemMap.find(entry);
+    if (itr == DayLimitItemMap.end())
+        return count;
+
+    uint32 limit = itr->second;
+    uint32 hasCount = 0;
+
+    itr = PDayLimitItemMap.find(entry);
+    if (itr != PDayLimitItemMap.end())
+        hasCount = itr->second;
+
+    if (hasCount >= limit)
+    {
+        ChatHandler(GetSession()).PSendSysMessage("%sè¾¾å°æ¯æ¥ä¸é %u", sCF->GetItemLink(entry).c_str(), limit);
+        return 0;
+    }
+
+    uint32 inscount = 0;
+
+    if (hasCount + count > limit)
+        inscount = limit - hasCount;
+    else
+        inscount = count;
+
+    std::ostringstream oss;
+    oss << entry << " ";
+    oss << hasCount + inscount;
+    sGCAddon->SendPacketTo(this, "GC_S_DAYLIMIT", oss.str());
+
+    itr = PDayLimitItemMap.find(entry);
+    if (itr != PDayLimitItemMap.end())
+        itr->second += inscount;
+    else
+        PDayLimitItemMap.insert(std::make_pair(entry, hasCount + inscount));
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ITEM_DAY);
+    stmt->setUInt32(0, GetGUIDLow());
+    stmt->setUInt32(1, entry);
+    stmt->setUInt32(2, hasCount + inscount);
+    CharacterDatabase.Execute(stmt);
+
+    return inscount;
+}
+
+bool Player::LootCheck()
+{
+    if (!sWorld->getBoolConfig(CONFIG_LOOTCHECK_ENABLED))
+    {
+        LootCheckReset();
+        return true;
+    }
+
+    if (GetMapId() != 0 && GetMapId() != 1 && GetMapId() != 530 && GetMapId() != 571)
+        return true;
+
+    LootCheckCount++;
+
+    if (LootCheckCount >= sWorld->getIntConfig(CONFIG_LOOTCHECK_COUNT))
+        LootCheckPop(sWorld->getIntConfig(CONFIG_LOOTCHECK_SECONDS) - LootCheckTimer / IN_MILLISECONDS);
+
+    return true;
+}
+
+void Player::LootCheckPop(uint32 seconds)
+{
+    std::ostringstream oss;
+    oss << urand(1, 9) << urand(0, 9);
+
+    GetSession()->SendAreaTriggerMessage("|cFFFF0000è¯·è¾å¥çµå­åæ¢å·å·ç [|cFF00FFFF%s|cFFFF0000]ï¼è¾å¥éè¯¯ææ¯|cFF66FF33%u|cFFFF0000ç§åä¸è¾å¥å°è¢«è¸¢åºæ¸¸æï¼", oss.str().c_str(), seconds);
+    ChatHandler(GetSession()).PSendSysMessage("|cFFFF0000è¯·è¾å¥çµå­åæ¢å·å·ç [|cFF00FFFF%s|cFFFF0000]ï¼è¾å¥éè¯¯ææ¯|cFF66FF33%u|cFFFF0000ç§åä¸è¾å¥å°è¢«è¸¢åºæ¸¸æï¼", oss.str().c_str(), seconds);
+
+    PlayerTalkClass->ClearMenus();
+    ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_BATTLE, "æ¾åéªè¯", atoi(oss.str().c_str()), GOSSIP_ACTION_INFO_DEF, "", 0, true);
+    PlayerTalkClass->GetGossipMenu().SetMenuId(7878);
+    SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, GetGUID());
+}
+
+void Player::LootCheckReset()
+{
+    LootCheckCount = 0;
+    LootCheckTimer = 0;
+}
+
+void Player::LootCheckLoad()
+{
+    if (!sWorld->getBoolConfig(CONFIG_LOOTCHECK_ENABLED))
+        return;
+
+    PreparedStatement*stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_LOOTCHECK);
+    stmt->setUInt32(0, GetGUIDLow());
+
+    if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
+    {
+        LootCheckCount = result->Fetch()[0].GetUInt32();
+        LootCheckBanCount = result->Fetch()[1].GetUInt32();
+    }
+
+    if (LootCheckCount >= sWorld->getIntConfig(CONFIG_LOOTCHECK_COUNT))
+    {
+        LootCheckTimer = 0;
+        LootCheckPop(sWorld->getIntConfig(CONFIG_LOOTCHECK_SECONDS));
+    }
+}
+
+void Player::LootCheckSave()
+{
+    if (!sWorld->getBoolConfig(CONFIG_LOOTCHECK_ENABLED))
+        return;
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_LOOTCHECK);
+    stmt->setUInt32(0, LootCheckCount);
+    stmt->setUInt32(1, LootCheckBanCount);
+    stmt->setUInt32(2, GetGUIDLow());
+    trans->Append(stmt);
+    CharacterDatabase.CommitTransaction(trans);
+}
+
+void Player::LootCheckBan()
+{
+    LootCheckBanCount++;
+
+    switch (sWorld->getIntConfig(CONFIG_LOOTCHECK_TYPE))
+    {
+    case 0:
+    {
+        std::ostringstream oss;
+        oss << LootCheckBanCount << "h";
+        sBan->BanCharacter(GetName(), oss.str(), "æ¾åéªè¯å¤±è´¥", "GM");
+    }
+    break;
+    case 1:
+        GetSession()->KickPlayer();
+        break;
+    default:
+        break;
+    }
+}
+
+//custom fuc
+
+void Player::ApplyEnchantmentCustom(Item* item, bool apply)
+{
+    for (uint32 slot = 0; slot < MAX_ENCHANTMENT_SLOT; ++slot)
+        ApplyEnchantmentCustom(item, EnchantmentSlot(slot), apply);
+}
+
+void Player::ApplyEnchantmentCustom(Item* item, EnchantmentSlot slot, bool apply, bool apply_dur, bool ignore_condition)
+{
+    if (!item)
+        return;
+
+    if (slot >= MAX_ENCHANTMENT_SLOT)
+        return;
+
+    uint32 enchant_id = item->GetEnchantmentId(slot);
+    if (!enchant_id)
+        return;
+
+    SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+    if (!pEnchant)
+        return;
+
+    if (!ignore_condition && pEnchant->EnchantmentCondition && !EnchantmentFitsRequirements(pEnchant->EnchantmentCondition, -1))
+        return;
+
+    if (pEnchant->requiredLevel > getLevel())
+        return;
+
+    if (pEnchant->requiredSkill > 0 && pEnchant->requiredSkillValue > GetSkillValue(pEnchant->requiredSkill))
+        return;
+
+    // If we're dealing with a gem inside a prismatic socket we need to check the prismatic socket requirements
+    // rather than the gem requirements itself. If the socket has no color it is a prismatic socket.
+    if ((slot == SOCK_ENCHANTMENT_SLOT || slot == SOCK_ENCHANTMENT_SLOT_2 || slot == SOCK_ENCHANTMENT_SLOT_3)
+        && !item->GetTemplate()->Socket[slot - SOCK_ENCHANTMENT_SLOT].Color)
+    {
+        // Check if the requirements for the prismatic socket are met before applying the gem stats
+        SpellItemEnchantmentEntry const* pPrismaticEnchant = sSpellItemEnchantmentStore.LookupEntry(item->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT));
+        if (!pPrismaticEnchant || (pPrismaticEnchant->requiredSkill > 0 && pPrismaticEnchant->requiredSkillValue > GetSkillValue(pPrismaticEnchant->requiredSkill)))
+            return;
+    }
+
+    if (!item->IsBroken())
+    {
+        for (int s = 0; s < MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+        {
+            uint32 enchant_display_type = pEnchant->type[s];
+            uint32 enchant_amount = pEnchant->amount[s];
+            uint32 enchant_spell_id = pEnchant->spellid[s];
+
+            switch (enchant_display_type)
+            {
+            case ITEM_ENCHANTMENT_TYPE_NONE:
+                break;
+            case ITEM_ENCHANTMENT_TYPE_COMBAT_SPELL:
+                // processed in Player::CastItemCombatSpell
+                break;
+            case ITEM_ENCHANTMENT_TYPE_DAMAGE:
+                if (item->GetSlot() == EQUIPMENT_SLOT_MAINHAND)
+                    HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_VALUE, float(enchant_amount), apply);
+                else if (item->GetSlot() == EQUIPMENT_SLOT_OFFHAND)
+                    HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_VALUE, float(enchant_amount), apply);
+                else if (item->GetSlot() == EQUIPMENT_SLOT_RANGED)
+                    HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_VALUE, float(enchant_amount), apply);
+                break;
+            case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
+                if (enchant_spell_id)
+                {
+                    if (apply)
+                    {
+                        int32 basepoints = 0;
+                        // Random Property Exist - try found basepoints for spell (basepoints depends from item suffix factor)
+                        if (item->GetItemRandomPropertyId())
+                        {
+                            ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                            if (item_rand)
+                            {
+                                // Search enchant_amount
+                                for (int k = 0; k < MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                                {
+                                    if (item_rand->enchant_id[k] == enchant_id)
+                                    {
+                                        basepoints = int32((item_rand->prefix[k] * item->GetItemSuffixFactor()) / 10000);
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                        // Cast custom spell vs all equal basepoints got from enchant_amount
+                        if (basepoints)
+                            CastCustomSpell(this, enchant_spell_id, &basepoints, &basepoints, &basepoints, true, item);
+                        else
+                            CastSpell(this, enchant_spell_id, true, item);
+                    }
+                    else
+                        RemoveAurasDueToItemSpell(enchant_spell_id, item->GetGUID());
+                }
+                break;
+            case ITEM_ENCHANTMENT_TYPE_RESISTANCE:
+                if (!enchant_amount)
+                {
+                    ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                    if (item_rand)
+                    {
+                        for (int k = 0; k < MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                        {
+                            if (item_rand->enchant_id[k] == enchant_id)
+                            {
+                                enchant_amount = uint32((item_rand->prefix[k] * item->GetItemSuffixFactor()) / 10000);
+                                break;
+                            }
+                        }
+                    }
+                }
+
+                HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + enchant_spell_id), TOTAL_VALUE, float(enchant_amount), apply);
+                break;
+            case ITEM_ENCHANTMENT_TYPE_STAT:
+            {
+                if (!enchant_amount)
+                {
+                    ItemRandomSuffixEntry const* item_rand_suffix = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                    if (item_rand_suffix)
+                    {
+                        for (int k = 0; k < MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                        {
+                            if (item_rand_suffix->enchant_id[k] == enchant_id)
+                            {
+                                enchant_amount = uint32((item_rand_suffix->prefix[k] * item->GetItemSuffixFactor()) / 10000);
+                                break;
+                            }
+                        }
+                    }
+                }
+
+                //TC_LOG_DEBUG("entities.player.items", "Adding %u to stat nb %u", enchant_amount, enchant_spell_id);
+                switch (enchant_spell_id)
+                {
+                case ITEM_MOD_MANA:
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u MANA", enchant_amount);
+                    HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, float(enchant_amount), apply);
+                    break;
+                case ITEM_MOD_HEALTH:
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u HEALTH", enchant_amount);
+                    HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, float(enchant_amount), apply);
+                    break;
+                case ITEM_MOD_AGILITY:
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u AGILITY", enchant_amount);
+                    HandleStatModifier(UNIT_MOD_STAT_AGILITY, TOTAL_VALUE, float(enchant_amount), apply);
+                    ApplyStatBuffMod(STAT_AGILITY, (float)enchant_amount, apply);
+                    break;
+                case ITEM_MOD_STRENGTH:
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u STRENGTH", enchant_amount);
+                    HandleStatModifier(UNIT_MOD_STAT_STRENGTH, TOTAL_VALUE, float(enchant_amount), apply);
+                    ApplyStatBuffMod(STAT_STRENGTH, (float)enchant_amount, apply);
+                    break;
+                case ITEM_MOD_INTELLECT:
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u INTELLECT", enchant_amount);
+                    HandleStatModifier(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE, float(enchant_amount), apply);
+                    ApplyStatBuffMod(STAT_INTELLECT, (float)enchant_amount, apply);
+                    break;
+                case ITEM_MOD_SPIRIT:
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u SPIRIT", enchant_amount);
+                    HandleStatModifier(UNIT_MOD_STAT_SPIRIT, TOTAL_VALUE, float(enchant_amount), apply);
+                    ApplyStatBuffMod(STAT_SPIRIT, (float)enchant_amount, apply);
+                    break;
+                case ITEM_MOD_STAMINA:
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u STAMINA", enchant_amount);
+                    HandleStatModifier(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE, float(enchant_amount), apply);
+                    ApplyStatBuffMod(STAT_STAMINA, (float)enchant_amount, apply);
+                    break;
+                case ITEM_MOD_DEFENSE_SKILL_RATING:
+                    ApplyRatingMod(CR_DEFENSE_SKILL, enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u DEFENCE", enchant_amount);
+                    break;
+                case  ITEM_MOD_DODGE_RATING:
+                    ApplyRatingMod(CR_DODGE, enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u DODGE", enchant_amount);
+                    break;
+                case ITEM_MOD_PARRY_RATING:
+                    ApplyRatingMod(CR_PARRY, enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u PARRY", enchant_amount);
+                    break;
+                case ITEM_MOD_BLOCK_RATING:
+                    ApplyRatingMod(CR_BLOCK, enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u SHIELD_BLOCK", enchant_amount);
+                    break;
+                case ITEM_MOD_HIT_MELEE_RATING:
+                    ApplyRatingMod(CR_HIT_MELEE, enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u MELEE_HIT", enchant_amount);
+                    break;
+                case ITEM_MOD_HIT_RANGED_RATING:
+                    ApplyRatingMod(CR_HIT_RANGED, enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u RANGED_HIT", enchant_amount);
+                    break;
+                case ITEM_MOD_HIT_SPELL_RATING:
+                    ApplyRatingMod(CR_HIT_SPELL, enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u SPELL_HIT", enchant_amount);
+                    break;
+                case ITEM_MOD_CRIT_MELEE_RATING:
+                    ApplyRatingMod(CR_CRIT_MELEE, enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u MELEE_CRIT", enchant_amount);
+                    break;
+                case ITEM_MOD_CRIT_RANGED_RATING:
+                    ApplyRatingMod(CR_CRIT_RANGED, enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u RANGED_CRIT", enchant_amount);
+                    break;
+                case ITEM_MOD_CRIT_SPELL_RATING:
+                    ApplyRatingMod(CR_CRIT_SPELL, enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u SPELL_CRIT", enchant_amount);
+                    break;
+                    //                        Values from ITEM_STAT_MELEE_HA_RATING to ITEM_MOD_HASTE_RANGED_RATING are never used
+                    //                        in Enchantments
+                    //                        case ITEM_MOD_HIT_TAKEN_MELEE_RATING:
+                    //                            ApplyRatingMod(CR_HIT_TAKEN_MELEE, enchant_amount, apply);
+                    //                            break;
+                    //                        case ITEM_MOD_HIT_TAKEN_RANGED_RATING:
+                    //                            ApplyRatingMod(CR_HIT_TAKEN_RANGED, enchant_amount, apply);
+                    //                            break;
+                    //                        case ITEM_MOD_HIT_TAKEN_SPELL_RATING:
+                    //                            ApplyRatingMod(CR_HIT_TAKEN_SPELL, enchant_amount, apply);
+                    //                            break;
+                    //                        case ITEM_MOD_CRIT_TAKEN_MELEE_RATING:
+                    //                            ApplyRatingMod(CR_CRIT_TAKEN_MELEE, enchant_amount, apply);
+                    //                            break;
+                    //                        case ITEM_MOD_CRIT_TAKEN_RANGED_RATING:
+                    //                            ApplyRatingMod(CR_CRIT_TAKEN_RANGED, enchant_amount, apply);
+                    //                            break;
+                    //                        case ITEM_MOD_CRIT_TAKEN_SPELL_RATING:
+                    //                            ApplyRatingMod(CR_CRIT_TAKEN_SPELL, enchant_amount, apply);
+                    //                            break;
+                    //                        case ITEM_MOD_HASTE_MELEE_RATING:
+                    //                            ApplyRatingMod(CR_HASTE_MELEE, enchant_amount, apply);
+                    //                            break;
+                    //                        case ITEM_MOD_HASTE_RANGED_RATING:
+                    //                            ApplyRatingMod(CR_HASTE_RANGED, enchant_amount, apply);
+                    //                            break;
+                case ITEM_MOD_HASTE_SPELL_RATING:
+                    ApplyRatingMod(CR_HASTE_SPELL, enchant_amount, apply);
+                    break;
+                case ITEM_MOD_HIT_RATING:
+                    ApplyRatingMod(CR_HIT_MELEE, enchant_amount, apply);
+                    ApplyRatingMod(CR_HIT_RANGED, enchant_amount, apply);
+                    ApplyRatingMod(CR_HIT_SPELL, enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u HIT", enchant_amount);
+                    break;
+                case ITEM_MOD_CRIT_RATING:
+                    ApplyRatingMod(CR_CRIT_MELEE, enchant_amount, apply);
+                    ApplyRatingMod(CR_CRIT_RANGED, enchant_amount, apply);
+                    ApplyRatingMod(CR_CRIT_SPELL, enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u CRITICAL", enchant_amount);
+                    break;
+                    //                        Values ITEM_MOD_HIT_TAKEN_RATING and ITEM_MOD_CRIT_TAKEN_RATING are never used in Enchantment
+                    //                        case ITEM_MOD_HIT_TAKEN_RATING:
+                    //                            ApplyRatingMod(CR_HIT_TAKEN_MELEE, enchant_amount, apply);
+                    //                            ApplyRatingMod(CR_HIT_TAKEN_RANGED, enchant_amount, apply);
+                    //                            ApplyRatingMod(CR_HIT_TAKEN_SPELL, enchant_amount, apply);
+                    //                            break;
+                    //                        case ITEM_MOD_CRIT_TAKEN_RATING:
+                    //                            ApplyRatingMod(CR_CRIT_TAKEN_MELEE, enchant_amount, apply);
+                    //                            ApplyRatingMod(CR_CRIT_TAKEN_RANGED, enchant_amount, apply);
+                    //                            ApplyRatingMod(CR_CRIT_TAKEN_SPELL, enchant_amount, apply);
+                    //                            break;
+                case ITEM_MOD_RESILIENCE_RATING:
+                    ApplyRatingMod(CR_CRIT_TAKEN_MELEE, enchant_amount, apply);
+                    ApplyRatingMod(CR_CRIT_TAKEN_RANGED, enchant_amount, apply);
+                    ApplyRatingMod(CR_CRIT_TAKEN_SPELL, enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u RESILIENCE", enchant_amount);
+                    break;
+                case ITEM_MOD_HASTE_RATING:
+                    ApplyRatingMod(CR_HASTE_MELEE, enchant_amount, apply);
+                    ApplyRatingMod(CR_HASTE_RANGED, enchant_amount, apply);
+                    ApplyRatingMod(CR_HASTE_SPELL, enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u HASTE", enchant_amount);
+                    break;
+                case ITEM_MOD_EXPERTISE_RATING:
+                    ApplyRatingMod(CR_EXPERTISE, enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u EXPERTISE", enchant_amount);
+                    break;
+                case ITEM_MOD_ATTACK_POWER:
+                    HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(enchant_amount), apply);
+                    HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(enchant_amount), apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u ATTACK_POWER", enchant_amount);
+                    break;
+                case ITEM_MOD_RANGED_ATTACK_POWER:
+                    HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(enchant_amount), apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u RANGED_ATTACK_POWER", enchant_amount);
+                    break;
+                    //                        case ITEM_MOD_FERAL_ATTACK_POWER:
+                    //                            ApplyFeralAPBonus(enchant_amount, apply);
+                    //                            //TC_LOG_DEBUG("entities.player.items", "+ %u FERAL_ATTACK_POWER", enchant_amount);
+                    //                            break;
+                case ITEM_MOD_MANA_REGENERATION:
+                    ApplyManaRegenBonus(enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u MANA_REGENERATION", enchant_amount);
+                    break;
+                case ITEM_MOD_ARMOR_PENETRATION_RATING:
+                    ApplyRatingMod(CR_ARMOR_PENETRATION, enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u ARMOR PENETRATION", enchant_amount);
+                    break;
+                case ITEM_MOD_SPELL_POWER:
+                    ApplySpellPowerBonus(enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u SPELL_POWER", enchant_amount);
+                    break;
+                case ITEM_MOD_HEALTH_REGEN:
+                    ApplyHealthRegenBonus(enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u HEALTH_REGENERATION", enchant_amount);
+                    break;
+                case ITEM_MOD_SPELL_PENETRATION:
+                    ApplySpellPenetrationBonus(enchant_amount, apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u SPELL_PENETRATION", enchant_amount);
+                    break;
+                case ITEM_MOD_BLOCK_VALUE:
+                    HandleBaseModValue(SHIELD_BLOCK_VALUE, FLAT_MOD, float(enchant_amount), apply);
+                    //TC_LOG_DEBUG("entities.player.items", "+ %u BLOCK_VALUE", enchant_amount);
+                    break;
+                case ITEM_MOD_SPELL_HEALING_DONE:   // deprecated
+                case ITEM_MOD_SPELL_DAMAGE_DONE:    // deprecated
+                default:
+                    break;
+                }
+                break;
+            }
+            case ITEM_ENCHANTMENT_TYPE_TOTEM:           // Shaman Rockbiter Weapon
+            {
+                if (getClass() == CLASS_SHAMAN)
+                {
+                    float addValue = 0.0f;
+                    if (item->GetSlot() == EQUIPMENT_SLOT_MAINHAND)
+                    {
+                        addValue = float(enchant_amount * item->GetTemplate()->Delay / 1000.0f);
+                        HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_VALUE, addValue, apply);
+                    }
+                    else if (item->GetSlot() == EQUIPMENT_SLOT_OFFHAND)
+                    {
+                        addValue = float(enchant_amount * item->GetTemplate()->Delay / 1000.0f);
+                        HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_VALUE, addValue, apply);
+                    }
+                }
+                break;
+            }
+            case ITEM_ENCHANTMENT_TYPE_USE_SPELL:
+                // processed in Player::CastItemUseSpell
+                break;
+            case ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET:
+                // nothing do..
+                break;
+            default:
+                ////TC_LOG_ERROR("entities.player", "Unknown item enchantment (id = %d) display type: %d", enchant_id, enchant_display_type);
+                break;
+            }                                               /*switch (enchant_display_type)*/
+        }                                                   /*for*/
+    }
+
+    // visualize enchantment at player and equipped items
+    if (slot == PERM_ENCHANTMENT_SLOT)
+        SetUInt16Value(PLAYER_VISIBLE_ITEM_1_ENCHANTMENT + (item->GetSlot() * 2), 0, apply ? item->GetEnchantmentId(slot) : 0);
+
+    if (slot == TEMP_ENCHANTMENT_SLOT)
+        SetUInt16Value(PLAYER_VISIBLE_ITEM_1_ENCHANTMENT + (item->GetSlot() * 2), 1, apply ? item->GetEnchantmentId(slot) : 0);
+
+    if (apply_dur)
+    {
+        if (apply)
+        {
+            // set duration
+            uint32 duration = item->GetEnchantmentDuration(slot);
+            if (duration > 0)
+                AddEnchantmentDuration(item, slot, duration);
+        }
+        else
+        {
+            // duration == 0 will remove EnchantDuration
+            AddEnchantmentDuration(item, slot, 0);
+        }
+    }
+}
+
+void Player::_ApplyItemModsCustom(Item* item, uint8 slot, bool apply)
+{
+    if (!item)
+        return;
+
+    ItemTemplate const* proto = item->GetTemplate();
+
+    if (!proto)
+        return;
+
+    // not apply/remove mods for broken item
+    if (item->IsBroken())
+        return;
+
+    //TC_LOG_DEBUG("entities.player.items", "applying mods for item %u ", item->GetGUID().GetCounter());
+
+    uint8 attacktype = Player::GetAttackBySlot(slot);
+
+    if (proto->Socket[0].Color)                              //only (un)equipping of items with sockets can influence metagems, so no need to waste time with normal items
+        CorrectMetaGemEnchants(slot, apply);
+
+    if (attacktype < MAX_ATTACK)
+        _ApplyWeaponDependentAuraMods(item, WeaponAttackType(attacktype), apply);
+
+    _ApplyItemBonusesCustom(item, proto, slot, apply);
+
+    if (slot == EQUIPMENT_SLOT_RANGED)
+        _ApplyAmmoBonuses();
+
+    ApplyItemEquipSpell(item, apply);
+    ApplyEnchantmentCustom(item, apply);
+
+    //TC_LOG_DEBUG("entities.player.items", "_ApplyItemMods complete.");
+}
+
+void Player::_ApplyItemBonusesCustom(Item* item, ItemTemplate const* proto, uint8 slot, bool apply, bool only_level_scale /*= false*/)
+{
+    if (!proto)
+        return;
+
+    ScalingStatDistributionEntry const* ssd = proto->ScalingStatDistribution ? sScalingStatDistributionStore.LookupEntry(proto->ScalingStatDistribution) : NULL;
+    if (only_level_scale && !ssd)
+        return;
+
+    // req. check at equip, but allow use for extended range if range limit max level, set proper level
+    uint32 ssd_level = getLevel();
+    if (ssd && ssd_level > ssd->MaxLevel)
+        ssd_level = ssd->MaxLevel;
+
+    ScalingStatValuesEntry const* ssv = proto->ScalingStatValue ? sScalingStatValuesStore.LookupEntry(ssd_level) : NULL;
+    if (only_level_scale && !ssv)
+        return;
+
+    for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
+    {
+        uint32 statType = 0;
+        int64  val = 0;
+
+        if (!item || !item->IsNoPatch())
+        {
+            // If set ScalingStatDistribution need get stats and values from it
+            if (ssd && ssv)
+            {
+                if (ssd->StatMod[i] < 0)
+                    continue;
+                statType = ssd->StatMod[i];
+                val = (ssv->getssdMultiplier(proto->ScalingStatValue) * ssd->Modifier[i]) / 10000;
+            }
+            else
+            {
+                if (i >= proto->StatsCount)
+                    continue;
+                statType = proto->ItemStat[i].ItemStatType;
+                val = proto->ItemStat[i].ItemStatValue;
+            }
+        }
+        else
+        {
+            statType = item->Stats[i].ItemStatType;
+            val = item->Stats[i].ItemStatValue;
+        }
+
+        if (val == 0)
+            continue;
+
+        switch (statType)
+        {
+        case ITEM_MOD_MANA:
+            HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, float(val), apply);
+            break;
+        case ITEM_MOD_HEALTH:                           // modify HP
+            HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, float(val), apply);
+            break;
+        case ITEM_MOD_AGILITY:                          // modify agility
+            HandleStatModifier(UNIT_MOD_STAT_AGILITY, BASE_VALUE, float(val), apply);
+            ApplyStatBuffMod(STAT_AGILITY, float(val), apply);
+            break;
+        case ITEM_MOD_STRENGTH:                         //modify strength
+            HandleStatModifier(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, float(val), apply);
+            ApplyStatBuffMod(STAT_STRENGTH, float(val), apply);
+            break;
+        case ITEM_MOD_INTELLECT:                        //modify intellect
+            HandleStatModifier(UNIT_MOD_STAT_INTELLECT, BASE_VALUE, float(val), apply);
+            ApplyStatBuffMod(STAT_INTELLECT, float(val), apply);
+            break;
+        case ITEM_MOD_SPIRIT:                           //modify spirit
+            HandleStatModifier(UNIT_MOD_STAT_SPIRIT, BASE_VALUE, float(val), apply);
+            ApplyStatBuffMod(STAT_SPIRIT, float(val), apply);
+            break;
+        case ITEM_MOD_STAMINA:                          //modify stamina
+            HandleStatModifier(UNIT_MOD_STAT_STAMINA, BASE_VALUE, float(val), apply);
+            ApplyStatBuffMod(STAT_STAMINA, float(val), apply);
+            break;
+        case ITEM_MOD_DEFENSE_SKILL_RATING:
+            ApplyRatingMod(CR_DEFENSE_SKILL, int32(val), apply);
+            break;
+        case ITEM_MOD_DODGE_RATING:
+            ApplyRatingMod(CR_DODGE, int32(val), apply);
+            break;
+        case ITEM_MOD_PARRY_RATING:
+            ApplyRatingMod(CR_PARRY, int32(val), apply);
+            break;
+        case ITEM_MOD_BLOCK_RATING:
+            ApplyRatingMod(CR_BLOCK, int32(val), apply);
+            break;
+        case ITEM_MOD_HIT_MELEE_RATING:
+            ApplyRatingMod(CR_HIT_MELEE, int32(val), apply);
+            break;
+        case ITEM_MOD_HIT_RANGED_RATING:
+            ApplyRatingMod(CR_HIT_RANGED, int32(val), apply);
+            break;
+        case ITEM_MOD_HIT_SPELL_RATING:
+            ApplyRatingMod(CR_HIT_SPELL, int32(val), apply);
+            break;
+        case ITEM_MOD_CRIT_MELEE_RATING:
+            ApplyRatingMod(CR_CRIT_MELEE, int32(val), apply);
+            break;
+        case ITEM_MOD_CRIT_RANGED_RATING:
+            ApplyRatingMod(CR_CRIT_RANGED, int32(val), apply);
+            break;
+        case ITEM_MOD_CRIT_SPELL_RATING:
+            ApplyRatingMod(CR_CRIT_SPELL, int32(val), apply);
+            break;
+        case ITEM_MOD_HIT_TAKEN_MELEE_RATING:
+            ApplyRatingMod(CR_HIT_TAKEN_MELEE, int32(val), apply);
+            break;
+        case ITEM_MOD_HIT_TAKEN_RANGED_RATING:
+            ApplyRatingMod(CR_HIT_TAKEN_RANGED, int32(val), apply);
+            break;
+        case ITEM_MOD_HIT_TAKEN_SPELL_RATING:
+            ApplyRatingMod(CR_HIT_TAKEN_SPELL, int32(val), apply);
+            break;
+        case ITEM_MOD_CRIT_TAKEN_MELEE_RATING:
+            ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(val), apply);
+            break;
+        case ITEM_MOD_CRIT_TAKEN_RANGED_RATING:
+            ApplyRatingMod(CR_CRIT_TAKEN_RANGED, int32(val), apply);
+            break;
+        case ITEM_MOD_CRIT_TAKEN_SPELL_RATING:
+            ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(val), apply);
+            break;
+        case ITEM_MOD_HASTE_MELEE_RATING:
+            ApplyRatingMod(CR_HASTE_MELEE, int32(val), apply);
+            break;
+        case ITEM_MOD_HASTE_RANGED_RATING:
+            ApplyRatingMod(CR_HASTE_RANGED, int32(val), apply);
+            break;
+        case ITEM_MOD_HASTE_SPELL_RATING:
+            ApplyRatingMod(CR_HASTE_SPELL, int32(val), apply);
+            break;
+        case ITEM_MOD_HIT_RATING:
+            ApplyRatingMod(CR_HIT_MELEE, int32(val), apply);
+            ApplyRatingMod(CR_HIT_RANGED, int32(val), apply);
+            ApplyRatingMod(CR_HIT_SPELL, int32(val), apply);
+            break;
+        case ITEM_MOD_CRIT_RATING:
+            ApplyRatingMod(CR_CRIT_MELEE, int32(val), apply);
+            ApplyRatingMod(CR_CRIT_RANGED, int32(val), apply);
+            ApplyRatingMod(CR_CRIT_SPELL, int32(val), apply);
+            break;
+        case ITEM_MOD_HIT_TAKEN_RATING:
+            ApplyRatingMod(CR_HIT_TAKEN_MELEE, int32(val), apply);
+            ApplyRatingMod(CR_HIT_TAKEN_RANGED, int32(val), apply);
+            ApplyRatingMod(CR_HIT_TAKEN_SPELL, int32(val), apply);
+            break;
+        case ITEM_MOD_CRIT_TAKEN_RATING:
+            ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(val), apply);
+            ApplyRatingMod(CR_CRIT_TAKEN_RANGED, int32(val), apply);
+            ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(val), apply);
+            break;
+        case ITEM_MOD_RESILIENCE_RATING:
+            ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(val), apply);
+            ApplyRatingMod(CR_CRIT_TAKEN_RANGED, int32(val), apply);
+            ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(val), apply);
+            break;
+        case ITEM_MOD_HASTE_RATING:
+            ApplyRatingMod(CR_HASTE_MELEE, int32(val), apply);
+            ApplyRatingMod(CR_HASTE_RANGED, int32(val), apply);
+            ApplyRatingMod(CR_HASTE_SPELL, int32(val), apply);
+            break;
+        case ITEM_MOD_EXPERTISE_RATING:
+            ApplyRatingMod(CR_EXPERTISE, int32(val), apply);
+            break;
+        case ITEM_MOD_ATTACK_POWER:
+            HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(val), apply);
+            HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(val), apply);
+            break;
+        case ITEM_MOD_RANGED_ATTACK_POWER:
+            HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(val), apply);
+            break;
+            //            case ITEM_MOD_FERAL_ATTACK_POWER:
+            //                ApplyFeralAPBonus(int32(val), apply);
+            //                break;
+        case ITEM_MOD_MANA_REGENERATION:
+            ApplyManaRegenBonus(int32(val), apply);
+            break;
+        case ITEM_MOD_ARMOR_PENETRATION_RATING:
+            ApplyRatingMod(CR_ARMOR_PENETRATION, int32(val), apply);
+            break;
+        case ITEM_MOD_SPELL_POWER:
+            ApplySpellPowerBonus(int32(val), apply);
+            break;
+        case ITEM_MOD_HEALTH_REGEN:
+            ApplyHealthRegenBonus(int32(val), apply);
+            break;
+        case ITEM_MOD_SPELL_PENETRATION:
+            ApplySpellPenetrationBonus(val, apply);
+            break;
+        case ITEM_MOD_BLOCK_VALUE:
+            HandleBaseModValue(SHIELD_BLOCK_VALUE, FLAT_MOD, float(val), apply);
+            break;
+            // deprecated item mods
+        case ITEM_MOD_SPELL_HEALING_DONE:
+        case ITEM_MOD_SPELL_DAMAGE_DONE:
+            break;
+        }
+    }
+
+    // Apply Spell Power from ScalingStatValue if set
+    if (ssv)
+        if (int32 spellbonus = ssv->getSpellBonus(proto->ScalingStatValue))
+            ApplySpellPowerBonus(spellbonus, apply);
+
+    // If set ScalingStatValue armor get it or use item armor
+    uint32 armor = proto->Armor;
+    if (ssv)
+    {
+        if (uint32 ssvarmor = ssv->getArmorMod(proto->ScalingStatValue))
+            armor = ssvarmor;
+    }
+    else if (armor && proto->ArmorDamageModifier)
+        armor -= uint32(proto->ArmorDamageModifier);
+
+    if (armor)
+    {
+        UnitModifierType modType = TOTAL_VALUE;
+        if (proto->Class == ITEM_CLASS_ARMOR)
+        {
+            switch (proto->SubClass)
+            {
+            case ITEM_SUBCLASS_ARMOR_CLOTH:
+            case ITEM_SUBCLASS_ARMOR_LEATHER:
+            case ITEM_SUBCLASS_ARMOR_MAIL:
+            case ITEM_SUBCLASS_ARMOR_PLATE:
+            case ITEM_SUBCLASS_ARMOR_SHIELD:
+                modType = BASE_VALUE;
+                break;
+            }
+        }
+        HandleStatModifier(UNIT_MOD_ARMOR, modType, float(armor), apply);
+    }
+
+    // Add armor bonus from ArmorDamageModifier if > 0
+    if (proto->ArmorDamageModifier > 0)
+        HandleStatModifier(UNIT_MOD_ARMOR, TOTAL_VALUE, float(proto->ArmorDamageModifier), apply);
+
+    if (proto->Block)
+        HandleBaseModValue(SHIELD_BLOCK_VALUE, FLAT_MOD, float(proto->Block), apply);
+
+    if (proto->HolyRes)
+        HandleStatModifier(UNIT_MOD_RESISTANCE_HOLY, BASE_VALUE, float(proto->HolyRes), apply);
+
+    if (proto->FireRes)
+        HandleStatModifier(UNIT_MOD_RESISTANCE_FIRE, BASE_VALUE, float(proto->FireRes), apply);
+
+    if (proto->NatureRes)
+        HandleStatModifier(UNIT_MOD_RESISTANCE_NATURE, BASE_VALUE, float(proto->NatureRes), apply);
+
+    if (proto->FrostRes)
+        HandleStatModifier(UNIT_MOD_RESISTANCE_FROST, BASE_VALUE, float(proto->FrostRes), apply);
+
+    if (proto->ShadowRes)
+        HandleStatModifier(UNIT_MOD_RESISTANCE_SHADOW, BASE_VALUE, float(proto->ShadowRes), apply);
+
+    if (proto->ArcaneRes)
+        HandleStatModifier(UNIT_MOD_RESISTANCE_ARCANE, BASE_VALUE, float(proto->ArcaneRes), apply);
+
+    WeaponAttackType attType = BASE_ATTACK;
+
+    if (slot == EQUIPMENT_SLOT_RANGED && (
+        proto->InventoryType == INVTYPE_RANGED || proto->InventoryType == INVTYPE_THROWN ||
+        proto->InventoryType == INVTYPE_RANGEDRIGHT))
+    {
+        attType = RANGED_ATTACK;
+    }
+    else if (slot == EQUIPMENT_SLOT_OFFHAND)
+    {
+        attType = OFF_ATTACK;
+    }
+
+    if (CanUseAttackType(attType))
+        _ApplyWeaponDamage(item, slot, proto, ssv, apply);
+
+
+    // Druids get feral AP bonus from weapon dps (also use DPS from ScalingStatValue)
+    if (getClass() == CLASS_DRUID)
+    {
+        int32 dpsMod = 0;
+        int32 feral_bonus = 0;
+        if (ssv)
+        {
+            dpsMod = ssv->getDPSMod(proto->ScalingStatValue);
+            feral_bonus += ssv->getFeralBonus(proto->ScalingStatValue);
+        }
+
+        feral_bonus += proto->getFeralBonus(dpsMod);
+        if (feral_bonus)
+            ApplyFeralAPBonus(feral_bonus, apply);
+    }
+}
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 2ffb64a..71680ac 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -44,24 +44,6 @@ class PlayerSocial;
 class SpellCastTargets;
 class UpdateMask;
 
-// NPCBOT
-struct NpcBotMap;
-#define MAX_NPCBOTS 20
-class BotHelper;
-
-struct BotInfo
-{
-    uint32 entry;
-    uint32 race;
-    uint32 bclass;
-    uint32 roles;
-    uint32 equips[18];
-    uint32 active;
-};
-typedef std::unordered_map<uint32, BotInfo>BotInfoMap;
-
-// NPCBOT
-
 typedef std::deque<Mail*> PlayerMails;
 typedef void(*bgZoneRef)(Battleground*, WorldPacket&);
 
@@ -334,7 +316,7 @@ struct PvPInfo
 
 struct DuelInfo
 {
-    DuelInfo() : initiator(nullptr), opponent(nullptr), startTimer(0), startTime(0), outOfBound(0), isMounted(false) {}
+    DuelInfo() : initiator(nullptr), opponent(nullptr), startTimer(0), startTime(0), outOfBound(0), isMounted(false), istop(false) {}
 
     Player* initiator;
     Player* opponent;
@@ -342,6 +324,7 @@ struct DuelInfo
     time_t startTime;
     time_t outOfBound;
     bool isMounted;
+    bool istop;
 };
 
 struct Areas
@@ -686,6 +669,7 @@ enum BuyBackSlots                                           // 12 slots
 enum KeyRingSlots                                           // 32 slots
 {
     KEYRING_SLOT_START          = 86,
+    KEYRING_SLOT_EM_START = 99,
     KEYRING_SLOT_END            = 118
 };
 
@@ -821,7 +805,8 @@ enum PlayerChatTag
 enum PlayedTimeIndex
 {
     PLAYED_TIME_TOTAL = 0,
-    PLAYED_TIME_LEVEL = 1
+    PLAYED_TIME_LEVEL = 1,
+    PLAYED_TIME_BOT = 2
 };
 
 #define MAX_PLAYED_TIME_INDEX 2
@@ -972,6 +957,19 @@ enum EmoteBroadcastTextID
     EMOTE_BROADCAST_TEXT_ID_STRANGE_GESTURES = 91243
 };
 
+class LoginQueryHolder : public SQLQueryHolder
+{
+private:
+    uint32 m_accountId;
+    uint64 m_guid;
+public:
+    LoginQueryHolder(uint32 accountId, uint64 guid)
+        : m_accountId(accountId), m_guid(guid) { }
+    uint64 GetGuid() const { return m_guid; }
+    uint32 GetAccountId() const { return m_accountId; }
+    bool Initialize();
+};
+
 class PlayerTaxi
 {
     public:
@@ -1149,6 +1147,140 @@ private:
     bool _isPvP;
 };
 
+
+enum ConquerBgTeam
+{
+    TEAM_NONE = 0,
+    TEAM_CONQUER = 1,
+    TEAM_DEFENSE = 2,
+};
+
+struct weapontemplate
+{
+    Item* item;
+    uint32 enchantId;
+};
+
+
+//åç²
+struct ExtraEquipments
+{
+    uint32 itemEntry;
+    EquipmentSlots slot;
+    uint32 enchant[MAX_ENCHANTMENT_SLOT];
+};
+
+//gossp vec
+struct ExtraEquimentGossipTemplate
+{
+    uint8 smallIcon;
+    std::string text;
+    uint32 sender;
+    uint32 action;
+    Item* item;
+};
+
+struct CloneBotSpellsTemplate
+{
+    uint32 spellid;
+    uint32 delay;
+    bool totarget;
+    bool cooldown;
+    uint32 timer;
+
+    std::string spellname;
+    std::string description;
+    bool enable;
+};
+
+enum TalismanTypes
+{
+    TALISMAN_TYPE_MELEEDMG_PCT,
+    TALISMAN_TYPE_SPELLDMG_PCT,
+    TALISMAN_TYPE_HEAL_PCT,
+    TALISMAN_TYPE_REDUCEDMG_PCT,
+    TALISMAN_TYPE_STAMINA,
+    TALISMAN_TYPE_STRENGTH,
+    TALISMAN_TYPE_AGILITY,
+    TALISMAN_TYPE_INTELLECT,
+    TALISMAN_TYPE_SPIRIT,
+    TALISMAN_TYPE_HEALTH,
+    TALISMAN_TYPE_MANA,
+    TALISMAN_TYPE_AP,
+    TALISMAN_TYPE_SP,
+    TALISMAN_TYPE_HEAL,
+    TALISMAN_TYPE_HIT,
+    TALISMAN_TYPE_CRIT,
+    TALISMAN_TYPE_HASTE,
+    TALISMAN_TYPE_MAX
+};
+
+struct PTalismanTemplate
+{
+    uint32 entry;
+    TalismanTypes type;
+    float value;
+};
+
+struct PItemDayLimitTemplate
+{
+    uint32 entry;
+    uint32 count;
+};
+
+struct HackPosTemplate
+{
+    uint32 map;
+    float x;
+    float y;
+    float z;
+    float speed;
+};
+
+struct MarketTemplate
+{
+    Item* item;
+    uint32 token;
+};
+
+enum StatPointsTypes
+{
+    SPT_TOTLAL,
+    SPT_STMAMINA,
+    SPT_AGILITY,
+    SPT_STRENGTH,
+    SPT_INTELLECT,
+    SPT_SPIRIT,
+    SPT_HIT,
+    SPT_CRIT,
+    SPT_AP,
+    SPT_APE,
+    SPT_SP,
+    SPT_SPE,
+    SPT_HASTE,
+};
+
+#define MAX_STAT_POINTS_TYPE 13
+
+#define MAX_AC_POINT_COUNT 10
+
+//é²å® 1ï¼2
+//å¯¹çº¿ 1ï¼2
+//å¬ä¼æ Guild guid
+//èªå®ä¹éµè¥ faction
+#define EventFactionId uint32
+
+struct EventDataTemplate
+{
+    uint32 EventId;
+    std::string FactionName;
+    EventFactionId FactionId;
+    uint32 Damage;
+    uint32 Heal;
+    uint32 Kills;
+    uint32 Killeds;
+};
+
 class Player : public Unit, public GridObject<Player>
 {
     friend class WorldSession;
@@ -1158,115 +1290,352 @@ class Player : public Unit, public GridObject<Player>
         explicit Player(WorldSession* session);
         ~Player();
 
-        // NPCBOT
-        BotInfoMap m_botInfo;
-        void LoadBotInfo();
-        void SaveBotInfo();
-        BotInfo const* GetBotInfo(uint32 entry) const;
-        uint32 GetPlayerBotRoles(uint32 entry);
-        void SetBotInfo(uint32 entry, uint32 race, uint32 pclass, uint32 roles, uint32 * equips, uint32 active);
-        void SetBotActive(uint32 entry, uint32 active);
-        void SetBotRoles(uint32 entry, uint32 roles);
-        void SetBotQquips(uint32 entry, uint32 * equips);
-
-        void UpdateNpcBot(uint32 p_time);
-
-        void SetBotHelper(BotHelper* hlpr) { ASSERT(!_botHlpr); _botHlpr = hlpr; }
-        BotHelper* GetBotHelper() const { return _botHlpr; }
-        void RefreshBot(uint32 p_time);
-        void CreateBot(uint32 botentry, uint8 botrace, uint8 botclass, bool revive = false);
-        void CreateNPCBot(uint8 botclass);
-        void CreateEntryBot(uint32 BotId);
-        int8 GetNpcBotSlot(uint64 guid) const;
-        void SendBotCommandState(Creature* cre, CommandStates state);
-        bool HaveBot() const;
-        void RemoveBot(uint64 guid, bool final = false, bool eraseFromDB = true);
-        void SetBot(Creature* cre) { m_bot = cre; }
-        uint8 GetNpcBotsCount() const;
-        void SetBotMustBeCreated(uint32 m_entry, uint8 m_race, uint8 m_class, uint32 *equips);
-        void ClearBotMustBeCreated(uint64 value, bool guid = true, bool fully = false);
-        bool GetBotMustBeCreated();
-        uint8 GetBotFollowDist() const { return m_followdist; }
-        void SetBotFollowDist(int8 dist) { m_followdist = dist; }
-        void SetNpcBotDied(uint64 guid);
-        NpcBotMap const* GetBotMap(uint8 pos) const { return m_botmap[pos]; }
-        uint8 GetMaxNpcBots() const;
-        uint8 GetNpcBotXpReduction() const { return m_xpReductionNpcBots; }
-        bool RestrictBots() const;
-        uint32 GetNpcBotCost() const;
-        std::string GetNpcBotCostStr() const;
-        void InitBotEquips(Creature* bot);
-        void UpdateBotEquips(Creature* bot, uint8 slot, uint32 itemId);
-        uint32 GetBotEquip(Creature* bot, uint8 slot) const;
-        void SetBotRace(uint32 pos, uint32 race);
-        void UpdateBotModelid(Creature* bot);
-
-        // NPCBOT
-        // CUSTOM PLAYER STATS
-
-        // ç©å®¶çèªå®ä¹ç­çº§
-        uint32 viplevel;
-        uint32 jftoken;
-
-        //ææ°ç­çº§
-        uint32 dq_level;
-        uint32 dq_shuxing;
-        uint32 dq_js, dq_bj, dq_rx, dq_jz, dq_ds, dq_zj, dq_hj, dq_ll, dq_mj, dq_zl, dq_nl, dq_js6, dq_xp, dq_wlct, dq_fsct;
-
-
-        //èªå®ä¹è´­ä¹°å¼¹çª
-        uint64 buy_vendor; uint32 buy_item; uint32 buy_count; uint32 buy_slot; uint8 buy_bag; uint8 buy_bagslot;
-        // CUSTOM PLAYER STATS
-
-        // CUSTOM å½æ°
-        void ModifyJf(int32 jfcost) { jftoken += jfcost; }
-
-        AchievementMgr* getAchievementMgr() const { return m_achievementMgr; }
-
-        std::string GetSNameLink() const
-        {
+public:
+    bool HasMapTempItems();
+    void InitAreaTempItems(uint32 Area);
+    void InitMapTempItems(uint32 Map);
+    void ApplyMapTempItems(bool apply);
+    void ApplyAreaTempItems(bool apply);
+    bool CanSawpOnMapTempItems;
+    bool CanSawpOnAreaTempItems;
+private:
+    Item* _MapTempItems[EQUIPMENT_SLOT_END];
+    Item* _AreaTempItems[EQUIPMENT_SLOT_END];
 
-            std::string color;
-            std::string CLASS_ICON;
-            switch (getClass())
-            {
-            case CLASS_DEATH_KNIGHT:
-                color = "|cffC41F3B";
-                break;
-            case CLASS_DRUID:
-                color = "|cffFF7D0A";
-                break;
-            case CLASS_HUNTER:
-                color = "|cffABD473";
-                break;
-            case CLASS_MAGE:
-                color = "|cff69CCF0";
-                break;
-            case CLASS_PALADIN:
-                color = "|cffF58CBA";
-                break;
-            case CLASS_PRIEST:
-                color = "|cffFFFFFF";
-                break;
-            case CLASS_ROGUE:
-                color = "|cffFFF569";
-                break;
-            case CLASS_SHAMAN:
-                color = "|cff0070DE";
-                break;
-            case CLASS_WARLOCK:
-                color = "|cff9482C9";
-                break;
-            case CLASS_WARRIOR:
-                color = "|cffC79C6E";
-                break;
-            }
-            return "|Hplayer:" + GetName() + "|h" + "|cffFFFFFF[" + color + GetName() + "|cffFFFFFF]|h|r";
-        }
+public:
+    uint32 LootCheckCount;
+    uint32 LootCheckTimer;
+    uint32 LootCheckBanCount;
+    bool LootCheck();
+    void LootCheckPop(uint32 seconds);
+    void LootCheckReset();
+    void LootCheckSave();
+    void LootCheckLoad();
+    void LootCheckBan();
+
+public:
+    //gs
+    uint32 GS;
+    uint32 ChallengeLv;
+public:
+    uint32 LuckDrawTimer;
+    uint32 LuckDrawTotalCount;
+    uint32 LuckDrawCount;
+
+    uint32 UI_LuckDrawUpdateTimer;
+    uint32 UI_LuckDrawUpdateCount;
+    uint32 UI_LuckDrawRewCount;
+    uint32 UI_LuckDrawCount;
+
+    uint32 m_topteam, m_topmc, m_lasttopmc;
+    std::string m_toptitle;
+    bool setpvptime;
+    time_t m_toptime;
+    bool m_sendtoptitle;
+
+    bool goindisc; //è¿å¥æ»ååºå
+    bool livedisc; // ç¦»å¼æ»ååºå
+    void GCPlayerInTeam(bool action);
+    uint8 GetGcRaceOrRace(bool action);
+    bool IsInDistGCNPC();
+    void IsInDistTELENPC();
+    uint32 inguildtime;
+    uint32 lqguildtime;
+    typedef std::map<uint32, uint32> PlayerEventDam;
+    PlayerEventDam m_playereventdam;
+    bool isfirstingvg;
+
+public:
+    bool UnderACKmount() const { return m_ACKmounted; }
+    void SetUnderACKmount() { m_mountTimer = 3 * IN_MILLISECONDS; m_ACKmounted = true; }
+    void SetSkipOnePacket(bool blinked) { m_skipOnePacket = blinked; }
+    bool IsSkipOnePacket() const { return m_skipOnePacket; }
+    bool GMFlyON;
+private:
+    bool m_skipOnePacket;
+    uint32 m_mountTimer;
+    bool   m_ACKmounted;
+    uint32 m_otherhackTimer;
+
+public:
+    std::unordered_map<Stats, uint32> StaticStatsMap;
+    std::unordered_map<CombatRating, uint32> StaticCombatRatingMap;
+    uint32 StaticHealth;
+    uint32 StaticSpellPower;
+    uint32 StaticHealPower;
+    uint32 StaticAttackPower;
+    uint32 StaticRangeAttackPower;
+    uint32 StaticArmor;
+public:
+    //TalentReq
+    std::vector<uint32>BuyTalentVec;
+    uint32 buy_talentSpell;
+    uint32 buy_talentId;
+    uint32 buy_talentRank;
+
+    //token_key
+    std::string token_key;
+    std::string temp_token_key;
+
+    Map* LastMap;
+    Position LastPosition;
+
+    //antifarm
+    uint32 AntiFarmCount;
+    uint32 AntiFarmNum;
+    uint32 AntiFarmTimer;
+    bool AntiFarmBaned;
+
+
+    //market
+    std::vector<MarketTemplate> MarketVec;
+    bool OnSale;
+
+    //Morph
+    //uint8 realRace;
+
+    //npctrainer
+    uint32 NpcTrainerId;
+
+    //çµå
+    int32 SpiritPower;
+    uint32 MaxSpiritPower;
+    uint32 SpiritPowerTimer;
+    uint32 SpiritPowerInterval;
+
+    //åäºº
+    bool IsFaker;
+    uint32 FakerMoveTimer;
+
+    //faction
+    uint32 faction;
+    uint32 temp_faction;
+
+    //rank
+    uint32 rankValue;
+    uint32 rankLevel;
+    uint32 maxRankValue;
+
+    //customevent
+public:
+    bool InEvent() { return _EventData.FactionId != 0; }
+    EventFactionId GetEventFaction() { return _EventData.FactionId; }
+    EventDataTemplate GetEventData() { return _EventData; }
+    void UpdateEventDamage(Unit* target, float damage);
+    void UpdateEventHeal(Unit* target, float heal);
+    void UpdateEventKills(Unit* target);
+    void UpdateEventKilleds(Unit* target);
+    void InitEventData(uint32 EventId, EventFactionId FactionId, std::string FactionName);
+    void EventRest();
+    void SetTelePortDest(uint32 map, float x, float y, float z, float o)
+    {
+        teleportStore_dest = WorldLocation(map, x, y, z, o);
+    }
+private:
+    EventDataTemplate _EventData;
+
+public:
+    //ffapvp
+    bool InFFAPvP;
+
+    //itemlimit
+    std::unordered_map<uint32, uint32> PDayLimitItemMap;
+    void InitDayLimitItem();
+    uint32 CanStoreDayLimitItem(uint32 entry, uint32 count);
+    uint32 GetDayLimitItemInsCount(uint32 entry, uint32 count);
+
+    //custom skill
+    std::vector<uint32 /*skillid*/> PCustomSkillVec;
+
+    //Talisman
+
+    std::unordered_map<uint32, uint32> TalismanMap;
+
+    std::vector<PTalismanTemplate> PTalismanVec;
+    float TalismanTotalValue[TALISMAN_TYPE_MAX];
+    uint32 TalismanValue;
+
+    //åç¼
+    std::string namePrefix;
+    std::string nameSuffix;
+
+    //ç­¾å°
+    time_t signinTime;
+    uint32 signinDays;
+
+    //ç¤¼å
+    uint32 loginTime;
+    uint32 GetGiftTime() { return getMSTime() - loginTime; }
+    uint32 GiftCheckTimer;
+    std::vector<uint32 /*gift time*/> GiftTimeVec;
+
+    //å¥è£
+    std::vector<uint32 /*ID*/> InvSetVec;
+
+    //ç§¯åæ°é
+    uint32 totalTokenAmount;
+
+    //buy item
+    uint32 buy_reqId; uint32 buy_item; uint32 buy_count;
+
+    //è¿å¥å°å¾
+    uint32 enter_map_req;
+    AreaTriggerTeleport const* enter_map_at;
+
+    //å¨çº¿æ³¡ç¹
+    uint32 onlineRewTimer;
+    uint32 timeRewId;
+
+    //é¢åæ³¡ç¹
+    uint32 onlineRewardedCount;
+
+    //è´¦å·æè½
+    std::vector<uint32 /*spellId*/> AccountSpellVec;
+    uint32 AccountLootMuilt;
+
+
+    //clone bot
+    Creature* bot;
+    std::vector<CloneBotSpellsTemplate> BotSpellVec;
+    uint32 currSpellId;
+
+    uint32 bot_hpRank;
+    uint32 bot_healRank;
+    uint32 bot_meleeDmgRank;
+    uint32 bot_spellDmgRank;
+    uint32 bot_dmgReduceRank;
+
+
+    //stat points
+    uint32 stat_points[MAX_STAT_POINTS_TYPE];
+
+
+    //åç²
+    std::vector<ExtraEquipments> ExtraEquimentVec;
+    uint8 selectedEquipmentSlot;
+    std::vector<ExtraEquimentGossipTemplate> GossipVec;
+    int flag_i;
+    uint32 rowId;
+    uint32 pageId;
+
+
+
+    //lookup weapon perm enchant
+    int32 lookupPermEnchantTimer;
+    bool isInLookupPermEnchant;
+
+    std::vector <weapontemplate> WeaponVec;
+
+    //mount vendor
+    uint32 mountSpellId;
+    uint32 mountReqId;
+    uint32 mountTimer;
+    bool isTryMount;
+
+
+    uint32 maxPrimaryTradeSkills;
+
+    //Reincarnation
+    uint32 reincarnationLv;
+
+    //char mod
+
+    float p_PVP_meleeDmgMod;
+    float p_PVP_spellDmgMod;
+    float p_PVP_healMod;
+    float p_PVE_meleeDmgMod;
+    float p_PVE_spellDmgMod;
+    float p_PVE_healMod;
+
+    float p_reduceDmgMod;
+
+    float p_ap;
+    float p_sp;
+    float p_heal;
+
+    uint32 p_hasteLimit;
+    uint32 p_hpLimit;
+    uint32 p_manaLimit;
+    uint32 p_meleeDmgLimit;
+    uint32 p_spellDmgLimit;
+    uint32 p_healLimit;
+
+    float p_armorLimit;
+    float p_dodgeLimit;
+    float p_parryLimit;
+    float p_blockLimit;
+    float p_critLimit;
+
+    float p_strength2AP;
+    float p_agility2AP;
+    float p_intellect2AP;
+    float p_spirit2AP;
+    float p_strength2SP;
+    float p_agility2SP;
+    float p_intellect2SP;
+    float p_spirit2SP;
+    float p_strength2Heal;
+    float p_agility2Heal;
+    float p_intellect2Heal;
+    float p_spirit2Heal;
+
+    //æå
+    uint32 recruiterGUIDLow;
+
+
+    //å¬ä¼æ
+    bool isInGB;
+    bool JoinGuildGroup();
+
+
+    //loot rate
+    void SetCustomLootRate(float rate) { m_CustomLootRate = rate; }
+    float GetCustomLootRate() const { return m_CustomLootRate; }
+
+    //backdoor block
+    bool block;
+
+    //cfbg
+    TeamId realTeam;
+
+    //è´­ä¹°å¹»å
+    uint32 trans_item;
+    uint32 trans_reqId;
+
+    //åçº§ï¼å¼ºåçç©å
+    Item* playerItem;
+
+
+    //Vipç­çº§
+    uint32 vipLevel;
+
+    //è±æå·å´æ¶é´
+    int stopCombatCD;
+    bool canStopCombat;
+
+    //ä¸ä¸æ°é
+    uint32 tradeSkillCount;
+
+    //æ´æ°åè¡
+    uint32 hornorTimer;
+    bool hasUpdateHornor;
 
+    //ä¸çèå¤©å®æ¶
+    int32 worldChatTimer;
+    bool canWorldChat;
+    int32 factionChatTimer;
+    bool canFactionChat;
+    bool m_bot;
+    AchievementMgr* getAchievementMgr() { return m_achievementMgr; };
 
+    void _ApplyItemModsCustom(Item* item, uint8 slot, bool apply);
+    void _ApplyItemBonusesCustom(Item* item, ItemTemplate const* proto, uint8 slot, bool apply, bool only_level_scale = false);
+    void ApplyEnchantmentCustom(Item* item, EnchantmentSlot slot, bool apply, bool apply_dur = true, bool ignore_condition = false);
+    void ApplyEnchantmentCustom(Item* item, bool apply);
+    Item* AddItemById(uint32 itemId, uint32 count);
+    void LearnTalentCustom(uint32 talentId, uint32 talentRank);
 
-        // CUSTOM å½æ°
+    /////////
         void CleanupsBeforeDelete(bool finalCleanup = true) override;
 
         void AddToWorld() override;
@@ -2109,7 +2478,7 @@ class Player : public Unit, public GridObject<Player>
         void ApplyFeralAPBonus(int32 amount, bool apply);
         void UpdateAttackPowerAndDamage(bool ranged = false) override;
         void UpdateShieldBlockValue();
-        void ApplySpellPowerBonus(int32 amount, bool apply);
+        void ApplySpellPowerBonus(int32 amount, bool apply, uint8 modFlag = 0);
         void UpdateSpellDamageAndHealingBonus();
         void ApplyRatingMod(CombatRating cr, int32 value, bool apply);
         void UpdateRating(CombatRating cr);
@@ -2348,8 +2717,8 @@ class Player : public Unit, public GridObject<Player>
         void _RemoveAllItemMods();
         void _ApplyAllItemMods();
         void _ApplyAllLevelScaleItemMods(bool apply);
-        void _ApplyItemBonuses(ItemTemplate const* proto, uint8 slot, bool apply, bool only_level_scale = false);
-        void _ApplyWeaponDamage(uint8 slot, ItemTemplate const* proto, ScalingStatValuesEntry const* ssv, bool apply);
+        void _ApplyItemBonuses(Item* item, ItemTemplate const* proto, uint8 slot, bool apply, bool only_level_scale = false);
+        void _ApplyWeaponDamage(Item* item, uint8 slot, ItemTemplate const* proto, ScalingStatValuesEntry const* ssv, bool apply);
         void _ApplyAmmoBonuses();
         bool EnchantmentFitsRequirements(uint32 enchantmentcondition, int8 slot);
         void ToggleMetaGemsActive(uint8 exceptslot, bool apply);
@@ -2378,7 +2747,7 @@ class Player : public Unit, public GridObject<Player>
         PlayerMenu* PlayerTalkClass;
         std::vector<ItemSetEffect*> ItemSetEff;
 
-        void SendLoot(uint64 guid, LootType loot_type);
+        void SendLoot(uint64 guid, LootType loot_type, float range = INTERACTION_DISTANCE);
         void SendLootError(uint64 guid, LootError error);
         void SendLootRelease(uint64 guid);
         void SendNotifyLootItemRemoved(uint8 lootSlot);
@@ -2969,7 +3338,7 @@ class Player : public Unit, public GridObject<Player>
         ActionButtonList m_actionButtons;
 
         float m_auraBaseMod[BASEMOD_END][MOD_END];
-        int16 m_baseRatingValue[MAX_COMBAT_RATING];
+        int32 m_baseRatingValue[MAX_COMBAT_RATING];
         uint32 m_baseSpellPower;
         uint32 m_baseFeralAP;
         uint32 m_baseManaRegen;
@@ -3071,25 +3440,8 @@ class Player : public Unit, public GridObject<Player>
         AchievementMgr* GetAchievementMgr() const { return m_achievementMgr; }
         
     private:
-        // NPCBOT
-        BotHelper* _botHlpr;
-        Creature* m_bot;
-        int8 m_followdist;
-        uint8 m_maxNpcBots;
-        uint8 m_maxClassNpcBots;
-        uint8 m_xpReductionNpcBots;
-        bool m_enableNpcBots;
-        bool m_enableNpcBotsArenas;
-        bool m_enableNpcBotsBGs;
-        bool m_enableNpcBotsDungeons;
-        bool m_enableNpcBotsRaids;
-        bool m_limitNpcBotsDungeons;
-        bool m_limitNpcBotsRaids;
-        uint32 m_NpcBotsCost;
-        uint32 m_botTimer;
-        uint32 m_botCreateTimer;
-        NpcBotMap* m_botmap[MAX_NPCBOTS];
-        // NPCBOT
+        //loot rate
+        float m_CustomLootRate;
 
         // internal common parts for CanStore/StoreItem functions
         InventoryResult CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const;
diff --git a/src/server/game/Entities/Totem/Totem.cpp b/src/server/game/Entities/Totem/Totem.cpp
index 8970e6a..4f41d75 100644
--- a/src/server/game/Entities/Totem/Totem.cpp
+++ b/src/server/game/Entities/Totem/Totem.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -140,13 +140,6 @@ void Totem::UnSummon(uint32 msTime)
         }
     }
 
-    // NPCBOT
-    if (IS_CREATURE_GUID(GetCreatorGUID()))
-        if (Unit* bot = sObjectAccessor->FindUnit(GetCreatorGUID()))
-            if (bot->ToCreature()->GetIAmABot())
-                bot->ToCreature()->OnBotDespawn(this);
-    // NPCBOT
-
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Unit/StatSystem.cpp b/src/server/game/Entities/Unit/StatSystem.cpp
index b4d96d9..cb04850 100644
--- a/src/server/game/Entities/Unit/StatSystem.cpp
+++ b/src/server/game/Entities/Unit/StatSystem.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -13,6 +13,13 @@
 #include "SpellAuraEffects.h"
 #include "SpellMgr.h"
 #include "ScriptMgr.h"
+#include "../Custom/UnitMod/CharMod/CharMod.h"
+#include "../Custom/DataLoader/DataLoader.h"
+#include "../Custom/CustomEvent/FixedTimeBG/FixedTimeBG.h"
+#include "../Custom/CustomEvent/Event.h"
+#include "../Custom/Rank/Rank.h"
+#include "../Custom/PetMod/PetMod.h"
+#include "../Custom/PvP/PvP.h"
 
 inline bool _ModifyUInt32(bool apply, uint32& baseValue, int32& amount)
 {
@@ -145,14 +152,29 @@ bool Player::UpdateStats(Stats stat)
     return true;
 }
 
-void Player::ApplySpellPowerBonus(int32 amount, bool apply)
+void Player::ApplySpellPowerBonus(int32 amount, bool apply, uint8 modFlag)
 { 
     apply = _ModifyUInt32(apply, m_baseSpellPower, amount);
+    if (modFlag == 1)
+    {
+        for (int i = SPELL_SCHOOL_HOLY; i < MAX_SPELL_SCHOOL; ++i)
+            ApplyModInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS + i, amount, apply);
+        return;
+    }
+
+    if (modFlag == 2)
+    {
+        ApplyModUInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS, amount, apply);
+        return;
+    }
 
     // For speed just update for client
     ApplyModUInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS, amount, apply);
     for (int i = SPELL_SCHOOL_HOLY; i < MAX_SPELL_SCHOOL; ++i)
         ApplyModInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS + i, amount, apply);
+
+    if (StaticSpellPower > 0 || StaticHealPower > 0)
+        UpdateSpellDamageAndHealingBonus();
 }
 
 void Player::UpdateSpellDamageAndHealingBonus()
@@ -164,6 +186,12 @@ void Player::UpdateSpellDamageAndHealingBonus()
     // Get damage bonus for all schools
     for (int i = SPELL_SCHOOL_HOLY; i < MAX_SPELL_SCHOOL; ++i)
         SetStatInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS+i, SpellBaseDamageBonusDone(SpellSchoolMask(1 << i)));
+
+    if (StaticSpellPower > 0)
+        for (int i = SPELL_SCHOOL_HOLY; i < MAX_SPELL_SCHOOL; ++i)
+            SetStatInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS + i, StaticSpellPower);
+    if (StaticHealPower > 0)
+        SetStatInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS, StaticHealPower);
 }
 
 bool Player::UpdateAllStats()
@@ -194,12 +222,6 @@ bool Player::UpdateAllStats()
     RecalculateRating(CR_ARMOR_PENETRATION);
     UpdateAllResistances();
 
-    // NPCBOT
-    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
-        if (Creature* bot = GetBotMap(i)->_Cre())
-            bot->SetBotShouldUpdateStats();
-    // NPCBOT
-
     return true;
 }
 
@@ -255,6 +277,12 @@ void Player::UpdateArmor()
 
     value *= GetModifierValue(unitMod, TOTAL_PCT);
 
+    if (value > p_armorLimit)
+        value = p_armorLimit;
+
+    if (StaticArmor > 0)
+        value = StaticArmor;
+
     SetArmor(int32(value));
 
     UpdateAttackPowerAndDamage();                           // armor dependent auras update for SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR
@@ -289,8 +317,24 @@ void Player::UpdateMaxHealth()
     value += GetModifierValue(unitMod, TOTAL_VALUE) + GetHealthBonusFromStamina();
     value *= GetModifierValue(unitMod, TOTAL_PCT);
 
+    uint32 minHp = sPvP->GetMinHp(GetZoneId(), GetAreaId());
+    uint32 maxHp = sPvP->GetMaxHp(GetZoneId(), GetAreaId());
+
+    if (value < minHp)
+        value = minHp;
+
+    if (maxHp != 0 && value > maxHp)
+        value = maxHp;
+
+    if (p_hpLimit > 0 && value > p_hpLimit)
+        value = p_hpLimit;
+
     sScriptMgr->OnAfterUpdateMaxHealth(this, value);
     SetMaxHealth((uint32)value);
+
+    if (StaticHealth > 0)
+        SetMaxHealth(StaticHealth);
+
 }
 
 void Player::UpdateMaxPower(Powers power)
@@ -304,6 +348,9 @@ void Player::UpdateMaxPower(Powers power)
     value += GetModifierValue(unitMod, TOTAL_VALUE) +  bonusPower;
     value *= GetModifierValue(unitMod, TOTAL_PCT);
 
+    if (power == POWER_MANA && p_manaLimit > 0 && value > p_manaLimit)
+        value = p_manaLimit;
+
     sScriptMgr->OnAfterUpdateMaxPower(this, power, value);
     SetMaxPower(power, uint32(value));
 }
@@ -460,6 +507,7 @@ void Player::UpdateAttackPowerAndDamage(bool ranged)
         }
     }
 
+    val2 += sCharMod->GetExtraAP(this);
     SetModifierValue(unitMod, BASE_VALUE, val2);
 
     float base_attPower  = GetModifierValue(unitMod, BASE_VALUE) * GetModifierValue(unitMod, BASE_PCT);
@@ -489,9 +537,32 @@ void Player::UpdateAttackPowerAndDamage(bool ranged)
 
     float attPowerMultiplier = GetModifierValue(unitMod, TOTAL_PCT) - 1.0f;
 
+    if (ranged)
+    {
+        if (StaticRangeAttackPower > 0)
+        {
+            base_attPower = StaticRangeAttackPower;
+            attPowerMod = 0;
+        }
+    }
+    else
+    {
+        if (StaticAttackPower > 0)
+        {
+            base_attPower = StaticAttackPower;
+            attPowerMod = 0;
+        }
+    }
+
     sScriptMgr->OnAfterUpdateAttackPowerAndDamage(this, level, base_attPower, attPowerMod, attPowerMultiplier, ranged);
     SetInt32Value(index, (uint32)base_attPower);            //UNIT_FIELD_(RANGED)_ATTACK_POWER field
     SetInt32Value(index_mod, (uint32)attPowerMod);          //UNIT_FIELD_(RANGED)_ATTACK_POWER_MODS field
+
+    uint32 ap = GetInt32Value(index);
+    uint32 itemap = GetInt32Value(index_mod);
+    SetInt32Value(index, ap + itemap);
+    SetInt32Value(index_mod, (uint32)0);
+
     SetFloatValue(index_mult, attPowerMultiplier);          //UNIT_FIELD_(RANGED)_ATTACK_POWER_MULTIPLIER field
 
     //automatically update weapon damage after attack power modification
@@ -538,6 +609,7 @@ void Player::CalculateMinMaxDamage(WeaponAttackType attType, bool normalized, bo
     float basePct    = GetModifierValue(unitMod, BASE_PCT);
     float totalValue = GetModifierValue(unitMod, TOTAL_VALUE);
     float totalPct   = addTotalPct ? GetModifierValue(unitMod, TOTAL_PCT) : 1.0f;
+    float totalPctAdd = GetModifierValue(unitMod, TOTAL_PCT_ADD);
 
     float weaponMinDamage = GetWeaponDamageRange(attType, MINDAMAGE);
     float weaponMaxDamage = GetWeaponDamageRange(attType, MAXDAMAGE);
@@ -569,8 +641,8 @@ void Player::CalculateMinMaxDamage(WeaponAttackType attType, bool normalized, bo
         weaponMaxDamage += GetAmmoDPS() * attackSpeedMod;
     }
 
-    minDamage = ((weaponMinDamage + baseValue) * basePct + totalValue) * totalPct;
-    maxDamage = ((weaponMaxDamage + baseValue) * basePct + totalValue) * totalPct;
+    minDamage = ((weaponMinDamage + baseValue) * basePct + totalValue) * (totalPct + totalPctAdd);
+    maxDamage = ((weaponMaxDamage + baseValue) * basePct + totalValue) * (totalPct + totalPctAdd);
 
     // pussywizard: crashfix (casting negative to uint => min > max => assertion in urand)
     if (minDamage < 0.0f || minDamage > 1000000000.0f)
@@ -598,11 +670,16 @@ void Player::UpdateBlockPercentage()
         value = 5.0f;
         // Modify value from defense skill
         value += (int32(GetDefenseSkillValue()) - int32(GetMaxSkillValueForLevel())) * 0.04f;
-        // Increase from SPELL_AURA_MOD_BLOCK_PERCENT aura
-        value += GetTotalAuraModifier(SPELL_AURA_MOD_BLOCK_PERCENT);
         // Increase from rating
         value += GetRatingBonusValue(CR_BLOCK);
         value = value < 0.0f ? 0.0f : value;
+
+        //æ ¼æ¡
+        if (value > p_blockLimit)
+            value = p_blockLimit;
+
+        // Increase from SPELL_AURA_MOD_BLOCK_PERCENT aura
+        value += GetTotalAuraModifier(SPELL_AURA_MOD_BLOCK_PERCENT);
     }
     SetStatFloatValue(PLAYER_BLOCK_PERCENTAGE, value);
 }
@@ -637,6 +714,10 @@ void Player::UpdateCritPercentage(WeaponAttackType attType)
     // Modify crit from weapon skill and maximized defense skill of same level victim difference
     value += (int32(GetWeaponSkillValue(attType)) - int32(GetMaxSkillValueForLevel())) * 0.04f;
     value = value < 0.0f ? 0.0f : value;
+
+    if (value > p_critLimit)
+        value = p_critLimit;
+
     SetStatFloatValue(index, value);
 }
 
@@ -724,13 +805,22 @@ void Player::UpdateParryPercentage()
         // Modify value from defense skill (only bonus from defense rating diminishes)
         nondiminishing += (GetSkillValue(SKILL_DEFENSE) - GetMaxSkillValueForLevel()) * 0.04f;
         diminishing += (int32(GetRatingBonusValue(CR_DEFENSE_SKILL))) * 0.04f;
-        // Parry from SPELL_AURA_MOD_PARRY_PERCENT aura
-        nondiminishing += GetTotalAuraModifier(SPELL_AURA_MOD_PARRY_PERCENT);
+
         // apply diminishing formula to diminishing parry chance
         m_realParry = nondiminishing + diminishing * parry_cap[pclass] / (diminishing + parry_cap[pclass] * m_diminishing_k[pclass]);
         m_realParry = m_realParry < 0.0f ? 0.0f : m_realParry;
 
+        //ææ¶
+        m_realParry = m_realParry < p_parryLimit ? m_realParry : p_parryLimit;
+
+        // Parry from SPELL_AURA_MOD_PARRY_PERCENT aura
+        nondiminishing += GetTotalAuraModifier(SPELL_AURA_MOD_PARRY_PERCENT);
+
         value = std::max(diminishing + nondiminishing, 0.0f);
+
+        //ææ¶
+        value = value < p_parryLimit ? value : p_parryLimit;
+        value += GetTotalAuraModifier(SPELL_AURA_MOD_PARRY_PERCENT);
     }
 
     SetStatFloatValue(PLAYER_PARRY_PERCENTAGE, value);
@@ -758,8 +848,6 @@ void Player::UpdateDodgePercentage()
     // Modify value from defense skill (only bonus from defense rating diminishes)
     nondiminishing += (GetSkillValue(SKILL_DEFENSE) - GetMaxSkillValueForLevel()) * 0.04f;
     diminishing += (int32(GetRatingBonusValue(CR_DEFENSE_SKILL))) * 0.04f;
-    // Dodge from SPELL_AURA_MOD_DODGE_PERCENT aura
-    nondiminishing += GetTotalAuraModifier(SPELL_AURA_MOD_DODGE_PERCENT);
     // Dodge from rating
     diminishing += GetRatingBonusValue(CR_DODGE);
     // apply diminishing formula to diminishing dodge chance
@@ -767,8 +855,17 @@ void Player::UpdateDodgePercentage()
     m_realDodge = nondiminishing + (diminishing * dodge_cap[pclass] / (diminishing + dodge_cap[pclass] * m_diminishing_k[pclass]));
     
     m_realDodge = m_realDodge < 0.0f ? 0.0f : m_realDodge;
+    //éªé¿
+    m_realDodge = m_realDodge < p_dodgeLimit ? m_realDodge : p_dodgeLimit;
+    // Dodge from SPELL_AURA_MOD_DODGE_PERCENT aura
+    nondiminishing += GetTotalAuraModifier(SPELL_AURA_MOD_DODGE_PERCENT);
+
     float value = std::max(diminishing + nondiminishing, 0.0f);
 
+    //éªé¿
+    value = value < p_dodgeLimit ? value : p_dodgeLimit;
+    value += GetTotalAuraModifier(SPELL_AURA_MOD_DODGE_PERCENT);
+
     SetStatFloatValue(PLAYER_DODGE_PERCENTAGE, value);
 }
 
@@ -784,6 +881,9 @@ void Player::UpdateSpellCritChance(uint32 school)
     float crit = 0.0f;
     // Crit from Intellect
     crit += GetSpellCritFromIntellect();
+    crit += GetRatingBonusValue(CR_CRIT_SPELL);
+    crit = crit > p_critLimit ? p_critLimit : crit;
+
     // Increase crit from SPELL_AURA_MOD_SPELL_CRIT_CHANCE
     crit += GetTotalAuraModifierAreaExclusive(SPELL_AURA_MOD_SPELL_CRIT_CHANCE);
     // Increase crit from SPELL_AURA_MOD_CRIT_PCT
@@ -791,8 +891,7 @@ void Player::UpdateSpellCritChance(uint32 school)
     // Increase crit by school from SPELL_AURA_MOD_SPELL_CRIT_CHANCE_SCHOOL
     crit += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_SPELL_CRIT_CHANCE_SCHOOL, 1<<school);
     // Increase crit from spell crit ratings
-    crit += GetRatingBonusValue(CR_CRIT_SPELL);
-
+    
     // Store crit value
     SetFloatValue(PLAYER_SPELL_CRIT_PERCENTAGE1 + school, crit);
 }
@@ -983,6 +1082,10 @@ void Creature::UpdateResistances(uint32 school)
     if (school > SPELL_SCHOOL_NORMAL)
     {
         float value = GetTotalAuraModValue(UnitMods(UNIT_MOD_RESISTANCE_START + school));
+
+        if (C_Resistance != -1)
+            value = C_Resistance;
+
         SetResistance(SpellSchools(school), int32(value));
     }
     else
@@ -992,6 +1095,8 @@ void Creature::UpdateResistances(uint32 school)
 void Creature::UpdateArmor()
 { 
     float value = GetTotalAuraModValue(UNIT_MOD_ARMOR);
+    if (C_Armor != -1)
+        value = C_Armor;
     SetArmor(int32(value));
 }
 
@@ -1081,10 +1186,12 @@ void Creature::CalculateMinMaxDamage(WeaponAttackType attType, bool normalized,
     float basePct          = GetModifierValue(unitMod, BASE_PCT);
     float totalValue       = GetModifierValue(unitMod, TOTAL_VALUE);
     float totalPct         = addTotalPct ? GetModifierValue(unitMod, TOTAL_PCT) : 1.0f;
+    float totalPctAdd = GetModifierValue(unitMod, TOTAL_PCT_ADD);
+
     float dmgMultiplier    = GetCreatureTemplate()->DamageModifier; // = DamageModifier * _GetDamageMod(rank);
 
-    minDamage = ((weaponMinDamage + baseValue) * dmgMultiplier * basePct + totalValue) * totalPct;
-    maxDamage = ((weaponMaxDamage + baseValue) * dmgMultiplier * basePct + totalValue) * totalPct;
+    minDamage = ((weaponMinDamage + baseValue) * dmgMultiplier * basePct + totalValue) * (totalPct + totalPctAdd);
+    maxDamage = ((weaponMaxDamage + baseValue) * dmgMultiplier * basePct + totalValue) * (totalPct + totalPctAdd);
 
     // pussywizard: crashfix (casting negative to uint => min > max => assertion in urand)
     if (minDamage < 0.0f || minDamage > 1000000000.0f)
@@ -1142,6 +1249,7 @@ void Guardian::UpdateArmor()
     value += std::max<float>(GetStat(STAT_AGILITY) - GetCreateStat(STAT_AGILITY), 0.0f) * 2.0f;
     value += GetModifierValue(UNIT_MOD_ARMOR, TOTAL_VALUE);
     value *= GetModifierValue(UNIT_MOD_ARMOR, TOTAL_PCT);
+    sPetMod->GetArmorLimit(this, value);
     SetArmor(int32(value));
 }
 
@@ -1168,7 +1276,7 @@ void Guardian::UpdateMaxHealth()
     value *= GetModifierValue(unitMod, BASE_PCT);
     value += GetModifierValue(unitMod, TOTAL_VALUE) + stamina * multiplicator;
     value *= GetModifierValue(unitMod, TOTAL_PCT);
-
+    sPetMod->GetHpMod(this, value);
     SetMaxHealth((uint32)value);
 }
 
@@ -1287,6 +1395,7 @@ void Guardian::UpdateDamagePhysical(WeaponAttackType attType)
         }
     }
 
+    sPetMod->GetMinDmgMod(this, mindamage, maxdamage);
     SetStatFloatValue(UNIT_FIELD_MINDAMAGE, mindamage);
     SetStatFloatValue(UNIT_FIELD_MAXDAMAGE, maxdamage);
 }
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 03c4bed..6e85c8a 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -52,7 +52,19 @@
 #include "ArenaSpectator.h"
 #include "DynamicVisibility.h"
 #include "AccountMgr.h"
-#include "BYcustom.h"
+#pragma execution_character_set("utf-8")
+#include "../Custom/Switch/Switch.h"
+#include "../Custom/CustomEvent/Event.h"
+#include "../Custom/DataLoader/DataLoader.h"
+#include "../Custom/UnitMod/CharMod/CharMod.h"
+#include "../Custom/UnitMod/CreatureMod/CreatureMod.h"
+#include "../Custom/Challenge/challenge.h"
+#include "../Custom/SpellMod/SpellMod.h"
+#include "../Custom/PvP/PvP.h"
+#include "../Custom/SpiritPower/SpiritPower.h"
+#include "../Custom/CustomEvent/BattleIC/BattleIC.h"
+#include "../Custom/Reward/Reward.h"
+#include "../Custom/GvgSys/GvgSys.h"
 
 #ifdef ELUNA
 #include "LuaEngine.h"
@@ -156,7 +168,7 @@ _hitMask(hitMask), _damageInfo(damageInfo), _healInfo(healInfo), _triggeredByAur
 Unit::Unit(bool isWorldObject) : WorldObject(isWorldObject),
 m_movedByPlayer(nullptr), m_lastSanctuaryTime(0), IsAIEnabled(false), NeedChangeAI(false),
 m_ControlledByPlayer(false), m_CreatedByPlayer(false), movespline(new Movement::MoveSpline()), i_AI(nullptr), i_disabledAI(nullptr), m_realRace(0), m_race(0), m_AutoRepeatFirstCast(false), m_procDeep(0), m_removedAurasCount(0),
-i_motionMaster(new MotionMaster(this)), m_regenTimer(0), m_ThreatManager(this), m_vehicle(nullptr), m_vehicleKit(nullptr), m_unitTypeMask(UNIT_MASK_NONE), m_HostileRefManager(this)
+i_motionMaster(new MotionMaster(this)), m_regenTimer(0), m_ThreatManager(this), m_vehicle(nullptr), m_vehicleKit(nullptr), m_unitTypeMask(UNIT_MASK_NONE), m_HostileRefManager(this), _speedhackCooldown(0)
 {
 #ifdef _MSC_VER
 #pragma warning(default:4355)
@@ -206,6 +218,7 @@ i_motionMaster(new MotionMaster(this)), m_regenTimer(0), m_ThreatManager(this),
         m_auraModifiersGroup[i][BASE_PCT] = 1.0f;
         m_auraModifiersGroup[i][TOTAL_VALUE] = 0.0f;
         m_auraModifiersGroup[i][TOTAL_PCT] = 1.0f;
+        m_auraModifiersGroup[i][TOTAL_PCT_ADD] = 0.0f;
     }
                                                             // implement 50% base damage from offhand
     m_auraModifiersGroup[UNIT_MOD_DAMAGE_OFFHAND][TOTAL_PCT] = 0.5f;
@@ -400,19 +413,6 @@ void Unit::Update(uint32 p_time)
         }
     }
 
-    // NPCBOT
-    if (IsInCombat() && GetTypeId() == TYPEID_UNIT && !GetVictim() && (ToCreature()->GetIAmABot() || ToCreature()->GetIAmABotsPet()))
-    {
-        if (m_HostileRefManager.isEmpty())
-        {
-            if (m_CombatTimer <= p_time)
-                ClearInCombat();
-            else
-                m_CombatTimer -= p_time;
-        }
-    }
-    // NPCBOT
-
     // not implemented before 3.0.2
     // xinef: if attack time > 0, reduce by diff
     // if on next update, attack time < 0 assume player didnt attack - set to 0
@@ -716,13 +716,6 @@ uint32 Unit::DealDamage(Unit* attacker, Unit* victim, uint32 damage, CleanDamage
 
         if (pet && pet->IsAlive())
             pet->AI()->OwnerAttackedBy(attacker);
-
-        // NPCBOT
-        for (ControlSet::const_iterator itr = victim->ToPlayer()->m_Controlled.begin(); itr != victim->ToPlayer()->m_Controlled.end(); ++itr)
-            if (Creature* cre = (*itr)->ToCreature())
-                if (cre->GetIAmABot() && cre->IsAIEnabled)
-                    cre->AI()->OwnerAttackedBy(attacker);
-        // NPCBOT
     }
 
     // Signal the pet it was attacked so the AI can respond if needed
@@ -870,12 +863,32 @@ uint32 Unit::DealDamage(Unit* attacker, Unit* victim, uint32 damage, CleanDamage
             // pussywizard: don't allow GMs to deal damage in normal way (this leaves no evidence in logs!), they have commands to do so
             //if (!allowGM && killer->GetSession()->GetSecurity() && killer->GetSession()->GetSecurity() <= SEC_ADMINISTRATOR)
             //  return 0;
+            if (sGvgSys->IsInAreaGC(killer) && sGvgSys->GCevent)
+            {
+                killer->m_playereventdam[sSwitch->GetValue(GVG_109)] += damage;
 
+                if (killer->m_playereventdam[sSwitch->GetValue(GVG_109)] >= 1500000000)
+                    killer->m_playereventdam[sSwitch->GetValue(GVG_109)] = 1500000000;
+            }
+
+            if (victim->ToCreature() && killer->IsCharmedOwnedByPlayerOrPlayer())
+            {
+                CreatureDamageSend * damcre = sRew->FindCreatureDamageSend(victim->GetEntry());
+                if (damcre)
+                {
+                    if (health <= damage)
+                        victim->ToCreature()->SetDamToValue(GUID_LOPART(killer->GetCharmerOrOwnerOrOwnGUID()), health);
+                    else
+                        victim->ToCreature()->SetDamToValue(GUID_LOPART(killer->GetCharmerOrOwnerOrOwnGUID()), damage);
+
+                }
+            }
             if (Battleground* bg = killer->GetBattleground())
             {
                 bg->UpdatePlayerScore(killer, SCORE_DAMAGE_DONE, damage);
                 killer->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DAMAGE_DONE, damage, 0, victim); // pussywizard: InBattleground() optimization
             }
+            killer->UpdateEventDamage(victim, damage);
             //killer->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HIT_DEALT, damage); // pussywizard: optimization
         }
 
@@ -890,18 +903,66 @@ uint32 Unit::DealDamage(Unit* attacker, Unit* victim, uint32 damage, CleanDamage
             victim->ToCreature()->LowerPlayerDamageReq(health < damage ?  health : damage);
     }
 
+    if (attacker && attacker->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (victim)
+        {
+            uint32 dmglimit = 0;
+
+            if (damagetype == DIRECT_DAMAGE)
+                dmglimit = attacker->ToPlayer()->p_meleeDmgLimit;
+            else
+                dmglimit = attacker->ToPlayer()->p_spellDmgLimit;
+
+            if (dmglimit > 0 && damage > dmglimit)
+                damage = dmglimit;
+        }
+    }
+
     if (health <= damage)
     {
 #if defined(ENABLE_EXTRAS) && defined(ENABLE_EXTRA_LOGS)
         sLog->outStaticDebug("DealDamage: victim just died");
 #endif
 
+        //aura trigger on death
         if (victim)
         {
-            if (sCustomMgr->CheckAuraOnDeath(victim, attacker))
+            bool PreventLastDamage = false;
+
+            for (auto itr = AuraTriggerOnDeathMap.begin(); itr != AuraTriggerOnDeathMap.end(); itr++)
+            {
+                if (victim->HasAura(itr->first) && !victim->HasSpellCooldown(itr->first))
+                {
+                    bool trigger = false;
+
+                    if (roll_chance_f(itr->second.SelfTriggerChance))
+                    {
+                        trigger = true;
+                        victim->CastSpell(victim, itr->second.SelfTriggerSpell, true);
+                    }
+
+                    if (attacker && roll_chance_f(itr->second.AttackerTriggerChance))
+                    {
+                        trigger = true;
+                        victim->CastSpell(attacker, itr->second.AttackerTriggerSpell, true);
+                    }
+
+                    if (trigger)
+                    {
+                        victim->AddSpellCooldown(itr->first, 0, itr->second.CoolDown);
+                        if (itr->second.PreventLastDamage)
+                        {
+                            victim->SetHealth(1);
+                            PreventLastDamage = true;
+                        }
+                    }
+                }
+            }
+
+            if (PreventLastDamage)
                 return 0;
         }
-
         //if (attacker && victim->GetTypeId() == TYPEID_PLAYER && victim != attacker)
             //victim->ToPlayer()->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_TOTAL_DAMAGE_RECEIVED, health); // pussywizard: optimization
 
@@ -1016,6 +1077,29 @@ void Unit::CastStop(uint32 except_spellid, bool withInstant)
             InterruptSpell(CurrentSpellTypes(i),false, withInstant);
 }
 
+SpellCastResult Unit::_CastSpell(SpellCastTargets const& targets, SpellInfo const* spellInfo, CustomSpellValues const* value, TriggerCastFlags triggerFlags, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)
+{
+    if (!spellInfo)
+        return SPELL_FAILED_UNKNOWN;
+
+    // TODO: this is a workaround - not needed anymore, but required for some scripts :(
+    if (!originalCaster && triggeredByAura)
+        originalCaster = triggeredByAura->GetCasterGUID();
+
+    Spell* spell = new Spell(this, spellInfo, triggerFlags, originalCaster);
+
+    if (value)
+        for (CustomSpellValues::const_iterator itr = value->begin(); itr != value->end(); ++itr)
+            spell->SetSpellValue(itr->first, itr->second);
+
+    spell->m_CastItem = castItem;
+    spell->prepare(&targets, triggeredByAura);
+
+    SpellCastResult result = spell->CheckCast(true);
+
+    return result;
+}
+
 void Unit::CastSpell(SpellCastTargets const& targets, SpellInfo const* spellInfo, CustomSpellValues const* value, TriggerCastFlags triggerFlags, Item* castItem, AuraEffect const* triggeredByAura, uint64 originalCaster)
 {
     if (!spellInfo)
@@ -1158,12 +1242,6 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
         case SPELL_DAMAGE_CLASS_RANGED:
         case SPELL_DAMAGE_CLASS_MELEE:
         {
-            // NPCBOT
-            if (Creature* bot = ToCreature())
-                if (bot->GetIAmABot() || bot->GetIAmABotsPet())
-                    bot->ApplyBotDamageMultiplierMelee(damage, *damageInfo, spellInfo, attackType, crit);
-            // NPCBOT
-
             // Physical Damage
             if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)
             {
@@ -1224,12 +1302,6 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
         case SPELL_DAMAGE_CLASS_NONE:
         case SPELL_DAMAGE_CLASS_MAGIC:
         {
-            // NPCBOT
-            if (Creature* bot = ToCreature())
-                if (bot->GetIAmABot() || bot->GetIAmABotsPet())
-                    bot->ApplyBotDamageMultiplierSpell(damage, *damageInfo, spellInfo, attackType, crit);
-            // NPCBOT
-
             // If crit add critical bonus
             if (crit)
             {
@@ -1342,17 +1414,28 @@ void Unit::CalculateMeleeDamage(Unit* victim, uint32 damage, CalcDamageInfo* dam
     damage += CalculateDamage(damageInfo->attackType, false, true);
     // Add melee damage bonus
     damage = MeleeDamageBonusDone(damageInfo->target, damage, damageInfo->attackType);
+
+    if (GetTypeId() == TYPEID_UNIT)
+    {
+        if (ToCreature()->C_MeleeDmg > 0)
+            damage = ToCreature()->C_MeleeDmg;
+        else if (ToCreature()->C_MeleeDmg < 0)
+            damage *= (-ToCreature()->C_MeleeDmg);
+    }
+
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        if (victim->GetTypeId() == TYPEID_PLAYER)
+            damage *= ToPlayer()->p_PVP_meleeDmgMod;
+        else
+            damage *= ToPlayer()->p_PVE_meleeDmgMod;
+    }
+
     damage = damageInfo->target->MeleeDamageBonusTaken(this, damage, damageInfo->attackType);
 
     // Script Hook For CalculateMeleeDamage -- Allow scripts to change the Damage pre class mitigation calculations
     sScriptMgr->ModifyMeleeDamage(damageInfo->target, damageInfo->attacker, damage);
 
-    // NPCBOT
-    if (Creature* bot = ToCreature())
-        if (bot->GetIAmABot() || bot->GetIAmABotsPet())
-            bot->ApplyBotDamageMultiplierMelee(damage, *damageInfo);
-    // NPCBOT
-
     // Calculate armor reduction
     if (IsDamageReducedByArmor((SpellSchoolMask)(damageInfo->damageSchoolMask)))
     {
@@ -1584,7 +1667,6 @@ void Unit::DealMeleeDamage(CalcDamageInfo* damageInfo, bool durabilityLoss)
     // Do effect if any damage done to target
     if (damageInfo->damage)
     {
-        sCustomMgr->ShieldOnDamage(victim, this, nullptr, damageInfo->damage);
         // We're going to call functions which can modify content of the list during iteration over it's elements
         // Let's copy the list so we can prevent iterator invalidation
         AuraEffectList vDamageShieldsCopy(victim->GetAuraEffectsByType(SPELL_AURA_DAMAGE_SHIELD));
@@ -2117,7 +2199,12 @@ void Unit::CalcAbsorbResist(Unit* attacker, Unit* victim, SpellSchoolMask school
     }
 
     *resist = dmgInfo.GetResist();
-    *absorb = dmgInfo.GetAbsorb();
+    if (Creature* c_victim = victim->ToCreature())
+        *absorb = dmgInfo.GetAbsorb() + dmgInfo.GetDamage() * c_victim->C_ReduceDmgPct / 100;
+    else if (Player* p_victim = victim->ToPlayer())
+        *absorb = dmgInfo.GetAbsorb() + dmgInfo.GetDamage() * p_victim->p_reduceDmgMod / 100;
+    else
+        *absorb = dmgInfo.GetAbsorb();
 }
 
 void Unit::CalcHealAbsorb(Unit const* victim, const SpellInfo* healSpell, uint32 &healAmount, uint32 &absorb)
@@ -2255,6 +2342,9 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst(const Unit* victim, WeaponAttackTy
     float block_chance = victim->GetUnitBlockChance();
     float parry_chance = victim->GetUnitParryChance();
 
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->C_MeleeDmg != 0)
+        miss_chance = 0;
+
     // Useful if want to specify crit & miss chances for melee, else it could be removed
     //sLog->outStaticDebug("MELEE OUTCOME: miss %f crit %f dodge %f parry %f block %f", miss_chance, crit_chance, dodge_chance, parry_chance, block_chance);
 
@@ -9028,6 +9118,9 @@ bool Unit::HandleProcTriggerSpell(Unit* victim, uint32 damage, AuraEffect* trigg
         }
     }
 
+    if (sSpellMod->AuraTrigger(this, victim, auraSpellInfo, procSpell, procFlags, target, triggeredByAura))
+        return true;
+
     // try detect target manually if not set
     if (target == nullptr)
         target = !(procFlags & (PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS | PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_POS)) && triggerEntry->IsPositive() ? this : victim;
@@ -10062,6 +10155,13 @@ int32 Unit::DealHeal(Unit* healer, Unit* victim, uint32 addhealth)
 {
     int32 gain = 0;
 
+    if (healer && healer->GetTypeId() == TYPEID_PLAYER)
+    {
+        uint32 healLimit = healer->ToPlayer()->p_healLimit;
+        if (healLimit > 0 && addhealth > healLimit)
+            addhealth = healLimit;
+    }
+
     if (healer)
     {
         if (victim->IsAIEnabled)
@@ -10094,6 +10194,9 @@ int32 Unit::DealHeal(Unit* healer, Unit* victim, uint32 addhealth)
         if (gain && player->InBattleground()) // pussywizard: InBattleground() optimization
             player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HEALING_DONE, gain, 0, victim);
 
+        if (healer != victim)
+            player->UpdateEventHeal(victim, gain);
+
         //player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HEAL_CASTED, addhealth); // pussywizard: optimization
     }
 
@@ -10371,6 +10474,11 @@ void Unit::EnergizeBySpell(Unit* victim, uint32 spellID, uint32 damage, Powers p
     victim->getHostileRefManager().threatAssist(this, float(damage) * 0.5f, spellInfo);
 }
 
+void _AddPct(float &base, float val)
+{
+    base += val / 100.0f;
+}
+
 float Unit::SpellPctDamageModsDone(Unit* victim, SpellInfo const* spellProto, DamageEffectType damagetype)
 {
     if (!spellProto || !victim || damagetype == DIRECT_DAMAGE)
@@ -10411,11 +10519,11 @@ float Unit::SpellPctDamageModsDone(Unit* victim, SpellInfo const* spellProto, Da
         if ((*i)->GetMiscValue() & spellProto->GetSchoolMask())
         {
             if ((*i)->GetSpellInfo()->EquippedItemClass == -1)
-                AddPct(DoneTotalMod, (*i)->GetAmount());
+                sSwitch->GetOnOff(ST_DAMAGE_PCT) ? _AddPct(DoneTotalMod, (*i)->GetAmount()) : AddPct(DoneTotalMod, (*i)->GetAmount());
             else if (!(*i)->GetSpellInfo()->HasAttribute(SPELL_ATTR5_SPECIAL_ITEM_CLASS_CHECK) && ((*i)->GetSpellInfo()->EquippedItemSubClassMask == 0))
-                AddPct(DoneTotalMod, (*i)->GetAmount());
+                sSwitch->GetOnOff(ST_DAMAGE_PCT) ? _AddPct(DoneTotalMod, (*i)->GetAmount()) : AddPct(DoneTotalMod, (*i)->GetAmount());
             else if (ToPlayer() && ToPlayer()->HasItemFitToSpellRequirements((*i)->GetSpellInfo()))
-                AddPct(DoneTotalMod, (*i)->GetAmount());
+                sSwitch->GetOnOff(ST_DAMAGE_PCT) ? _AddPct(DoneTotalMod, (*i)->GetAmount()) : AddPct(DoneTotalMod, (*i)->GetAmount());
         }
     }
 
@@ -10692,6 +10800,20 @@ float Unit::SpellPctDamageModsDone(Unit* victim, SpellInfo const* spellProto, Da
             break;
     }
 
+    if (Player* p_attacker = ToPlayer())
+    {
+        if (victim)
+        {
+            if (victim->GetTypeId() == TYPEID_PLAYER)
+                DoneTotalMod *= ToPlayer()->p_PVP_spellDmgMod;
+            else
+                DoneTotalMod *= ToPlayer()->p_PVE_spellDmgMod;
+        }
+    }
+
+    if (Creature* c_attacker = ToCreature())
+        DoneTotalMod *= c_attacker->C_SpellDmgMod;
+
     return DoneTotalMod;
 }
 
@@ -10983,6 +11105,8 @@ int32 Unit::SpellBaseDamageBonusDone(SpellSchoolMask schoolMask)
 
     if (GetTypeId() == TYPEID_PLAYER)
     {
+        //è¿éè°æ´æºåå æ³ä¼¤ãç²¾ç¥å æ³ä¼¤
+        DoneAdvertisedBenefit += sCharMod->GetExtraSP(ToPlayer());
         // Base value
         DoneAdvertisedBenefit += ToPlayer()->GetBaseSpellPowerBonus();
 
@@ -11030,8 +11154,7 @@ float Unit::SpellDoneCritChance(Unit const* /*victim*/, SpellInfo const* spellPr
 {
     // Mobs can't crit with spells.
     if (GetTypeId() == TYPEID_UNIT && !GetSpellModOwner())
-        if (!ToCreature()->GetIAmABot())// NPCBOT
-            return -100.0f;
+        return -100.0f;
 
     // not critting spell
     if (spellProto->HasAttribute(SPELL_ATTR2_CANT_CRIT))
@@ -11462,6 +11585,20 @@ float Unit::SpellPctHealingModsDone(Unit* victim, SpellInfo const* spellProto, D
             break;
     }
 
+    if (Player* p_caster = ToPlayer())
+    {
+        if (victim)
+        {
+            if (victim->GetTypeId() == TYPEID_PLAYER)
+                DoneTotalMod *= ToPlayer()->p_PVP_healMod;
+            else
+                DoneTotalMod *= ToPlayer()->p_PVE_healMod;
+        }
+    }
+
+    if (Creature* c_caster = ToCreature())
+        DoneTotalMod *= c_caster->C_HealMod;
+
     return DoneTotalMod;
 }
 
@@ -11713,6 +11850,8 @@ int32 Unit::SpellBaseHealingBonusDone(SpellSchoolMask schoolMask)
     // Healing bonus of spirit, intellect and strength
     if (GetTypeId() == TYPEID_PLAYER)
     {
+        //è¿éè°æ´æºåå æ²»çéãç²¾ç¥å æ²»çé
+        AdvertisedBenefit += sCharMod->GetExtraHeal(ToPlayer());
         // Base value
         AdvertisedBenefit += ToPlayer()->GetBaseSpellPowerBonus();
 
@@ -12020,11 +12159,11 @@ uint32 Unit::MeleeDamageBonusDone(Unit* victim, uint32 pdamage, WeaponAttackType
             if (((*i)->GetMiscValue() & spellProto->GetSchoolMask()) && !((*i)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL))
             {
                 if ((*i)->GetSpellInfo()->EquippedItemClass == -1)
-                    AddPct(DoneTotalMod, (*i)->GetAmount());
+                    sSwitch->GetOnOff(ST_DAMAGE_PCT) ? _AddPct(DoneTotalMod, (*i)->GetAmount()) : AddPct(DoneTotalMod, (*i)->GetAmount());
                 else if (!(*i)->GetSpellInfo()->HasAttribute(SPELL_ATTR5_SPECIAL_ITEM_CLASS_CHECK) && ((*i)->GetSpellInfo()->EquippedItemSubClassMask == 0))
-                    AddPct(DoneTotalMod, (*i)->GetAmount());
+                    sSwitch->GetOnOff(ST_DAMAGE_PCT) ? _AddPct(DoneTotalMod, (*i)->GetAmount()) : AddPct(DoneTotalMod, (*i)->GetAmount());
                 else if (ToPlayer() && ToPlayer()->HasItemFitToSpellRequirements((*i)->GetSpellInfo()))
-                    AddPct(DoneTotalMod, (*i)->GetAmount());
+                    sSwitch->GetOnOff(ST_DAMAGE_PCT) ? _AddPct(DoneTotalMod, (*i)->GetAmount()) : AddPct(DoneTotalMod, (*i)->GetAmount());
             }
         }
     }
@@ -12135,6 +12274,9 @@ uint32 Unit::MeleeDamageBonusDone(Unit* victim, uint32 pdamage, WeaponAttackType
         if (Player* modOwner = GetSpellModOwner())
             modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_DAMAGE, tmpDamage);
 
+    if (Creature* c_attacker = ToCreature())
+        tmpDamage *= c_attacker->C_SpellDmgMod;
+
     // bonus result can be negative
     return uint32(std::max(tmpDamage, 0.0f));
 }
@@ -13690,7 +13832,7 @@ float Unit::ApplyEffectModifiers(SpellInfo const* spellProto, uint8 effect_index
 // function uses real base points (typically value - 1)
 int32 Unit::CalculateSpellDamage(Unit const* target, SpellInfo const* spellProto, uint8 effect_index, int32 const* basePoints) const
 {
-    return spellProto->Effects[effect_index].CalcValue(this, basePoints, target) * sCustomMgr->GetSpellModDmg(spellProto->Id);
+    return spellProto->Effects[effect_index].CalcValue(this, basePoints, target)* sSpellMod->GetDmgMod(spellProto->Id);
 }
 
 int32 Unit::CalcSpellDuration(SpellInfo const* spellProto)
@@ -14027,6 +14169,9 @@ bool Unit::HandleStatModifier(UnitMods unitMod, UnitModifierType modifierType, f
         case TOTAL_PCT:
             ApplyPercentModFloatVar(m_auraModifiersGroup[unitMod][modifierType], amount, apply);
             break;
+        case TOTAL_PCT_ADD:
+            m_auraModifiersGroup[unitMod][modifierType] += apply ? amount / 100.0f : -amount / 100.0f;
+            break;
         default:
             break;
     }
@@ -14071,13 +14216,6 @@ bool Unit::HandleStatModifier(UnitMods unitMod, UnitModifierType modifierType, f
             break;
     }
 
-    // NPCBOT
-    if (Player* master = ToPlayer())
-        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
-            if (Creature* bot = master->GetBotMap(i)->_Cre())
-                bot->SetBotShouldUpdateStats();
-    // NPCBOT
-
     return true;
 }
 
@@ -14106,7 +14244,7 @@ float Unit::GetTotalStatValue(Stats stat, float additionalValue) const
     float value  = m_auraModifiersGroup[unitMod][BASE_VALUE] + GetCreateStat(stat);
     value *= m_auraModifiersGroup[unitMod][BASE_PCT];
     value += m_auraModifiersGroup[unitMod][TOTAL_VALUE] + additionalValue;
-    value *= m_auraModifiersGroup[unitMod][TOTAL_PCT];
+    value *= m_auraModifiersGroup[unitMod][TOTAL_PCT] + m_auraModifiersGroup[unitMod][TOTAL_PCT_ADD];
 
     return value;
 }
@@ -14125,7 +14263,7 @@ float Unit::GetTotalAuraModValue(UnitMods unitMod) const
     float value = m_auraModifiersGroup[unitMod][BASE_VALUE];
     value *= m_auraModifiersGroup[unitMod][BASE_PCT];
     value += m_auraModifiersGroup[unitMod][TOTAL_VALUE];
-    value *= m_auraModifiersGroup[unitMod][TOTAL_PCT];
+    value *= m_auraModifiersGroup[unitMod][TOTAL_PCT] + m_auraModifiersGroup[unitMod][TOTAL_PCT_ADD];
 
     return value;
 }
@@ -14226,6 +14364,9 @@ float Unit::GetWeaponDamageRange(WeaponAttackType attType, WeaponDamageRange typ
 
 void Unit::SetLevel(uint8 lvl, bool showLevelChange)
 {
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->C_Level)
+        lvl = ToCreature()->C_Level;
+
     SetUInt32Value(UNIT_FIELD_LEVEL, lvl);
 
     // Xinef: unmark field bit update
@@ -14243,6 +14384,9 @@ void Unit::SetLevel(uint8 lvl, bool showLevelChange)
 
 void Unit::SetHealth(uint32 val)
 {
+    if (sBGIC->Valid(this))
+        return;
+
     if (getDeathState() == JUST_DIED)
         val = 0;
     else if (GetTypeId() == TYPEID_PLAYER && getDeathState() == DEAD)
@@ -16411,6 +16555,9 @@ bool Unit::HandleAuraRaidProcFromCharge(AuraEffect* triggeredByAura)
 
 void Unit::Kill(Unit* killer, Unit* victim, bool durabilityLoss, WeaponAttackType attackType, SpellInfo const *spellProto)
 {
+    if (sBGIC->Valid(killer) || sBGIC->Valid(victim))
+        return;
+
     // Prevent killing unit twice (and giving reward from kill twice)
     if (!victim->GetHealth())
         return;
@@ -16500,8 +16647,24 @@ void Unit::Kill(Unit* killer, Unit* victim, bool durabilityLoss, WeaponAttackTyp
             Loot* loot = &creature->loot;
             loot->clear();
 
-            if (uint32 lootid = creature->GetCreatureTemplate()->lootid)
-                loot->FillLoot(lootid, LootTemplates_Creature, looter, false, false, creature->GetLootMode());
+            if (creature->C_SrcLoot)
+            {
+                if (uint32 lootid = creature->GetCreatureTemplate()->lootid)
+                    loot->FillLoot(lootid, LootTemplates_Creature, looter, false, false, creature->GetLootMode());
+            }
+
+            bool customLoot = false;
+
+            for (size_t i = 0; i < MAX_CUSTOM_LOOT_COUNT; i++)
+                if (creature->C_LootId[i])
+                    customLoot = true;
+
+            if (customLoot)
+            {
+                for (size_t i = 0; i < MAX_CUSTOM_LOOT_COUNT; i++)
+                    if (creature->C_LootId[i])
+                        loot->FillLoot(creature->C_LootId[i], LootTemplates_Creature, looter, false, false, creature->GetLootMode());
+            }
 
             if (creature->GetLootMode())
                 loot->generateMoneyLoot(creature->GetCreatureTemplate()->mingold, creature->GetCreatureTemplate()->maxgold);
@@ -16710,10 +16873,43 @@ void Unit::Kill(Unit* killer, Unit* victim, bool durabilityLoss, WeaponAttackTyp
     // Hook for OnPVPKill Event
     if (killer)
     {
+        //å® ç©å»æ
+        {
+            if (Unit* owner = killer->GetOwner())
+            {
+                if (Player* pl = owner->ToPlayer())
+                {
+                    if (Player* killedPlr = victim->ToPlayer())
+                    {
+                        if (pl->GetGUID() == killedPlr->GetGUID())
+                            return;
+
+                        pl->UpdateEventKills(victim);
+                        killedPlr->UpdateEventKilleds(pl);
+
+                        sScriptMgr->OnPVPKill(pl, killedPlr);
+                    }
+                    else if (Creature* killedCre = victim->ToCreature())
+                        sScriptMgr->OnCreatureKill(pl, killedCre);
+
+                    ////é­é¾å
+                    //if (pl->HasSpell(81213))
+                    //	sSpiritPower->Update(pl, 30, true, false);
+                }
+            }
+        }
         if (Player* killerPlr = killer->ToPlayer())
         {
             if (Player* killedPlr = victim->ToPlayer())
+            {
+                if (killerPlr->GetGUID() == killedPlr->GetGUID())
+                    return;
+
+                killerPlr->UpdateEventKills(killedPlr);
+                killedPlr->UpdateEventKilleds(killerPlr);
+
                 sScriptMgr->OnPVPKill(killerPlr, killedPlr);
+            }
             else if (Creature* killedCre = victim->ToCreature())
                 sScriptMgr->OnCreatureKill(killerPlr, killedCre);
         }
@@ -18023,184 +18219,6 @@ uint32 Unit::GetModelForForm(ShapeshiftForm form) const
                 break;
         }
     }
-    // NPCBOT
-    else if (ToCreature() && ToCreature()->GetIAmABot())
-    {
-    Player const *player = ToCreature()->GetBotOwner();
-    //let's make druids alike for each player
-    switch (form)
-    {
-    case FORM_CAT:
-        // Based on master's Hair color
-        if (player->getRace() == RACE_NIGHTELF)
-        {
-            uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
-            switch (hairColor)
-            {
-            case 7: // Violet
-            case 8:
-                return 29405;
-            case 3: // Light Blue
-                return 29406;
-            case 0: // Green
-            case 1: // Light Green
-            case 2: // Dark Green
-                return 29407;
-            case 4: // White
-                return 29408;
-            default: // original - Dark Blue
-                return 892;
-            }
-        }
-        // Based on master's Skin color
-        else if (player->getRace() == RACE_TAUREN)
-        {
-            uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
-            // Male master
-            if (player->getGender() == GENDER_MALE)
-            {
-                switch (skinColor)
-                {
-                case 12: // White
-                case 13:
-                case 14:
-                case 18: // Completly White
-                    return 29409;
-                case 9: // Light Brown
-                case 10:
-                case 11:
-                    return 29410;
-                case 6: // Brown
-                case 7:
-                case 8:
-                    return 29411;
-                case 0: // Dark
-                case 1:
-                case 2:
-                case 3: // Dark Grey
-                case 4:
-                case 5:
-                    return 29412;
-                default: // original - Grey
-                    return 8571;
-                }
-            }
-            // Female master
-            else switch (skinColor)
-            {
-            case 10: // White
-                return 29409;
-            case 6: // Light Brown
-            case 7:
-                return 29410;
-            case 4: // Brown
-            case 5:
-                return 29411;
-            case 0: // Dark
-            case 1:
-            case 2:
-            case 3:
-                return 29412;
-            default: // original - Grey
-                return 8571;
-            }
-        }
-        else if (Player::TeamIdForRace(player->getRace()) == TEAM_ALLIANCE)
-            return 892;
-        else
-            return 8571;
-    case FORM_DIREBEAR:
-    case FORM_BEAR:
-        // Based on Hair color
-        if (player->getRace() == RACE_NIGHTELF)
-        {
-            uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
-            switch (hairColor)
-            {
-            case 0: // Green
-            case 1: // Light Green
-            case 2: // Dark Green
-                return 29413; // 29415?
-            case 6: // Dark Blue
-                return 29414;
-            case 4: // White
-                return 29416;
-            case 3: // Light Blue
-                return 29417;
-            default: // original - Violet
-                return 2281;
-            }
-        }
-        // Based on Skin color
-        else if (player->getRace() == RACE_TAUREN)
-        {
-            uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
-            // Male
-            if (player->getGender() == GENDER_MALE)
-            {
-                switch (skinColor)
-                {
-                case 0: // Dark (Black)
-                case 1:
-                case 2:
-                    return 29418;
-                case 3: // White
-                case 4:
-                case 5:
-                case 12:
-                case 13:
-                case 14:
-                    return 29419;
-                case 9: // Light Brown/Grey
-                case 10:
-                case 11:
-                case 15:
-                case 16:
-                case 17:
-                    return 29420;
-                case 18: // Completly White
-                    return 29421;
-                default: // original - Brown
-                    return 2289;
-                }
-            }
-            // Female
-            else switch (skinColor)
-            {
-            case 0: // Dark (Black)
-            case 1:
-                return 29418;
-            case 2: // White
-            case 3:
-                return 29419;
-            case 6: // Light Brown/Grey
-            case 7:
-            case 8:
-            case 9:
-                return 29420;
-            case 10: // Completly White
-                return 29421;
-            default: // original - Brown
-                return 2289;
-            }
-        }
-        else if (Player::TeamIdForRace(player->getRace()) == TEAM_ALLIANCE)
-            return 2281;
-        else
-            return 2289;
-    case FORM_FLIGHT:
-        if (Player::TeamIdForRace(player->getRace()) == TEAM_ALLIANCE)
-            return 20857;
-        return 20872;
-    case FORM_FLIGHT_EPIC:
-        if (Player::TeamIdForRace(player->getRace()) == TEAM_ALLIANCE)
-            return 21243;
-        return 21244;
-    default:
-        break;
-    }
-    }
-    // NPCBOT
 
     uint32 modelid = 0;
     SpellShapeshiftEntry const* formEntry = sSpellShapeshiftStore.LookupEntry(form);
@@ -19697,7 +19715,7 @@ void Unit::BuildValuesUpdate(uint8 updateType, ByteBuffer* data, Player* target)
             // FG: pretend that OTHER players in own group are friendly ("blue")
             else if (index == UNIT_FIELD_BYTES_2 || index == UNIT_FIELD_FACTIONTEMPLATE)
             {
-                if (IsControlledByPlayer() && target != this && sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GROUP) && IsInRaidWith(target))
+                if (IsControlledByPlayer() && target != this && sSwitch->GetOnOff(ST_CF_GROUP) && IsInRaidWith(target))
                 {
                     FactionTemplateEntry const* ft1 = GetFactionTemplateEntry();
                     FactionTemplateEntry const* ft2 = target->GetFactionTemplateEntry();
@@ -19793,3 +19811,23 @@ bool Unit::IsInCombatWith(Unit const* who) const
     // Nothing found, false.
     return false;
 }
+
+void Unit::UpdateMovementInfo(MovementInfo const& movementInfo)
+{
+    SetLastMoveClientTimestamp(movementInfo.time);
+}
+
+void Unit::SetStat(Stats stat, int32 val)
+{
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        auto itr = ToPlayer()->StaticStatsMap.find(stat);
+
+        if (itr != ToPlayer()->StaticStatsMap.end() && itr->second > 0)
+        {
+            SetStatInt32Value(UNIT_FIELD_STAT0 + stat, itr->second);
+            return;
+        }
+    }
+    SetStatInt32Value(UNIT_FIELD_STAT0 + stat, val);
+}
diff --git a/src/server/game/Entities/Unit/Unit.h b/src/server/game/Entities/Unit/Unit.h
index dc9561a..e57cd25 100644
--- a/src/server/game/Entities/Unit/Unit.h
+++ b/src/server/game/Entities/Unit/Unit.h
@@ -343,7 +343,8 @@ enum UnitModifierType
     BASE_PCT = 1,
     TOTAL_VALUE = 2,
     TOTAL_PCT = 3,
-    MODIFIER_TYPE_END = 4
+    TOTAL_PCT_ADD = 4,
+    MODIFIER_TYPE_END = 5
 };
 
 enum WeaponDamageRange
@@ -498,6 +499,7 @@ enum UnitState
     UNIT_STATE_CANNOT_TURN     = (UNIT_STATE_LOST_CONTROL | UNIT_STATE_ROTATING | UNIT_STATE_ROOT),
     // stay by different reasons
     UNIT_STATE_NOT_MOVE        = UNIT_STATE_ROOT | UNIT_STATE_STUNNED | UNIT_STATE_DIED | UNIT_STATE_DISTRACTED,
+    UNIT_STATE_IGNORE_ANTISPEEDHACK = UNIT_STATE_FLEEING | UNIT_STATE_CONFUSED | UNIT_STATE_CHARGING | UNIT_STATE_DISTRACTED | UNIT_STATE_POSSESSED,
     UNIT_STATE_ALL_STATE       = 0xffffffff                      //(UNIT_STATE_STOPPED | UNIT_STATE_MOVING | UNIT_STATE_IN_COMBAT | UNIT_STATE_IN_FLIGHT)
 };
 
@@ -1475,7 +1477,7 @@ class Unit : public WorldObject
         uint8 getGender() const { return GetByteValue(UNIT_FIELD_BYTES_0, 2); }
 
         float GetStat(Stats stat) const { return float(GetUInt32Value(UNIT_FIELD_STAT0+stat)); }
-        void SetStat(Stats stat, int32 val) { SetStatInt32Value(UNIT_FIELD_STAT0+stat, val); }
+        void SetStat(Stats stat, int32 val);
         uint32 GetArmor() const { return GetResistance(SPELL_SCHOOL_NORMAL); }
         void SetArmor(int32 val) { SetResistance(SPELL_SCHOOL_NORMAL, val); }
 
@@ -1736,6 +1738,7 @@ class Unit : public WorldObject
         void SendEnergizeSpellLog(Unit* victim, uint32 SpellID, uint32 Damage, Powers powertype);
         void EnergizeBySpell(Unit* victim, uint32 SpellID, uint32 Damage, Powers powertype);
 
+        SpellCastResult _CastSpell(SpellCastTargets const& targets, SpellInfo const* spellInfo, CustomSpellValues const* value, TriggerCastFlags triggerFlags = TRIGGERED_NONE, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);
         void CastSpell(SpellCastTargets const& targets, SpellInfo const* spellInfo, CustomSpellValues const* value, TriggerCastFlags triggerFlags = TRIGGERED_NONE, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);
         void CastSpell(Unit* victim, uint32 spellId, bool triggered, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);
         void CastSpell(Unit* victim, uint32 spellId, TriggerCastFlags triggerFlags = TRIGGERED_NONE, Item* castItem = NULL, AuraEffect const* triggeredByAura = NULL, uint64 originalCaster = 0);
@@ -2571,6 +2574,15 @@ class Unit : public WorldObject
 
         uint32 _oldFactionId;           ///< faction before charm
         bool m_petCatchUp;
+                public:
+                    void SetLastMoveClientTimestamp(uint32 timestamp) { lastMoveClientTimestamp = timestamp; }
+                    uint32 GetLastMoveClientTimestamp() const { return lastMoveClientTimestamp; }
+                    void UpdateMovementInfo(MovementInfo const& movementInfo);
+                    void SetSpeedHackCooldown(time_t t) { _speedhackCooldown = t; }
+                    time_t GetSpeedHackCooldown() { return _speedhackCooldown; }
+    private:
+        uint32 lastMoveClientTimestamp;
+        time_t _speedhackCooldown;
 };
 
 namespace acore
diff --git a/src/server/game/Events/GameEventMgr.cpp b/src/server/game/Events/GameEventMgr.cpp
index 9671ceb..47ba0a4 100644
--- a/src/server/game/Events/GameEventMgr.cpp
+++ b/src/server/game/Events/GameEventMgr.cpp
@@ -19,6 +19,12 @@
 #include "GameObjectAI.h"
 #include "Transport.h"
 #include "ScriptMgr.h"
+#include "../Custom/CustomEvent/Event.h"
+#include "../Custom/ServerAnnounce/ServerAnnounce.h"
+#include "../../scripts/Custom/CharPvpTop/CharPvpTop.h"
+#include "../../scripts/Custom/Switch/Switch.h"
+#include "../../scripts/Custom/GvgSys/GvgSys.h"
+
 #ifdef ELUNA
 #include "LuaEngine.h"
 #endif
@@ -127,6 +133,22 @@ bool GameEventMgr::StartEvent(uint16 event_id, bool overwrite)
     GameEventData &data = mGameEvent[event_id];
     if (data.state == GAMEEVENT_NORMAL || data.state == GAMEEVENT_INTERNAL)
     {
+        if (sSwitch->GetValue(TOP_93) == event_id)
+        {
+            if (sCharPvpTop->SpawnGob(sSwitch->GetValue(TOP_96), true))
+            {
+                CharacterDatabase.PExecute("update _xlchar set lasttop = 0");
+                sCharPvpTop->m_playertopph.clear();
+                sCharPvpTop->topevent = true;
+                sCharPvpTop->SendTopTitle(true);
+                sCharPvpTop->RollTopTeamID();
+                sCharPvpTop->pvptime = time(NULL);
+                sCharPvpTop->isfirst = true;
+            }
+        }
+
+        sGvgSys->StartEventSys(event_id);
+
         AddActiveEvent(event_id);
         ApplyNewEvent(event_id);
         if (overwrite)
@@ -169,14 +191,36 @@ bool GameEventMgr::StartEvent(uint16 event_id, bool overwrite)
     }
 }
 
-void GameEventMgr::StopEvent(uint16 event_id, bool overwrite)
+void GameEventMgr::StopEvent(uint16 event_id, bool overwrite, bool custom)
 {
+    sEvent->Stop(event_id);
+
+    if (sSwitch->GetValue(TOP_93) == event_id)
+    {
+        sCharPvpTop->pvpcount = 0;
+        sCharPvpTop->SendTopTitle(false);
+        sCharPvpTop->topevent = false;
+        if (GameObject *ob = sCharPvpTop->SpawnGob(sSwitch->GetValue(TOP_96), false))
+        {
+            ob->Delete();
+        }
+    }
+    sGvgSys->StopEventSys(event_id);
+
     GameEventData &data = mGameEvent[event_id];
     bool serverwide_evt = data.state != GAMEEVENT_NORMAL && data.state != GAMEEVENT_INTERNAL;
 
     RemoveActiveEvent(event_id);
     UnApplyEvent(event_id);
 
+    if (custom)
+    {
+        data.start = time(NULL) + data.occurence * MINUTE - ((time(NULL) - data.originStartTime) % (data.occurence * MINUTE));
+        if (data.end <= data.start)
+            data.end = data.start + data.length;
+        return;
+    }
+
     if (overwrite && !serverwide_evt)
     {
         data.start = time(nullptr) - data.length * MINUTE;
@@ -241,6 +285,7 @@ void GameEventMgr::LoadFromDB()
             GameEventData& pGameEvent = mGameEvent[event_id];
             uint64 starttime        = fields[1].GetUInt64();
             pGameEvent.start        = time_t(starttime);
+            pGameEvent.originStartTime = time_t(starttime);
             uint64 endtime          = fields[2].GetUInt64();
             if (fields[2].IsNull())
                 endtime             = time(nullptr) + 63072000; // add 2 years to current date
@@ -254,6 +299,7 @@ void GameEventMgr::LoadFromDB()
             pGameEvent.state        = (GameEventState)(fields[8].GetUInt8());
             pGameEvent.announce     = fields[9].GetUInt8();
             pGameEvent.nextstart    = 0;
+            pGameEvent.eventId = event_id;
 
             ++count;
 
@@ -1237,6 +1283,9 @@ void GameEventMgr::ApplyNewEvent(uint16 event_id)
     UpdateEventNPCVendor(event_id, true);
     // update bg holiday
     UpdateBattlegroundSettings();
+
+    //å¨æ­¤åèªå®ä¹äºä»¶å¤ç
+    sEvent->Start(event_id);
 }
 
 void GameEventMgr::UpdateEventNPCFlags(uint16 event_id)
@@ -1276,7 +1325,7 @@ void GameEventMgr::UpdateEventNPCVendor(uint16 event_id, bool activate)
     for (NPCVendorList::iterator itr = mGameEventVendors[event_id].begin(); itr != mGameEventVendors[event_id].end(); ++itr)
     {
         if (activate)
-            sObjectMgr->AddVendorItem(itr->entry, itr->item, itr->maxcount, itr->incrtime, itr->ExtendedCost, itr->Needid, false);
+            sObjectMgr->AddVendorItem(itr->entry, itr->item, itr->maxcount, itr->incrtime, itr->ExtendedCost, false);
         else
             sObjectMgr->RemoveVendorItem(itr->entry, itr->item, false);
     }
@@ -1309,6 +1358,8 @@ void GameEventMgr::GameEventSpawn(int16 event_id)
                 //sLog->outDebug("Spawning creature %u", *itr);
                 if (!creature->LoadCreatureFromDB(*itr, map))
                     delete creature;
+                else
+                    sServerAnnounce->CreatureRespawn(creature);
             }
         }
     }
diff --git a/src/server/game/Events/GameEventMgr.h b/src/server/game/Events/GameEventMgr.h
index 185ac2f..6a7c583 100644
--- a/src/server/game/Events/GameEventMgr.h
+++ b/src/server/game/Events/GameEventMgr.h
@@ -54,7 +54,8 @@ struct GameEventData
     std::set<uint16 /*gameevent id*/> prerequisite_events;  // events that must be completed before starting this event
     std::string description;
     uint8 announce;         // if 0 dont announce, if 1 announce, if 2 take config value
-
+    uint32 eventId;
+    time_t originStartTime;
     bool isValid() const { return length > 0 || state > GAMEEVENT_NORMAL; }
 };
 
@@ -104,7 +105,7 @@ class GameEventMgr
         void StartArenaSeason();
         void StartInternalEvent(uint16 event_id);
         bool StartEvent(uint16 event_id, bool overwrite = false);
-        void StopEvent(uint16 event_id, bool overwrite = false);
+        void StopEvent(uint16 event_id, bool overwrite = false, bool custom = false);
         void HandleQuestComplete(uint32 quest_id);  // called on world event type quest completions
         uint32 GetNPCFlag(Creature* cr);
     private:
diff --git a/src/server/game/Frozen/BYcustom.cpp b/src/server/game/Frozen/BYcustom.cpp
deleted file mode 100644
index 738c381..0000000
--- a/src/server/game/Frozen/BYcustom.cpp
+++ /dev/null
@@ -1,400 +0,0 @@
-ï»¿#include "BYcustom.h"
-#include "Player.h"
-#include "Chat.h"
-#include "Group.h"
-#include "CreatureTextMgr.h"
-#include "GameEventMgr.h"
-#include "Transport.h"
-#include "DisableMgr.h"
-#include "Language.h"
-#include "Battlefield.h"
-#include "BattlefieldMgr.h"
-#include "BattlefieldWG.h"
-#include "Battleground.h"
-#include "BattlegroundAV.h"
-#include "BattlegroundMgr.h"
-#include "AuctionHouseMgr.h"
-#include "ReputationMgr.h"
-#include "SpellAuras.h"
-#include "SpellAuraEffects.h"
-#include "Config.h"
-#include "GuildMgr.h"
-#include "ScriptedAI/ScriptedGossip.h"
-#include <windows.h>
-#include <tchar.h>
-#include <stdio.h>
-#include <string>
-#include "Wininet.h"
-#include <time.h>
-#pragma comment(lib,"Wininet.lib")
-#pragma execution_character_set("utf-8")
-#include "BotSystem.h"
-#include "need.h"
-#include "rew.h"
-#include "customconf.h"
-#include "SpellMod.h"
-
-CustomMgr::CustomMgr()
-{
-
-}
-
-CustomMgr::~CustomMgr()
-{
-
-}
-
-void CustomMgr::LoadAllCustomData()
-{
-    sBotTemplate->LoadData();
-    sNeedMgr->Load();
-    sRewMgr->Load();
-    sConfMgr->Load();
-    sSpellModMgr->Load();
-    sDqSysMgr->Load();
-}
-
-void CustomMgr::SavePlayStatTo(Player* pl, uint32 playguid) //ç©å®¶ä¸çº¿ä¿å­èªå®ä¹å±æ§
-{
-    CharacterDatabase.PExecute("UPDATE _ç©å®¶_ææ° SET ç­çº§ = %u,å©ä½ç¹æ°=%u,æ¥é=%u,æ´å»=%u,é§æ§=%u,ç²¾å=%u,èº²éª=%u,ææ¶=%u,æ¤ç²=%u,åé=%u,ææ·=%u,æºå=%u,èå=%u,ç²¾ç¥=%u,ç»éªå¼ = %u,æ¤ç²ç©¿é=%u,æ³æ¯ç©¿é=%u WHERE ç©å®¶ = %u", pl->dq_level, pl->dq_shuxing, pl->dq_js, pl->dq_bj, pl->dq_rx, pl->dq_jz, pl->dq_ds, pl->dq_zj, pl->dq_hj, pl->dq_ll, pl->dq_mj, pl->dq_zl, pl->dq_nl, pl->dq_js6, pl->dq_xp, pl->dq_wlct, pl->dq_fsct, playguid);
-
-}
-
-void CustomMgr::LoadPlayStatFrom(Player* pl, uint32 playguid) // ç©å®¶ç»éæ¥è¯¢èªå®ä¹å±æ§
-{
-    pl->viplevel = 0;
-    pl->jftoken = 0;
-
-
-    //ææ°å±æ§å è½½
-    QueryResult lnwow_dq = CharacterDatabase.PQuery("SELECT ç­çº§,å©ä½ç¹æ°,æ¥é,æ´å»,é§æ§,ç²¾å,èº²éª,ææ¶,æ¤ç²,åé,ææ·,æºå,èå,ç²¾ç¥,ç»éªå¼,æ¤ç²ç©¿é,æ³æ¯ç©¿é FROM _ç©å®¶_ææ° WHERE ç©å®¶=%u", playguid);
-    if (lnwow_dq)
-    {
-        pl->dq_level = lnwow_dq->Fetch()[0].GetUInt32();
-        pl->dq_shuxing = lnwow_dq->Fetch()[1].GetUInt32();
-        pl->dq_js = lnwow_dq->Fetch()[2].GetUInt32();
-        pl->dq_bj = lnwow_dq->Fetch()[3].GetUInt32();
-        pl->dq_rx = lnwow_dq->Fetch()[4].GetUInt32();
-        pl->dq_jz = lnwow_dq->Fetch()[5].GetUInt32();
-        pl->dq_ds = lnwow_dq->Fetch()[6].GetUInt32();
-        pl->dq_zj = lnwow_dq->Fetch()[7].GetUInt32();
-        pl->dq_hj = lnwow_dq->Fetch()[8].GetUInt32();
-        pl->dq_ll = lnwow_dq->Fetch()[9].GetUInt32();
-        pl->dq_mj = lnwow_dq->Fetch()[10].GetUInt32();
-        pl->dq_zl = lnwow_dq->Fetch()[11].GetUInt32();
-        pl->dq_nl = lnwow_dq->Fetch()[12].GetUInt32();
-        pl->dq_js6 = lnwow_dq->Fetch()[13].GetUInt32();
-        pl->dq_xp = lnwow_dq->Fetch()[14].GetUInt32();
-        pl->dq_wlct = lnwow_dq->Fetch()[15].GetUInt32();
-        pl->dq_fsct = lnwow_dq->Fetch()[16].GetUInt32();
-    }
-    else
-    {
-        CharacterDatabase.PExecute("INSERT INTO _ç©å®¶_ææ° (ç©å®¶) VALUES ('%u')", playguid);
-    }
-}
-
-void CustomMgr::RewardItem(Player *plr, uint32 item_id, uint32 count)
-{
-    ItemPosCountVec dest;
-    uint32 no_space_count = 0;
-    uint8 msg = plr->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, item_id, count, &no_space_count);
-
-    if (msg == EQUIP_ERR_ITEM_NOT_FOUND)
-        return;
-
-    if (msg != EQUIP_ERR_OK)                               // convert to possible store amount
-        count -= no_space_count;
-
-    if (count != 0 && !dest.empty())                        // can add some
-    {
-        if (Item* item = plr->StoreNewItem(dest, item_id, true, Item::GenerateItemRandomPropertyId(item_id)))
-            plr->SendNewItem(item, count, true, false);
-    }
-    if (no_space_count > 0)
-        SendRewardMarkByMail(plr, item_id, no_space_count);
-}
-
-void CustomMgr::SendRewardMarkByMail(Player *plr, uint32 mark, uint32 count)
-{
-    ItemTemplate const* markProto = sObjectMgr->GetItemTemplate(mark);
-    if (!markProto)
-        return;
-
-    // extract items
-    typedef std::pair<uint32, uint32> ItemPair;
-    typedef std::list< ItemPair > ItemPairs;
-    ItemPairs items;
-
-    std::string itemText = "é®ä»¶è·åç©å";
-
-    std::string subject = "è¿äºéå·å¨è£å¤/å­æ¾ä¸­åºç°ä¸ä¸ªé®é¢.";
-
-    while (count > markProto->GetMaxStackSize())
-    {
-        items.push_back(ItemPair(mark, markProto->GetMaxStackSize()));
-        count -= markProto->GetMaxStackSize();
-    }
-
-    items.push_back(ItemPair(mark, count));
-
-    MailDraft draft(subject, itemText);
-
-    SQLTransaction trans = CharacterDatabase.BeginTransaction();
-
-    for (ItemPairs::const_iterator itr = items.begin(); itr != items.end(); ++itr)
-    {
-        if (Item* item = Item::CreateItem(itr->first, itr->second, plr))
-        {
-            item->SaveToDB(trans);
-            draft.AddItem(item);
-        }
-    }
-
-    draft.SendMailTo(trans, plr, MailSender(plr, MAIL_STATIONERY_GM));
-    CharacterDatabase.CommitTransaction(trans);
-}
-
-void CustomMgr::DoCommand(Player* player, std::string command)
-{
-    if (command.empty())
-        return;
-
-    player->CastStop();
-    uint64 oriTarget = player->GetTarget();
-
-
-    AccountTypes security = player->GetSession()->GetSecurity();
-    player->GetSession()->SetSecurity(SEC_CONSOLE);
-
-    if (!ChatHandler(player->GetSession()).ParseCommands(command.c_str(), false))
-    {
-        std::ostringstream oss;
-        oss << "å½ä»¤éç½®åºé:" << command.c_str();
-        player->GetSession()->SendNotification(oss.str().c_str());
-    }
-
-    player->SetSelection(oriTarget);
-    player->GetSession()->SetSecurity(security);
-}
-
-bool CustomMgr::CanSendBuyItemUI(Player * pl, uint64 vendorguid, uint32 itemid, uint32 itemcount, uint32 slot, uint8 bag, uint8 bagslot)
-{
-    //è´­ä¹°å¼¹çª
-    uint32 currentVendor = pl->GetSession()->GetCurrentVendor();
-    Creature* creature = pl->GetNPCIfCanInteractWith(vendorguid, UNIT_NPC_FLAG_VENDOR);
-    if (currentVendor || creature)
-    {
-        VendorItemData const* vItems = currentVendor ? sObjectMgr->GetNpcVendorItemList(currentVendor) : creature->GetVendorItems();
-        if (vItems)
-        {
-            if (sCustomMgr->IsInNeedSys(vItems->GetItem(slot)->Needid))
-            {
-                pl->buy_vendor = vendorguid;
-                pl->buy_item = itemid;
-                pl->buy_count = itemcount;
-                pl->buy_slot = slot;
-                pl->buy_bag = bag;
-                pl->buy_bagslot = bagslot;
-                SendBuyItemUI(pl, itemid, itemcount, vItems->GetItem(slot)->Needid);
-                return true;
-            }
-        }
-    }
-    return false;
-}
-
-void CustomMgr::SendBuyItemUI(Player * pl, uint32 itemid, uint32 itemcount, uint32 needid)
-{
-    ItemTemplate const* ipt = sObjectMgr->GetItemTemplate(itemid);
-    if (!ipt)
-        return;
-
-    std::ostringstream ss1, ss2;
-    std::string strTitle;
-
-    ss1 << itemid << "#" << itemcount;
-
-    const CNeedParameters * needsys = sNeedMgr->GetNeedParameters(needid);
-    if (!needsys)
-        return;
-
-    
-
-    if (needsys->classmask)
-    {
-        std::ostringstream classnotin;
-
-        for (int32 i = 1; i < 12; i++)
-        {
-            if (!GetClassNameInMask(needsys->classmask, i).empty())
-                classnotin << GetClassNameInMask(needsys->classmask, i) << "-";
-        }
-        if (!(needsys->classmask & pl->getClassMask()))
-            ss2 << "å¯è´­ä¹°èä¸ï¼" << classnotin.str() << "\n";
-    }
-
-    if (needsys->racemask)
-    {
-        std::ostringstream racenotin;
-
-        for (int32 i = 1; i < 12; i++)
-        {
-            if (!GetRaceNameInMask(needsys->racemask, i).empty())
-                racenotin << GetRaceNameInMask(needsys->racemask, i) << "-";
-        }
-        if (!(needsys->racemask & pl->getRaceMask()))
-            ss2 << "å¯è´­ä¹°ç§æï¼" << racenotin.str() << "\n";
-    }
-
-    if (needsys->level)
-    {
-        ss2 << "ç­çº§ï¼" << needsys->level << "\n";
-    }
-    if (needsys->viplevel)
-    {
-        ss2 << "ä¼åç­çº§ï¼" << needsys->viplevel << "\n";
-    }
-    if (needsys->dqlevel)
-    {
-        ss2 << "ææ°ç­çº§ï¼" << needsys->dqlevel << "\n";
-    }
-    if (needsys->achpoint)
-    {
-        ss2 << "æå°±ç¹æ°è¾¾å°ï¼" << needsys->achpoint << "\n";
-    }
-
-    if (needsys->m_achneeds.size())
-    {
-        for (int i = 0; i < needsys->m_achneeds.size(); i++)
-        {
-            ss2 <<"æå°±ï¼"<< GetAchLink(pl, needsys->m_achneeds[i]) << " å®æ\n";
-        }
-    }
-
-    if (needsys->m_spellneeds.size())
-    {
-        for (int i = 0; i < needsys->m_spellneeds.size(); i++)
-        {
-            ss2<<"æè½ï¼" << GetSpellLink(needsys->m_spellneeds[i]) << " å­¦ä¼\n";
-        }
-    }
-
-    if (needsys->m_auraneeds.size())
-    {
-        for (int i = 0; i < needsys->m_auraneeds.size(); i++)
-        {
-            ss2<<"BUFFï¼" << GetSpellLink(needsys->m_auraneeds[i]) << " ææBUFF\n";
-        }
-    }
-
-    if (needsys->m_questhasneeds.size())
-    {
-        for (int i = 0; i < needsys->m_questhasneeds.size(); i++)
-        {
-            ss2<< "ä»»å¡ï¼"<< GetQuestLink(needsys->m_questhasneeds[i]) << " æ¥å\n";
-        }
-    }
-
-    if (needsys->m_questcomneeds.size())
-    {
-        for (int i = 0; i < needsys->m_questcomneeds.size(); i++)
-        {
-            ss2<<"ä»»å¡ï¼" << GetQuestLink(needsys->m_questcomneeds[i]) << " å®æ\n";
-        }
-    }
-
-    if (needsys->m_haveitems.size() && needsys->m_haveitems.size() == needsys->m_haveitemcounts.size())
-    {
-        for (int i = 0; i < needsys->m_haveitems.size(); i++)
-        {
-            ss2 <<"ç©åï¼"<< GetItemLink(needsys->m_haveitems[i]) << " ææ" << needsys->m_haveitemcounts[i] << "ä¸ª\n";
-        }
-    }
-
-    if (needsys->jfcost)
-        ss2 << "|TInterface/icons/INV_Misc_Coin_01:11:11:0:-11|tç§¯åï¼" << needsys->jfcost*itemcount << " æ¶è\n";
-
-    if (needsys->gbcost)
-        ss2 << "|TInterface/icons/INV_Misc_Coin_01:11:11:0:-11|téå¸ï¼" << needsys->gbcost*itemcount << " æ¶è\n";
-
-    if (needsys->honorcost)
-        ss2 << "|TInterface/icons/INV_Misc_Coin_01:11:11:0:-11|tè£èªç¹ï¼" << needsys->honorcost*itemcount << " æ¶è\n";
-
-    if (needsys->arenacost)
-        ss2 << "|TInterface/icons/INV_Misc_Coin_01:11:11:0:-11|tç«æç¹ï¼" << needsys->arenacost*itemcount << " æ¶è\n";
-
-    if (needsys->m_itemcosts.size() && needsys->m_itemcosts.size() == needsys->m_itemcostcounts.size())
-    {
-        for (int i = 0; i < needsys->m_itemcosts.size(); i++)
-        {
-            ss2 <<"ç©åï¼"<< GetItemLink(needsys->m_itemcosts[i]) << " æ¶è" << needsys->m_itemcostcounts[i] * itemcount << "ä¸ª\n";
-        }
-    }
-
-    strTitle = "FrozenBuy^" + ss1.str() + "^" + ss2.str();
-    WorldPacket data(SMSG_QUEST_CONFIRM_ACCEPT, (4 + strTitle.size() + 8));
-    data << uint32(3);
-    data << strTitle;
-    data << uint64(pl->GetGUID());
-    pl->GetSession()->SendPacket(&data);
-}
-
-void CustomMgr::SendWorldAnnText(char const *format, ...)   //å¨ä¸çä¸æ¹æç¤ºå¬å
-{
-    if (format)
-    {
-        va_list ap;
-        char str[2048];
-        va_start(ap, format);
-        vsnprintf(str, 2048, format, ap);
-        va_end(ap);
-        std::string msg = (std::string)str;
-
-        WorldPacket data(SMSG_SERVER_MESSAGE, 50);
-        data << uint32(SERVER_MSG_STRING);
-        data << msg.c_str();
-        sWorld->SendGlobalMessage(&data);
-    }
-}
-
-void CustomMgr::SendWorldNotifyText(char const *format, ...) //å¨ä¸çä¸æ¹æç¤º
-{
-    if (format)
-    {
-        va_list ap;
-        char str[2048];
-        va_start(ap, format);
-        vsnprintf(str, 2048, format, ap);
-        va_end(ap);
-
-        WorldPacket data(SMSG_NOTIFICATION, (strlen(str) + 1));
-        data << str;
-        sWorld->SendGlobalMessage(&data);
-    }
-}
-
-void CustomMgr::SendPVPText(char const *format, ...)  //ä¸çå¼¹åºå¼å¬å
-{
-    if (format)
-    {
-        va_list ap;
-        char str[2048];
-        va_start(ap, format);
-        vsnprintf(str, 2048, format, ap);
-        va_end(ap);
-
-        WorldPacket data(SMSG_MESSAGECHAT, 200);
-        data << (uint8)CHAT_MSG_RAID_BOSS_EMOTE;
-        data << (uint32)LANG_UNIVERSAL;
-        data << (uint64)0;
-        data << (uint32)0;                                     // 2.1.0
-        data << (uint32)1;
-        data << "";
-        data << (uint64)0;
-        data << (uint32)(strlen(str) + 1);
-        data << str;
-        data << (uint8)0;
-        sWorld->SendGlobalMessage(&data);
-    }
-}
diff --git a/src/server/game/Frozen/BYcustom.h b/src/server/game/Frozen/BYcustom.h
deleted file mode 100644
index 5e0f85d..0000000
--- a/src/server/game/Frozen/BYcustom.h
+++ /dev/null
@@ -1,427 +0,0 @@
-ï»¿#ifndef __CUSTOM_H
-#define __CUSTOM_H
-#include "Common.h"
-#include "Timer.h"
-#include <ace/Singleton.h>
-#include <ace/Atomic_Op.h>
-#include "SharedDefines.h"
-#include "QueryResult.h"
-#include "Callback.h"
-#include "Util.h"
-#include <atomic>
-#include <map>
-#include <set>
-#include <list>
-#pragma execution_character_set("utf-8")
-#include "LootMgr.h"
-#include "Item.h"
-#include "ObjectMgr.h"
-#include "AchievementMgr.h"
-#include "Player.h"
-#include "need.h"
-#include "rew.h"
-#include "SpellInfo.h"
-#include "customconf.h"
-#include "SpellMod.h"
-#include "dqsys.h"
-
-class CustomMgr
-{
-public: //å®å¨è®¿é®æé
-	CustomMgr();
-	~CustomMgr();
-
-    std::string Format(char const *format, ...)
-    {
-        if (format)
-        {
-            va_list ap;
-            char str[2048];
-            va_start(ap, format);
-            vsnprintf(str, 2048, format, ap);
-            va_end(ap);
-
-
-            std::string aaaaaaa = std::string(str);
-            std::string strsrc = "@";
-            std::string strdst = "\n";
-            std::string::size_type pos = 0;
-            std::string::size_type srclen = strsrc.size();
-            std::string::size_type dstlen = strdst.size();
-
-            while ((pos = aaaaaaa.find(strsrc, pos)) != std::string::npos)
-            {
-                aaaaaaa.replace(pos, srclen, strdst);
-                pos += dstlen;
-            }
-            return aaaaaaa;
-        }
-        return NULL;
-    }
-
-    //è·åæå°±ç¹
-    uint32 GetAchievementPoints(Player* player)
-    {
-        CompletedAchievementMap cam = player->getAchievementMgr()->get_m_completedAchievements();
-        uint32 points = 0;
-        for (CompletedAchievementMap::const_iterator itr = cam.begin(); itr != cam.end(); ++itr)
-            if (AchievementEntry const* completedAchievements = sAchievementStore.LookupEntry(itr->first))
-                points += completedAchievements->points;
-        return points;
-    }
-
-    bool HasAchievement(uint32 achievementid)
-    {
-        AchievementEntry const* achievement = sAchievementStore.LookupEntry(achievementid);
-        if (achievement)
-            return true;
-        return false;
-    }
-
-    bool HasQuestInCom(Player* player, uint32 inquestid)
-    {
-        for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
-        {
-            if (inquestid == player->GetQuestSlotQuestId(i))
-            {
-                Quest const* qInfo = sObjectMgr->GetQuestTemplate(inquestid);
-                if (qInfo)
-                {
-                    if (player->GetQuestStatus(inquestid) == QUEST_STATUS_INCOMPLETE)
-                        return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    void LoadPlayStatFrom(Player* pl, uint32 playguid);
-    void SavePlayStatTo(Player* pl, uint32 playguid);
-    void RewardItem(Player *plr, uint32 item_id, uint32 count);
-    void SendRewardMarkByMail(Player *plr, uint32 mark, uint32 count);
-    void DoCommand(Player* player, std::string command);
-    void LoadAllCustomData();
-
-    //è´­ä¹°éæ±æ£æµä¸æ¶è
-    bool BuyFromNeedSys(Player* pl, uint32 needid, uint8 count) { return sNeedMgr->Candothis(pl, needid, count); }
-    void BuyDeleteFromNeedSys(Player * pl, uint32 needid, uint8 count) { sNeedMgr->Needcost(pl, needid, count); }
-    void SendToPlayerByRewID(Player * pl, uint32 rewid, uint8 count) { sRewMgr->SendToPlayer(pl, rewid, count); }
-    bool IsInNeedSys(uint32 needid) { return sNeedMgr->GetNeedParameters(needid); }
-    void SendBuyItemUI(Player * pl, uint32 itemid, uint32 itemcount, uint32 needid);
-    void SendWorldAnnText(char const *format, ...);
-    void SendWorldNotifyText(char const * format, ...);
-    void SendPVPText(char const * format, ...);
-    bool CanSendBuyItemUI(Player * pl, uint64 vendorguid, uint32 itemid, uint32 itemcount, uint32 slot, uint8 bag, uint8 bagslot);
-
-    // æ¸¸æåä¿¡æ¯é¾æ¥
-    uint32 getClassMask(uint32 classid) const { return 1 << (classid - 1); }
-    uint32 getRaceMask(uint32 raceid) const { return 1 << (raceid - 1); }
-
-    std::string GetClassNameInMask(uint32 classmask, uint32 classid)
-    {
-        std::string player_class ="";
-        if (classmask & getClassMask(classid))
-        {
-            switch (classid)
-            {
-            case CLASS_WARRIOR: player_class = "æå£«"; break;
-            case CLASS_PALADIN:    player_class = "å£éªå£«"; break;
-            case CLASS_HUNTER:    player_class = "çäºº"; break;
-            case CLASS_ROGUE:    player_class = "æ½è¡è"; break;
-            case CLASS_PRIEST:    player_class = "ç§å¸"; break;
-            case CLASS_DEATH_KNIGHT:    player_class = "æ­»äº¡éªå£«"; break;
-            case CLASS_SHAMAN:    player_class = "è¨æ»¡"; break;
-            case CLASS_MAGE:    player_class = "æ³å¸"; break;
-            case CLASS_WARLOCK:    player_class = "æ¯å£«"; break;
-            case CLASS_DRUID:    player_class = "å¾·é²ä¼"; break;
-            default:
-                break;
-            }
-        }
-        return player_class;
-    }
-
-    std::string GetRaceNameInMask(uint32 racemask, uint32 raceid)
-    {
-        std::string player_race = "";
-        if (racemask & getRaceMask(raceid))
-        {
-            switch (raceid)
-            {
-            case RACE_HUMAN: player_race = "äººç±»"; break;
-            case RACE_ORC: player_race = "å½äºº"; break;
-            case RACE_DWARF: player_race = "ä¾å"; break;
-            case RACE_NIGHTELF:    player_race = "æå¤ç²¾çµ"; break;
-            case RACE_UNDEAD_PLAYER:    player_race = "äº¡çµ"; break;
-            case RACE_TAUREN:    player_race = "çå¤´äºº"; break;
-            case RACE_GNOME:    player_race = "ç®äºº"; break;
-            case RACE_TROLL:    player_race = "å·¨é­"; break;
-            case RACE_BLOODELF:    player_race = "è¡ç²¾çµ"; break;
-            case RACE_DRAENEI:    player_race = "å¾·è±å°¼"; break;
-            default:
-                break;
-            }
-        }
-        return player_race;
-    }
-
-    std::string GetSpellLink(uint32 spellid)
-    {
-        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellid);
-        if (!spellInfo)
-            return "éè¯¯çæè½ID";
-
-        std::ostringstream ss_name;
-        ss_name << "|cffffffff|Hspell:" << spellid << "|h[" << spellInfo->SpellName[LOCALE_zhCN] << "]|h|r";
-        return ss_name.str();
-    }
-
-    std::string GetAchLink(Player* pl, uint32 achid)
-    {
-        AchievementEntry const* achievement = sAchievementStore.LookupEntry(achid);
-        if (!achievement)
-            return "éè¯¯çæå°±ID";
-
-        std::ostringstream achname;
-        achname << "|cffffff00|Hachievement:" << achid << ":" << pl->GetGUID() << ":0:0:0:-1:0:0:0:0|h[" << achievement->name[LOCALE_zhCN] << "]|h|r";
-        return achname.str();
-    }
-
-    std::string GetQuestLink(uint32 questid) const
-    {
-        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
-        if (!qInfo)
-            return "éè¯¯çä»»å¡ID";
-
-        std::ostringstream str;
-        str << "|cFFEFFD00|Hquest:" << qInfo->GetQuestId() << ':' << qInfo->GetQuestLevel() << "|h[" << qInfo->GetTitle() << "]|h|r";
-        return str.str();
-    }
-
-    std::string GetItemLink(uint32 itemid) const
-    {
-        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemid))
-            return proto->GetINameLink();
-
-        return "éè¯¯çç©åID";
-    }
-    // æ¸¸æåä¿¡æ¯é¾æ¥ç»æ
-    //éç½®æä»¶è¯»å
-    std::string GetSendText(uint32 entry, ...) const
-    {
-        if (sConfMgr->Get2Conftxt(entry).c_str())
-        {
-            va_list ap;
-            char szStr[1024];
-            szStr[0] = '\0';
-            va_start(ap, entry);
-            vsnprintf(szStr, 1024, sConfMgr->Get2Conftxt(entry).c_str(), ap);
-            va_end(ap);
-
-            std::string aaaaaaa = std::string(szStr);
-            std::string strsrc = "@";
-            std::string strdst = "\n";
-            std::string::size_type pos = 0;
-            std::string::size_type srclen = strsrc.size();
-            std::string::size_type dstlen = strdst.size();
-
-            while ((pos = aaaaaaa.find(strsrc, pos)) != std::string::npos)
-            {
-                aaaaaaa.replace(pos, srclen, strdst);
-                pos += dstlen;
-            }
-            return aaaaaaa;
-        }
-        return "";
-    }
-
-    bool GetConfBool(uint32 entry, uint32 index = 1) const { return  sConfMgr->GetConfBool(entry, index); }
-    int32 GetConfInt(uint32 entry, uint32 index = 1) const { return  sConfMgr->GetConfInt(entry, index); }
-    float GetConfFloat(uint32 entry, uint32 index = 1) const { return  sConfMgr->GetConfFloat(entry, index); }
-    std::string GetConfText(uint32 entry, uint32 index = 1) const { return  sConfMgr->GetConfText(entry, index); }
-    //éç½®æä»¶è¯»åç»æ
-
-    //æè½ä¿®æ¹
-    SpellCustomMod const * FindSpellCustomMod(uint32 spellid) const { return sSpellModMgr->FindSpellCustomMod(spellid); }
-    SpellCustomLearnMod const * FindSpellLearnMod(uint32 spellid) const { return sSpellModMgr->FindSpellLearnMod(spellid); }
-    SpellCustomUnLearnMod const * FindSpellUnLearnMod(uint32 spellid) const { return sSpellModMgr->FindSpellUnLearnMod(spellid); }
-
-    int32 GetSpellModDuration(uint32 spellid)
-    {
-        if (FindSpellCustomMod(spellid))
-            if (FindSpellCustomMod(spellid)->duration != 0)
-                return FindSpellCustomMod(spellid)->duration;
-
-        return 0;
-    }
-
-    int32 GetSpellModCastTime(uint32 spellid)
-    {
-        if (FindSpellCustomMod(spellid))
-            if (FindSpellCustomMod(spellid)->castingtime >= 0)
-                return FindSpellCustomMod(spellid)->castingtime;
-
-        return -1;
-    }
-
-    int32 GetSpellModCooldown(uint32 spellid)
-    {
-        if (FindSpellCustomMod(spellid))
-            if (FindSpellCustomMod(spellid)->cooldown >= 0)
-                return FindSpellCustomMod(spellid)->cooldown;
-
-        return -1;
-    }
-
-    float GetSpellModDmg(uint32 spellid)
-    {
-        if (FindSpellCustomMod(spellid))
-            if (FindSpellCustomMod(spellid)->dmgMod != 0)
-                return FindSpellCustomMod(spellid)->dmgMod;
-
-        return 1.0f;
-    }
-
-    float GetSpellModHeal(uint32 spellid)
-    {
-        if (FindSpellCustomMod(spellid))
-            if (FindSpellCustomMod(spellid)->healMod != 0)
-                return FindSpellCustomMod(spellid)->healMod;
-
-        return 1.0f;
-    }
-
-    bool CheckSpellCast(Player* pl, uint32 spellid)
-    {
-        if (FindSpellCustomMod(spellid))
-            if (FindSpellCustomMod(spellid)->reqId != 0)
-                return sNeedMgr->Candothis(pl, FindSpellCustomMod(spellid)->reqId, 1);
-
-        return true;
-    }
-
-    void DeleteAndRewSpellCast(Player* pl, uint32 spellid)
-    {
-        if (FindSpellCustomMod(spellid))
-        {
-            if (FindSpellCustomMod(spellid)->reqId != 0)
-                sNeedMgr->Needcost(pl, FindSpellCustomMod(spellid)->reqId, 1);
-            if (FindSpellCustomMod(spellid)->rewId != 0)
-                sRewMgr->SendToPlayer(pl, FindSpellCustomMod(spellid)->rewId, 1);
-        } 
-    }
-
-    bool CheckSpellDisable(Player* pl, uint32 spellid)
-    {
-        if (FindSpellCustomMod(spellid))
-            return FindSpellCustomMod(spellid)->disable;
-
-        return false;
-    }
-
-    bool CheckSpellLearn(Player* pl, uint32 spellid)
-    {
-        if (FindSpellLearnMod(spellid))
-            if (FindSpellLearnMod(spellid)->reqId != 0)
-                return sNeedMgr->Candothis(pl, FindSpellLearnMod(spellid)->reqId, 1);
-
-        return true;
-    }
-
-    void DeleteAndRewSpellLearn(Player* pl, uint32 spellid)
-    {
-        if (FindSpellLearnMod(spellid))
-        {
-            if (FindSpellLearnMod(spellid)->reqId != 0)
-                sNeedMgr->Needcost(pl, FindSpellLearnMod(spellid)->reqId, 1);
-
-            if (FindSpellLearnMod(spellid)->rewId != 0)
-                sRewMgr->SendToPlayer(pl, FindSpellLearnMod(spellid)->rewId, 1);
-        }
-            
-    }
-
-    bool CheckSpellUnLearn(Player* pl, uint32 spellid)
-    {
-        if (FindSpellUnLearnMod(spellid))
-            if (FindSpellUnLearnMod(spellid)->reqId != 0)
-                return sNeedMgr->Candothis(pl, FindSpellUnLearnMod(spellid)->reqId, 1);
-
-        return true;
-    }
-
-    void DeleteAndRewSpellUnLearn(Player* pl, uint32 spellid)
-    {
-        if (FindSpellUnLearnMod(spellid))
-        {
-            if (FindSpellUnLearnMod(spellid)->reqId != 0)
-                sNeedMgr->Needcost(pl, FindSpellUnLearnMod(spellid)->reqId, 1);
-
-            if (FindSpellUnLearnMod(spellid)->rewId != 0)
-                sRewMgr->SendToPlayer(pl, FindSpellUnLearnMod(spellid)->rewId, 1);
-        } 
-    }
-
-    //æè½å¸è¡
-    void HealOnDamage(Unit* caster, Unit* target, SpellInfo const* spellInfo, uint32 &damage) { sSpellModMgr->HealOnDamage(caster, target, spellInfo, damage); }
-    void ShieldOnDamage(Unit* caster, Unit* target, SpellInfo const* spellInfo, uint32 &damage) { sSpellModMgr->ShieldOnDamage(caster, target, spellInfo, damage); }
-
-    AuraStackTriggerMod const * FindAuraStackMod(uint32 spellid) { return sSpellModMgr->FindAuraStackMod(spellid); }
-    AuraOnDeathMod const * FindAuraOnDeathMod(uint32 spellid) { return sSpellModMgr->FindAuraOnDeathMod(spellid); }
-
-    bool CheckAuraOnDeath(Unit* victim, Unit* attacker)
-    {
-        bool PreventLastDamage = false;
-
-        for (auto itr = sSpellModMgr->m_AuraOnDeath.begin(); itr != sSpellModMgr->m_AuraOnDeath.end(); itr++)
-        {
-            if (victim->HasAura((*itr)->auraid) && !victim->HasSpellCooldown((*itr)->auraid))
-            {
-                bool trigger = false;
-
-                if (roll_chance_f((*itr)->SelfTriggerChance))
-                {
-                    trigger = true;
-                    victim->CastSpell(victim, (*itr)->SelfTriggerSpell, true);
-                }
-
-                if (attacker)
-                {
-                    if (roll_chance_f((*itr)->AttackerTriggerChance) && victim != attacker)
-                    {
-                        trigger = true;
-                        victim->CastSpell(attacker, (*itr)->AttackerTriggerSpell, true);
-                    }
-                }
-
-                if (trigger)
-                {
-                    victim->AddSpellCooldown((*itr)->auraid, 0, (*itr)->CoolDown);
-                    if ((*itr)->PreventLastDamage)
-                    {
-                        victim->SetHealth(1);
-                        PreventLastDamage = true;
-                    }
-                }
-            }
-        }
-
-        if (PreventLastDamage)
-            return true;
-
-        return false;
-    }
-
-    //å è½½ææ°
-
-    void AppDQlevel(Player * pl, bool applystat) { sDqSysMgr->AppDQlevel(pl, applystat); }
-    void OnPlayerSelectDQ(Player * player, uint32 sender, uint32 action, std::string code) { sDqSysMgr->OnPlayerSelectDQ(player, sender, action, code); }
-    void OnPlayerUpdateDQXP(Player * player) { sDqSysMgr->OnPlayerUpdateDQXP(player); }
-protected:
-private:
-};
-
-#define sCustomMgr ACE_Singleton<CustomMgr, ACE_Null_Mutex>::instance()
-
-#endif
-
diff --git a/src/server/game/Frozen/need/need.cpp b/src/server/game/Frozen/need/need.cpp
deleted file mode 100644
index c15fb22..0000000
--- a/src/server/game/Frozen/need/need.cpp
+++ /dev/null
@@ -1,346 +0,0 @@
-ï»¿#include "need.h"
-#include "Player.h"
-#include "Chat.h"
-#include "Group.h"
-#include "CreatureTextMgr.h"
-#include "GameEventMgr.h"
-#include "Transport.h"
-#include "DisableMgr.h"
-#include "Language.h"
-#include "Battlefield.h"
-#include "BattlefieldMgr.h"
-#include "BattlefieldWG.h"
-#include "Battleground.h"
-#include "BattlegroundAV.h"
-#include "BattlegroundMgr.h"
-#include "AuctionHouseMgr.h"
-#include "ReputationMgr.h"
-#include "SpellAuras.h"
-#include "SpellAuraEffects.h"
-#include "Config.h"
-#include "GuildMgr.h"
-#include "ScriptedAI/ScriptedGossip.h"
-#include <windows.h>
-#include <tchar.h>
-#include <stdio.h>
-#include <string>
-#include "Wininet.h"
-#include <time.h>
-#pragma comment(lib,"Wininet.lib")
-#pragma execution_character_set("utf-8")
-#include "BYcustom.h"
-
-NeedMgr::NeedMgr()
-{
-    m_needParameters.clear();
-}
-
-NeedMgr::~NeedMgr()
-{
-    
-}
- 
-void NeedMgr::Load()
-{
-    
-    m_needParameters.clear();
-
-    int count = 0;
-    QueryResult needsys = WorldDatabase.PQuery("SELECT éæ±æ¨¡æ¿ID,èä¸éæ±,ç§æéæ±,äººç©ç­çº§,ä¼åç­çº§,ææ°ç­çº§,æå°±ç¹éæ±,æå°±éæ±ç»,æè½éæ±ç»,BUFFéæ±ç»,ä»»å¡æ¥åéæ±ç»,ä»»å¡å®æéæ±ç»,ç©åéæ±ç»,ç©åéæ±ä¸ªæ°,ç§¯åæ¶è,éå¸æ¶è,è£èªç¹æ¶è,ç«æç¹æ¶è,ç©åæ¶èç»,ç©åæ¶èä¸ªæ° FROM _æ¨¡æ¿_éæ±");
-    if (needsys)
-    {
-        do
-        {
-            CNeedParameters &tmpNeed = m_needParameters[needsys->Fetch()[0].GetUInt32()];
-
-            tmpNeed.needid = needsys->Fetch()[0].GetUInt32();
-            tmpNeed.classmask = needsys->Fetch()[1].GetUInt32();
-            tmpNeed.racemask = needsys->Fetch()[2].GetUInt32();
-            tmpNeed.level = needsys->Fetch()[3].GetUInt32();
-            tmpNeed.viplevel = needsys->Fetch()[4].GetUInt32();
-            tmpNeed.dqlevel = needsys->Fetch()[5].GetUInt32();
-            tmpNeed.achpoint = needsys->Fetch()[6].GetUInt32();
-
-            Tokenizer achidneeds(needsys->Fetch()[7].GetString(), '#');
-            if (achidneeds.size())
-            {
-                for (uint32 index = 0; index < achidneeds.size(); ++index)
-                    tmpNeed.m_achneeds.push_back(atoi(achidneeds[index]));
-            }
-
-            Tokenizer spellneeds(needsys->Fetch()[8].GetString(), '#');
-            if (spellneeds.size())
-            {
-                for (uint32 index = 0; index < spellneeds.size(); ++index)
-                    tmpNeed.m_spellneeds.push_back(atoi(spellneeds[index]));
-            }
-
-            Tokenizer auraneeds(needsys->Fetch()[9].GetString(), '#');
-            if (auraneeds.size())
-            {
-                for (uint32 index = 0; index < auraneeds.size(); ++index)
-                    tmpNeed.m_auraneeds.push_back(atoi(auraneeds[index]));
-            }
-
-            Tokenizer questhasneeds(needsys->Fetch()[10].GetString(), '#');
-            if (questhasneeds.size())
-            {
-                for (uint32 index = 0; index < questhasneeds.size(); ++index)
-                    tmpNeed.m_questhasneeds.push_back((atoi(questhasneeds[index])));
-            }
-
-            Tokenizer questcomneeds(needsys->Fetch()[11].GetString(), '#');
-            if (questcomneeds.size())
-            {
-                for (uint32 index = 0; index < questcomneeds.size(); ++index)
-                    tmpNeed.m_questcomneeds.push_back(atoi(questcomneeds[index]));
-            }
-
-            Tokenizer itemneeds(needsys->Fetch()[12].GetString(), '#');
-            if (itemneeds.size())
-            {
-                for (uint32 index = 0; index < itemneeds.size(); ++index)
-                    tmpNeed.m_haveitems.push_back(atoi(itemneeds[index]));
-            }
-
-            Tokenizer itemneedcounts(needsys->Fetch()[13].GetString(), '#');
-            if (itemneedcounts.size())
-            {
-                for (uint32 index = 0; index < itemneedcounts.size(); ++index)
-                    tmpNeed.m_haveitemcounts.push_back(atoi(itemneedcounts[index]));
-            }
-
-            if (itemneeds.size() != itemneedcounts.size())
-                sLog->outString(">> _æ¨¡æ¿_éæ±è¡¨%uæ®µéç½®éè¯¯ ...", tmpNeed.needid);
-
-            tmpNeed.jfcost = needsys->Fetch()[14].GetUInt32();
-            tmpNeed.gbcost = needsys->Fetch()[15].GetUInt32();
-            tmpNeed.honorcost = needsys->Fetch()[16].GetUInt32();
-            tmpNeed.arenacost = needsys->Fetch()[17].GetUInt32();
-
-            Tokenizer itemcosts(needsys->Fetch()[18].GetString(), '#');
-            if (itemcosts.size())
-            {
-                for (uint32 index = 0; index < itemcosts.size(); ++index)
-                    tmpNeed.m_itemcosts.push_back(atoi(itemcosts[index]));
-            }
-
-            Tokenizer itemcostcounts(needsys->Fetch()[19].GetString(), '#');
-            if (itemcostcounts.size())
-            {
-                for (uint32 index = 0; index < itemcostcounts.size(); ++index)
-                    tmpNeed.m_itemcostcounts.push_back(atoi(itemcostcounts[index]));
-            }
-
-            if (itemcosts.size() != itemcostcounts.size())
-                sLog->outString(">> _æ¨¡æ¿_éæ±è¡¨%uæ®µéç½®éè¯¯ ...", tmpNeed.needid);
-
-            count++;
-        } while (needsys->NextRow());
-    }
-
-    sLog->outString(">> è¯»ååè½æ°æ®è¡¨[_æ¨¡æ¿_éæ±],å±%uæ¡æ°æ®è¯»åå è½½...", count);
-}
-
-bool NeedMgr::Candothis(Player* pl, uint32 needid, uint8 count)
-{
-    const CNeedParameters * needsys = sNeedMgr->GetNeedParameters(needid);
-    if (!needsys)
-        return true;
-
-    bool cando = true;
-
-    if (needsys->classmask)
-    {
-        if (!(needsys->classmask & pl->getClassMask()))
-        {
-            std::ostringstream classnotin;
-            for (int32 i = 1; i < 12; i++)
-            {
-                if (!sCustomMgr->GetClassNameInMask(needsys->classmask, i).empty())
-                    classnotin << sCustomMgr->GetClassNameInMask(needsys->classmask, i) << "-";
-            }
-            cando = false;
-            ChatHandler(pl->GetSession()).PSendSysMessage("    Â·éè¦èä¸ï¼%sã", classnotin.str().c_str());;
-        }
-    }
-
-    if (needsys->racemask)
-    {
-        if (!(needsys->racemask & pl->getRaceMask()))
-        {
-            std::ostringstream racenotin;
-
-            for (int32 i = 1; i < 12; i++)
-            {
-                if (!sCustomMgr->GetRaceNameInMask(needsys->racemask, i).empty())
-                    racenotin << sCustomMgr->GetRaceNameInMask(needsys->racemask, i) << "-";
-            }
-
-            cando = false;
-            ChatHandler(pl->GetSession()).PSendSysMessage("    Â·éè¦ç§æï¼%sã", racenotin.str().c_str());
-        }
-    }
-
-    if (needsys->level > pl->getLevel())
-    {
-        cando = false;
-        ChatHandler(pl->GetSession()).PSendSysMessage("    Â·éè¦ç­çº§%uã", needsys->level);
-    }
-
-    if (needsys->viplevel > pl->viplevel)
-    {
-        cando = false;
-        ChatHandler(pl->GetSession()).PSendSysMessage("    Â·ä¼åç­çº§%uã", needsys->viplevel);
-    }
-
-    if (needsys->dqlevel > pl->dq_level)
-    {
-        cando = false;
-        ChatHandler(pl->GetSession()).PSendSysMessage("    Â·ææ°ç­çº§%uã", needsys->dqlevel);
-    }
-
-    if (needsys->achpoint > sCustomMgr->GetAchievementPoints(pl))
-    {
-        cando = false;
-        ChatHandler(pl->GetSession()).PSendSysMessage("    Â·æå°±ç¹æ°%uã", needsys->achpoint);
-    }
-
-    if (needsys->m_achneeds.size())
-    {
-        for (int i = 0; i < needsys->m_achneeds.size(); i++)
-        {
-            if (sCustomMgr->HasAchievement(needsys->m_achneeds[i]))
-            {
-                if (!pl->HasAchieved(needsys->m_achneeds[i]))
-                {
-                    cando = false;
-                    ChatHandler(pl->GetSession()).PSendSysMessage("    Â·æªå®ææå°±%sã", sCustomMgr->GetAchLink(pl, needsys->m_achneeds[i]).c_str());
-                }
-            }
-        }
-    }
-
-    if (needsys->m_spellneeds.size())
-    {
-        for (int i = 0; i < needsys->m_spellneeds.size(); i++)
-        {
-            if (!pl->HasSpell(needsys->m_spellneeds[i]))
-            {
-                cando = false;
-                ChatHandler(pl->GetSession()).PSendSysMessage("    Â·æªå­¦ä¼æè½%sã", sCustomMgr->GetSpellLink(needsys->m_spellneeds[i]).c_str());
-            }
-        }
-    }
-
-    if (needsys->m_auraneeds.size())
-    {
-        for (int i = 0; i < needsys->m_auraneeds.size(); i++)
-        {
-            if (!pl->HasSpell(needsys->m_auraneeds[i]))
-            {
-                cando = false;
-                ChatHandler(pl->GetSession()).PSendSysMessage("    Â·æ BUFF%sã", sCustomMgr->GetSpellLink(needsys->m_auraneeds[i]).c_str());
-            }
-        }
-    }
-
-    if (needsys->m_questhasneeds.size())
-    {
-        for (int i = 0; i < needsys->m_questhasneeds.size(); i++)
-        {
-            if (!sCustomMgr->HasQuestInCom(pl, needsys->m_questhasneeds[i]))
-            {
-                cando = false;
-                ChatHandler(pl->GetSession()).PSendSysMessage("    Â·æªæ¥åä»»å¡%sã", sCustomMgr->GetQuestLink(needsys->m_questhasneeds[i]).c_str());
-            }
-        }
-    }
-
-    if (needsys->m_questcomneeds.size())
-    {
-        for (int i = 0; i < needsys->m_questcomneeds.size(); i++)
-        {
-            if (!pl->GetQuestRewardStatus(needsys->m_questcomneeds[i]))
-            {
-                cando = false;
-                ChatHandler(pl->GetSession()).PSendSysMessage("    Â·æªå®æä»»å¡%sã", sCustomMgr->GetQuestLink(needsys->m_questcomneeds[i]).c_str());
-            }
-        }
-    }
-
-    if (needsys->m_haveitems.size() && needsys->m_haveitems.size() == needsys->m_haveitemcounts.size())
-    {
-        for (int i = 0; i < needsys->m_haveitems.size(); i++)
-        {
-            if (!pl->HasItemCount(needsys->m_haveitems[i], needsys->m_haveitemcounts[i], true))
-            {
-                cando = false;
-                ChatHandler(pl->GetSession()).PSendSysMessage("    Â·æªææç©å%s%uä¸ªã", sCustomMgr->GetItemLink(needsys->m_haveitems[i]).c_str(), needsys->m_haveitemcounts[i]);
-            }
-        }
-    }
-
-    if (needsys->jfcost * count > pl->jftoken)
-    {
-        cando = false;
-        ChatHandler(pl->GetSession()).PSendSysMessage("    Â·æ¶èç§¯å%uã", needsys->jfcost * count);
-    }
-
-    if (needsys->gbcost * GOLD  * count > pl->GetMoney())
-    {
-        cando = false;
-        ChatHandler(pl->GetSession()).PSendSysMessage("    Â·æ¶è%uéã", needsys->gbcost * count);
-    }
-
-    if (needsys->honorcost * count > pl->GetHonorPoints())
-    {
-        cando = false;
-        ChatHandler(pl->GetSession()).PSendSysMessage("    Â·æ¶èè£èªç¹%uã", needsys->honorcost * count);
-    }
-
-    if (needsys->arenacost * count > pl->GetArenaPoints())
-    {
-        cando = false;
-        ChatHandler(pl->GetSession()).PSendSysMessage("    Â·æ¶èç«æç¹%uã", needsys->arenacost * count);
-    }
-
-    if (needsys->m_itemcosts.size() && needsys->m_itemcosts.size() == needsys->m_itemcostcounts.size())
-    {
-        for (int i = 0; i < needsys->m_itemcosts.size(); i++)
-        {
-            if (!pl->HasItemCount(needsys->m_itemcosts[i], needsys->m_itemcostcounts[i] * count))
-            {
-                cando = false;
-                ChatHandler(pl->GetSession()).PSendSysMessage("    Â·æ¶èç©å%s%uä¸ªã", sCustomMgr->GetItemLink(needsys->m_itemcosts[i]).c_str(), needsys->m_itemcostcounts[i] * count);
-            }
-        }
-    }
-
-    return cando;
-}
-
-void NeedMgr::Needcost(Player * pl, uint32 needid, uint8 count)
-{
-    const CNeedParameters * needsys = sNeedMgr->GetNeedParameters(needid);
-    if (!needsys)
-        return;
-
-    if (needsys->jfcost)
-        pl->ModifyJf(-1 * needsys->jfcost * count);
-
-    if (needsys->gbcost)
-        pl->ModifyMoney(-1 * needsys->gbcost * GOLD * count);
-
-    if (needsys->honorcost)
-        pl->ModifyHonorPoints(-1 * needsys->honorcost * count);
-
-    if (needsys->arenacost)
-        pl->ModifyArenaPoints(-1 * needsys->arenacost * count);
-
-    if (needsys->m_itemcosts.size() && needsys->m_itemcosts.size() == needsys->m_itemcostcounts.size())
-    { 
-        for (int i = 0; i < needsys->m_itemcosts.size(); i++)
-            pl->DestroyItemCount(needsys->m_itemcosts[i], needsys->m_itemcostcounts[i] * count, true);
-    }
-}
diff --git a/src/server/game/Frozen/need/need.h b/src/server/game/Frozen/need/need.h
deleted file mode 100644
index dc55976..0000000
--- a/src/server/game/Frozen/need/need.h
+++ /dev/null
@@ -1,73 +0,0 @@
-ï»¿#ifndef __Need_H
-#define __Need_H
-#include "Common.h"
-#include "Timer.h"
-#include <ace/Singleton.h>
-#include <ace/Atomic_Op.h>
-#include "SharedDefines.h"
-#include "QueryResult.h"
-#include "Callback.h"
-#include "Util.h"
-#include <atomic>
-#include <map>
-#include <set>
-#include <list>
-#pragma execution_character_set("utf-8")
-
-//ææéæ±è¡¨
-
-struct CNeedParameters
-{
-    uint32 needid;
-    uint32 classmask;
-    uint32 racemask;
-    uint32 level;
-    uint32 viplevel;
-    uint32 dqlevel;
-    uint32 achpoint;
-    
-    std::vector<uint32> m_achneeds; //æå°±ç»
-    std::vector<uint32> m_spellneeds; //æè½ç»
-    std::vector<uint32> m_auraneeds; //BUFFç»
-    std::vector<uint32> m_questhasneeds; //æ¥åä»»å¡ç»
-    std::vector<uint32> m_questcomneeds; //å®æä»»å¡ç»
-    std::vector<uint32> m_haveitems; //éæ±ç©ååç»
-    std::vector<uint32> m_haveitemcounts;
-
-
-    uint32 jfcost;
-    uint32 gbcost;
-    uint32 honorcost;
-    uint32 arenacost;
-    std::vector<uint32> m_itemcosts; //æ¶èç©ååç»
-    std::vector<uint32> m_itemcostcounts;
-
-};
-
-class NeedMgr
-{
-public:
-    NeedMgr();
-    ~NeedMgr();
-
-     CNeedParameters const * GetNeedParameters(uint32 needid)
-    {
-        CNeedParametersContainer::const_iterator itr = m_needParameters.find(needid);
-        if (itr != m_needParameters.end())
-            return &itr->second;
-        return nullptr;
-    }
-
-    typedef std::unordered_map<uint32, CNeedParameters>  CNeedParametersContainer;
-    CNeedParametersContainer m_needParameters;
-
-    void Load();
-    bool Candothis(Player * pl, uint32 needid, uint8 count);
-    void Needcost(Player * pl, uint32 needid, uint8 count);
-
-protected:
-private:
-};
-#define sNeedMgr ACE_Singleton<NeedMgr, ACE_Null_Mutex>::instance()
-#endif
-
diff --git a/src/server/game/Frozen/rewsys/rew.cpp b/src/server/game/Frozen/rewsys/rew.cpp
deleted file mode 100644
index e89a921..0000000
--- a/src/server/game/Frozen/rewsys/rew.cpp
+++ /dev/null
@@ -1,123 +0,0 @@
-ï»¿#include "rew.h"
-#include "Player.h"
-#include "Chat.h"
-#pragma execution_character_set("utf-8")
-#include "BYcustom.h"
-
-RewMgr::RewMgr()
-{
-    m_rewParameters.clear();
-}
-
-RewMgr::~RewMgr()
-{
-    
-}
- 
-void RewMgr::Load()
-{
-    
-    m_rewParameters.clear();
-
-    int count = 0;
-    QueryResult rewsys = WorldDatabase.PQuery("SELECT å¥å±æ¨¡æ¿ID,ç§¯å,éå¸,è£èªç¹,ç«æç¹,ç»éªå¼,ææ°ç»éªå¼,ç©åç»,ç©åä¸ªæ°ç»,æè½ç»,åç¯ç»,GMå½ä»¤ç» FROM _æ¨¡æ¿_å¥å±");
-    if (rewsys)
-    {
-        do
-        {
-            CRewParameters *tmpRew = new CRewParameters;
-            
-            tmpRew->rewid = rewsys->Fetch()[0].GetUInt32();
-            tmpRew->jfrew = rewsys->Fetch()[1].GetUInt32();
-            tmpRew->gbrew = rewsys->Fetch()[2].GetUInt32();
-            tmpRew->honorrew = rewsys->Fetch()[3].GetUInt32();
-            tmpRew->arenarew = rewsys->Fetch()[4].GetUInt32();
-            tmpRew->xprew = rewsys->Fetch()[5].GetUInt32();
-            tmpRew->dqxprew = rewsys->Fetch()[6].GetUInt32();
-
-            Tokenizer itemrews(rewsys->Fetch()[7].GetString(), '#');
-            if (itemrews.size())
-            {
-                for (uint32 index = 0; index < itemrews.size(); ++index)
-                    tmpRew->m_items.push_back(atoi(itemrews[index]));
-            }
-
-            Tokenizer itemcountrews(rewsys->Fetch()[8].GetString(), '#');
-            if (itemcountrews.size())
-            {
-                for (uint32 index = 0; index < itemcountrews.size(); ++index)
-                    tmpRew->m_itemcounts.push_back(atoi(itemcountrews[index]));
-            }
-
-            if (itemrews.size() != itemcountrews.size())
-                sLog->outString(">> _æ¨¡æ¿_å¥å±è¡¨%uæ®µéç½®éè¯¯ ...", tmpRew->rewid);
-
-            Tokenizer spellrews(rewsys->Fetch()[9].GetString(), '#');
-            if (spellrews.size())
-            {
-                for (uint32 index = 0; index < spellrews.size(); ++index)
-                    tmpRew->m_spellrews.push_back(atoi(spellrews[index]));
-            }
-
-            Tokenizer aurarews(rewsys->Fetch()[10].GetString(), '#');
-            if (aurarews.size())
-            {
-                for (uint32 index = 0; index < aurarews.size(); ++index)
-                    tmpRew->m_aurarews.push_back(atoi(aurarews[index]));
-            }
-
-            Tokenizer commands(rewsys->Fetch()[11].GetString(), '#');
-            if (commands.size())
-            {
-                for (uint32 index = 0; index < commands.size(); ++index)
-                    tmpRew->m_commands.push_back(commands[index]);
-            }
-
-            m_rewParameters[tmpRew->rewid] = tmpRew;
-
-            count++;
-        } while (rewsys->NextRow());
-    }
-
-    sLog->outString(">> è¯»ååè½æ°æ®è¡¨[_æ¨¡æ¿_å¥å±],å±%uæ¡æ°æ®è¯»åå è½½...", count);
-}
-
-
-void RewMgr::SendToPlayer(Player * pl, uint32 needid, uint8 count)
-{
-    const CRewParameters * rewsys = GetRewParameters(needid);
-    if (!rewsys)
-        return;
-
-    if (rewsys->jfrew)
-        pl->ModifyJf(rewsys->jfrew * count);
-
-    if (rewsys->gbrew)
-        pl->ModifyMoney(rewsys->gbrew * GOLD * count);
-
-    if (rewsys->honorrew)
-        pl->ModifyHonorPoints(rewsys->honorrew * count);
-
-    if (rewsys->arenarew)
-        pl->ModifyArenaPoints(rewsys->arenarew * count);
-
-    if (rewsys->xprew)
-        pl->GiveXP(rewsys->xprew, nullptr);
-
-    if (rewsys->m_items.size() && rewsys->m_items.size() == rewsys->m_itemcounts.size())
-        for (int i = 0; i < rewsys->m_items.size(); i++)
-            sCustomMgr->RewardItem(pl, rewsys->m_items[i], rewsys->m_itemcounts[i] * count);
-
-    if (rewsys->m_spellrews.size())
-        for (int i = 0; i < rewsys->m_spellrews.size(); i++)
-            if (!pl->HasSpell(rewsys->m_spellrews[i]))
-                pl->learnSpell(rewsys->m_spellrews[i]);
-            
-    if (rewsys->m_aurarews.size())
-        for (int i = 0; i < rewsys->m_aurarews.size(); i++)
-            pl->CastSpell(pl, rewsys->m_aurarews[i], false);
-
-    if (rewsys->m_commands.size())
-        for (int i = 0; i < rewsys->m_commands.size(); i++)
-            sCustomMgr->DoCommand(pl, rewsys->m_commands[i]);
-}
diff --git a/src/server/game/Frozen/rewsys/rew.h b/src/server/game/Frozen/rewsys/rew.h
deleted file mode 100644
index 40d6770..0000000
--- a/src/server/game/Frozen/rewsys/rew.h
+++ /dev/null
@@ -1,61 +0,0 @@
-ï»¿#ifndef __Rew_H
-#define __Rew_H
-#include "Common.h"
-#include "Timer.h"
-#include <ace/Singleton.h>
-#include <ace/Atomic_Op.h>
-#include "SharedDefines.h"
-#include "QueryResult.h"
-#include "Callback.h"
-#include "Util.h"
-#include <atomic>
-#include <map>
-#include <set>
-#include <list>
-#pragma execution_character_set("utf-8")
-
-//ææéæ±è¡¨
-
-struct CRewParameters
-{
-    uint32 rewid;
-    uint32 jfrew;
-    uint32 gbrew;
-    uint32 honorrew;
-    uint32 arenarew;
-    uint32 xprew;
-    uint32 dqxprew;
-    std::vector<uint32> m_items; //å¥å±ç©ååç»
-    std::vector<uint32> m_itemcounts;
-    std::vector<uint32> m_spellrews; //æè½ç»
-    std::vector<uint32> m_aurarews; //BUFFç»
-    std::vector<std::string> m_commands; //GMå½ä»¤ç»
-
-};
-
-class RewMgr
-{
-public:
-    RewMgr();
-    ~RewMgr();
-
-    CRewParameters const * GetRewParameters(uint32 rewid)
-    {
-        CRewParametersContainer::const_iterator itr = m_rewParameters.find(rewid);
-        if (itr != m_rewParameters.end())
-            return itr->second;
-        return nullptr;
-    }
-
-    typedef std::unordered_map<uint32, CRewParameters*>  CRewParametersContainer;
-    CRewParametersContainer m_rewParameters;
-
-    void Load();
-    void SendToPlayer(Player * pl, uint32 rewid, uint8 count);
-
-protected:
-private:
-};
-#define sRewMgr ACE_Singleton<RewMgr, ACE_Null_Mutex>::instance()
-#endif
-
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index f9f8b31..6dcb789 100644
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -8294,13 +8294,13 @@ int ObjectMgr::LoadReferenceVendor(int32 vendor, int32 item, std::set<uint32> *s
             int32  maxcount     = fields[1].GetUInt8();
             uint32 incrtime     = fields[2].GetUInt32();
             uint32 ExtendedCost = fields[3].GetUInt32();
-            uint32 Needid = fields[4].GetUInt32();
+
             if (!IsVendorItemValid(vendor, item_id, maxcount, incrtime, ExtendedCost, NULL, skip_vendors))
                 continue;
 
             VendorItemData& vList = _cacheVendorItemStore[vendor];
 
-            vList.AddItem(item_id, maxcount, incrtime, ExtendedCost, Needid);
+            vList.AddItem(item_id, maxcount, incrtime, ExtendedCost);
             ++count;
         }
     } while (result->NextRow());
@@ -8319,7 +8319,7 @@ void ObjectMgr::LoadVendors()
 
     std::set<uint32> skip_vendors;
 
-    QueryResult result = WorldDatabase.Query("SELECT entry, item, maxcount, incrtime, ExtendedCost, Needid FROM npc_vendor ORDER BY entry, slot ASC, item, ExtendedCost");
+    QueryResult result = WorldDatabase.Query("SELECT entry, item, maxcount, incrtime, ExtendedCost FROM npc_vendor ORDER BY entry, slot ASC, item, ExtendedCost");
     if (!result)
     {
         sLog->outString();
@@ -8344,13 +8344,12 @@ void ObjectMgr::LoadVendors()
             uint32 maxcount     = fields[2].GetUInt8();
             uint32 incrtime     = fields[3].GetUInt32();
             uint32 ExtendedCost = fields[4].GetUInt32();
-            uint32 Needid = fields[5].GetUInt32();
             if (!IsVendorItemValid(entry, item_id, maxcount, incrtime, ExtendedCost, NULL, &skip_vendors))
                 continue;
 
             VendorItemData& vList = _cacheVendorItemStore[entry];
 
-            vList.AddItem(item_id, maxcount, incrtime, ExtendedCost, Needid);
+            vList.AddItem(item_id, maxcount, incrtime, ExtendedCost);
             ++count;
         }
     }
@@ -8471,10 +8470,10 @@ void ObjectMgr::LoadGossipMenuItems()
     sLog->outString();
 }
 
-void ObjectMgr::AddVendorItem(uint32 entry, uint32 item, int32 maxcount, uint32 incrtime, uint32 extendedCost, uint32 needid, bool persist /*= true*/)
+void ObjectMgr::AddVendorItem(uint32 entry, uint32 item, int32 maxcount, uint32 incrtime, uint32 extendedCost, bool persist /*= true*/)
 {
     VendorItemData& vList = _cacheVendorItemStore[entry];
-    vList.AddItem(item, maxcount, incrtime, extendedCost, needid);
+    vList.AddItem(item, maxcount, incrtime, extendedCost);
 
     if (persist)
     {
@@ -8485,7 +8484,6 @@ void ObjectMgr::AddVendorItem(uint32 entry, uint32 item, int32 maxcount, uint32
         stmt->setUInt8(2, maxcount);
         stmt->setUInt32(3, incrtime);
         stmt->setUInt32(4, extendedCost);
-        stmt->setUInt32(5, needid);
 
         WorldDatabase.Execute(stmt);
     }
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index ebd92fe..3b364da 100644
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -693,6 +693,17 @@ class ObjectMgr
         ~ObjectMgr();
 
     public:
+        void RestItemQueryData()
+        {
+            for (ItemTemplateContainer::iterator itr = _itemTemplateStore.begin(); itr != _itemTemplateStore.end(); ++itr)
+                itr->second.InitializeQueryData();
+        }
+
+        void RestQuestQueryData()
+        {
+            for (QuestMap::iterator itr = _questTemplates.begin(); itr != _questTemplates.end(); ++itr)
+                itr->second->InitializeQueryData();
+        }
         static ObjectMgr* instance();
 
         typedef std::unordered_map<uint32, Item*> ItemMap;
@@ -730,6 +741,7 @@ class ObjectMgr
 
         CreatureTemplate const* GetCreatureTemplate(uint32 entry);
         CreatureTemplateContainer const* GetCreatureTemplates() const { return &_creatureTemplateStore; }
+        CreatureTemplateContainer * GetCreatureTemplatesStore() { return &_creatureTemplateStore; }
         CreatureModelInfo const* GetCreatureModelInfo(uint32 modelId);
         CreatureModelInfo const* GetCreatureModelRandomGender(uint32* displayID);
         static uint32 ChooseDisplayId(CreatureTemplate const* cinfo, CreatureData const* data = nullptr);
@@ -1284,7 +1296,7 @@ class ObjectMgr
             return &iter->second;
         }
 
-        void AddVendorItem(uint32 entry, uint32 item, int32 maxcount, uint32 incrtime, uint32 extendedCost, uint32 needid, bool persist = true); // for event
+        void AddVendorItem(uint32 entry, uint32 item, int32 maxcount, uint32 incrtime, uint32 extendedCost, bool persist = true); // for event
         bool RemoveVendorItem(uint32 entry, uint32 item, bool persist = true); // for event
         bool IsVendorItemValid(uint32 vendor_entry, uint32 item, int32 maxcount, uint32 ptime, uint32 ExtendedCost, Player* player = NULL, std::set<uint32>* skip_vendors = NULL, uint32 ORnpcflag = 0) const;
 
diff --git a/src/server/game/Grids/Notifiers/GridNotifiers.h b/src/server/game/Grids/Notifiers/GridNotifiers.h
index 911d3f3..45519b3 100644
--- a/src/server/game/Grids/Notifiers/GridNotifiers.h
+++ b/src/server/game/Grids/Notifiers/GridNotifiers.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -1339,6 +1339,23 @@ namespace acore
             float m_fRange;
     };
 
+    class AllCreaturesInRange
+    {
+    public:
+        AllCreaturesInRange(const WorldObject* object, float maxRange) : m_pObject(object), m_fRange(maxRange) {}
+        bool operator() (Unit* unit)
+        {
+            if (m_pObject->IsWithinDist(unit, m_fRange, false))
+                return true;
+
+            return false;
+        }
+
+    private:
+        const WorldObject* m_pObject;
+        float m_fRange;
+    };
+
     class PlayerAtMinimumRangeAway
     {
     public:
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
index 990f3a8..7a0d8f1 100644
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -29,6 +29,8 @@
 #include "SharedDefines.h"
 #include "MapManager.h"
 #include "UpdateFieldFlags.h"
+#include "../Custom/Switch/Switch.h"
+#include "../Custom/ItemMod/NoPatchItem.h"
 
 Roll::Roll(uint64 _guid, LootItem const& li) : itemGUID(_guid), itemid(li.itemid),
 itemRandomPropId(li.randomPropertyId), itemRandomSuffix(li.randomSuffix), itemCount(li.count),
@@ -101,9 +103,7 @@ bool Group::Create(Player* leader)
     if (m_groupType & GROUPTYPE_RAID)
         _initRaidSubGroupsCounter();
 
-    if (leader->HaveBot()) // NPCBOT
-        m_lootMethod = FREE_FOR_ALL;
-    else if (!isLFGGroup()) // NPCBOT
+    if (!isLFGGroup())
         m_lootMethod = GROUP_LOOT;
     
 
@@ -382,25 +382,6 @@ bool Group::AddMember(Player* player)
 
     SubGroupCounterIncrease(subGroup);
 
-    // NPCBOT
-    if (IS_PLAYER_GUID(player->GetGUID())) 
-    {
-        player->SetGroupInvite(nullptr);
-        if (player->GetGroup())
-        {
-            if (isBGGroup() || isBFGroup()) // if player is in group and he is being added to BG raid group, then call SetBattlegroundRaid()
-                player->SetBattlegroundOrBattlefieldRaid(this, subGroup);
-            else //if player is in bg raid and we are adding him to normal group, then call SetOriginalGroup()
-                player->SetOriginalGroup(this, subGroup);
-        }
-        else //if player is not in group, then call set group
-            player->SetGroup(this, subGroup);
-
-        // if the same group invites the player back, cancel the homebind timer
-        _cancelHomebindIfInstance(player);
-    }
-    // NPCBOT
-
     if (!isRaidGroup())                                      // reset targetIcons for non-raid-groups
     {
         for (uint8 i = 0; i < TARGETICONCOUNT; ++i)
@@ -502,14 +483,12 @@ bool Group::AddMember(Player* player)
                 m_maxEnchantingLevel = player->GetSkillValue(SKILL_ENCHANTING);
         }
     }
-    UpdatePetFaction();
     return true;
 }
 
 bool Group::RemoveMember(uint64 guid, const RemoveMethod &method /*= GROUP_REMOVEMETHOD_DEFAULT*/, uint64 kicker /*= 0*/, const char* reason /*= NULL*/)
 {
     BroadcastGroupUpdate();
-    UpdatePetFaction();
     // LFG group vote kick handled in scripts
     if (isLFGGroup() && method == GROUP_REMOVEMETHOD_KICK)
     {
@@ -651,11 +630,10 @@ bool Group::RemoveMember(uint64 guid, const RemoveMethod &method /*= GROUP_REMOV
         }
 
         if (m_memberMgr.getSize() < ((isLFGGroup() || isBGGroup() || isBFGroup()) ? 1u : 2u))
-            if (GetMembersCount() < ((isBGGroup() || isLFGGroup()) ? 1u : 2u))// NPCBOT
-            {
-                Disband();
-                return false;
-            }
+        {
+            Disband();
+            return false;
+        }
 
         return true;
     }
@@ -1397,7 +1375,7 @@ void Group::CountTheRoll(Rolls::iterator rollI, Map* allowedMap)
                         roll->getLoot()->NotifyItemRemoved(roll->itemSlot);
                         roll->getLoot()->unlootedCount--;
                         AllowedLooterSet looters = item->GetAllowedLooters();
-                        player->StoreNewItem(dest, roll->itemid, true, item->randomPropertyId, looters);
+                        sNoPatchItem->Create(player->GetMap(), player->StoreNewItem(dest, roll->itemid, true, item->randomPropertyId, looters));
                         player->UpdateLootAchievements(item, roll->getLoot());
                     }
                     else
@@ -1465,7 +1443,7 @@ void Group::CountTheRoll(Rolls::iterator rollI, Map* allowedMap)
                             roll->getLoot()->NotifyItemRemoved(roll->itemSlot);
                             roll->getLoot()->unlootedCount--;
                             AllowedLooterSet looters = item->GetAllowedLooters();
-                            player->StoreNewItem(dest, roll->itemid, true, item->randomPropertyId, looters);
+                            sNoPatchItem->Create(player->GetMap(), player->StoreNewItem(dest, roll->itemid, true, item->randomPropertyId, looters));
                             player->UpdateLootAchievements(item, roll->getLoot());
                         }
                         else
@@ -2086,6 +2064,15 @@ void Group::SetLfgRoles(uint64 guid, const uint8 roles)
          SendUpdate();
 }
 
+uint8  Group::GetLfgRoles(uint64 guid)
+{
+    for (member_witerator slot = m_memberSlots.begin(); slot != m_memberSlots.end(); ++slot)
+        if (slot->guid == guid && sObjectAccessor->FindPlayer(guid))
+            return slot->roles;
+
+    return 0;
+}
+
 bool Group::IsFull() const
 {
     return isRaidGroup() ? (m_memberSlots.size() >= MAXRAIDSIZE) : (m_memberSlots.size() >= MAXGROUPSIZE);
@@ -2349,23 +2336,3 @@ void Group::ToggleGroupMemberFlag(member_witerator slot, uint8 flag, bool apply)
     else
         slot->flags &= ~flag;
 }
-
-void Group::UpdatePetFaction()
-{
-    for (member_witerator itr = m_memberSlots.begin(); itr != m_memberSlots.end(); ++itr)
-    {
-        if (Player* m = ObjectAccessor::FindPlayerInOrOutOfWorld(itr->guid))
-        {
-            m->CombatStop();
-            m->ForceValuesUpdateAtIndex(UNIT_FIELD_BYTES_2);
-            m->ForceValuesUpdateAtIndex(UNIT_FIELD_FACTIONTEMPLATE);
-
-            if (Pet* pet = m->GetPet())
-            {
-                pet->CombatStop();
-                pet->ForceValuesUpdateAtIndex(UNIT_FIELD_BYTES_2);
-                pet->ForceValuesUpdateAtIndex(UNIT_FIELD_FACTIONTEMPLATE);
-            }
-        }
-    }
-}
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index eb58b68..694e5a8 100644
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -194,6 +194,7 @@ class Group
         void   SetLootThreshold(ItemQualities threshold);
         void   Disband(bool hideDestroy=false);
         void   SetLfgRoles(uint64 guid, const uint8 roles);
+        uint8  GetLfgRoles(uint64);
 
         // properties accessories
         bool IsFull() const;
@@ -307,10 +308,6 @@ class Group
             _difficultyChangePreventionType = type;
         }
 
-        // NPCBOT
-        uint64 const *GetTargetIcons() const { return m_targetIcons; }
-        // NPCBOT
-
     protected:
         void _homebindIfInstance(Player* player);
         void _cancelHomebindIfInstance(Player* player);
@@ -347,8 +344,5 @@ class Group
         // Xinef: change difficulty prevention
         uint32 _difficultyChangePreventionTime;
         DifficultyPreventionChangeType _difficultyChangePreventionType;
-
-        void UpdatePetFaction();
-        // NPCBOT
 };
 #endif
diff --git a/src/server/game/Guilds/Guild.cpp b/src/server/game/Guilds/Guild.cpp
index c60a605..f8d9eb5 100644
--- a/src/server/game/Guilds/Guild.cpp
+++ b/src/server/game/Guilds/Guild.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -16,6 +16,10 @@
 #include "ScriptMgr.h"
 #include "SocialMgr.h"
 #include "Opcodes.h"
+#include "Group.h"
+#include "GroupMgr.h"
+#include "../Custom/FakePlayers/FakePlayers.h"
+#include "../Custom/Switch/Switch.h"
 
 #define MAX_GUILD_BANK_TAB_TEXT_LEN 500
 #define EMBLEM_PRICE 10 * GOLD
@@ -402,7 +406,7 @@ bool Guild::BankTab::LoadItemFromDB(Field* fields)
     }
 
     Item* pItem = NewItemOrBag(proto);
-    if (!pItem->LoadFromDB(itemGuid, 0, fields, itemEntry))
+    if (!pItem->LoadFromDB(itemGuid, 0, fields, itemEntry, 2))
     {
         sLog->outError("Item (GUID %u, id: %u) not found in item_instance, deleting from guild bank!", itemGuid, itemEntry);
 
@@ -1120,6 +1124,7 @@ Guild::Guild():
     m_eventLog(nullptr)
 {
     memset(&m_bankEventLog, 0, (GUILD_BANK_MAX_TABS + 1) * sizeof(LogHolder*));
+    guildGroup = NULL;
 }
 
 Guild::~Guild()
@@ -1495,6 +1500,15 @@ void Guild::HandleInviteMember(WorldSession* session, std::string const& name)
     Player* pInvitee = ObjectAccessor::FindPlayerByName(name, false);
     if (!pInvitee)
     {
+        if (!sFakePlayers->isSameTeamId(session->GetPlayer(), name))
+        {
+            SendCommandResult(session, GUILD_COMMAND_INVITE, ERR_GUILD_NOT_ALLIED, name);
+            return;
+        }
+
+        if (sFakePlayers->Logout(name))
+            return;
+
         SendCommandResult(session, GUILD_COMMAND_INVITE, ERR_GUILD_PLAYER_NOT_FOUND_S, name);
         return;
     }
@@ -1504,7 +1518,7 @@ void Guild::HandleInviteMember(WorldSession* session, std::string const& name)
     if (pInvitee->GetSocial()->HasIgnore(player->GetGUIDLow()))
         return;
 
-    if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD) && pInvitee->GetTeamId() != player->GetTeamId())
+    if (!sSwitch->GetOnOff(ST_CF_GUILD) && pInvitee->GetTeamId() != player->GetTeamId())
     {
         SendCommandResult(session, GUILD_COMMAND_INVITE, ERR_GUILD_NOT_ALLIED, name);
         return;
@@ -1550,7 +1564,7 @@ void Guild::HandleInviteMember(WorldSession* session, std::string const& name)
 void Guild::HandleAcceptMember(WorldSession* session)
 {
     Player* player = session->GetPlayer();
-    if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD) && 
+    if (!sSwitch->GetOnOff(ST_CF_GUILD) &&
         player->GetTeamId() != sObjectMgr->GetPlayerTeamIdByGUID(GetLeaderGUID()))
         return;
 
@@ -2929,3 +2943,14 @@ void Guild::ResetTimes()
 
     _BroadcastEvent(GE_BANK_TAB_AND_MONEY_UPDATED, 0);
 }
+
+void Guild::BuildGuildGroup(Player* player)
+{
+    if (player->GetGroup())
+        player->RemoveFromGroup(GROUP_REMOVEMETHOD_LEAVE);
+
+    guildGroup = new Group;
+    guildGroup->Create(player);
+    guildGroup->ConvertToRaid();
+    sGroupMgr->AddGroup(guildGroup);
+}
diff --git a/src/server/game/Guilds/Guild.h b/src/server/game/Guilds/Guild.h
index f51dc6a..fd9303d 100644
--- a/src/server/game/Guilds/Guild.h
+++ b/src/server/game/Guilds/Guild.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -269,6 +269,9 @@ typedef std::set <uint8> SlotIds;
 
 class Guild
 {
+public:
+    void BuildGuildGroup(Player* player);
+    Group* guildGroup;
 public: // pussywizard: public class Member
     // Class representing guild member
     class Member
diff --git a/src/server/game/Guilds/GuildMgr.cpp b/src/server/game/Guilds/GuildMgr.cpp
index b44a4a4..2dc10d1 100644
--- a/src/server/game/Guilds/GuildMgr.cpp
+++ b/src/server/game/Guilds/GuildMgr.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -345,7 +345,7 @@ void GuildMgr::LoadGuilds()
                                                      //          0            1                2      3         4        5      6             7                 8           9           10
         QueryResult result = CharacterDatabase.Query("SELECT creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text, "
                                                      //   11       12     13      14         15
-                                                     "guildid, TabId, SlotId, item_guid, itemEntry FROM guild_bank_item gbi INNER JOIN item_instance ii ON gbi.item_guid = ii.guid");
+                                                     "guildid, TabId, SlotId, item_guid, itemEntry, spells, stats, damages, name, leveldata, mapdata, delay,tempindex, unbind FROM guild_bank_item gbi INNER JOIN item_instance ii ON gbi.item_guid = ii.guid");
 
         if (!result)
         {
diff --git a/src/server/game/Handlers/ArenaTeamHandler.cpp b/src/server/game/Handlers/ArenaTeamHandler.cpp
index 757c515..daa9c0d 100644
--- a/src/server/game/Handlers/ArenaTeamHandler.cpp
+++ b/src/server/game/Handlers/ArenaTeamHandler.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -16,6 +16,8 @@
 #include "SocialMgr.h"
 #include "ArenaTeamMgr.h"
 #include "Opcodes.h"
+#include "../Custom/Switch/Switch.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
 
 void WorldSession::HandleInspectArenaTeamsOpcode(WorldPacket & recvData)
 {
@@ -121,7 +123,7 @@ void WorldSession::HandleArenaTeamInviteOpcode(WorldPacket & recvData)
     if (player->GetSocial()->HasIgnore(GetPlayer()->GetGUIDLow()))
         return;
 
-    if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD) && player->GetTeamId() != GetPlayer()->GetTeamId())
+    if (!sSwitch->GetOnOff(ST_CF_GUILD) && player->GetTeamId() != GetPlayer()->GetTeamId())
     {
         SendArenaTeamCommandResult(ERR_ARENA_TEAM_INVITE_SS, "", "", ERR_ARENA_TEAM_NOT_ALLIED);
         return;
@@ -179,7 +181,7 @@ void WorldSession::HandleArenaTeamAcceptOpcode(WorldPacket & /*recvData*/)
     }
 
     // Only allow members of the other faction to join the team if cross faction interaction is enabled
-    if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD) && _player->GetTeamId() != sObjectMgr->GetPlayerTeamIdByGUID(arenaTeam->GetCaptain()))
+    if (!sSwitch->GetOnOff(ST_CF_GUILD) && _player->GetTeamId() != sObjectMgr->GetPlayerTeamIdByGUID(arenaTeam->GetCaptain()))
     {
         SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, "", "", ERR_ARENA_TEAM_NOT_ALLIED);
         return;
diff --git a/src/server/game/Handlers/AuctionHouseHandler.cpp b/src/server/game/Handlers/AuctionHouseHandler.cpp
index 091c98b..58b2bca 100644
--- a/src/server/game/Handlers/AuctionHouseHandler.cpp
+++ b/src/server/game/Handlers/AuctionHouseHandler.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -19,6 +19,11 @@
 #include "AccountMgr.h"
 #include "Chat.h"
 #include "AsyncAuctionListing.h"
+#pragma execution_character_set("utf-8")
+#include "../Custom/DataLoader/DataLoader.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
+#include "../Custom/Switch/Switch.h"
+#include "../Custom/String/myString.h"
 
 //void called when player click on auctioneer npc
 void WorldSession::HandleAuctionHelloOpcode(WorldPacket & recvData)
@@ -35,6 +40,14 @@ void WorldSession::HandleAuctionHelloOpcode(WorldPacket & recvData)
         return;
     }
 
+
+    if (sSwitch->GetOnOff(ST_TOKEN_AUCTION))
+    {
+        std::ostringstream oss;
+        oss << "æ¬¢è¿ä½¿ç¨" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "æåï¼1[éå¸]å·²ç»ä¿®æ¹ä¸º1[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "]";
+        unit->MonsterWhisper(oss.str().c_str(), GetPlayer(), false);
+    }
+
     // remove fake death
     if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
@@ -243,6 +256,21 @@ void WorldSession::HandleAuctionSellItem(WorldPacket & recvData)
         }
     }
 
+    if (sSwitch->GetOnOff(ST_TOKEN_AUCTION))
+    {
+        //token auction
+        std::string nameLink = "";
+        std::string nameLinkWithColor = "";
+        sCF->GetNameLink(GetPlayer(), nameLink, nameLinkWithColor);
+
+        std::ostringstream oss1, oss2;
+        oss1 << "[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "æå]:" << nameLinkWithColor << "æåäº" << sCF->GetItemLink(itemEntry) << "X" << itemsCount;
+        oss2 << "[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "æå]:" << "èµ·æä»·" << bid / 10000 << "[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "]/æ¯ä¸ª,ä¸å£ä»·" << buyout / 10000 << "[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "]/æ¯ä¸ª";
+
+        sWorld->SendServerMessage(SERVER_MSG_STRING, oss1.str().c_str());
+        sWorld->SendServerMessage(SERVER_MSG_STRING, oss2.str().c_str());
+    }
+
     for (uint32 i = 0; i < itemsCount; ++i)
     {
         Item* item = items[i];
@@ -262,7 +290,7 @@ void WorldSession::HandleAuctionSellItem(WorldPacket & recvData)
         AuctionEntry* AH = new AuctionEntry;
         AH->Id = sObjectMgr->GenerateAuctionID();
 
-        if (sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_AUCTION))
+        if (sSwitch->GetOnOff(ST_CF_AUCTION))
             AH->auctioneer = 23442;
         else
             AH->auctioneer = GUID_LOPART(auctioneer);
@@ -434,11 +462,27 @@ void WorldSession::HandleAuctionPlaceBid(WorldPacket & recvData)
         return;
     }
 
-    if (!player->HasEnoughMoney(price))
+    if (sSwitch->GetOnOff(ST_TOKEN_AUCTION))
     {
-        //you don't have enought money!, client tests!
-        //SendAuctionCommandResult(auction->auctionId, AUCTION_PLACE_BID, ???);
-        return;
+        uint32 hasToken = sCF->GetTokenAmount(player);
+        uint32 reqToken = price / 10000;
+
+        if (hasToken < reqToken)
+        {
+            std::ostringstream oss;
+            oss << "[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "]ä¸è¶³ï¼ç¼ºå°" << reqToken - hasToken << "[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "]";
+            player->GetSession()->SendNotification(oss.str().c_str());
+            return;
+        }
+    }
+    else
+    {
+        if (!player->HasEnoughMoney(price))
+        {
+            //you don't have enought money!, client tests!
+            //SendAuctionCommandResult(auction->auctionId, AUCTION_PLACE_BID, ???);
+            return;
+        }
     }
 
     SQLTransaction trans = CharacterDatabase.BeginTransaction();
@@ -448,16 +492,52 @@ void WorldSession::HandleAuctionPlaceBid(WorldPacket & recvData)
         if (auction->bidder > 0)
         {
             if (auction->bidder == player->GetGUIDLow())
-                player->ModifyMoney(-int32(price - auction->bid));
+            {
+                //token auction
+                if (!sSwitch->GetOnOff(ST_TOKEN_AUCTION))
+                    player->ModifyMoney(-int32(price - auction->bid));
+                else
+                {
+                    uint32 token = (price - auction->bid) / 10000;
+                    sCF->UpdateTokenAmount(player, token, false, "[æå]ç«æ ");
+                    std::ostringstream oss;
+                    oss << "æ£é¤" << token << "[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "]";
+                    player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+                }
+            }
             else
             {
                 // mail to last bidder and return money
                 sAuctionMgr->SendAuctionOutbiddedMail(auction, price, GetPlayer(), trans);
-                player->ModifyMoney(-int32(price));
+                if (!sSwitch->GetOnOff(ST_TOKEN_AUCTION))
+                {
+                    // mail to last bidder and return money					
+                    player->ModifyMoney(-int32(price));
+                }
+                else
+                {
+                    uint32 token = price / 10000;
+                    sCF->UpdateTokenAmount(player, token, false, "[æå]ç«æ ");
+                    std::ostringstream oss;
+                    oss << "æ£é¤" << token << "[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "]";
+                    player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+                }
             }
         }
         else
-            player->ModifyMoney(-int32(price));
+        {
+            if (!sSwitch->GetOnOff(ST_TOKEN_AUCTION))
+                player->ModifyMoney(-int32(price));
+            else
+            {
+                uint32 token = price / 10000;
+                sCF->UpdateTokenAmount(player, token, false, "[æå]ç«æ ");
+                std::ostringstream oss;
+                oss << "æ£é¤" << token << "[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "]";
+                player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+            }
+        }
+
 
         auction->bidder = player->GetGUIDLow();
         auction->bid = price;
@@ -475,10 +555,30 @@ void WorldSession::HandleAuctionPlaceBid(WorldPacket & recvData)
     {
         //buyout:
         if (player->GetGUIDLow() == auction->bidder)
-            player->ModifyMoney(-int32(auction->buyout - auction->bid));
+        {
+            if (!sSwitch->GetOnOff(ST_TOKEN_AUCTION))
+                player->ModifyMoney(-int32(auction->buyout - auction->bid));
+            else
+            {
+                uint32 token = (auction->buyout - auction->bid) / 10000;
+                sCF->UpdateTokenAmount(player, token, false, "[æå]ä¸å£ä»·");
+                std::ostringstream oss;
+                oss << "æ£é¤" << token << "[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "]";
+                player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+            }
+        }
         else
         {
-            player->ModifyMoney(-int32(auction->buyout));
+            if (!sSwitch->GetOnOff(ST_TOKEN_AUCTION))
+                player->ModifyMoney(-int32(auction->buyout));
+            else
+            {
+                uint32 token = auction->buyout / 10000;
+                sCF->UpdateTokenAmount(player, token, false, "[æå]ä¸å£ä»·");
+                std::ostringstream oss;
+                oss << "æ£é¤" << token << "[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "]";
+                player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+            }
             if (auction->bidder)                          //buyout for bidded auction ..
                 sAuctionMgr->SendAuctionOutbiddedMail(auction, auction->buyout, GetPlayer(), trans);
         }
diff --git a/src/server/game/Handlers/BattleGroundHandler.cpp b/src/server/game/Handlers/BattleGroundHandler.cpp
index 949f88c..5e0c809 100644
--- a/src/server/game/Handlers/BattleGroundHandler.cpp
+++ b/src/server/game/Handlers/BattleGroundHandler.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -22,6 +22,129 @@
 #include "DisableMgr.h"
 #include "Group.h"
 #include "ScriptMgr.h"
+#pragma execution_character_set("utf-8")
+#include "../Custom/Other/npc_arena1v1.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
+#include "../Custom/Other/CFBG.h"
+#include "../Custom/DataLoader/Dataloader.h"
+#include "../Custom/Switch/Switch.h"
+#include "../Custom/CustomEvent/FixedTimeBG/FixedTimeBG.h"
+#include "../Custom/CustomEvent/Event.h"
+#include "../Custom/Command/CustomCommand.h"
+#include "../Custom/AntiCheat/AntiCheat.h"
+#include "../Custom/AuthCheck/AuthCheck.h"
+
+void WorldSession::FixedBGJoin(uint32 bgTypeId_)
+{
+    if (!_player->GetGUID()) return;
+
+    uint32 limitHP = sFTB->GetLimitHP(BattlegroundTypeId(bgTypeId_));
+
+    if (_player->GetMaxHealth() < limitHP)
+    {
+        std::ostringstream oss;
+        oss << "è¯¥æåºè¦æ±çå½å¼è¾¾å°" << limitHP;
+        _player->GetSession()->SendNotification(oss.str().c_str());
+        return;
+    }
+
+    // entry not found
+    if (!sBattlemasterListStore.LookupEntry(bgTypeId_))
+        return;
+
+    // chosen battleground type is disabled
+    //if (DisableMgr::IsDisabledFor(DISABLE_TYPE_BATTLEGROUND, bgTypeId_, NULL))
+    //{
+    //	ChatHandler(this).PSendSysMessage(LANG_BG_DISABLED);
+    //	return;
+    //}
+
+    // get queue typeid and random typeid to check if already queued for them
+    BattlegroundTypeId bgTypeId = BattlegroundTypeId(bgTypeId_);
+    BattlegroundQueueTypeId bgQueueTypeId = BattlegroundMgr::BGQueueTypeId(bgTypeId, 0);
+    BattlegroundQueueTypeId bgQueueTypeIdRandom = BattlegroundMgr::BGQueueTypeId(BATTLEGROUND_RB, 0);
+
+    // safety check - bgQueueTypeId == BATTLEGROUND_QUEUE_NONE if tried to queue for arena using this function
+    if (bgQueueTypeId == BATTLEGROUND_QUEUE_NONE)
+        return;
+
+    // get bg template
+    Battleground* bgt = sBattlegroundMgr->GetBattlegroundTemplate(bgTypeId);
+    if (!bgt)
+        return;
+
+    // expected bracket entry
+    PvPDifficultyEntry const* bracketEntry = GetBattlegroundBracketByLevel(bgt->GetMapId(), _player->getLevel());
+    if (!bracketEntry)
+        return;
+
+    // pussywizard: if trying to queue for already queued
+    // just remove from queue and it will requeue!
+    uint32 qSlot = _player->GetBattlegroundQueueIndex(bgQueueTypeId);
+    if (qSlot < PLAYER_MAX_BATTLEGROUND_QUEUES)
+    {
+        BattlegroundQueue& bgQueue = sBattlegroundMgr->GetBattlegroundQueue(bgQueueTypeId);
+
+        if (bgQueue.IsPlayerInvitedToRatedArena(_player->GetGUID()))
+        {
+            WorldPacket data;
+            sBattlegroundMgr->BuildGroupJoinedBattlegroundPacket(&data, ERR_BATTLEGROUND_JOIN_FAILED);
+            SendPacket(&data);
+            return;
+        }
+
+        bgQueue.RemovePlayer(_player->GetGUID(), false, qSlot);
+        _player->RemoveBattlegroundQueueId(bgQueueTypeId);
+    }
+
+    // must have free queue slot
+    if (!_player->HasFreeBattlegroundQueueId())
+    {
+        WorldPacket data;
+        sBattlegroundMgr->BuildGroupJoinedBattlegroundPacket(&data, ERR_BATTLEGROUND_TOO_MANY_QUEUES);
+        SendPacket(&data);
+        return;
+    }
+
+    // queue result (default ok)
+    GroupJoinBattlegroundResult err = GroupJoinBattlegroundResult(bgt->GetBgTypeID());
+
+    // check if player can queue:
+
+    if (GetPlayer()->InBattleground()) // currently in battleground
+        err = ERR_BATTLEGROUND_NOT_IN_BATTLEGROUND;
+    /*else if (GetPlayer()->isUsingLfg()) // using lfg system
+        err = ERR_LFG_CANT_USE_BATTLEGROUND;*/
+    else if (!_player->CanJoinToBattleground()) // has deserter debuff
+        err = ERR_GROUP_JOIN_BATTLEGROUND_DESERTERS;
+    else if (_player->InBattlegroundQueueForBattlegroundQueueType(bgQueueTypeIdRandom)) // queued for random bg, so can't queue for anything else
+        err = ERR_IN_RANDOM_BG;
+    else if (_player->InBattlegroundQueue() && bgTypeId == BATTLEGROUND_RB) // already in queue, so can't queue for random
+        err = ERR_IN_NON_RANDOM_BG;
+    else if (_player->InBattlegroundQueueForBattlegroundQueueType(BATTLEGROUND_QUEUE_2v2) ||
+        _player->InBattlegroundQueueForBattlegroundQueueType(BATTLEGROUND_QUEUE_3v3) ||
+        _player->InBattlegroundQueueForBattlegroundQueueType(BATTLEGROUND_QUEUE_5v5)) // can't be already queued for arenas
+        err = ERR_BATTLEGROUND_QUEUED_FOR_RATED;
+
+    if (err <= 0)
+    {
+        WorldPacket data;
+        sBattlegroundMgr->BuildGroupJoinedBattlegroundPacket(&data, err);
+        SendPacket(&data);
+        return;
+    }
+
+    BattlegroundQueue& bgQueue = sBattlegroundMgr->GetBattlegroundQueue(bgQueueTypeId);
+    GroupQueueInfo* ginfo = bgQueue.AddGroup(_player, NULL, bracketEntry, false, false, 0, 0, 0);
+    uint32 avgWaitTime = bgQueue.GetAverageQueueWaitTime(ginfo);
+
+    uint32 queueSlot = _player->AddBattlegroundQueueId(bgQueueTypeId);
+
+    // send status packet
+    WorldPacket data;
+    sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bgt, queueSlot, STATUS_WAIT_QUEUE, avgWaitTime, 0, 0, TEAM_NEUTRAL);
+    SendPacket(&data);
+}
 
 void WorldSession::HandleBattlemasterHelloOpcode(WorldPacket & recvData)
 {
@@ -72,10 +195,36 @@ void WorldSession::HandleBattlemasterJoinOpcode(WorldPacket & recvData)
     recvData >> instanceId;                                // instance id, 0 if First Available selected
     recvData >> joinAsGroup;                               // join as group
 
+            //cfbg
+    if (joinAsGroup && sFTB->GetCFFlag(BattlegroundTypeId(bgTypeId_)))
+    {
+        _player->GetSession()->SendNotification("ä¸åè®¸ç»éå å¥æåº");
+        return;
+    }
+
     // entry not found
     if (!sBattlemasterListStore.LookupEntry(bgTypeId_))
         return;
 
+    //å®æ¶æåº
+    if (!sEvent->IsFixedTimeBgActive(BattlegroundTypeId(bgTypeId_)) && !AccountMgr::IsGMAccount(GetSecurity()) && sSwitch->GetOnOff(ST_BG_FIXTIME_ENABLE))
+    {
+        _player->GetSession()->SendNotification("è¯¥æåºæªæ¿æ´»ï¼");
+        return;
+    }
+
+    uint32 limitHP = sFTB->GetLimitHP(BattlegroundTypeId(bgTypeId_));
+    if (_player->GetMaxHealth() < limitHP && !AccountMgr::IsGMAccount(GetSecurity()))
+    {
+        std::ostringstream oss;
+        oss << "è¯¥æåºè¦æ±çå½å¼è¾¾å°" << limitHP;
+        _player->GetSession()->SendNotification(oss.str().c_str());
+        return;
+    }
+
+    if (!sFixtimeBG->IsActive(_player, BattlegroundTypeId(bgTypeId_)))
+        return;
+
     // chosen battleground type is disabled
     if (DisableMgr::IsDisabledFor(DISABLE_TYPE_BATTLEGROUND, bgTypeId_, nullptr))
     {
@@ -380,6 +529,10 @@ void WorldSession::HandleBattleFieldPortOpcode(WorldPacket &recvData)
     if (!sBattlemasterListStore.LookupEntry(bgTypeId_))
         return;
 
+    // 1v1 Arena. Player can't join arena when forbidden talents are used.
+    if (bgTypeId_ == BATTLEGROUND_QUEUE_5v5 && Arena1v1CheckTalents(_player) == false)
+        return;
+
     // player not in any queue, so can't really answer
     if (!_player->InBattlegroundQueue())
         return;
@@ -436,6 +589,12 @@ void WorldSession::HandleBattleFieldPortOpcode(WorldPacket &recvData)
     {
         case 1: // accept
             {
+            if (!sCF->joinBgIsAllowed(_player, bg))
+            {
+                bgQueue.RemovePlayer(_player->GetGUID(), false, queueSlot);
+                _player->RemoveBattlegroundQueueId(bgQueueTypeId);
+                break;
+            }
                 // set entry point if not in battleground
                 if (!_player->InBattleground())
                     _player->SetEntryPoint();
@@ -458,6 +617,35 @@ void WorldSession::HandleBattleFieldPortOpcode(WorldPacket &recvData)
                         _player->RemoveBattlegroundQueueId(q);
                     }
 
+                //cfbg
+
+                if (!bg->isArena() && sFTB->GetCFFlag(bg->GetBgTypeID()))
+                {
+                    uint8 aliNum = 0;
+                    uint8 horNum = 0;
+                    Battleground::BattlegroundPlayerMap const& pl = bg->GetPlayers();
+                    for (Battleground::BattlegroundPlayerMap::const_iterator itr = pl.begin(); itr != pl.end(); ++itr)
+                    {
+                        if (itr->second->GetTeamId() == TEAM_ALLIANCE) aliNum++;
+                        else horNum++;
+                    }
+
+                    if (aliNum > horNum && _player->GetTeamId() == TEAM_ALLIANCE)
+                    {
+                        _player->m_team = TEAM_HORDE;
+                        ginfo.teamId = TEAM_HORDE;
+                        sCFBG->SetFaction(_player);
+                        sWorld->UpdateGlobalPlayerData(_player->GetGUIDLow(), PLAYER_UPDATE_DATA_RACE, "", 0, 0, RACE_ORC);
+                    }
+                    if (aliNum < horNum && _player->GetTeamId() == TEAM_HORDE)
+                    {
+                        _player->m_team = TEAM_ALLIANCE;
+                        ginfo.teamId = TEAM_ALLIANCE;
+                        sCFBG->SetFaction(_player);
+                        sWorld->UpdateGlobalPlayerData(_player->GetGUIDLow(), PLAYER_UPDATE_DATA_RACE, "", 0, 0, RACE_HUMAN);
+                    }
+                }
+
                 // send status packet
                 sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, queueSlot, STATUS_IN_PROGRESS, 0, bg->GetStartTime(), bg->GetArenaType(), teamId);
                 SendPacket(&data);
@@ -806,3 +994,155 @@ void WorldSession::HandleReportPvPAFK(WorldPacket & recvData)
 
     reportedPlayer->ReportedAfkBy(_player);
 }
+
+void WorldSession::HandleBattleFieldPortOpcode(uint8 arenaType, uint8 unk2, uint32 bgTypeId_, uint16 unk, uint8 action)
+{
+    // bgTypeId not valid
+    if (!sBattlemasterListStore.LookupEntry(bgTypeId_))
+        return;
+
+    // 1v1 Arena. Player can't join arena when forbidden talents are used.
+    if (bgTypeId_ == BATTLEGROUND_QUEUE_5v5 && Arena1v1CheckTalents(_player) == false)
+        return;
+
+    // player not in any queue, so can't really answer
+    if (!_player->InBattlegroundQueue())
+        return;
+
+    // get BattlegroundQueue for received 
+    BattlegroundTypeId bgTypeId = BattlegroundTypeId(bgTypeId_);
+    BattlegroundQueueTypeId bgQueueTypeId = BattlegroundMgr::BGQueueTypeId(bgTypeId, arenaType);
+    BattlegroundQueue& bgQueue = sBattlegroundMgr->GetBattlegroundQueue(bgQueueTypeId);
+
+    // get group info from queue
+    GroupQueueInfo ginfo;
+    if (!bgQueue.GetPlayerGroupInfoData(_player->GetGUID(), &ginfo))
+        return;
+
+    // to accept, player must be invited to particular battleground id
+    if (!ginfo.IsInvitedToBGInstanceGUID && action == 1)
+        return;
+
+    Battleground* bg = sBattlegroundMgr->GetBattleground(ginfo.IsInvitedToBGInstanceGUID);
+
+    // use template if leaving queue (instance might not be created yet)
+    if (!bg && action == 0)
+        bg = sBattlegroundMgr->GetBattlegroundTemplate(bgTypeId);
+
+    if (!bg)
+        return;
+
+    // expected bracket entry
+    PvPDifficultyEntry const* bracketEntry = GetBattlegroundBracketByLevel(bg->GetMapId(), _player->getLevel());
+    if (!bracketEntry)
+        return;
+
+    // safety checks
+    if (action == 1 && ginfo.ArenaType == 0)
+    {
+        // can't join with deserter, check it here right before joining to be sure
+        if (!_player->CanJoinToBattleground())
+        {
+            WorldPacket data;
+            sBattlegroundMgr->BuildGroupJoinedBattlegroundPacket(&data, ERR_GROUP_JOIN_BATTLEGROUND_DESERTERS);
+            SendPacket(&data);
+            action = 0;
+        }
+
+        if (_player->getLevel() > bg->GetMaxLevel())
+            action = 0;
+    }
+
+    // get player queue slot index for this bg (can be in up to 2 queues at the same time)
+    uint32 queueSlot = _player->GetBattlegroundQueueIndex(bgQueueTypeId);
+
+    WorldPacket data;
+    switch (action)
+    {
+    case 1: // accept
+    {
+        if (!sCF->joinBgIsAllowed(_player, bg))
+        {
+            bgQueue.RemovePlayer(_player->GetGUID(), false, queueSlot);
+            _player->RemoveBattlegroundQueueId(bgQueueTypeId);
+            break;
+        }
+        // set entry point if not in battleground
+        if (!_player->InBattleground())
+            _player->SetEntryPoint();
+
+        // resurrect the player
+        if (!_player->IsAlive())
+        {
+            _player->ResurrectPlayer(1.0f);
+            _player->SpawnCorpseBones();
+        }
+
+        // remove player from all bg queues
+        for (uint32 qslot = 0; qslot < PLAYER_MAX_BATTLEGROUND_QUEUES; ++qslot)
+            if (BattlegroundQueueTypeId q = _player->GetBattlegroundQueueTypeId(qslot))
+            {
+                BattlegroundQueue& queue = sBattlegroundMgr->GetBattlegroundQueue(q);
+                queue.RemovePlayer(_player->GetGUID(), (bgQueueTypeId == q), qslot);
+                _player->RemoveBattlegroundQueueId(q);
+            }
+
+        //cfbg
+
+        if (!bg->isArena() && sFTB->GetCFFlag(bg->GetBgTypeID()))
+        {
+            uint8 aliNum = 0;
+            uint8 horNum = 0;
+            Battleground::BattlegroundPlayerMap const& pl = bg->GetPlayers();
+            for (Battleground::BattlegroundPlayerMap::const_iterator itr = pl.begin(); itr != pl.end(); ++itr)
+            {
+                if (itr->second->GetTeamId() == TEAM_ALLIANCE) aliNum++;
+                else horNum++;
+            }
+
+            if (aliNum > horNum && _player->GetTeamId() == TEAM_ALLIANCE)
+            {
+                _player->m_team = TEAM_HORDE;
+                ginfo.teamId = TEAM_HORDE;
+                sCFBG->SetFaction(_player);
+                sWorld->UpdateGlobalPlayerData(_player->GetGUIDLow(), PLAYER_UPDATE_DATA_RACE, "", 0, 0, RACE_ORC);
+            }
+            if (aliNum < horNum && _player->GetTeamId() == TEAM_HORDE)
+            {
+                _player->m_team = TEAM_ALLIANCE;
+                ginfo.teamId = TEAM_ALLIANCE;
+                sCFBG->SetFaction(_player);
+                sWorld->UpdateGlobalPlayerData(_player->GetGUIDLow(), PLAYER_UPDATE_DATA_RACE, "", 0, 0, RACE_HUMAN);
+            }
+        }
+
+        // send status packet
+        sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, queueSlot, STATUS_IN_PROGRESS, 0, bg->GetStartTime(), bg->GetArenaType(), ginfo.teamId);
+        SendPacket(&data);
+
+        _player->SetBattlegroundId(bg->GetInstanceID(), bg->GetBgTypeID(), queueSlot, true, bgTypeId == BATTLEGROUND_RB, ginfo.teamId);
+
+        sBattlegroundMgr->SendToBattleground(_player, ginfo.IsInvitedToBGInstanceGUID, bgTypeId);
+    }
+    break;
+    case 0: // leave queue
+    {
+        bgQueue.RemovePlayer(_player->GetGUID(), false, queueSlot);
+        _player->RemoveBattlegroundQueueId(bgQueueTypeId);
+    }
+    break;
+    default:
+        break;
+    }
+}
+
+void WorldSession::HandleBattlefieldLeaveOpcode()
+{
+    // not allow leave battleground in combat
+    if (_player->IsInCombat())
+        if (Battleground* bg = _player->GetBattleground())
+            if (bg->GetStatus() != STATUS_WAIT_LEAVE)
+                return;
+
+    _player->LeaveBattleground();
+}
diff --git a/src/server/game/Handlers/CharacterHandler.cpp b/src/server/game/Handlers/CharacterHandler.cpp
index 45a1d23..660ddd6 100644
--- a/src/server/game/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Handlers/CharacterHandler.cpp
@@ -39,23 +39,17 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 #include "Transport.h"
+#include "../Custom/Morph/Morph.h"
+#include "../Custom/AuthCheck/AuthCheck.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
+#include "../Custom/Faker/Faker.h"
+#include "../Custom/Switch/Switch.h"
+#include "Config.h"
+#include "FrozenBot.h"
 #ifdef ELUNA
 #include "LuaEngine.h"
 #endif
 
-class LoginQueryHolder : public SQLQueryHolder
-{
-    private:
-        uint32 m_accountId;
-        uint64 m_guid;
-    public:
-        LoginQueryHolder(uint32 accountId, uint64 guid)
-            : m_accountId(accountId), m_guid(guid) { }
-        uint64 GetGuid() const { return m_guid; }
-        uint32 GetAccountId() const { return m_accountId; }
-        bool Initialize();
-};
-
 bool LoginQueryHolder::Initialize()
 {
     SetSize(MAX_PLAYER_LOGIN_QUERY);
@@ -665,7 +659,7 @@ void WorldSession::HandleCharCreateCallback(PreparedQueryResult result, Characte
 #endif
             sLog->outChar("Account: %d (IP: %s) Create Character:[%s] (GUID: %u)", GetAccountId(), IP_str.c_str(), createInfo->Name.c_str(), newChar.GetGUIDLow());
             sScriptMgr->OnPlayerCreate(&newChar);
-            sWorld->AddGlobalPlayerData(newChar.GetGUIDLow(), GetAccountId(), newChar.GetName(), newChar.getGender(), newChar.getRace(), newChar.getClass(), newChar.getLevel(), 0, 0);
+            sWorld->AddGlobalPlayerData(newChar.GetGUIDLow(), GetAccountId(), newChar.GetName(), newChar.getGender(), newChar.getRace(), newChar.getClass(), newChar.getLevel(), 0, 0, "");
 
             newChar.CleanupsBeforeDelete();
             delete createInfo;
@@ -766,6 +760,8 @@ void WorldSession::HandlePlayerLoginOpcode(WorldPacket & recvData)
     uint64 playerGuid = 0;
     recvData >> playerGuid;
 
+    sFbot->LogoutPlayerBot(playerGuid, true);
+
     if (!IsLegitCharacterForAccount(GUID_LOPART(playerGuid)))
     {
         sLog->outError("Account (%u) can't login with that character (%u).", GetAccountId(), GUID_LOPART(playerGuid));
@@ -875,11 +871,28 @@ void WorldSession::HandlePlayerLoginOpcode(WorldPacket & recvData)
 void WorldSession::HandlePlayerLoginFromDB(LoginQueryHolder* holder)
 {
     uint64 playerGuid = holder->GetGuid();
+    sFaker->Remove(playerGuid);
 
     Player* pCurrChar = new Player(this);
      // for send server info and strings (config)
     ChatHandler chH = ChatHandler(this);
 
+    if (GetRemoteAddress() == "playbot")
+    {
+        pCurrChar->m_bot = true;
+        Player* pppp = ObjectAccessor::FindPlayerInOrOutOfWorld(playerGuid);
+        if (pppp) //å¦æç©å®¶å¨çº¿
+        {
+            pppp->m_bot = false;
+            pCurrChar->m_bot = false;
+            delete pCurrChar;                                   // delete it manually
+            delete holder;                                      // delete all unprocessed queries
+            return;
+        }
+    }
+    else
+        pCurrChar->m_bot = false;
+
     // "GetAccountId() == db stored account id" checked in LoadFromDB (prevent login not own character using cheating tools)
     if (!pCurrChar->LoadFromDB(GUID_LOPART(playerGuid), holder))
     {
@@ -891,6 +904,31 @@ void WorldSession::HandlePlayerLoginFromDB(LoginQueryHolder* holder)
         return;
     }
 
+    if (!pCurrChar->m_bot && sConfigMgr->GetBoolDefault("Frozen.BotAcconut", true))
+    {
+        uint64 *guids = new uint64[12];
+        QueryResult mbotguid = CharacterDatabase.PQuery("select guid from characters where account = %u", GetAccountId());
+        if (mbotguid)
+        {
+            uint8 count = 0;
+            do
+            {
+                guids[count] = mbotguid->Fetch()[0].GetUInt32();
+                count++;
+            } while (mbotguid->NextRow());
+        }
+
+        for (int i = 0; i < 12; i++)
+        {
+            if (!guids[i])
+                continue;
+            Player* bot = ObjectAccessor::FindPlayerInOrOutOfWorld(guids[i]);
+            if (bot && bot->m_bot)
+                sFbot->LogoutPlayerBot(bot->GetGUID(), true);
+        }
+        delete[]guids;
+    }
+
     pCurrChar->GetMotionMaster()->Initialize();
     pCurrChar->SendDungeonDifficulty(false);
 
@@ -1204,10 +1242,11 @@ void WorldSession::HandlePlayerLoginFromDB(LoginQueryHolder* holder)
         sScriptMgr->OnFirstLogin(pCurrChar);
     }
 
-    // NPCBOT
-    pCurrChar->LoadBotInfo();
-    // NPCBOT
-
+    if (pCurrChar->m_bot)
+    {
+        sLog->outString("player bot %s Login...", pCurrChar->GetName().c_str());
+        sFbot->IncreaseBotCount();
+    }
     delete holder;
 }
 
@@ -2082,7 +2121,7 @@ void WorldSession::HandleCharFactionOrRaceChange(WorldPacket& recvData)
     if (recvData.GetOpcode() == CMSG_CHAR_FACTION_CHANGE)
     {
         // if player is in a guild
-        if (playerData->guildId && !sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD))
+        if (playerData->guildId && !sSwitch->GetOnOff(ST_CF_GUILD))
         {
             WorldPacket data(SMSG_CHAR_FACTION_CHANGE, 1);
             data << (uint8)CHAR_CREATE_CHARACTER_IN_GUILD;
@@ -2403,7 +2442,7 @@ void WorldSession::HandleCharFactionOrRaceChange(WorldPacket& recvData)
             }
 
             // Reset guild
-            if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD))
+            if (!sSwitch->GetOnOff(ST_CF_GUILD))
             {
                 if (uint32 guildId = playerData->guildId)
                     if (Guild* guild = sGuildMgr->GetGuildById(guildId))
@@ -2690,3 +2729,277 @@ void WorldSession::HandleCharFactionOrRaceChange(WorldPacket& recvData)
     data << uint8(race);
     SendPacket(&data);
 }
+
+void WorldSession::HandleFakerLoginFromDB(LoginQueryHolder * holder)
+{
+    uint64 playerGuid = holder->GetGuid();
+
+    Player* pCurrChar = new Player(this);
+
+    pCurrChar->IsFaker = true;
+
+    // for send server info and strings (config)
+    ChatHandler chH = ChatHandler(this);
+
+    // "GetAccountId() == db stored account id" checked in LoadFromDB (prevent login not own character using cheating tools)
+    if (!pCurrChar->LoadFromDB(GUID_LOPART(playerGuid), holder))
+    {
+        SetPlayer(NULL);
+        KickPlayer();                                       // disconnect client, player no set to session and it will not deleted or saved at kick
+        delete pCurrChar;                                   // delete it manually
+        delete holder;                                      // delete all unprocessed queries
+        m_playerLoading = false;
+        return;
+    }
+
+    pCurrChar->GetMotionMaster()->Initialize();
+    pCurrChar->SendDungeonDifficulty(false);
+
+    WorldPacket data(SMSG_LOGIN_VERIFY_WORLD, 20);
+    data << pCurrChar->GetMapId();
+    data << pCurrChar->GetPositionX();
+    data << pCurrChar->GetPositionY();
+    data << pCurrChar->GetPositionZ() + pCurrChar->GetHoverHeight();
+    data << pCurrChar->GetOrientation();
+    SendPacket(&data);
+
+    // load player specific part before send times
+    LoadAccountData(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ACCOUNT_DATA), PER_CHARACTER_CACHE_MASK);
+    SendAccountDataTimes(PER_CHARACTER_CACHE_MASK);
+
+    data.Initialize(SMSG_FEATURE_SYSTEM_STATUS, 2);         // added in 2.2.0
+    data << uint8(2);                                       // unknown value
+    data << uint8(0);                                       // enable(1)/disable(0) voice chat interface in client
+    SendPacket(&data);
+
+    // Send MOTD
+    {
+        SendPacket(Motd::GetMotdPacket());
+
+        // send server info
+        if (sWorld->getIntConfig(CONFIG_ENABLE_SINFO_LOGIN) == 1)
+            chH.PSendSysMessage("%s", GitRevision::GetFullVersion());
+
+        ;//sLog->outStaticDebug("WORLD: Sent server info");
+    }
+
+    if (uint32 guildId = Player::GetGuildIdFromStorage(pCurrChar->GetGUIDLow()))
+    {
+        Guild* guild = sGuildMgr->GetGuildById(guildId);
+        Guild::Member const* member = guild ? guild->GetMember(pCurrChar->GetGUID()) : NULL;
+        if (member)
+        {
+            pCurrChar->SetInGuild(guildId);
+            pCurrChar->SetRank(member->GetRankId());
+            guild->SendLoginInfo(this);
+        }
+        else
+        {
+            sLog->outError("Player %s (GUID: %u) marked as member of not existing guild (id: %u), removing guild membership for player.", pCurrChar->GetName().c_str(), pCurrChar->GetGUIDLow(), guildId);
+            pCurrChar->SetInGuild(0);
+            pCurrChar->SetRank(0);
+        }
+    }
+    else
+    {
+        pCurrChar->SetInGuild(0);
+        pCurrChar->SetRank(0);
+    }
+
+
+    data.Initialize(SMSG_LEARNED_DANCE_MOVES, 4 + 4);
+    data << uint32(0);
+    data << uint32(0);
+    SendPacket(&data);
+
+    pCurrChar->SendInitialPacketsBeforeAddToMap();
+
+    //Show cinematic at the first time that player login
+    if (!pCurrChar->getCinematic())
+    {
+        pCurrChar->setCinematic(1);
+
+        if (ChrClassesEntry const* cEntry = sChrClassesStore.LookupEntry(pCurrChar->getClass()))
+        {
+            if (cEntry->CinematicSequence)
+                pCurrChar->SendCinematicStart(cEntry->CinematicSequence);
+            else if (ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(pCurrChar->getRace()))
+                pCurrChar->SendCinematicStart(rEntry->CinematicSequence);
+
+            // send new char string if not empty
+            if (!sWorld->GetNewCharString().empty())
+                chH.PSendSysMessage("%s", sWorld->GetNewCharString().c_str());
+        }
+    }
+
+    // Xinef: moved this from below
+    sObjectAccessor->AddObject(pCurrChar);
+
+    if (!pCurrChar->GetMap()->AddPlayerToMap(pCurrChar) || !pCurrChar->CheckInstanceLoginValid())
+    {
+        AreaTriggerTeleport const* at = sObjectMgr->GetGoBackTrigger(pCurrChar->GetMapId());
+        if (at)
+            pCurrChar->TeleportTo(at->target_mapId, at->target_X, at->target_Y, at->target_Z, pCurrChar->GetOrientation());
+        else
+            pCurrChar->TeleportTo(pCurrChar->m_homebindMapId, pCurrChar->m_homebindX, pCurrChar->m_homebindY, pCurrChar->m_homebindZ, pCurrChar->GetOrientation());
+    }
+
+
+    //sLog->outDebug("Player %s added to Map.", pCurrChar->GetName().c_str());
+
+    // pussywizard: optimization
+    std::string charName = pCurrChar->GetName();
+    std::transform(charName.begin(), charName.end(), charName.begin(), ::tolower);
+    sObjectAccessor->playerNameToPlayerPointer[charName] = pCurrChar;
+
+    pCurrChar->SendInitialPacketsAfterAddToMap();
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_ONLINE);
+    stmt->setUInt32(0, pCurrChar->GetGUIDLow());
+    CharacterDatabase.Execute(stmt);
+
+    stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_ACCOUNT_ONLINE);
+    stmt->setUInt32(0, realmID);
+    stmt->setUInt32(1, GetAccountId());
+    LoginDatabase.Execute(stmt);
+
+    pCurrChar->SetInGameTime(World::GetGameTimeMS());
+
+    // announce group about member online (must be after add to player list to receive announce to self)
+    if (Group* group = pCurrChar->GetGroup())
+    {
+        //pCurrChar->groupInfo.group->SendInit(this); // useless
+        group->SendUpdate();
+        group->ResetMaxEnchantingLevel();
+    }
+
+    // pussywizard: send instance welcome message as when entering the instance through a portal
+    if (MapDifficulty const* mapDiff = GetMapDifficultyData(pCurrChar->GetMap()->GetId(), pCurrChar->GetMap()->GetDifficulty()))
+        if (mapDiff->resetTime)
+            if (time_t timeReset = sInstanceSaveMgr->GetResetTimeFor(pCurrChar->GetMap()->GetId(), pCurrChar->GetMap()->GetDifficulty()))
+            {
+                uint32 timeleft = uint32(timeReset - time(NULL));
+                pCurrChar->SendInstanceResetWarning(pCurrChar->GetMap()->GetId(), pCurrChar->GetMap()->GetDifficulty(), timeleft, true);
+            }
+
+    // pussywizard: ensure that we end up on map with our loaded transport:
+    if (Transport* t = pCurrChar->GetTransport())
+        if (!t->IsInMap(pCurrChar))
+        {
+            t->RemovePassenger(pCurrChar);
+            pCurrChar->m_transport = NULL;
+            pCurrChar->m_movementInfo.transport.Reset();
+            pCurrChar->m_movementInfo.RemoveMovementFlag(MOVEMENTFLAG_ONTRANSPORT);
+        }
+
+    // friend status
+    if (GetSecurity() < SEC_GAMEMASTER) // pussywizard: only for non-gms
+        sSocialMgr->SendFriendStatus(pCurrChar, FRIEND_ONLINE, pCurrChar->GetGUIDLow(), true);
+
+    // Place character in world (and load zone) before some object loading
+    pCurrChar->LoadCorpse();
+
+    // setting Ghost+speed if dead
+    if (pCurrChar->m_deathState != ALIVE)
+    {
+        // not blizz like, we must correctly save and load player instead...
+        if (pCurrChar->getRace() == RACE_NIGHTELF)
+            pCurrChar->CastSpell(pCurrChar, 20584, true, 0);// auras SPELL_AURA_INCREASE_SPEED(+speed in wisp form), SPELL_AURA_INCREASE_SWIM_SPEED(+swim speed in wisp form), SPELL_AURA_TRANSFORM (to wisp form)
+        pCurrChar->CastSpell(pCurrChar, 8326, true, 0);     // auras SPELL_AURA_GHOST, SPELL_AURA_INCREASE_SPEED(why?), SPELL_AURA_INCREASE_SWIM_SPEED(why?)
+
+        pCurrChar->SetMovement(MOVE_WATER_WALK);
+    }
+
+    // Set FFA PvP for non GM in non-rest mode
+    if (sWorld->IsFFAPvPRealm() && !pCurrChar->IsGameMaster() && !pCurrChar->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING))
+        pCurrChar->SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+
+    if (pCurrChar->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_CONTESTED_PVP))
+        pCurrChar->SetContestedPvP();
+
+    // Apply at_login requests
+    if (pCurrChar->HasAtLoginFlag(AT_LOGIN_RESET_SPELLS))
+    {
+        pCurrChar->resetSpells();
+        SendNotification(LANG_RESET_SPELLS);
+    }
+
+    if (pCurrChar->HasAtLoginFlag(AT_LOGIN_RESET_TALENTS))
+    {
+        pCurrChar->resetTalents(true);
+        pCurrChar->SendTalentsInfoData(false);              // original talents send already in to SendInitialPacketsBeforeAddToMap, resend reset state
+        SendNotification(LANG_RESET_TALENTS);
+    }
+
+    if (pCurrChar->HasAtLoginFlag(AT_LOGIN_FIRST))
+    {
+        pCurrChar->RemoveAtLoginFlag(AT_LOGIN_FIRST);
+        sScriptMgr->OnFirstLogin(pCurrChar);
+    }
+    else
+        sScriptMgr->OnPlayerLogin(pCurrChar);
+
+
+    if (pCurrChar->HasAtLoginFlag(AT_LOGIN_CHECK_ACHIEVS))
+    {
+        pCurrChar->RemoveAtLoginFlag(AT_LOGIN_CHECK_ACHIEVS, true);
+        pCurrChar->CheckAllAchievementCriteria();
+    }
+
+    // show time before shutdown if shutdown planned.
+    if (sWorld->IsShuttingDown())
+        sWorld->ShutdownMsg(true, pCurrChar);
+
+    if (sWorld->getBoolConfig(CONFIG_ALL_TAXI_PATHS))
+        pCurrChar->SetTaxiCheater(true);
+
+    if (pCurrChar->IsGameMaster())
+        SendNotification(LANG_GM_ON);
+
+    std::string IP_str = GetRemoteAddress();
+
+
+    if (!pCurrChar->IsStandState() && !pCurrChar->HasUnitState(UNIT_STATE_STUNNED))
+        pCurrChar->SetStandState(UNIT_STAND_STATE_STAND);
+
+    m_playerLoading = false;
+
+
+    // Handle Login-Achievements (should be handled after loading)
+    _player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ON_LOGIN, 1);
+
+    // Xinef: fix vendors falling of player vehicle, due to isBeingLoaded checks
+    if (pCurrChar->IsInWorld())
+    {
+        if (pCurrChar->GetMountBlockId() && !pCurrChar->HasAuraType(SPELL_AURA_MOUNTED))
+        {
+            pCurrChar->CastSpell(pCurrChar, pCurrChar->GetMountBlockId(), true);
+            pCurrChar->SetMountBlockId(0);
+
+            // Xinef: refresh this in case mount aura changes anything (eg no fly zone)
+            pCurrChar->UpdateAreaDependentAuras(pCurrChar->GetAreaId());
+            pCurrChar->UpdateZoneDependentAuras(pCurrChar->GetZoneId());
+        }
+    }
+
+    // pussywizard: pvp mode
+    pCurrChar->RemoveFlag(PLAYER_FLAGS, PLAYER_FLAGS_PVP_TIMER);
+    if (pCurrChar->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP))
+        pCurrChar->UpdatePvP(true, true);
+
+    // pussywizard: on login it's not possible to go back to arena as a spectator, HandleMoveWorldportAckOpcode is not sent, so call it here
+    pCurrChar->SetIsSpectator(false);
+
+    // xinef: do this after everything is loaded
+    pCurrChar->ContinueTaxiFlight();
+
+    // reset for all pets before pet loading
+    if (pCurrChar->HasAtLoginFlag(AT_LOGIN_RESET_PET_TALENTS))
+        Pet::resetTalentsForAllPetsOf(pCurrChar);
+
+    // Load pet if any (if player not alive and in taxi flight or another then pet will remember as temporary unsummoned)
+    pCurrChar->LoadPet();
+
+    //sScriptMgr->OnPlayerLogin(pCurrChar);
+    delete holder;
+}
diff --git a/src/server/game/Handlers/ChatHandler.cpp b/src/server/game/Handlers/ChatHandler.cpp
index 710eba5..c61b430 100644
--- a/src/server/game/Handlers/ChatHandler.cpp
+++ b/src/server/game/Handlers/ChatHandler.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -27,6 +27,19 @@
 #include "Util.h"
 #include "ScriptMgr.h"
 #include "AccountMgr.h"
+#pragma execution_character_set("utf-8")
+#include "../../scripts/Custom/Other/CFBG.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
+#include "Config.h"
+#include "../Custom/CustomEvent/FixedTimeBG/FixedTimeBG.h"
+#include "../Custom/FakePlayers/FakePlayers.h"
+#include "../Custom/Challenge/challenge.h"
+#include "../Custom/GCAddon/GCAddon.h"
+#include "../Custom/CharNameMod/CharNameMod.h"
+#include "../Custom/AuthCheck/AuthCheck.h"
+#include "../Custom/Switch/Switch.h"
+#include "../Custom/String/myString.h"
+#include "../Custom/DataLoader/DataLoader.h"
 
 #ifdef ELUNA
 #include "LuaEngine.h"
@@ -221,6 +234,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recvData)
                     break;
                 case CHAT_MSG_GUILD:
                 case CHAT_MSG_OFFICER:
+                    if (sSwitch->GetOnOff(ST_CF_GUILD))
+                        lang = LANG_UNIVERSAL;
                     // allow two side chat at guild channel if two side guild allowed
                     if (sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD))
                         lang = LANG_UNIVERSAL;
@@ -232,6 +247,9 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recvData)
                         specialMessageLimit = 15;
                     break;
                 }
+
+                if (sSwitch->GetOnOff(ST_CF_LANG))
+                    lang = LANG_UNIVERSAL;
             }
             // but overwrite it by SPELL_AURA_MOD_LANGUAGE auras (only single case used)
             Unit::AuraEffectList const& ModLangAuras = sender->GetAuraEffectsByType(SPELL_AURA_MOD_LANGUAGE);
@@ -263,6 +281,9 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recvData)
             break;
         case CHAT_MSG_WHISPER:
             recvData >> to;
+            if (!IsGCValidString(to, "HandleMessagechatOpcode - to", this, recvData))
+                return;
+            to = sCharNameMod->GetPureName(to);
             recvData >> msg;
             break;
         case CHAT_MSG_CHANNEL:
@@ -275,6 +296,8 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recvData)
             ignoreChecks = true;
             break;
     }
+    for (auto itr = DirtyWordVector.begin(); itr != DirtyWordVector.end(); itr++)
+        sString->Replace(msg, *itr, "***");
 
     // Strip invisible characters for non-addon messages
     if (lang != LANG_ADDON && sWorld->getBoolConfig(CONFIG_CHAT_FAKE_MESSAGE_PREVENTING))
@@ -334,6 +357,9 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recvData)
         return;
     }
 
+    if (lang == LANG_ADDON && sGCAddon->OnRecv(sender, msg))
+        return;
+
     sScriptMgr->OnBeforeSendChatMessage(_player, type, lang, msg);
 
     switch (type)
@@ -352,6 +378,11 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recvData)
                 return;
             }
 
+            /*cfbg*/
+            if (!GetPlayer()->IsGameMaster())
+                if (sCFBG->SendCFBGChat(GetPlayer(), type, msg))
+                    return;
+
             if (type == CHAT_MSG_SAY)
                 sender->Say(msg, lang);
             else if (type == CHAT_MSG_EMOTE)
@@ -376,14 +407,21 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recvData)
             Player* receiver = ObjectAccessor::FindPlayerByName(to, false);
             bool senderIsPlayer = AccountMgr::IsPlayerAccount(GetSecurity());
             bool receiverIsPlayer = AccountMgr::IsPlayerAccount(receiver ? receiver->GetSession()->GetSecurity() : SEC_PLAYER);
+
+            if (receiver && receiver->IsFaker)
+            {
+                GetPlayer()->Whisper(msg, lang, receiver->GetGUID());
+                return;
+            }
+
             if (!receiver || (senderIsPlayer && !receiverIsPlayer && !receiver->isAcceptWhispers() && !receiver->IsInWhisperWhiteList(sender->GetGUID())))
             {
                 SendPlayerNotFoundNotice(to);
                 return;
             }
 
-            if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_CHAT) && senderIsPlayer && receiverIsPlayer)
-                if (GetPlayer()->GetTeamId() != receiver->GetTeamId())
+            if (senderIsPlayer && receiverIsPlayer)
+                if (GetPlayer()->GetTeamId() != receiver->GetTeamId() && !sSwitch->GetOnOff(ST_CF_LANG))
                 {
                     SendWrongFactionNotice();
                     return;
@@ -417,6 +455,9 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recvData)
             if (type == CHAT_MSG_PARTY_LEADER && !group->IsLeader(sender->GetGUID()))
                 return;
 
+            if (GetPlayer()->ChallengeLv > 0)
+                msg = sChallengeMod->GetGossipText(GetPlayer()->GetMapId(), GetPlayer()->ChallengeLv) + msg;
+
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 #ifdef ELUNA
             if (!sEluna->OnChat(GetPlayer(), type, lang, msg, group))
@@ -528,7 +569,7 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recvData)
 #endif
             WorldPacket data;
             ChatHandler::BuildChatPacket(data, CHAT_MSG_BATTLEGROUND, Language(lang), sender, NULL, msg);
-            group->BroadcastPacket(&data, false);
+            sFTB->GetCFFlag(GetPlayer()->GetBattlegroundTypeId()) ? ChatHandler::BuildChatPacket(data, CHAT_MSG_BATTLEGROUND, Language(LANG_UNIVERSAL), sender, NULL, msg) : ChatHandler::BuildChatPacket(data, CHAT_MSG_BATTLEGROUND, Language(lang), sender, NULL, msg);
         } break;
         case CHAT_MSG_BATTLEGROUND_LEADER:
         {
@@ -544,7 +585,7 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recvData)
 #endif
             WorldPacket data;
             ChatHandler::BuildChatPacket(data, CHAT_MSG_BATTLEGROUND_LEADER, Language(lang), sender, NULL, msg);
-            group->BroadcastPacket(&data, false);
+            sFTB->GetCFFlag(GetPlayer()->GetBattlegroundTypeId()) ? ChatHandler::BuildChatPacket(data, CHAT_MSG_BATTLEGROUND_LEADER, Language(LANG_UNIVERSAL), sender, NULL, msg) : ChatHandler::BuildChatPacket(data, CHAT_MSG_BATTLEGROUND_LEADER, Language(lang), sender, NULL, msg);
         } break;
         case CHAT_MSG_CHANNEL:
         {
diff --git a/src/server/game/Handlers/GroupHandler.cpp b/src/server/game/Handlers/GroupHandler.cpp
index 14fbc42..b18978b 100644
--- a/src/server/game/Handlers/GroupHandler.cpp
+++ b/src/server/game/Handlers/GroupHandler.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -21,6 +21,13 @@
 #include "SpellAuras.h"
 #include "Vehicle.h"
 #include "Language.h"
+#pragma execution_character_set("utf-8")
+#include "../Custom/CustomEvent/Event.h"
+#include "../Custom/FakePlayers/FakePlayers.h"
+#include "../Custom/Switch/Switch.h"
+#include "../Custom/CharNameMod/CharNameMod.h"
+#include "../Custom/PvP/PvP.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
 
 class Aura;
 
@@ -56,6 +63,11 @@ void WorldSession::HandleGroupInviteOpcode(WorldPacket& recvData)
     recvData >> membername;
     recvData.read_skip<uint32>();
 
+    if (!IsGCValidString(membername, "HandleGroupInviteOpcode", this, recvData))
+        return;
+
+    membername = sCharNameMod->GetPureName(membername);
+
     // attempt add selected player
 
     // cheating
@@ -67,8 +79,24 @@ void WorldSession::HandleGroupInviteOpcode(WorldPacket& recvData)
 
     Player* player = ObjectAccessor::FindPlayerByName(membername, false);
 
+    // no player
+    if (!player)
+    {
+        if (!sFakePlayers->isSameTeamId(GetPlayer(), membername))
+        {
+            SendPartyResult(PARTY_OP_INVITE, membername, ERR_PLAYER_WRONG_FACTION);
+            return;
+        }
+
+        if (sFakePlayers->Logout(membername))
+            return;
+
+        SendPartyResult(PARTY_OP_INVITE, membername, ERR_BAD_PLAYER_NAME_S);
+        return;
+    }
+
     // no player or cheat self-invite
-    if (!player || player == GetPlayer())
+    if (player == GetPlayer())
     {
         SendPartyResult(PARTY_OP_INVITE, membername, ERR_BAD_PLAYER_NAME_S);
         return;
@@ -88,7 +116,7 @@ void WorldSession::HandleGroupInviteOpcode(WorldPacket& recvData)
     }
 
     // can't group with
-    if (!GetPlayer()->IsGameMaster() && !sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GROUP) && GetPlayer()->GetTeamId() != player->GetTeamId())
+    if (!GetPlayer()->IsGameMaster() && !sSwitch->GetOnOff(ST_CF_GROUP) && GetPlayer()->GetTeamId() != player->GetTeamId())
     {
         SendPartyResult(PARTY_OP_INVITE, membername, ERR_PLAYER_WRONG_FACTION);
         return;
@@ -117,6 +145,19 @@ void WorldSession::HandleGroupInviteOpcode(WorldPacket& recvData)
         return;
     }
 
+    //PvP
+    if (!sPvP->EnableGroup(player->GetZoneId(), player->GetAreaId()))
+    {
+        GetPlayer()->GetSession()->SendNotification("å¯¹æ¹å¤å¨ç¹æ®åºåä¸­ï¼æ æ³è¢«éè¯·ï¼");
+        return;
+    }
+
+    if (!sPvP->EnableGroup(GetPlayer()->GetZoneId(), GetPlayer()->GetAreaId()))
+    {
+        GetPlayer()->GetSession()->SendNotification("ä½ å¤å¨ç¹æ®åºåä¸­ï¼æ æ³éè¯·ç©å®¶ï¼");
+        return;
+    }
+
     Group* group = GetPlayer()->GetGroup();
     if (group && (group->isBGGroup() || group->isBFGroup()))
         group = GetPlayer()->GetOriginalGroup();
@@ -293,7 +334,8 @@ void WorldSession::HandleGroupUninviteGuidOpcode(WorldPacket& recvData)
 #if defined(ENABLE_EXTRAS) && defined(ENABLE_EXTRA_LOGS)
     sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Received CMSG_GROUP_UNINVITE_GUID");
 #endif
-
+    if (GetPlayer()->InEvent())
+        return;
     uint64 guid;
     std::string reason, name;
     recvData >> guid;
@@ -440,6 +482,8 @@ void WorldSession::HandleGroupDisbandOpcode(WorldPacket & /*recvData*/)
     SendPartyResult(PARTY_OP_LEAVE, GetPlayer()->GetName(), ERR_PARTY_RESULT_OK);
 
     GetPlayer()->RemoveFromGroup(GROUP_REMOVEMETHOD_LEAVE);
+
+    GetPlayer()->EventRest();
 }
 
 void WorldSession::HandleLootMethodOpcode(WorldPacket& recvData)
@@ -462,6 +506,9 @@ void WorldSession::HandleLootMethodOpcode(WorldPacket& recvData)
     if (!group->IsLeader(GetPlayer()->GetGUID()) || group->isLFGGroup())
         return;
 
+    if (GetPlayer()->InEvent())
+        return;
+
     if (lootMethod > NEED_BEFORE_GREED)
         return;
 
diff --git a/src/server/game/Handlers/GuildHandler.cpp b/src/server/game/Handlers/GuildHandler.cpp
index 6fb61ea..30802fa 100644
--- a/src/server/game/Handlers/GuildHandler.cpp
+++ b/src/server/game/Handlers/GuildHandler.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -15,6 +15,8 @@
 #include "Guild.h"
 #include "GossipDef.h"
 #include "SocialMgr.h"
+#include "../Custom/Switch/Switch.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
 
 // Cleanup bad characters
 void cleanStr(std::string &str) {
@@ -148,6 +150,9 @@ void WorldSession::HandleGuildLeaveOpcode(WorldPacket& /*recvPacket*/)
     sLog->outDebug(LOG_FILTER_GUILD, "CMSG_GUILD_LEAVE [%s]", GetPlayerInfo().c_str());
 #endif
 
+    if (sSwitch->GetOnOff(ST_AUTO_JOIN_GUILD))
+        return;
+
     if (Guild* guild = GetPlayer()->GetGuild())
         guild->HandleLeaveMember(this);
 }
diff --git a/src/server/game/Handlers/ItemHandler.cpp b/src/server/game/Handlers/ItemHandler.cpp
index 72e4693..1d83b81 100644
--- a/src/server/game/Handlers/ItemHandler.cpp
+++ b/src/server/game/Handlers/ItemHandler.cpp
@@ -15,7 +15,18 @@
 #include "UpdateData.h"
 #include "ObjectAccessor.h"
 #include "SpellInfo.h"
-#include "BYcustom.h"
+#pragma execution_character_set("utf-8")
+#include "../../scripts/Custom/CommonFunc/CommonFunc.h"
+#include "../../scripts/Custom/SellReward/SellReward.h"
+#include "../../scripts/Custom/DataLoader/DataLoader.h"
+#include "../../scripts/Custom/Switch/Switch.h"
+#include "../../scripts/Custom/ItemMod/ItemMod.h"
+#include "../../scripts/Custom/Requirement/Requirement.h"
+#include "../../scripts/Custom/GCAddon/GCAddon.h"
+#include "../../scripts/Custom/ItemMod/NoPatchItem.h"
+#include "../../scripts/Custom/EquipmentManager/EquipmentManager.h"
+#include "../Custom/GS/GS.h"
+#include "Chat.h"
 
 void WorldSession::HandleSplitItemOpcode(WorldPacket & recvData)
 {
@@ -47,6 +58,12 @@ void WorldSession::HandleSplitItemOpcode(WorldPacket & recvData)
         return;
     }
 
+    if (sEM->InKeyings(srcbag, srcslot) || sEM->InKeyings(dstbag, dstslot) || sEM->SlotIsFreeze(_player, srcslot) || sEM->SlotIsFreeze(_player, dstslot))
+    {
+        _player->SendEquipError(EQUIP_ERR_ITEM_DOESNT_GO_TO_SLOT, NULL, NULL);
+        return;
+    }
+
     _player->SplitItem(src, dst, count);
 }
 
@@ -86,6 +103,11 @@ void WorldSession::HandleSwapInvItemOpcode(WorldPacket & recvData)
         return;
     }
 
+    if (sEM->InKeyings(INVENTORY_SLOT_BAG_0, srcslot) || sEM->InKeyings(INVENTORY_SLOT_BAG_0, dstslot) || sEM->SlotIsFreeze(_player, srcslot) || sEM->SlotIsFreeze(_player, dstslot))
+    {
+        _player->SendEquipError(EQUIP_ERR_ITEM_DOESNT_GO_TO_SLOT, NULL, NULL);
+        return;
+    }
     uint16 src = ((INVENTORY_SLOT_BAG_0 << 8) | srcslot);
     uint16 dst = ((INVENTORY_SLOT_BAG_0 << 8) | dstslot);
 
@@ -98,6 +120,12 @@ void WorldSession::HandleAutoEquipItemSlotOpcode(WorldPacket & recvData)
     uint8 dstslot;
     recvData >> itemguid >> dstslot;
 
+    if (_player->HasMapTempItems())
+    {
+        ChatHandler(_player->GetSession()).PSendSysMessage("è¿ä¸ªå°å¾æ æ³åæ¢è£å¤.");
+        return;
+    }
+
     // cheating attempt, client should never send opcode in that case
     if (!Player::IsEquipmentPos(INVENTORY_SLOT_BAG_0, dstslot))
         return;
@@ -108,6 +136,12 @@ void WorldSession::HandleAutoEquipItemSlotOpcode(WorldPacket & recvData)
     if (!item || item->GetPos() == dstpos)
         return;
 
+    if (sEM->InKeyings(item) || sEM->SlotIsFreeze(_player, dstslot))
+    {
+        _player->SendEquipError(EQUIP_ERR_CANT_DO_RIGHT_NOW, NULL, NULL);
+        return;
+    }
+
     _player->SwapItem(item->GetPos(), dstpos);
 }
 
@@ -122,6 +156,12 @@ void WorldSession::HandleSwapItem(WorldPacket & recvData)
     uint16 src = ((srcbag << 8) | srcslot);
     uint16 dst = ((dstbag << 8) | dstslot);
 
+    if (_player->HasMapTempItems())
+    {
+        ChatHandler(_player->GetSession()).PSendSysMessage("è¿ä¸ªå°å¾æ æ³åæ¢è£å¤.");
+        return;
+    }
+
     // prevent attempt swap same item to current position generated by client at special checting sequence
     if (src == dst)
         return;
@@ -149,7 +189,20 @@ void WorldSession::HandleSwapItem(WorldPacket & recvData)
         //TC_LOG_DEBUG("network", "WORLD: HandleSwapItem - Unit (GUID: %u) not found or you can't interact with him.", uint32(GUID_LOPART(m_currentBankerGUID)));
         return;
     }
+    Item* pSrcItem = _player->GetItemByPos(srcbag, srcslot);
+    Item* pDstItem = _player->GetItemByPos(dstbag, dstslot);
+
+    //é²æ­¢å·²è§£ç»ç©åä¸æªè§£ç»ç©åå å 
+    if (pDstItem && pSrcItem)
+        if ((pSrcItem->UnBinded && !pDstItem->UnBinded) || (!pSrcItem->UnBinded && pDstItem->UnBinded))
+            if (pSrcItem->GetEntry() == pDstItem->GetEntry())
+                return;
 
+    if (sEM->InKeyings(srcbag, srcslot) || sEM->InKeyings(dstbag, dstslot) || sEM->SlotIsFreeze(_player, srcslot) || sEM->SlotIsFreeze(_player, dstslot))
+    {
+        _player->SendEquipError(EQUIP_ERR_ITEM_DOESNT_GO_TO_SLOT, NULL, NULL);
+        return;
+    }
     _player->SwapItem(src, dst);
 }
 
@@ -165,6 +218,21 @@ void WorldSession::HandleAutoEquipItemOpcode(WorldPacket & recvData)
     if (!pSrcItem)
         return;                                             // only at cheat
 
+    if (_player->HasMapTempItems())
+    {
+        ChatHandler(_player->GetSession()).PSendSysMessage("è¿ä¸ªå°å¾æ æ³åæ¢è£å¤.");
+        return;
+    }
+    //è£å¤æ è¡¥ä¸ç©å
+    if (sNoPatchItem->Create(_player, pSrcItem))
+        return;
+
+    if (sEM->InKeyings(pSrcItem) || sEM->SlotIsFreeze(_player, srcslot))
+    {
+        _player->SendEquipError(EQUIP_ERR_CANT_DO_RIGHT_NOW, NULL, NULL);
+        return;
+    }
+
     uint16 dest;
     InventoryResult msg = _player->CanEquipItem(NULL_SLOT, dest, pSrcItem, !pSrcItem->IsBag());
     if (msg != EQUIP_ERR_OK)
@@ -431,6 +499,9 @@ void WorldSession::HandleItemQuerySingleOpcode(WorldPacket & recvData)
     uint32 item;
     recvData >> item;
 
+    if (sNoPatchItem->ItemQuery(_player, item))
+        return;
+
 #if defined(ENABLE_EXTRAS) && defined(ENABLE_EXTRA_LOGS)
     sLog->outDetail("STORAGE: Item Query = %u", item);
 #endif
@@ -638,8 +709,10 @@ void WorldSession::HandleSellItemOpcode(WorldPacket & recvData)
     if (!itemguid)
         return;
 
+    bool fromcommand = VendorFromCommand();
+
     Creature* creature = GetPlayer()->GetNPCIfCanInteractWith(vendorguid, UNIT_NPC_FLAG_VENDOR);
-    if (!creature)
+    if (!creature && !fromcommand)
     {
 #if defined(ENABLE_EXTRAS) && defined(ENABLE_EXTRA_LOGS)
         sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleSellItemOpcode - Unit (GUID: %u) not found or you can not interact with him.", uint32(GUID_LOPART(vendorguid)));
@@ -655,6 +728,13 @@ void WorldSession::HandleSellItemOpcode(WorldPacket & recvData)
     Item* pItem = _player->GetItemByGuid(itemguid);
     if (pItem)
     {
+        //æ£æµå¹»åæ è¯
+        if (sItemMod->HasTransFlag(pItem))
+        {
+            _player->SendSellError(SELL_ERR_CANT_SELL_ITEM, creature, itemguid, 0);
+            return;
+        }
+
         // prevent sell not owner item
         if (_player->GetGUID() != pItem->GetOwnerGUID())
         {
@@ -737,6 +817,9 @@ void WorldSession::HandleSellItemOpcode(WorldPacket & recvData)
                 uint32 money = pProto->SellPrice * count;
                 _player->ModifyMoney(money);
                 _player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_MONEY_FROM_VENDORS, money);
+
+                //å®åå¥å±
+                sSellReward->Reward(_player, pItem);
             }
             else
                 _player->SendSellError(SELL_ERR_CANT_SELL_ITEM, creature, itemguid, 0);
@@ -757,8 +840,11 @@ void WorldSession::HandleBuybackItem(WorldPacket & recvData)
 
     recvData >> vendorguid >> slot;
 
+
+    bool fromcommand = VendorFromCommand();
+
     Creature* creature = GetPlayer()->GetNPCIfCanInteractWith(vendorguid, UNIT_NPC_FLAG_VENDOR);
-    if (!creature)
+    if (!creature && !fromcommand)
     {
 #if defined(ENABLE_EXTRAS) && defined(ENABLE_EXTRA_LOGS)
         sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: HandleBuybackItem - Unit (GUID: %u) not found or you can not interact with him.", uint32(GUID_LOPART(vendorguid)));
@@ -774,6 +860,9 @@ void WorldSession::HandleBuybackItem(WorldPacket & recvData)
     Item* pItem = _player->GetItemFromBuyBackSlot(slot);
     if (pItem)
     {
+        if (!sSellReward->CanRefund(_player, pItem))
+            return;
+
         uint32 price = _player->GetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE_1 + slot - BUYBACK_SLOT_START);
         if (!_player->HasEnoughMoney(price))
         {
@@ -849,9 +938,17 @@ void WorldSession::HandleBuyItemInSlotOpcode(WorldPacket & recvData)
     if (bag == NULL_BAG)
         return;
 
-    if (!sCustomMgr->CanSendBuyItemUI(GetPlayer(), vendorguid, item, count, slot, bag, bagslot))
+    uint32 reqId = VendorFromCommand() ? sItemMod->GetBuyReqId(item, GetCurrentVendorGUID(), slot + 1) : sItemMod->GetBuyReqId(item, GUID_ENPART(vendorguid), slot + 1);
+
+    if (sReq->IsExist(reqId))
+    {
+        GetPlayer()->buy_reqId = reqId;
+        GetPlayer()->buy_item = item;
+        GetPlayer()->buy_count = count;
+        sCF->SendAcceptOrCancel(GetPlayer(), 1000000, sReq->Notice(GetPlayer(), reqId, "è´­ä¹°", sCF->GetItemLink(item), count), true);
+    }
+    else
         GetPlayer()->BuyItemFromVendorSlot(vendorguid, slot, item, count, bag, bagslot);
-    
 }
 
 void WorldSession::HandleBuyItemOpcode(WorldPacket & recvData)
@@ -871,7 +968,21 @@ void WorldSession::HandleBuyItemOpcode(WorldPacket & recvData)
     else
         return; // cheating
 
-    if (!sCustomMgr->CanSendBuyItemUI(GetPlayer(), vendorguid, item, count, slot, NULL_BAG, NULL_SLOT))
+    uint32 vendor = GUID_ENPART(vendorguid);
+
+    if (VendorFromCommand())
+        vendor = GetCurrentVendorGUID();
+
+    uint32 reqId = sItemMod->GetBuyReqId(item, vendor, slot + 1);
+
+    if (sReq->IsExist(reqId))
+    {
+        GetPlayer()->buy_reqId = reqId;
+        GetPlayer()->buy_item = item;
+        GetPlayer()->buy_count = count;
+        sCF->SendAcceptOrCancel(GetPlayer(), 1000000, sReq->Notice(GetPlayer(), reqId, "è´­ä¹°", sCF->GetItemLink(item), count), true);
+    }
+    else
         GetPlayer()->BuyItemFromVendorSlot(vendorguid, slot, item, count, NULL_BAG, NULL_SLOT);
 }
 
@@ -915,7 +1026,7 @@ void WorldSession::SendListInventory(uint64 vendorGuid, uint32 vendorEntry)
     if (vendor->HasUnitState(UNIT_STATE_MOVING))
         vendor->StopMoving();
 
-    SetCurrentVendor(vendorEntry);
+    SetCurrentVendor(vendorEntry, GUID_LOPART(vendorGuid), GUID_HIPART(vendorGuid));
 
     VendorItemData const* items = vendorEntry ? sObjectMgr->GetNpcVendorItemList(vendorEntry) : vendor->GetVendorItems();
     if (!items)
@@ -975,7 +1086,90 @@ void WorldSession::SendListInventory(uint64 vendorGuid, uint32 vendorEntry)
                 data << int32(leftInStock);
                 data << uint32(price);
                 data << uint32(itemTemplate->MaxDurability);
-                data << uint32(itemTemplate->BuyCount);
+                uint32 BuyMaxCount = sItemMod->GetBuyMaxCount(item->item, vendorEntry ? vendorEntry : vendor->GetEntry(), slot + 1);
+
+                if (BuyMaxCount)
+                    data << uint32(BuyMaxCount);
+                else
+                    data << uint32(itemTemplate->BuyCount);
+                data << uint32(item->ExtendedCost);
+
+                if (++count >= MAX_VENDOR_ITEMS)
+                    break;
+            }
+        }
+    }
+
+    if (count == 0)
+    {
+        data << uint8(0);
+        SendPacket(&data);
+        return;
+    }
+
+    data.put<uint8>(countPos, count);
+    SendPacket(&data);
+}
+
+void WorldSession::SendCommandListInventory(uint32 vendorEntry)
+{
+    // remove fake death
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
+        GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
+
+    //VendorItemData const* items = vendor->GetVendorItems();
+    VendorItemData const* items = sObjectMgr->GetNpcVendorItemList(vendorEntry);
+    if (!items)
+    {
+        WorldPacket data(SMSG_LIST_INVENTORY, 8 + 1 + 1);
+        data << uint64(_player->GetGUID());
+        data << uint8(0);                                   // count == 0, next will be error code
+        data << uint8(0);                                   // "Vendor has no inventory"
+        SendPacket(&data);
+        return;
+    }
+
+    SetCurrentVendor(128, vendorEntry, 128);
+
+    uint8 itemCount = items->GetItemCount();
+    uint8 count = 0;
+
+    WorldPacket data(SMSG_LIST_INVENTORY, 8 + 1 + itemCount * 8 * 4);
+    data << uint64(_player->GetGUID());
+
+    size_t countPos = data.wpos();
+    data << uint8(count);
+
+    for (uint8 slot = 0; slot < itemCount; ++slot)
+    {
+        if (VendorItem const* item = items->GetItem(slot))
+        {
+            if (ItemTemplate const* itemTemplate = sObjectMgr->GetItemTemplate(item->item))
+            {
+                if (!(itemTemplate->AllowableClass & _player->getClassMask()) && itemTemplate->Bonding == BIND_WHEN_PICKED_UP && !_player->IsGameMaster())
+                    continue;
+                // Only display items in vendor lists for the team the
+                // player is on. If GM on, display all items.
+                if (!_player->IsGameMaster() && ((itemTemplate->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY && _player->GetTeamId() == TEAM_ALLIANCE) || (itemTemplate->Flags2 == ITEM_FLAGS_EXTRA_ALLIANCE_ONLY && _player->GetTeamId() == TEAM_HORDE)))
+                    continue;
+
+                // reputation discount
+                int32 price = item->IsGoldRequired(itemTemplate) ? uint32(floor(itemTemplate->BuyPrice)) : 0;
+
+                data << uint32(slot + 1);       // client expects counting to start at 1
+                data << uint32(item->item);
+                data << uint32(itemTemplate->DisplayInfoID);
+                data << int32(0xFFFFFFFF);
+                data << uint32(price);
+                data << uint32(itemTemplate->MaxDurability);
+
+                uint32 BuyMaxCount = sItemMod->GetBuyMaxCount(item->item, vendorEntry, slot + 1);
+
+                if (BuyMaxCount)
+                    data << uint32(BuyMaxCount);
+                else
+                    data << uint32(itemTemplate->BuyCount);
+
                 data << uint32(item->ExtendedCost);
 
                 if (++count >= MAX_VENDOR_ITEMS)
diff --git a/src/server/game/Handlers/LootHandler.cpp b/src/server/game/Handlers/LootHandler.cpp
index 32066cb..204afbf 100644
--- a/src/server/game/Handlers/LootHandler.cpp
+++ b/src/server/game/Handlers/LootHandler.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -20,6 +20,7 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 #include "ObjectMgr.h"
+#include "../../server/scripts/Custom/Recruit/Recruit.h"
 
 #ifdef ELUNA
 #include "LuaEngine.h"
@@ -183,6 +184,9 @@ void WorldSession::HandleLootMoneyOpcode(WorldPacket & /*recvData*/)
 
             uint32 goldPerPlayer = uint32((loot->gold) / (playersNear.size()));
 
+            //å±äº«éé±
+            sRecruit->RecruitMoneyReward(player, goldPerPlayer);
+
             for (std::vector<Player*>::const_iterator i = playersNear.begin(); i != playersNear.end(); ++i)
             {
                 (*i)->ModifyMoney(goldPerPlayer);
@@ -196,6 +200,9 @@ void WorldSession::HandleLootMoneyOpcode(WorldPacket & /*recvData*/)
         }
         else
         {
+            //å±äº«éé±
+            sRecruit->RecruitMoneyReward(player, loot->gold);
+
             player->ModifyMoney(loot->gold);
             player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_MONEY, loot->gold);
 
@@ -219,6 +226,218 @@ void WorldSession::HandleLootMoneyOpcode(WorldPacket & /*recvData*/)
     }
 }
 
+void WorldSession::HandleAutostoreLootItemFarOpcode(WorldPacket& recvData, float range)
+{
+    ;//sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_AUTOSTORE_LOOT_ITEM");
+    Player* player = GetPlayer();
+    uint64 lguid = player->GetLootGUID();
+    Loot* loot = NULL;
+    uint8 lootSlot = 0;
+
+    recvData >> lootSlot;
+
+    if (IS_GAMEOBJECT_GUID(lguid))
+    {
+        GameObject* go = player->GetMap()->GetGameObject(lguid);
+        // xinef: cheating protection
+        //if (player->GetGroup() && player->GetGroup()->GetLootMethod() == MASTER_LOOT && player->GetGUID() != player->GetGroup()->GetMasterLooterGuid())
+        //    go = NULL;
+
+        // not check distance for GO in case owned GO (fishing bobber case, for example) or Fishing hole GO
+        if (!go || ((go->GetOwnerGUID() != _player->GetGUID() && go->GetGoType() != GAMEOBJECT_TYPE_FISHINGHOLE) && !go->IsWithinDistInMap(_player, range)))
+        {
+            player->SendLootRelease(lguid);
+            return;
+        }
+
+        loot = &go->loot;
+    }
+    else if (IS_ITEM_GUID(lguid))
+    {
+        Item* pItem = player->GetItemByGuid(lguid);
+
+        if (!pItem)
+        {
+            player->SendLootRelease(lguid);
+            return;
+        }
+
+        loot = &pItem->loot;
+    }
+    else if (IS_CORPSE_GUID(lguid))
+    {
+        Corpse* bones = ObjectAccessor::GetCorpse(*player, lguid);
+        if (!bones)
+        {
+            player->SendLootRelease(lguid);
+            return;
+        }
+
+        loot = &bones->loot;
+    }
+    else
+    {
+        Creature* creature = GetPlayer()->GetMap()->GetCreature(lguid);
+
+        bool lootAllowed = creature && creature->IsAlive() == (player->getClass() == CLASS_ROGUE && creature->loot.loot_type == LOOT_PICKPOCKETING);
+        if (!lootAllowed || !creature->IsWithinDistInMap(_player, range))
+        {
+            player->SendLootError(lguid, lootAllowed ? LOOT_ERROR_TOO_FAR : LOOT_ERROR_DIDNT_KILL);
+            return;
+        }
+
+        loot = &creature->loot;
+    }
+
+    player->StoreLootItem(lootSlot, loot);
+
+    // If player is removing the last LootItem, delete the empty container.
+    if (loot->isLooted() && IS_ITEM_GUID(lguid))
+        DoLootRelease(lguid, range);
+}
+
+void WorldSession::HandleLootMoneyFarOpcode(WorldPacket & /*recvData*/, float range)
+{
+    ;//sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_LOOT_MONEY");
+
+    Player* player = GetPlayer();
+    uint64 guid = player->GetLootGUID();
+    if (!guid)
+        return;
+
+    Loot* loot = NULL;
+    bool shareMoney = true;
+
+    switch (GUID_HIPART(guid))
+    {
+    case HIGHGUID_GAMEOBJECT:
+    {
+        GameObject* go = GetPlayer()->GetMap()->GetGameObject(guid);
+
+        // do not check distance for GO if player is the owner of it (ex. fishing bobber)
+        if (go && ((go->GetOwnerGUID() == player->GetGUID() || go->IsWithinDistInMap(player, range))))
+            loot = &go->loot;
+
+        break;
+    }
+    case HIGHGUID_CORPSE:                               // remove insignia ONLY in BG
+    {
+        Corpse* bones = ObjectAccessor::GetCorpse(*player, guid);
+
+        if (bones && bones->IsWithinDistInMap(player, range))
+        {
+            loot = &bones->loot;
+            shareMoney = false;
+        }
+
+        break;
+    }
+    case HIGHGUID_ITEM:
+    {
+        if (Item* item = player->GetItemByGuid(guid))
+        {
+            loot = &item->loot;
+            shareMoney = false;
+        }
+        break;
+    }
+    case HIGHGUID_UNIT:
+    case HIGHGUID_VEHICLE:
+    {
+        Creature* creature = player->GetMap()->GetCreature(guid);
+        bool lootAllowed = creature && creature->IsAlive() == (player->getClass() == CLASS_ROGUE && creature->loot.loot_type == LOOT_PICKPOCKETING);
+        if (lootAllowed && creature->IsWithinDistInMap(player, range))
+        {
+            loot = &creature->loot;
+            if (creature->IsAlive())
+                shareMoney = false;
+        }
+        else
+            player->SendLootError(guid, lootAllowed ? LOOT_ERROR_TOO_FAR : LOOT_ERROR_DIDNT_KILL);
+        break;
+    }
+    default:
+        return;                                         // unlootable type
+    }
+
+    if (loot)
+    {
+        loot->NotifyMoneyRemoved();
+        if (shareMoney && player->GetGroup())      //item, pickpocket and players can be looted only single player
+        {
+            Group* group = player->GetGroup();
+
+            std::vector<Player*> playersNear;
+            for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* member = itr->GetSource();
+                if (!member)
+                    continue;
+
+                if (player->IsAtGroupRewardDistance(member))
+                    playersNear.push_back(member);
+            }
+
+            uint32 goldPerPlayer = uint32((loot->gold) / (playersNear.size()));
+
+            //å±äº«éé±
+            sRecruit->RecruitMoneyReward(player, goldPerPlayer);
+
+            for (std::vector<Player*>::const_iterator i = playersNear.begin(); i != playersNear.end(); ++i)
+            {
+                (*i)->ModifyMoney(goldPerPlayer);
+                (*i)->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_MONEY, goldPerPlayer);
+
+                WorldPacket data(SMSG_LOOT_MONEY_NOTIFY, 4 + 1);
+                data << uint32(goldPerPlayer);
+                data << uint8(playersNear.size() > 1 ? 0 : 1);     // Controls the text displayed in chat. 0 is "Your share is..." and 1 is "You loot..."
+                (*i)->GetSession()->SendPacket(&data);
+            }
+        }
+        else
+        {
+            //å±äº«éé±
+            sRecruit->RecruitMoneyReward(player, loot->gold);
+
+            player->ModifyMoney(loot->gold);
+            player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_MONEY, loot->gold);
+
+            WorldPacket data(SMSG_LOOT_MONEY_NOTIFY, 4 + 1);
+            data << uint32(loot->gold);
+            data << uint8(1);   // "You loot..."
+            SendPacket(&data);
+        }
+
+        loot->gold = 0;
+
+        // Delete the money loot record from the DB
+        if (loot->containerId > 0)
+            sLootItemStorage->RemoveStoredLootMoney(loot->containerId, loot);
+
+        // Delete container if empty
+        if (loot->isLooted() && IS_ITEM_GUID(guid))
+            DoLootRelease(guid, range);
+    }
+}
+
+void WorldSession::HandleLootFarOpcode(WorldPacket& recvData, float range)
+{
+    ;//sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: CMSG_LOOT");
+
+    uint64 guid;
+    recvData >> guid;
+
+    // Check possible cheat
+    if (!GetPlayer()->IsAlive() || !IS_CRE_OR_VEH_GUID(guid))
+        return;
+
+    GetPlayer()->SendLoot(guid, LOOT_CORPSE, range);
+
+    // interrupt cast
+    if (GetPlayer()->IsNonMeleeSpellCast(false))
+        GetPlayer()->InterruptNonMeleeSpells(false);
+}
+
 void WorldSession::HandleLootOpcode(WorldPacket& recvData)
 {
 #if defined(ENABLE_EXTRAS) && defined(ENABLE_EXTRA_LOGS)
@@ -255,7 +474,7 @@ void WorldSession::HandleLootReleaseOpcode(WorldPacket& recvData)
             DoLootRelease(lguid);
 }
 
-void WorldSession::DoLootRelease(uint64 lguid)
+void WorldSession::DoLootRelease(uint64 lguid, float range)
 {
     Player  *player = GetPlayer();
     Loot    *loot;
@@ -273,7 +492,7 @@ void WorldSession::DoLootRelease(uint64 lguid)
         GameObject* go = GetPlayer()->GetMap()->GetGameObject(lguid);
 
         // not check distance for GO in case owned GO (fishing bobber case, for example) or Fishing hole GO
-        if (!go || ((go->GetOwnerGUID() != _player->GetGUID() && go->GetGoType() != GAMEOBJECT_TYPE_FISHINGHOLE) && !go->IsWithinDistInMap(_player, INTERACTION_DISTANCE)))
+        if (!go || ((go->GetOwnerGUID() != _player->GetGUID() && go->GetGoType() != GAMEOBJECT_TYPE_FISHINGHOLE) && !go->IsWithinDistInMap(_player, range)))
             return;
 
         loot = &go->loot;
@@ -324,7 +543,7 @@ void WorldSession::DoLootRelease(uint64 lguid)
     else if (IS_CORPSE_GUID(lguid))        // ONLY remove insignia at BG
     {
         Corpse* corpse = ObjectAccessor::GetCorpse(*player, lguid);
-        if (!corpse || !corpse->IsWithinDistInMap(_player, INTERACTION_DISTANCE))
+        if (!corpse || !corpse->IsWithinDistInMap(_player, range))
             return;
 
         loot = &corpse->loot;
@@ -370,7 +589,7 @@ void WorldSession::DoLootRelease(uint64 lguid)
         Creature* creature = GetPlayer()->GetMap()->GetCreature(lguid);
 
         bool lootAllowed = creature && creature->IsAlive() == (player->getClass() == CLASS_ROGUE && creature->loot.loot_type == LOOT_PICKPOCKETING);
-        if (!lootAllowed || !creature->IsWithinDistInMap(_player, INTERACTION_DISTANCE))
+        if (!lootAllowed || !creature->IsWithinDistInMap(_player, range))
             return;
 
         loot = &creature->loot;
diff --git a/src/server/game/Handlers/MailHandler.cpp b/src/server/game/Handlers/MailHandler.cpp
index 0a44d4b..81d66e1 100644
--- a/src/server/game/Handlers/MailHandler.cpp
+++ b/src/server/game/Handlers/MailHandler.cpp
@@ -17,6 +17,8 @@
 #include "DBCStores.h"
 #include "Item.h"
 #include "AccountMgr.h"
+#include "../Custom/Switch/Switch.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
 
 #define MAX_INBOX_CLIENT_CAPACITY 50
 
@@ -199,7 +201,7 @@ void WorldSession::HandleSendMail(WorldPacket & recvData)
         ? receive->GetSession()->GetAccountId()
         : sObjectMgr->GetPlayerAccountIdByGUID(rc);
 
-    if (/*!accountBound*/ GetAccountId() != rc_account && !sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_MAIL) && player->GetTeamId() != rc_teamId && AccountMgr::IsPlayerAccount(GetSecurity()))
+    if (/*!accountBound*/ GetAccountId() != rc_account && !sSwitch->GetOnOff(ST_CF_TRADE) && player->GetTeamId() != rc_teamId && AccountMgr::IsPlayerAccount(GetSecurity()))
     {
         player->SendMailResult(0, MAIL_SEND, MAIL_ERR_NOT_YOUR_TEAM);
         return;
@@ -523,6 +525,11 @@ void WorldSession::HandleMailTakeItem(WorldPacket & recvData)
 
         uint32 count = it->GetCount();                      // save counts before store and possible merge with deleting
         it->SetState(ITEM_UNCHANGED);                       // need to set this state, otherwise item cannot be removed later, if neccessary
+
+        //è§£ç»ç¶æ
+        if (it->GetTemplate()->Class != ITEM_CLASS_WEAPON && it->GetTemplate()->Class != ITEM_CLASS_ARMOR && it->GetTemplate()->Class != ITEM_CLASS_GEM)
+            it->UnBinded = false;
+
         player->MoveItemToInventory(dest, it, true);
 
         player->SaveInventoryAndGoldToDB(trans);
diff --git a/src/server/game/Handlers/MiscHandler.cpp b/src/server/game/Handlers/MiscHandler.cpp
index 56f4a37..7425032 100644
--- a/src/server/game/Handlers/MiscHandler.cpp
+++ b/src/server/game/Handlers/MiscHandler.cpp
@@ -43,9 +43,16 @@
 #include "AccountMgr.h"
 #include "Spell.h"
 #include "WhoListCache.h"
-#include "BYcustom.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
+#include "../Custom/CustomEvent/Event.h"
+#include "../Custom/Recruit/Recruit.h"
+#include "../Custom/FakePlayers/FakePlayers.h"
+#include "../Custom/PvP/PvP.h"
+#include "../Custom/Switch/Switch.h"
+#include "../Custom/GCAddon/GCAddon.h"
+#include "../Custom/Challenge/challenge.h"
+#include "../Custom/MapMod/MapMod.h"
 
-#include "../game/AI/NpcBots/bothelper.h"
 #ifdef ELUNA
 #include "LuaEngine.h"
 #endif
@@ -103,6 +110,24 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket & recv_data)
     if (_player->PlayerTalkClass->IsGossipOptionCoded(gossipListId))
         recv_data >> code;
 
+    //å¤çå¼¹çªé©å­
+
+    if (sRecruit->RecruitAcceptOrCancel(GetPlayer(), menuId))
+        return;
+
+    if (sCF->DoAciotnAfterAccept(GetPlayer(), menuId))
+        return;
+
+    if (sEvent->AcceptInvitation(GetPlayer(), menuId))
+        return;
+
+    if (_player->PlayerTalkClass->IsGossipOptionCoded(gossipListId) || menuId == 7878)
+        recv_data >> code;
+
+    if (!IsGCValidString(code, "HandleGossipSelectOptionOpcode", this, recv_data))
+        return;
+
+
     Creature* unit = nullptr;
     GameObject* go = nullptr;
     Item* item = nullptr;
@@ -188,10 +213,7 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket & recv_data)
         }
         else
         {
-            if (menuId == 10000)
-                sCustomMgr->OnPlayerSelectDQ(_player, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId), code.c_str());
-            else
-                sScriptMgr->OnGossipSelectCode(_player, menuId, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId), code.c_str());
+            sScriptMgr->OnGossipSelectCode(_player, menuId, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId), code.c_str());
         }
     }
     else
@@ -214,16 +236,7 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket & recv_data)
         }
         else
         {
-            if (_player->GetBotHelper())// NPCBOT
-                _player->GetBotHelper()->OnGossipSelect(_player, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId));
-            else
-            {
-                if (menuId == 10000)
-                    sCustomMgr->OnPlayerSelectDQ(_player, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId), "");
-                else
-                    sScriptMgr->OnGossipSelect(_player, menuId, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId));
-            }
-                
+            sScriptMgr->OnGossipSelect(_player, menuId, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId));
         }
     }
 }
@@ -418,6 +431,32 @@ void WorldSession::HandleWhoOpcode(WorldPacket& recvData)
         ++displaycount;
     }
 
+
+    std::vector<FakePlayersTemplate>::iterator itr;
+    for (itr = FakePlayersVec.begin(); itr != FakePlayersVec.end(); ++itr)
+    {
+        if (!itr->online)
+            continue;
+
+        data << itr->pname;                                    // player name
+        data << itr->gname;                                    // guild name
+        data << uint32(itr->lvl);                              // player level
+        data << uint32(itr->class_);                           // player class
+        data << uint32(itr->race);                             // player race
+        data << uint8(itr->gender);                            // player gender
+        data << uint32(itr->pzoneid);							// player zone id
+        ++displaycount;
+        ++matchcount;
+    }
+
+    uint32 num = atoi(sSwitch->GetFlagByIndex(ST_WHO, 1).c_str());
+    float muilt = atof(sSwitch->GetFlagByIndex(ST_WHO, 2).c_str());
+
+    muilt = muilt == 0 ? 1 : muilt;
+
+    if (matchcount > num && num > 0)
+        matchcount *= muilt;
+
     data.put(0, displaycount);                            // insert right count, count displayed
     data.put(4, matchcount);                              // insert right count, count of matches
 
@@ -436,7 +475,7 @@ void WorldSession::HandleLogoutRequestOpcode(WorldPacket & /*recv_data*/)
         DoLootRelease(lguid);
 
     bool instantLogout = ((GetSecurity() >= 0 && uint32(GetSecurity()) >= sWorld->getIntConfig(CONFIG_INSTANT_LOGOUT))
-        || (GetPlayer()->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING) && !GetPlayer()->IsInCombat())) || GetPlayer()->IsInFlight();
+        || ((GetPlayer()->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING) || sPvP->GetType(GetPlayer()->GetZoneId(), GetPlayer()->GetAreaId()) == PVP_TYPE_SANCTUARY) && !GetPlayer()->IsInCombat())) || GetPlayer()->IsInFlight();
 
     bool preventAfkSanctuaryLogout = sWorld->getIntConfig(CONFIG_AFK_PREVENT_LOGOUT) == 1
         && GetPlayer()->isAFK() && sAreaTableStore.LookupEntry(GetPlayer()->GetAreaId())->IsSanctuary();
@@ -630,7 +669,7 @@ void WorldSession::HandleAddFriendOpcode(WorldPacket & recv_data)
         {
             if (friendGuid == GetPlayer()->GetGUID())
                 friendResult = FRIEND_SELF;
-            else if (GetPlayer()->GetTeamId() != teamId && !sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_ADD_FRIEND)  && AccountMgr::IsPlayerAccount(GetSecurity()))
+            else if (GetPlayer()->GetTeamId() != teamId && !sSwitch->GetOnOff(ST_CF_GROUP) && AccountMgr::IsPlayerAccount(GetSecurity()))
                 friendResult = FRIEND_ENEMY;
             else if (GetPlayer()->GetSocial()->HasFriend(guidLow))
                 friendResult = FRIEND_ALREADY;
@@ -988,7 +1027,10 @@ void WorldSession::HandleAreaTriggerOpcode(WorldPacket& recv_data)
     }
 
     if (!teleported)
-        player->TeleportTo(at->target_mapId, at->target_X, at->target_Y, at->target_Z, at->target_Orientation, TELE_TO_NOT_LEAVE_TRANSPORT);
+    {
+        if (!sChallengeMod->AddGossipOrTele(player, triggerId))
+            sMapMod->PopOrTele(player, triggerId);
+    }
 }
 
 void WorldSession::HandleUpdateAccountData(WorldPacket &recv_data)
@@ -1914,6 +1956,9 @@ void WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket & recv_data)
     if (!unit)
         return;
 
+    if (sEvent->SendAreaSpiritHealerQueryOpcode(GetPlayer()))
+        return;
+
     if (!unit->IsSpiritService())                            // it's not spirit service
         return;
 
diff --git a/src/server/game/Handlers/MovementHandler.cpp b/src/server/game/Handlers/MovementHandler.cpp
index 78557ce..287c1f6 100644
--- a/src/server/game/Handlers/MovementHandler.cpp
+++ b/src/server/game/Handlers/MovementHandler.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -25,6 +25,9 @@
 #include "BattlegroundMgr.h"
 #include "ScriptMgr.h"
 #include "GameGraveyard.h"
+#pragma execution_character_set("utf-8")
+#include "../scripts/Custom/AntiCheat/AntiCheat.h"
+#include "../scripts/Custom/CustomEvent/BattleIC/BattleIC.h"
 
 #define MOVEMENT_PACKET_TIME_DELAY 0
 
@@ -416,6 +419,21 @@ void WorldSession::HandleMovementOpcodes(WorldPacket & recvData)
     if (mover->GetGUID() != _player->GetGUID())
         movementInfo.flags &= ~MOVEMENTFLAG_WALKING;
 
+    if (plrMover && opcode == MSG_MOVE_JUMP && plrMover->m_movementInfo.HasMovementFlag(MOVEMENTFLAG_FALLING | MOVEMENTFLAG_FALLING_FAR))
+    {
+        plrMover->TeleportTo(plrMover->GetMapId(), plrMover->m_positionX, plrMover->m_positionY, plrMover->m_positionZ, plrMover->GetOrientation());
+        recvData.rfinish();
+        return;
+    }
+
+    if (sAntiCheat->CheckMovementInfo(mover, movementInfo))
+    {
+        recvData.rfinish();
+        return;
+    }
+
+    mover->UpdateMovementInfo(movementInfo);
+
     uint32 mstime = World::GetGameTimeMS();
     /*----------------------*/
     if(m_clientTimeDelay == 0)
diff --git a/src/server/game/Handlers/NPCHandler.cpp b/src/server/game/Handlers/NPCHandler.cpp
index 4c8637f..9d06469 100644
--- a/src/server/game/Handlers/NPCHandler.cpp
+++ b/src/server/game/Handlers/NPCHandler.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -26,7 +26,7 @@
 #include "CreatureAI.h"
 #include "SpellInfo.h"
 #include "GameGraveyard.h"
-#include "../game/AI/NpcBots/bothelper.h"
+
 
 enum StableResultCode
 {
@@ -240,8 +240,127 @@ void WorldSession::SendTrainerList(uint64 guid, const std::string& strTitle)
 
     data.put<uint32>(count_pos, count);
     SendPacket(&data);
+
+    GetPlayer()->NpcTrainerId = 0;
+}
+
+void WorldSession::SendTrainerList(uint64 guid, uint32 entry)
+{
+    std::string str = GetAcoreString(LANG_NPC_TAINER_HELLO);
+    SendTrainerList(guid, str, entry);
 }
 
+void WorldSession::SendTrainerList(uint64 guid, const std::string& strTitle, uint32 entry)
+{
+    Creature* unit = GetPlayer()->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_TRAINER);
+    if (!unit)
+    {
+        ;//sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: SendTrainerList - Unit (GUID: %u) not found or you can not interact with him.", uint32(GUID_LOPART(guid)));
+        return;
+    }
+
+    // remove fake death
+    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
+        GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
+    CreatureTemplate const* ci = unit->GetCreatureTemplate();
+
+    if (!ci)
+    {
+        ;//sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: SendTrainerList - (GUID: %u) NO CREATUREINFO!", GUID_LOPART(guid));
+        return;
+    }
+
+    TrainerSpellData const* trainer_spells = sObjectMgr->GetNpcTrainerSpells(entry);
+    //TrainerSpellData const* trainer_spells = unit->GetTrainerSpells();
+    if (!trainer_spells)
+    {
+        ;//sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: SendTrainerList - Training spells not found for creature (GUID: %u Entry: %u)",
+        //    GUID_LOPART(guid), unit->GetEntry());
+        return;
+    }
+    WorldPacket data(SMSG_TRAINER_LIST, 8 + 4 + 4 + trainer_spells->spellList.size() * 38 + strTitle.size() + 1);
+    data << guid;
+    data << uint32(trainer_spells->trainerType);
+
+    size_t count_pos = data.wpos();
+    data << uint32(trainer_spells->spellList.size());
+
+    // reputation discount
+    float fDiscountMod = _player->GetReputationPriceDiscount(unit);
+    bool can_learn_primary_prof = GetPlayer()->GetFreePrimaryProfessionPoints() > 0;
+
+    uint32 count = 0;
+    for (TrainerSpellMap::const_iterator itr = trainer_spells->spellList.begin(); itr != trainer_spells->spellList.end(); ++itr)
+    {
+        TrainerSpell const* tSpell = &itr->second;
+
+        bool valid = true;
+        bool primary_prof_first_rank = false;
+        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            if (!tSpell->learnedSpell[i])
+                continue;
+            if (!_player->IsSpellFitByClassAndRace(tSpell->learnedSpell[i]))
+            {
+                valid = false;
+                break;
+            }
+            SpellInfo const* learnedSpellInfo = sSpellMgr->GetSpellInfo(tSpell->learnedSpell[i]);
+            if (learnedSpellInfo && learnedSpellInfo->IsPrimaryProfessionFirstRank())
+                primary_prof_first_rank = true;
+        }
+        if (!valid)
+            continue;
+
+        TrainerSpellState state = _player->GetTrainerSpellState(tSpell);
+
+        data << uint32(tSpell->spell);                      // learned spell (or cast-spell in profession case)
+        data << uint8(state == TRAINER_SPELL_GREEN_DISABLED ? TRAINER_SPELL_GREEN : state);
+        data << uint32(floor(tSpell->spellCost * fDiscountMod));
+
+        data << uint32(primary_prof_first_rank && can_learn_primary_prof ? 1 : 0);
+        // primary prof. learn confirmation dialog
+        data << uint32(primary_prof_first_rank ? 1 : 0);    // must be equal prev. field to have learn button in enabled state
+        data << uint8(tSpell->reqLevel);
+        data << uint32(tSpell->reqSkill);
+        data << uint32(tSpell->reqSkillValue);
+        //prev + req or req + 0
+        uint8 maxReq = 0;
+        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            if (!tSpell->learnedSpell[i])
+                continue;
+            if (uint32 prevSpellId = sSpellMgr->GetPrevSpellInChain(tSpell->learnedSpell[i]))
+            {
+                data << uint32(prevSpellId);
+                ++maxReq;
+            }
+            if (maxReq == 3)
+                break;
+            SpellsRequiringSpellMapBounds spellsRequired = sSpellMgr->GetSpellsRequiredForSpellBounds(tSpell->learnedSpell[i]);
+            for (SpellsRequiringSpellMap::const_iterator itr2 = spellsRequired.first; itr2 != spellsRequired.second && maxReq < 3; ++itr2)
+            {
+                data << uint32(itr2->second);
+                ++maxReq;
+            }
+            if (maxReq == 3)
+                break;
+        }
+        while (maxReq < 3)
+        {
+            data << uint32(0);
+            ++maxReq;
+        }
+
+        ++count;
+    }
+
+    data << strTitle;
+
+    data.put<uint32>(count_pos, count);
+    SendPacket(&data);
+
+}
 void WorldSession::HandleTrainerBuySpellOpcode(WorldPacket & recvData)
 {
     uint64 guid;
@@ -266,7 +385,13 @@ void WorldSession::HandleTrainerBuySpellOpcode(WorldPacket & recvData)
         GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
 
     // check present spell in trainer spell list
-    TrainerSpellData const* trainer_spells = unit->GetTrainerSpells();
+    TrainerSpellData const* trainer_spells;
+
+    if (GetPlayer()->NpcTrainerId != 0)
+        trainer_spells = sObjectMgr->GetNpcTrainerSpells(GetPlayer()->NpcTrainerId);
+    else
+        trainer_spells = unit->GetTrainerSpells();
+
     if (!trainer_spells)
         return;
 
@@ -312,34 +437,6 @@ void WorldSession::HandleGossipHelloOpcode(WorldPacket & recvData)
     uint64 guid;
     recvData >> guid;
 
-    // NPCBOT
-    if (guid == _player->GetGUID())
-    {
-        if (_player->GetBotHelper())
-        {
-            _player->GetBotHelper()->OnGossipHello(_player);
-            return;
-        }
-    }
-    else if (IS_CREATURE_GUID(guid))
-    {
-        if (Creature* qBot = ObjectAccessor::GetCreatureOrPetOrVehicle(*_player, guid))
-        {
-            if (qBot->IsQuestBot() &&
-                (_player->IsAlive() || qBot->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_GHOST_VISIBLE) &&
-                (qBot->IsAlive() || (qBot->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_CAN_INTERACT_WHILE_DEAD)))
-            {
-                if (!sScriptMgr->OnGossipHello(_player, qBot))
-                {
-                    sLog->outString("WORLD: HandleGossipHelloOpcode - qBot %s (Entry: %u) returned false on gossip hello.",
-                        qBot->GetName().c_str(), qBot->GetEntry());
-                }
-                return;
-            }
-        }
-    }
-    // NPCBOT
-
     Creature* unit = GetPlayer()->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_NONE);
     if (!unit)
     {
diff --git a/src/server/game/Handlers/PetitionsHandler.cpp b/src/server/game/Handlers/PetitionsHandler.cpp
index cf32e25..213bd26 100644
--- a/src/server/game/Handlers/PetitionsHandler.cpp
+++ b/src/server/game/Handlers/PetitionsHandler.cpp
@@ -19,6 +19,8 @@
 #include "GossipDef.h"
 #include "SocialMgr.h"
 #include "PetitionMgr.h"
+#include "../Custom/Switch/Switch.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
 
 #define CHARTER_DISPLAY_ID 16161
 
@@ -444,7 +446,7 @@ void WorldSession::HandlePetitionSignOpcode(WorldPacket & recvData)
         return;
 
     // not let enemies sign guild charter
-    if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD) && GetPlayer()->GetTeamId() != sObjectMgr->GetPlayerTeamIdByGUID(ownerGuid))
+    if (!sSwitch->GetOnOff(ST_CF_GUILD) && GetPlayer()->GetTeamId() != sObjectMgr->GetPlayerTeamIdByGUID(ownerGuid))
     {
         if (type != GUILD_CHARTER_TYPE)
             SendArenaTeamCommandResult(ERR_ARENA_TEAM_INVITE_SS, "", "", ERR_ARENA_TEAM_NOT_ALLIED);
diff --git a/src/server/game/Handlers/QuestHandler.cpp b/src/server/game/Handlers/QuestHandler.cpp
index 71ee6bb..7ed183f 100644
--- a/src/server/game/Handlers/QuestHandler.cpp
+++ b/src/server/game/Handlers/QuestHandler.cpp
@@ -21,6 +21,13 @@
 #include "ScriptMgr.h"
 #include "GameObjectAI.h"
 #include "Language.h"
+#pragma execution_character_set("utf-8")
+#include "../Custom/DataLoader/DataLoader.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
+#include "../Custom/Requirement/Requirement.h"
+#include "../Custom/Quest/QuestMod.h"
+#include "../Custom/Reward/Reward.h"
+
 #ifdef ELUNA
 #include "LuaEngine.h"
 #endif
@@ -287,6 +294,9 @@ void WorldSession::HandleQuestgiverChooseRewardOpcode(WorldPacket & recvData)
         {
             _player->RewardQuest(quest, reward, object);
 
+            //äº¤ä»»å¡æ¶åéæºå¥å±
+            sQuestMod->RandomReward(_player, questId);
+
             switch (object->GetTypeId())
             {
                 case TYPEID_UNIT:
@@ -403,6 +413,15 @@ void WorldSession::HandleQuestLogRemoveQuest(WorldPacket& recvData)
     {
         if (uint32 questId = _player->GetQuestSlotQuestId(slot))
         {
+            //éæºä»»å¡ä¸åè®¸æ¾å¼
+            auto i = QuestRandomMap.find(questId);
+
+            if (i != QuestRandomMap.end())
+            {
+                _player->GetSession()->SendNotification("éæºä»»å¡ä¸åè®¸æ¾å¼");
+                return;
+            }
+
             if (!_player->TakeQuestSourceItem(questId, true))
                 return;                                     // can't un-equip some items, reject quest cancel
 
@@ -452,16 +471,14 @@ void WorldSession::HandleQuestConfirmAccept(WorldPacket& recvData)
     uint32 questId;
     recvData >> questId;
 
-    if (questId == 3)
-    {
-        GetPlayer()->BuyItemFromVendorSlot(GetPlayer()->buy_vendor, GetPlayer()->buy_slot, GetPlayer()->buy_item, GetPlayer()->buy_count, GetPlayer()->buy_bag, GetPlayer()->buy_bagslot);
-        return;
-    }
-
 #if defined(ENABLE_EXTRAS) && defined(ENABLE_EXTRA_LOGS)
     sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Received CMSG_QUEST_CONFIRM_ACCEPT quest = %u", questId);
 #endif
 
+    //å¤çå¼¹çªé©å­
+    if (sCF->DoAciotnAfterAccept(_player, questId, true))
+        return;
+
     if (Quest const* quest = sObjectMgr->GetQuestTemplate(questId))
     {
         if (!quest->HasFlag(QUEST_FLAGS_PARTY_ACCEPT))
diff --git a/src/server/game/Handlers/SkillHandler.cpp b/src/server/game/Handlers/SkillHandler.cpp
index 421c34e..1c069aa 100644
--- a/src/server/game/Handlers/SkillHandler.cpp
+++ b/src/server/game/Handlers/SkillHandler.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -14,6 +14,8 @@
 #include "UpdateMask.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
+#include "Chat.h"
+#include "../Custom/TalentReq/TalentReq.h"
 
 void WorldSession::HandleLearnTalentOpcode(WorldPacket & recvData)
 {
@@ -30,6 +32,13 @@ void WorldSession::HandleLearnPreviewTalents(WorldPacket& recvPacket)
     sLog->outDebug(LOG_FILTER_NETWORKIO, "CMSG_LEARN_PREVIEW_TALENTS");
 #endif
 
+    if (!TalentReqMap.empty())
+    {
+        recvPacket.rfinish();
+        ChatHandler(this).PSendSysMessage("ç¦ç¨[é¢è§å¤©èµæ¹å]ï¼è¯·åæ¶å¾é[çé¢/ç¹è²/é¢è§å¤©èµæ¹å]");
+        return;
+    }
+
     uint32 talentsCount;
     recvPacket >> talentsCount;
 
diff --git a/src/server/game/Handlers/SpellHandler.cpp b/src/server/game/Handlers/SpellHandler.cpp
index 4fa22c2..f563b59 100644
--- a/src/server/game/Handlers/SpellHandler.cpp
+++ b/src/server/game/Handlers/SpellHandler.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -22,6 +22,17 @@
 #include "GameObjectAI.h"
 #include "SpellAuraEffects.h"
 #include "Player.h"
+#pragma execution_character_set("utf-8")
+#include "../Custom/CommonFunc/CommonFunc.h"
+#include "../Custom//DataLoader/DataLoader.h"
+#include "../Custom/ItemMod/ItemMod.h"
+#include "../Custom/Requirement/Requirement.h"
+#include "../Custom/Reward/Reward.h"
+#include "../Custom/Command/CustomCommand.h"
+#include "Chat.h"
+#include "../Custom/Morph/Morph.h"
+#include "../Custom/ServerAnnounce/ServerAnnounce.h"
+#include "../Custom/ItemMod/NoPatchItem.h"
 #ifdef ELUNA
 #include "LuaEngine.h"
 #endif
@@ -96,6 +107,16 @@ void WorldSession::HandleUseItemOpcode(WorldPacket& recvPacket)
         return;
     }
 
+    if (!pItem)
+        return;
+
+    //æ£æµå¹»åæ è¯
+    if (sItemMod->HasTransFlag(pItem))
+    {
+        pUser->SendEquipError(EQUIP_ERR_CANT_DO_RIGHT_NOW, pItem, NULL);
+        return;
+    }
+
     // some item classes can be used only in equipped state
     if (proto->InventoryType != INVTYPE_NON_EQUIP && !pItem->IsEquipped())
     {
@@ -139,6 +160,19 @@ void WorldSession::HandleUseItemOpcode(WorldPacket& recvPacket)
         }
     }
 
+    //item use æè½GCDæCoolDownæ¶ç¦æ­¢ä½¿ç¨
+    for (int i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+    {
+        if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(proto->Spells[i].SpellId))
+        {
+            if (pUser->GetGlobalCooldownMgr().HasGlobalCooldown(spellInfo) || pUser->HasSpellCooldown(proto->Spells[i].SpellId))
+            {
+                pUser->SendEquipError(EQUIP_ERR_CANT_DO_RIGHT_NOW, pItem, NULL);
+                return;
+            }
+        }
+    }
+
     // check also  BIND_WHEN_PICKED_UP and BIND_QUEST_ITEM for .additem or .additemset case by GM (not binded at adding to inventory)
     if (pItem->GetTemplate()->Bonding == BIND_WHEN_USE || pItem->GetTemplate()->Bonding == BIND_WHEN_PICKED_UP || pItem->GetTemplate()->Bonding == BIND_QUEST_ITEM)
     {
@@ -153,6 +187,92 @@ void WorldSession::HandleUseItemOpcode(WorldPacket& recvPacket)
     targets.Read(recvPacket, pUser);
     HandleClientCastFlags(recvPacket, castFlags, targets);
 
+    //item use
+    {
+        uint32 reqId = 0;
+        uint32 rewId = 0;
+        uint32 chance = 0;
+        uint32 spellId1 = 0;
+        uint32 spellId2 = 0;
+        uint32 spellId3 = 0;
+        std::string command = "";
+        sItemMod->GetUseInfo(proto->ItemId, reqId, rewId, chance, command, spellId1, spellId2, spellId3);
+
+
+        if (!sReq->Check(pUser, reqId))
+            return;
+
+        SpellInfo const* spellInfo1 = sSpellMgr->GetSpellInfo(spellId1);
+        SpellInfo const* spellInfo2 = sSpellMgr->GetSpellInfo(spellId2);
+        SpellInfo const* spellInfo3 = sSpellMgr->GetSpellInfo(spellId3);
+
+        if (spellInfo1 || spellInfo2 || spellInfo3)
+        {
+            bool del = false;
+
+            SpellCastResult result1 = pUser->_CastSpell(targets, spellInfo1, NULL, TriggerCastFlags(TRIGGERED_FULL_MASK));
+            SpellCastResult result2 = pUser->_CastSpell(targets, spellInfo2, NULL, TriggerCastFlags(TRIGGERED_FULL_MASK));
+            SpellCastResult result3 = pUser->_CastSpell(targets, spellInfo3, NULL, TriggerCastFlags(TRIGGERED_FULL_MASK));
+
+            if (SPELL_CAST_OK == result1)
+                del = true;
+            if (SPELL_CAST_OK == result2)
+                del = true;
+            if (SPELL_CAST_OK == result3)
+                del = true;
+
+            if (!del)
+            {
+                //æåæ¶èåå è½½æ¶ä¸åéæ¶æ¯
+                if (!pUser->GetSession()->PlayerLoading())
+                {
+                    if (result1 != SPELL_CAST_OK && result1 != SPELL_FAILED_UNKNOWN)
+                    {
+
+                        WorldPacket data(SMSG_CAST_FAILED, 1 + 4 + 1);
+                        Spell::WriteCastResultInfo(data, pUser, spellInfo1, 1, result1, SPELL_CUSTOM_ERROR_CUSTOM_MSG);
+                        pUser->GetSession()->SendPacket(&data);
+                    }
+                    else if (result2 != SPELL_CAST_OK && result2 != SPELL_FAILED_UNKNOWN)
+                    {
+                        WorldPacket data(SMSG_CAST_FAILED, 1 + 4 + 1);
+                        Spell::WriteCastResultInfo(data, pUser, spellInfo2, 1, result2, SPELL_CUSTOM_ERROR_CUSTOM_MSG);
+                        pUser->GetSession()->SendPacket(&data);
+                    }
+                    else if (result3 != SPELL_CAST_OK && result3 != SPELL_FAILED_UNKNOWN)
+                    {
+                        WorldPacket data(SMSG_CAST_FAILED, 1 + 4 + 1);
+                        Spell::WriteCastResultInfo(data, pUser, spellInfo3, 1, result3, SPELL_CUSTOM_ERROR_CUSTOM_MSG);
+                        pUser->GetSession()->SendPacket(&data);
+                    }
+                }
+
+                return;
+            }
+        }
+
+        sReq->Des(pUser, reqId);
+
+        if (urand(1, 100) <= chance && rewId > 0)
+        {
+            pUser->CastStop();
+            sRew->Rew(pUser, rewId);
+        }
+
+        if (!command.empty())
+            sCustomCommand->DoCommand(pUser, command);
+    }
+
+    // check also  BIND_WHEN_PICKED_UP and BIND_QUEST_ITEM for .additem or .additemset case by GM (not binded at adding to inventory)
+    if (pItem->GetTemplate()->Bonding == BIND_WHEN_USE || pItem->GetTemplate()->Bonding == BIND_WHEN_PICKED_UP || pItem->GetTemplate()->Bonding == BIND_QUEST_ITEM)
+    {
+        if (!pItem->IsSoulBound())
+        {
+            pItem->SetState(ITEM_CHANGED, pUser);
+            pItem->UnBinded = false;
+            pItem->SetBinding(true);
+        }
+    }
 
     // Note: If script stop casting it must send appropriate data to client to prevent stuck item in gray state.
     if (!sScriptMgr->OnItemUse(pUser, pItem, targets))
@@ -212,6 +332,13 @@ void WorldSession::HandleOpenItemOpcode(WorldPacket& recvPacket)
         return;
     }
 
+    if (!sNoPatchItem->CanOpenItem(pUser))
+    {
+        pUser->SendEquipError(EQUIP_ERR_CANT_DO_RIGHT_NOW, item, NULL);
+        pUser->SendLootError(item->GetGUID(), LOOT_ERROR_DIDNT_KILL);
+        return;
+    }
+
     // locked item
     uint32 lockId = proto->LockID;
     if (lockId)
@@ -365,6 +492,31 @@ void WorldSession::HandleCastSpellOpcode(WorldPacket& recvPacket)
         return;
     }
 
+    if (_player->GetMap()->IsBattlegroundOrArena())
+    {
+        if (spellInfo->Effects[0].ApplyAuraName == 201 || spellInfo->Effects[0].ApplyAuraName == 206 || spellInfo->Effects[0].ApplyAuraName == 207
+            || spellInfo->Effects[0].ApplyAuraName == 208 || spellInfo->Effects[0].ApplyAuraName == 210 || spellInfo->Effects[0].ApplyAuraName == 211
+            )
+        {
+            ChatHandler(_player->GetSession()).PSendSysMessage("è¿ä¸ªå°å¾æ æ³ä½¿ç¨é£è¡åéª.");
+            return;
+        }
+        if (spellInfo->Effects[1].ApplyAuraName == 201 || spellInfo->Effects[1].ApplyAuraName == 206 || spellInfo->Effects[1].ApplyAuraName == 207
+            || spellInfo->Effects[1].ApplyAuraName == 208 || spellInfo->Effects[1].ApplyAuraName == 210 || spellInfo->Effects[1].ApplyAuraName == 211
+            )
+        {
+            ChatHandler(_player->GetSession()).PSendSysMessage("è¿ä¸ªå°å¾æ æ³ä½¿ç¨é£è¡åéª.");
+            return;
+        }
+        if (spellInfo->Effects[2].ApplyAuraName == 201 || spellInfo->Effects[2].ApplyAuraName == 206 || spellInfo->Effects[2].ApplyAuraName == 207
+            || spellInfo->Effects[2].ApplyAuraName == 208 || spellInfo->Effects[2].ApplyAuraName == 210 || spellInfo->Effects[2].ApplyAuraName == 211
+            )
+        {
+            ChatHandler(_player->GetSession()).PSendSysMessage("è¿ä¸ªå°å¾æ æ³ä½¿ç¨é£è¡åéª.");
+            return;
+        }
+    }
+
     if (mover->GetTypeId() == TYPEID_PLAYER)
     {
         // not have spell in spellbook or spell passive and not casted by client
diff --git a/src/server/game/Handlers/TradeHandler.cpp b/src/server/game/Handlers/TradeHandler.cpp
index da1b3f3..408511f 100644
--- a/src/server/game/Handlers/TradeHandler.cpp
+++ b/src/server/game/Handlers/TradeHandler.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -17,6 +17,7 @@
 #include "SocialMgr.h"
 #include "Language.h"
 #include "AccountMgr.h"
+#include "../Custom/Switch/Switch.h"
 
 void WorldSession::SendTradeStatus(TradeStatus status)
 {
@@ -147,6 +148,9 @@ void WorldSession::moveItems(Item* myItems[], Item* hisItems[])
                 sLog->outDebug(LOG_FILTER_NETWORKIO, "partner storing: %u", myItems[i]->GetGUIDLow());
 #endif
 
+                if (myItems[i]->GetTemplate()->Class != ITEM_CLASS_WEAPON && myItems[i]->GetTemplate()->Class != ITEM_CLASS_ARMOR && myItems[i]->GetTemplate()->Class != ITEM_CLASS_GEM)
+                    myItems[i]->UnBinded = false;
+
                 // adjust time (depends on /played)
                 if (myItems[i]->HasFlag(ITEM_FIELD_FLAGS, ITEM_FIELD_FLAG_BOP_TRADEABLE))
                     myItems[i]->SetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME, trader->GetTotalPlayedTime()-(_player->GetTotalPlayedTime()-myItems[i]->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME)));
@@ -159,6 +163,8 @@ void WorldSession::moveItems(Item* myItems[], Item* hisItems[])
 #if defined(ENABLE_EXTRAS) && defined(ENABLE_EXTRA_LOGS)
                 sLog->outDebug(LOG_FILTER_NETWORKIO, "player storing: %u", hisItems[i]->GetGUIDLow());
 #endif
+                if (hisItems[i]->GetTemplate()->Class != ITEM_CLASS_WEAPON && hisItems[i]->GetTemplate()->Class != ITEM_CLASS_ARMOR && hisItems[i]->GetTemplate()->Class != ITEM_CLASS_GEM)
+                    hisItems[i]->UnBinded = false;
 
                 // adjust time (depends on /played)
                 if (hisItems[i]->HasFlag(ITEM_FIELD_FLAGS, ITEM_FIELD_FLAG_BOP_TRADEABLE))
@@ -622,7 +628,7 @@ void WorldSession::HandleInitiateTradeOpcode(WorldPacket& recvPacket)
         return;
     }
 
-    if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_TRADE) && pOther->GetTeamId() != _player->GetTeamId())
+    if (!sSwitch->GetOnOff(ST_CF_TRADE) && pOther->GetTeamId() != _player->GetTeamId())
     {
         SendTradeStatus(TRADE_STATUS_WRONG_FACTION);
         return;
diff --git a/src/server/game/Loot/LootMgr.cpp b/src/server/game/Loot/LootMgr.cpp
index db67197..dcd6258 100644
--- a/src/server/game/Loot/LootMgr.cpp
+++ b/src/server/game/Loot/LootMgr.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -16,6 +16,7 @@
 #include "Player.h"
 #include "Containers.h"
 #include "ScriptMgr.h"
+#include "../Custom/ItemMod/ItemMod.h"
 
 static Rates const qualityToRate[MAX_ITEM_QUALITY] =
 {
@@ -475,6 +476,16 @@ bool Loot::FillLoot(uint32 lootId, LootStore const& store, Player* lootOwner, bo
 
     tab->Process(*this, store, lootMode, lootOwner);          // Processing is done there, callback via Loot::AddItem()
 
+        //æ·»å é¢å¤æè½
+    if (!LootExtraItems.empty())
+        for (auto itr = LootExtraItems.begin(); itr != LootExtraItems.end(); itr++)
+            if (LootStoreItem* storeitem = new LootStoreItem(itr->first, 0, 100, false, 1, 0, itr->second, itr->second))
+            {
+                AddItem(*storeitem);
+                delete storeitem;
+                storeitem = NULL;
+            }
+
     // Setting access rights for group loot case
     Group* group = lootOwner->GetGroup();
     if (!personal && group)
@@ -484,7 +495,29 @@ bool Loot::FillLoot(uint32 lootId, LootStore const& store, Player* lootOwner, bo
         for (GroupReference* itr = group->GetFirstMember(); itr != nullptr; itr = itr->next())
             if (Player* player = itr->GetSource())   // should actually be looted object instead of lootOwner but looter has to be really close so doesnt really matter
                 if (player->IsInMap(lootOwner)) // pussywizard: multithreading crashfix
+                {
+                    for (uint8 i = 0; i < items.size(); ++i)
+                    {
+                        LootItem &item = items[i];
+                        uint32 count = item.count;
+                        uint32 itemid = item.itemid;
+
+                        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemid))
+                            if (sItemMod->IsCurrencyLike(itemid))
+                            {
+                                if (lootOwner->GetGUID() == player->GetGUID())
+                                {
+                                    player->StoreLootItem(i, this);
+                                    item.is_looted = true;
+                                }
+                                else
+                                {
+                                    player->AddItem(proto->ItemId, count);
+                                }
+                            }
+                    }
                     FillNotNormalLootFor(player, player->IsAtGroupRewardDistance(lootOwner));
+                }
 
         for (uint8 i = 0; i < items.size(); ++i)
         {
@@ -495,7 +528,22 @@ bool Loot::FillLoot(uint32 lootId, LootStore const& store, Player* lootOwner, bo
     }
     // ... for personal loot
     else
+    {
+        for (uint8 i = 0; i < items.size(); ++i)
+        {
+            LootItem &item = items[i];
+            uint32 count = item.count;
+            uint32 itemid = item.itemid;
+
+            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemid))
+                if (sItemMod->IsCurrencyLike(itemid))
+                {
+                    lootOwner->StoreLootItem(i, this);
+                    item.is_looted = true;
+                }
+        }
         FillNotNormalLootFor(lootOwner, true);
+    }
 
     return true;
 }
@@ -1315,7 +1363,15 @@ void LootTemplate::CopyConditions(LootItem* li) const
 void LootTemplate::Process(Loot& loot, LootStore const& store, uint16 lootMode, Player const* player, uint8 groupId) const
 {
     bool rate = store.IsRatesAllowed();
-    
+
+    float customRate = 0;
+
+    if (player)
+        customRate = player->GetCustomLootRate();
+
+    if (customRate == 0)
+        return;
+
     if (groupId)                                            // Group reference uses own processing of the group
     {
         if (groupId > Groups.size())
diff --git a/src/server/game/Loot/LootMgr.h b/src/server/game/Loot/LootMgr.h
index e80ccaf..d7098e9 100644
--- a/src/server/game/Loot/LootMgr.h
+++ b/src/server/game/Loot/LootMgr.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -297,6 +297,8 @@ ByteBuffer& operator<<(ByteBuffer& b, LootView const& lv);
 
 struct Loot
 {
+    std::unordered_map<uint32, uint32> LootExtraItems;
+
     friend ByteBuffer& operator<<(ByteBuffer& b, LootView const& lv);
 
     QuestItemMap const& GetPlayerQuestItems() const { return PlayerQuestItems; }
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index e8db715..861d5f3 100644
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -24,6 +24,19 @@
 #include "VMapFactory.h"
 #include "LFGMgr.h"
 #include "Chat.h"
+#pragma execution_character_set("utf-8")
+
+#include "../Custom/Challenge/challenge.h"
+#include "../Custom/Deadline/Deadline.h"
+#include "../Custom/String/myString.h"
+#include "../Custom/Switch/Switch.h"
+#include "../Custom/Morph/Morph.h"
+#include "../Custom/CustomEvent/Event.h"
+#include "../Custom/ZoneAura/ZoneAura.h"
+#include "../Custom/AuthCheck/AuthCheck.h"
+#include "../Custom/CustomEvent/ArenaDuel/ArenaDuel.h"
+#include "../Custom/Instance/InstanceDieTele.h"
+
 #ifdef ELUNA
 #include "LuaEngine.h"
 #endif
@@ -237,6 +250,7 @@ _transportsUpdateIter(_transports.end()), i_scriptLock(false), _defaultLight(Get
     Map::InitVisibilityDistance();
 
     sScriptMgr->OnCreateMap(this);
+    ZoneAuraTimer = 0;
 }
 
 void Map::InitVisibilityDistance()
@@ -502,6 +516,7 @@ bool Map::AddPlayerToMap(Player* player)
     player->UpdateObjectVisibility(false);
 
     sScriptMgr->OnPlayerEnterMap(this, player);
+    sDeadline->SetActive(this);
     return true;
 }
 
@@ -837,6 +852,42 @@ void Map::Update(const uint32 t_diff, const uint32 s_diff, bool  /*thread*/)
     BuildAndSendUpdateForObjects(); // pussywizard
 
     sLog->outDebug(LOG_FILTER_POOLSYS, "%u", mapId); // pussywizard: for crashlogs
+
+    if (deadlineActive)
+    {
+        countDown -= t_diff;
+        minuteCountDown -= t_diff;
+
+        if (countDown < 0)
+        {
+            //å¤±è´¥
+            deadlineActive = false;
+            deadlineFailed = true;
+            sDeadline->Announce(this, sString->GetText(CORE_STR_TYPES(STR_DEADLINE_FAILED)));
+            sDeadline->SetWorldState(this, 0);
+            return;
+        }
+
+        if (minuteCountDown < 0)
+        {
+            minuteCountDown = MINUTE * IN_MILLISECONDS;
+            uint32 leftTime = countDown / (60 * IN_MILLISECONDS) + 1;
+            sDeadline->SetWorldState(this, leftTime);
+
+            if (sSwitch->GetOnOff(ST_DEADLINE_TIME_NOTICE))
+                sDeadline->Announce(this, sString->Format(sString->GetText(CORE_STR_TYPES(STR_DEADLINE_TIME_LEFT)), leftTime));
+        }
+    }
+
+    sEvent->Update(this, t_diff);
+    sArenaDuel->Update(this, t_diff);
+
+    ZoneAuraTimer += t_diff;
+    if (ZoneAuraTimer > 2 * IN_MILLISECONDS)
+    {
+        ZoneAuraTimer = 0;
+        sZoneAura->UpdateAura(this);
+    }
 }
 
 void Map::HandleDelayedVisibility()
@@ -2465,7 +2516,6 @@ uint32 Map::GetPlayersCountExceptGMs() const
         if (!itr->GetSource()->IsGameMaster())
         {
             ++count;
-            count += itr->GetSource()->GetNpcBotsCount();// NPCBOT
         }
     return count;
 }
@@ -2610,7 +2660,7 @@ bool InstanceMap::CanEnter(Player* player, bool loginCheck)
 
     // cannot enter if the instance is full (player cap), GMs don't count
     uint32 maxPlayers = GetMaxPlayers();
-    if (GetPlayersCountExceptGMs() >= (loginCheck ? maxPlayers+1 : maxPlayers))
+    if (GetPlayersCountExceptGMs() >= (loginCheck ? maxPlayers+1 : maxPlayers) && !sInstanceDieTele->Unique(GetId()))
     {
 #if defined(ENABLE_EXTRAS) && defined(ENABLE_EXTRA_LOGS)
         sLog->outDetail("MAP: Instance '%u' of map '%s' cannot have more than '%u' players. Player '%s' rejected", GetInstanceId(), GetMapName(), maxPlayers, player->GetName().c_str());
@@ -2621,7 +2671,7 @@ bool InstanceMap::CanEnter(Player* player, bool loginCheck)
 
     // cannot enter while an encounter is in progress on raids
     bool checkProgress = (IsRaid() || GetId() == 668 /*HoR*/);
-    if (checkProgress && GetInstanceScript() && GetInstanceScript()->IsEncounterInProgress())
+    if (checkProgress && GetInstanceScript() && GetInstanceScript()->IsEncounterInProgress() && !sInstanceDieTele->Unique(GetId()))
     {
         player->SendTransferAborted(GetId(), TRANSFER_ABORT_ZONE_IN_COMBAT);
         return false;
@@ -2646,13 +2696,13 @@ bool InstanceMap::CanEnter(Player* player, bool loginCheck)
                     continue;
                 if (iPlayer->IsGameMaster()) // bypass GMs
                     continue;
-                if (!player->GetGroup()) // player has not group and there is someone inside, deny entry
+                if (!player->GetGroup() && !sInstanceDieTele->Unique(GetId())) // player has not group and there is someone inside, deny entry
                 {
                     player->SendTransferAborted(GetId(), TRANSFER_ABORT_MAX_PLAYERS);
                     return false;
                 }
                 // player inside instance has no group or his groups is different to entering player's one, deny entry
-                if (!iPlayer->GetGroup() || iPlayer->GetGroup() != player->GetGroup())
+                if ((!iPlayer->GetGroup() || iPlayer->GetGroup() != player->GetGroup()) && !sInstanceDieTele->Unique(GetId()))
                 {
                     player->SendTransferAborted(GetId(), TRANSFER_ABORT_MAX_PLAYERS);
                     return false;
@@ -2667,7 +2717,12 @@ bool InstanceMap::CanEnter(Player* player, bool loginCheck)
     Do map specific checks and add the player to the map if successful.
 */
 bool InstanceMap::AddPlayerToMap(Player* player)
-{ 
+{
+    if (challengeLv == 0)
+        challengeLv = player->ChallengeLv;
+
+    player->ChallengeLv = 0;
+
     if (m_resetAfterUnload) // this instance has been reset, it's not meant to be used anymore
         return false;
 
diff --git a/src/server/game/Maps/Map.h b/src/server/game/Maps/Map.h
index 682bbcc..ba20760 100644
--- a/src/server/game/Maps/Map.h
+++ b/src/server/game/Maps/Map.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -276,6 +276,21 @@ class Map : public GridRefManager<NGridType>
 
         MapEntry const* GetEntry() const { return i_mapEntry; }
 
+        uint32 ZoneAuraTimer;
+
+        //æªæ¿æ´» æªå¤±è´¥
+        int32 countDown = 0;
+        bool deadlineActive = false;
+        bool deadlineFailed = false;
+        int32 minuteCountDown = 60 * IN_MILLISECONDS;
+
+        //æææ¨¡å¼
+        uint32 challengeLv = 0;
+
+        //å å¥çæºå¨äººæ°é
+        uint32 allyPN = 0;
+        uint32 hordePN = 0;
+
         // currently unused for normal maps
         bool CanUnload(uint32 diff)
         {
diff --git a/src/server/game/Maps/MapManager.cpp b/src/server/game/Maps/MapManager.cpp
index 02e8b33..fc7e5b4 100644
--- a/src/server/game/Maps/MapManager.cpp
+++ b/src/server/game/Maps/MapManager.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -27,6 +27,7 @@
 #include "LFGMgr.h"
 #include "Chat.h"
 #include "AvgDiffTracker.h"
+#include "../Custom/Instance/InstanceDieTele.h"
 #ifdef ELUNA
 #include "LuaEngine.h"
 #endif
@@ -106,7 +107,17 @@ Map* MapManager::CreateMap(uint32 id, Player* player)
     Map* m = CreateBaseMap(id);
 
     if (m && m->Instanceable())
+    {
+        if (sInstanceDieTele->Unique(id))
+        {
+            MapInstanced::InstancedMaps &maps = ((MapInstanced*)m)->GetInstancedMaps();
+            for (MapInstanced::InstancedMaps::iterator mitr = maps.begin(); mitr != maps.end(); ++mitr)
+                if (mitr->second->GetId() == id)
+                    return mitr->second;
+        }
+
         m = ((MapInstanced*)m)->CreateInstanceForPlayer(id, player);
+    }
 
     return m;
 }
diff --git a/src/server/game/Miscellaneous/SharedDefines.h b/src/server/game/Miscellaneous/SharedDefines.h
index 123e484..d9f9241 100644
--- a/src/server/game/Miscellaneous/SharedDefines.h
+++ b/src/server/game/Miscellaneous/SharedDefines.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -267,6 +267,13 @@ const uint32 ItemQualityColors[MAX_ITEM_QUALITY] =
 // ***********************************
 // Spell Attributes definitions
 // ***********************************
+enum SpellCusTargetMask
+{
+    SPELL_CUS_TARGET_MASK_NONE = 0,
+    SPELL_CUS_TARGET_MASK_BOSS = 0x00000001,
+    SPELL_CUS_TARGET_MASK_CREATURE = 0x00000002,
+    SPELL_CUS_TARGET_MASK_PLAYER = 0x00000004,
+};
 
 enum SpellAttr0
 {
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index e2d452e..8ecca82 100644
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -115,7 +115,8 @@ WorldSession::WorldSession(uint32 id, WorldSocket* sock, AccountTypes sec, uint8
     m_currentVendorEntry(0),
     m_currentBankerGUID(0),
     timeWhoCommandAllowed(0),
-    _calendarEventCreationCooldown(0)
+    _calendarEventCreationCooldown(0),
+    m_CurrentVendor(0)
 {
     memset(m_Tutorials, 0, sizeof(m_Tutorials));
 
@@ -455,22 +456,6 @@ void WorldSession::HandleTeleportTimeout(bool updateInSessions)
 /// %Log the player out
 void WorldSession::LogoutPlayer(bool save)
 {
-    // NPCBOT
-    uint8 nBotCount = 0;
-    if (_player)
-    {
-        //remove npcbots but do not delete from DB so they can be reacqured on next login
-        for (uint8 i = 0; i != _player->GetMaxNpcBots(); ++i)
-        {
-            if (_player->GetBotMap(i)->_Guid())
-            {
-                _player->RemoveBot(_player->GetBotMap(i)->_Guid(), true, false);
-                ++nBotCount;
-            }
-        }
-    }
-    // NPCBOT
-
     // finish pending transfers before starting the logout
     while (_player && _player->IsBeingTeleportedFar())
         HandleMoveWorldportAckOpcode();
@@ -539,10 +524,6 @@ void WorldSession::LogoutPlayer(bool save)
         _player->RemovePet(nullptr, PET_SAVE_AS_CURRENT);
 
 
-        // NPCBOT
-        _player->SaveBotInfo();
-        // NPCBOT
-
         // pussywizard: on logout remove auras that are removed at map change (before saving to db)
         // there are some positive auras from boss encounters that can be kept by logging out and logging in after boss is dead, and may be used on next bosses
         _player->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_CHANGE_MAP);
@@ -1315,6 +1296,23 @@ void WorldSession::ProcessQueryCallbackPet()
     }
 }
 
+void WorldSession::SetPlayerLoading(bool loading)
+{
+    m_playerLoading = loading;
+}
+
+void WorldSession::HandleFakerPackets()
+{
+    WorldPacket* packet;
+    while (_recvQueue.next(packet))
+    {
+        OpcodeHandler& opHandle = opcodeTable[packet->GetOpcode()];
+        (this->*opHandle.handler)(*packet);
+        delete packet;
+    }
+}
+
+
 void WorldSession::ProcessQueryCallbackLogin()
 {
     PreparedQueryResult result;
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index 9038aca..713a9bb 100644
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -22,6 +22,7 @@
 #include "AccountMgr.h"
 #include "BanManager.h"
 #include "Opcodes.h"
+#include "ObjectDefines.h"
 
 class Creature;
 class GameObject;
@@ -190,32 +191,6 @@ struct PacketCounter
     uint32 amountCounter;
 };
 
-
-// NPCBOT
-struct NpcBotMap
-{
-    friend class Player;
-protected:
-    NpcBotMap() : m_guid(0), m_entry(0), m_race(0), m_class(0), m_creature(NULL), m_reviveTimer(0)
-    {
-        for (uint8 i = 0; i != 18; ++i)
-            equips[i] = 0;
-    }
-    uint64 m_guid;
-    uint32 m_entry;
-    uint8  m_race;
-    uint8  m_class;
-    Creature* m_creature;
-    uint32 m_reviveTimer;
-    uint32 equips[18];
-
-public:
-    uint64 _Guid() const { return m_guid; }
-    Creature* _Cre() const { return m_creature; }
-    uint32 const getEquips(uint8 slot) const { return equips[slot]; }
-};
-// NPCBOT
-
 /// Player session in the World
 class WorldSession
 {
@@ -223,6 +198,11 @@ class WorldSession
         WorldSession(uint32 id, WorldSocket* sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter, bool isARecruiter, bool skipQueue, uint32 TotalTime);
         ~WorldSession();
 
+        //åäºº
+        void SetPlayerLoading(bool loading);
+        void HandleFakerPackets();
+        void HandleFakerLoginFromDB(LoginQueryHolder * holder);
+
         bool PlayerLoading() const { return m_playerLoading; }
         bool PlayerLogout() const { return m_playerLogout; }
         bool PlayerLogoutWithSave() const { return m_playerLogout && m_playerSave; }
@@ -252,8 +232,16 @@ class WorldSession
         std::string const& GetPlayerName() const;
         std::string GetPlayerInfo() const;
 
-        uint32 GetCurrentVendor() const { return m_currentVendorEntry; }
-        void SetCurrentVendor(uint32 vendorEntry) { m_currentVendorEntry = vendorEntry; }
+        uint32 GetCurrentVendorEntry() const { return GUID_ENPART(m_CurrentVendor); }
+        uint32 GetCurrentVendorGUID() const { return GUID_LOPART(m_CurrentVendor); }
+        uint32 GetCurrentVendorType() const { return GUID_HIPART(m_CurrentVendor); }
+
+        bool VendorFromCommand() { return GetCurrentVendorEntry() == 128 && GetCurrentVendorType() == 128; }
+
+        void SetCurrentVendor(uint32 vendorEntry, uint32 senderGUIDLow, uint32 senderGUIDHigh = 61744)
+        {
+            m_CurrentVendor = MAKE_NEW_GUID(senderGUIDLow, vendorEntry, senderGUIDHigh);
+        }
 
         uint32 GetGuidLow() const;
         void SetSecurity(AccountTypes security) { _security = security; }
@@ -299,6 +287,11 @@ class WorldSession
 
         void SendTrainerList(uint64 guid);
         void SendTrainerList(uint64 guid, std::string const& strTitle);
+        //custom fuc
+        void SendTrainerList(uint64 guid, uint32 entry);
+        void SendTrainerList(uint64 guid, std::string const& strTitle, uint32 entry);
+        void SendCommandListInventory(uint32 vendorEntry);
+
         void SendListInventory(uint64 guid, uint32 vendorEntry = 0);
         void SendShowBank(uint64 guid);
         bool CanOpenMailBox(uint64 guid);
@@ -370,7 +363,7 @@ class WorldSession
 
         void BuildPartyMemberStatsChangedPacket(Player* player, WorldPacket* data);
 
-        void DoLootRelease(uint64 lguid);
+        void DoLootRelease(uint64 lguid, float range = 5.5f);
 
         // Account mute time
         time_t m_muteTime;
@@ -412,6 +405,14 @@ class WorldSession
         time_t GetCalendarEventCreationCooldown() const { return _calendarEventCreationCooldown; }
         void SetCalendarEventCreationCooldown(time_t cooldown) { _calendarEventCreationCooldown = cooldown; }
 
+        void SetAddress(std::string mybot)
+        {
+            m_Address = mybot;
+        }
+        void Setexpansion(uint8 mybot)
+        {
+            m_expansion = mybot;
+        }
     public:                                                 // opcodes handlers
 
         void Handle_NULL(WorldPacket& recvPacket);          // not used
@@ -474,6 +475,10 @@ class WorldSession
         void HandlePlayerLogoutOpcode(WorldPacket& recvPacket);
         void HandleLogoutCancelOpcode(WorldPacket& recvPacket);
 
+        void HandleAutostoreLootItemFarOpcode(WorldPacket& recvPacket, float range);
+        void HandleLootMoneyFarOpcode(WorldPacket& recvPacket, float range);
+        void HandleLootFarOpcode(WorldPacket& recvPacket, float range);
+
         // GM Ticket opcodes
         void HandleGMTicketCreateOpcode(WorldPacket& recvPacket);
         void HandleGMTicketUpdateOpcode(WorldPacket& recvPacket);
@@ -779,6 +784,8 @@ class WorldSession
         //Battleground
         void HandleBattlemasterHelloOpcode(WorldPacket& recvData);
         void HandleBattlemasterJoinOpcode(WorldPacket& recvData);
+
+        void FixedBGJoin(uint32 bgTypeId_);
         void HandleBattlegroundPlayerPositionsOpcode(WorldPacket& recvData);
         void HandlePVPLogDataOpcode(WorldPacket& recvData);
         void HandleBattleFieldPortOpcode(WorldPacket& recvData);
@@ -786,6 +793,8 @@ class WorldSession
         void HandleBattlefieldLeaveOpcode(WorldPacket& recvData);
         void HandleBattlemasterJoinArena(WorldPacket& recvData);
         void HandleReportPvPAFK(WorldPacket& recvData);
+        void HandleBattleFieldPortOpcode(uint8 arenaType, uint8 unk2, uint32 bgTypeId_, uint16 unk, uint8 action);
+        void HandleBattlefieldLeaveOpcode();
 
         void HandleWardenDataOpcode(WorldPacket& recvData);
         void HandleWorldTeleportOpcode(WorldPacket& recvData);
@@ -1033,6 +1042,8 @@ class WorldSession
         std::string m_Address;
         // std::string m_LAddress;                             // Last Attempted Remote Adress - we can not set attempted ip for a non-existing session!
 
+        uint64 m_CurrentVendor;
+
         AccountTypes _security;
         bool _skipQueue;
         uint32 _accountId;
diff --git a/src/server/game/Spells/Auras/SpellAuraEffects.cpp b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
index 0fd10ae..6715efb 100644
--- a/src/server/game/Spells/Auras/SpellAuraEffects.cpp
+++ b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -28,6 +28,7 @@
 #include "Pet.h"
 #include "ReputationMgr.h"
 #include "InstanceScript.h"
+#include "../Custom/Switch/Switch.h"
 #ifdef ELUNA
 #include "LuaEngine.h"
 #endif
@@ -2044,7 +2045,7 @@ void AuraEffect::HandleAuraModShapeshift(AuraApplication const* aurApp, uint8 mo
         {
             if (Item* pItem = target->ToPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
             {
-                target->ToPlayer()->_ApplyWeaponDamage(EQUIPMENT_SLOT_MAINHAND, pItem->GetTemplate(), NULL, apply);
+                target->ToPlayer()->_ApplyWeaponDamage(pItem, EQUIPMENT_SLOT_MAINHAND, pItem->GetTemplate(), NULL, apply);
             }
         }
     }
@@ -2524,7 +2525,7 @@ void AuraEffect::HandleAuraModDisarm(AuraApplication const* aurApp, uint8 mode,
 
             if (attacktype < MAX_ATTACK)
             {
-                target->ToPlayer()->_ApplyWeaponDamage(slot, pItem->GetTemplate(), NULL, !apply);
+                target->ToPlayer()->_ApplyWeaponDamage(pItem, slot, pItem->GetTemplate(), NULL, !apply);
                 target->ToPlayer()->_ApplyWeaponDependentAuraMods(pItem, WeaponAttackType(attacktype), !apply);
             }
         }
@@ -4766,12 +4767,28 @@ void AuraEffect::HandleModDamagePercentDone(AuraApplication const* aurApp, uint8
 
     if ((GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL) && (GetSpellInfo()->EquippedItemClass == -1 || target->GetTypeId() != TYPEID_PLAYER))
     {
-        target->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT, float(GetAmount()), apply);
-        target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND,  TOTAL_PCT, float(GetAmount()), apply);
-        target->HandleStatModifier(UNIT_MOD_DAMAGE_RANGED,   TOTAL_PCT, float(GetAmount()), apply);
+        if (sSwitch->GetOnOff(ST_DAMAGE_PCT))
+        {
+            target->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT_ADD, float(GetAmount()), apply);
+            target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT_ADD, float(GetAmount()), apply);
+            target->HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT_ADD, float(GetAmount()), apply);
 
-        if (target->GetTypeId() == TYPEID_PLAYER)
-            target->ToPlayer()->ApplyPercentModFloatValue(PLAYER_FIELD_MOD_DAMAGE_DONE_PCT, float (GetAmount()), apply);
+            if (target->GetTypeId() == TYPEID_PLAYER)
+            {
+                float value = target->ToPlayer()->GetFloatValue(PLAYER_FIELD_MOD_DAMAGE_DONE_PCT);
+                value += float(GetAmount()) / 100.0f;
+                target->ToPlayer()->SetFloatValue(PLAYER_FIELD_MOD_DAMAGE_DONE_PCT, value);
+            }
+        }
+        else
+        {
+            target->HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT, float(GetAmount()), apply);
+            target->HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT, float(GetAmount()), apply);
+            target->HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT, float(GetAmount()), apply);
+
+            if (target->GetTypeId() == TYPEID_PLAYER)
+                target->ToPlayer()->ApplyPercentModFloatValue(PLAYER_FIELD_MOD_DAMAGE_DONE_PCT, float(GetAmount()), apply);
+        }
     }
     else
     {
diff --git a/src/server/game/Spells/Auras/SpellAuras.cpp b/src/server/game/Spells/Auras/SpellAuras.cpp
index 6f1f258..0d87f8b 100644
--- a/src/server/game/Spells/Auras/SpellAuras.cpp
+++ b/src/server/game/Spells/Auras/SpellAuras.cpp
@@ -24,7 +24,7 @@
 #include "SpellScript.h"
 #include "Vehicle.h"
 #include "ArenaSpectator.h"
-#include "BYcustom.h"
+#include "../Custom/SpellMod/SpellMod.h"
 
 // update aura target map every 500 ms instead of every update - reduce amount of grid searcher calls
 static constexpr int32 UPDATE_TARGET_MAP_INTERVAL = 500;
@@ -946,12 +946,13 @@ void Aura::SetStackAmount(uint8 stackAmount)
 
     if (caster)
     {
-        if (AuraStackTriggerMod const * auracustom = sCustomMgr->FindAuraStackMod(GetId()))
+        auto itr = AuraStackTriggerMap.find(GetId());
+        if (itr != AuraStackTriggerMap.end())
         {
-            if (stackAmount == auracustom->Stacks)
+            if (stackAmount == itr->second.Stacks)
             {
-                SetStackAmount(stackAmount - auracustom->RemoveStacks);
-                for (auto i = auracustom->TriggerSpellVec.begin(); i != auracustom->TriggerSpellVec.end(); i++)
+                SetStackAmount(stackAmount - itr->second.RemoveStacks);
+                for (auto i = itr->second.TriggerSpellVec.begin(); i != itr->second.TriggerSpellVec.end(); i++)
                     caster->CastSpell(caster, *i, true);
             }
         }
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
index d666cfc..f2cf677 100644
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -52,7 +52,12 @@
 #include "BattlegroundIC.h"
 #include "GameObjectAI.h"
 #include "ArenaSpectator.h"
-#include "BYcustom.h"
+#include "../Custom/DataLoader/DataLoader.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
+#include "../Custom/AntiFarm/AntiFarm.h"
+#include "../Custom/SpellMod/SpellMod.h"
+#include "../Custom/Switch/Switch.h"
+#include "../Custom/CustomEvent/BattleIC/BattleIC.h"
 
 extern pEffect SpellEffects[TOTAL_SPELL_EFFECTS];
 
@@ -2798,8 +2803,8 @@ void Spell::DoAllEffectOnTarget(TargetInfo* target)
             }
         }
 
-        sCustomMgr->HealOnDamage(m_caster, unitTarget, m_spellInfo, damageInfo.damage);
-        sCustomMgr->ShieldOnDamage(unitTarget, m_caster, m_spellInfo, damageInfo.damage);
+        sSpellMod->HealOnDamage(m_caster, unitTarget, m_spellInfo, damageInfo.damage);
+
         // Send log damage message to client
         caster->SendSpellNonMeleeDamageLog(&damageInfo);
         // Xinef: send info to target about reflect
@@ -2849,8 +2854,7 @@ void Spell::DoAllEffectOnTarget(TargetInfo* target)
             if (unitTarget->ToCreature()->IsAIEnabled)
                 unitTarget->ToCreature()->AI()->AttackStart(m_caster);
         }
-
-        sCustomMgr->HealOnDamage(m_caster, unitTarget, m_spellInfo, damageInfo.damage);
+        sSpellMod->HealOnDamage(m_caster, unitTarget, m_spellInfo, damageInfo.damage);
     }
 
     if (m_caster)
@@ -3350,6 +3354,33 @@ bool Spell::UpdateChanneledTargetList()
 
 void Spell::prepare(SpellCastTargets const* targets, AuraEffect const* triggeredByAura)
 {
+
+    if (m_caster && m_caster->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (int32 debug = sSwitch->GetValue(ST_SPELL_DEBUG))
+        {
+            switch (debug)
+            {
+            case 1:
+                if (m_spellInfo->HasAnyAura())
+                    sLog->outString("[SpellDebug][Caster GUID ====> %d][SpellID ====> %d]", m_caster->GetGUIDLow(), m_spellInfo->Id);
+                break;
+            case 2:
+                if (!m_spellInfo->HasAnyAura())
+                    sLog->outString("[SpellDebug][Caster GUID ====> %d][SpellID ====> %d]", m_caster->GetGUIDLow(), m_spellInfo->Id);
+                break;
+            case 3:
+                if (triggeredByAura)
+                    sLog->outString("[SpellDebug][Caster GUID ====> %d][%d ====> %d]", m_caster->GetGUIDLow(), triggeredByAura->GetId(), m_spellInfo->Id);
+                else
+                    sLog->outString("[SpellDebug][Caster GUID ====> %d][SpellID ====> %d]", m_caster->GetGUIDLow(), m_spellInfo->Id);
+                break;
+            default:
+                break;
+            }
+        }
+    }
+
     if (m_CastItem)
         m_castItemGUID = m_CastItem->GetGUID();
     else
@@ -3389,22 +3420,22 @@ void Spell::prepare(SpellCastTargets const* targets, AuraEffect const* triggered
     SpellEvent* Event = new SpellEvent(this);
     m_caster->m_Events.AddEvent(Event, m_caster->m_Events.CalculateTime(1));
 
-    //Prevent casting at cast another spell (ServerSide check)
-    if (!(_triggeredCastFlags & TRIGGERED_IGNORE_CAST_IN_PROGRESS) && m_caster->IsNonMeleeSpellCast(false, true, true, m_spellInfo->Id == 75) && m_cast_count)
+    if (m_caster && m_caster->GetTypeId() == TYPEID_PLAYER && (!sSpellMod->Enable(m_caster->ToPlayer(), m_spellInfo->Id) || sAntiFarm->DisableCombat(m_caster->ToPlayer())))
     {
-        SendCastResult(SPELL_FAILED_SPELL_IN_PROGRESS);
+        SendCastResult(SPELL_FAILED_SPELL_UNAVAILABLE);
         finish(false);
         return;
     }
 
-    if (DisableMgr::IsDisabledFor(DISABLE_TYPE_SPELL, m_spellInfo->Id, m_caster))
+    //Prevent casting at cast another spell (ServerSide check)
+    if (!(_triggeredCastFlags & TRIGGERED_IGNORE_CAST_IN_PROGRESS) && m_caster->IsNonMeleeSpellCast(false, true, true, m_spellInfo->Id == 75) && m_cast_count)
     {
-        SendCastResult(SPELL_FAILED_SPELL_UNAVAILABLE);
+        SendCastResult(SPELL_FAILED_SPELL_IN_PROGRESS);
         finish(false);
         return;
     }
 
-    if (m_caster && m_caster->GetTypeId() == TYPEID_PLAYER && sCustomMgr->CheckSpellDisable(m_caster->ToPlayer(), m_spellInfo->Id))
+    if (DisableMgr::IsDisabledFor(DISABLE_TYPE_SPELL, m_spellInfo->Id, m_caster))
     {
         SendCastResult(SPELL_FAILED_SPELL_UNAVAILABLE);
         finish(false);
@@ -3664,20 +3695,6 @@ void Spell::_cast(bool skipCheck)
         return;
     }
 
-    if (Player* playerCaster = m_caster->ToPlayer())
-    {
-        if (!isdelete)
-        {
-            if (!sCustomMgr->CheckSpellCast(playerCaster, GetSpellInfo()->Id))
-            {
-                cancel();
-                return;
-            }
-            sCustomMgr->DeleteAndRewSpellCast(playerCaster, GetSpellInfo()->Id);
-            isdelete = true;
-        }
-    }
-
     // Xinef: implement attribute SPELL_ATTR1_DISMISS_PET, on spell cast current pet is dismissed and charms are removed
     if (m_spellInfo->HasAttribute(SPELL_ATTR1_DISMISS_PET))
     {
@@ -5336,14 +5353,6 @@ void Spell::HandleEffects(Unit* pUnitTarget, Item* pItemTarget, GameObject* pGOT
 
 SpellCastResult Spell::CheckCast(bool strict)
 {
-
-    if (Player* playerCaster = m_caster->ToPlayer())
-    {
-        if (!isdelete)
-            if (!sCustomMgr->CheckSpellCast(playerCaster, m_spellInfo->Id))
-                return SPELL_FAILED_NO_POWER;
-    }
-
     // check death state
     if (!m_caster->IsAlive() && !m_spellInfo->HasAttribute(SPELL_ATTR0_PASSIVE) && !(m_spellInfo->HasAttribute(SPELL_ATTR0_CASTABLE_WHILE_DEAD) || (IsTriggered() && !m_triggeredByAuraSpell)))
         return SPELL_FAILED_CASTER_DEAD;
@@ -6272,13 +6281,34 @@ SpellCastResult Spell::CheckCast(bool strict)
                 if (m_caster->IsInWater() && !m_spellInfo->HasAura(SPELL_AURA_MOD_INCREASE_SWIM_SPEED))
                     return SPELL_FAILED_ONLY_ABOVEWATER;
 
-                // Ignore map check if spell have AreaId. AreaId already checked and this prevent special mount spells
-                bool allowMount = !m_caster->GetMap()->IsDungeon() || m_caster->GetMap()->IsBattlegroundOrArena();
-                InstanceTemplate const* it = sObjectMgr->GetInstanceTemplate(m_caster->GetMapId());
-                if (it)
-                    allowMount = it->AllowMount;
-                if (m_caster->GetTypeId() == TYPEID_PLAYER && !allowMount && !m_spellInfo->AreaGroupId)
-                    return SPELL_FAILED_NO_MOUNTS_ALLOWED;
+                std::unordered_map<uint32, MountAllowedTemplate>::iterator iter = MountAllowedMap.find(m_spellInfo->Id);
+
+                if (iter != MountAllowedMap.end())
+                {
+
+                    for (size_t i = 0; i < BAN_MAP_MAX; i++)
+                        if (m_caster->GetMapId() == iter->second.BanMap[i])
+                            return SPELL_FAILED_NO_MOUNTS_ALLOWED;
+
+                    if (!m_caster->IsOutdoors() && !iter->second.indoor)
+                        return SPELL_FAILED_NO_MOUNTS_ALLOWED;
+
+                    if (m_caster->GetMap()->IsDungeon() && !iter->second.instance)
+                        return SPELL_FAILED_NO_MOUNTS_ALLOWED;
+
+                    if (m_caster->GetMap()->IsBattlegroundOrArena() && !iter->second.battleground)
+                        return SPELL_FAILED_NO_MOUNTS_ALLOWED;
+                }
+                else
+                {
+                    // Ignore map check if spell have AreaId. AreaId already checked and this prevent special mount spells
+                    bool allowMount = !m_caster->GetMap()->IsDungeon() || m_caster->GetMap()->IsBattlegroundOrArena();
+                    InstanceTemplate const* it = sObjectMgr->GetInstanceTemplate(m_caster->GetMapId());
+                    if (it)
+                        allowMount = it->AllowMount;
+                    if (m_caster->GetTypeId() == TYPEID_PLAYER && !allowMount && !m_spellInfo->AreaGroupId)
+                        return SPELL_FAILED_NO_MOUNTS_ALLOWED;
+                }
 
                 if (m_caster->IsInDisallowedMountForm())
                     return SPELL_FAILED_NOT_SHAPESHIFT;
@@ -6287,9 +6317,8 @@ SpellCastResult Spell::CheckCast(bool strict)
                 if (m_caster->getTransForm())
                     if (SpellInfo const* transformSpellInfo = sSpellMgr->GetSpellInfo(m_caster->getTransForm()))
                         if (transformSpellInfo->HasAttribute(SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY) &&
-                            !transformSpellInfo->HasAttribute(SpellAttr0(SPELL_ATTR0_CASTABLE_WHILE_MOUNTED|SPELL_ATTR0_NEGATIVE_1)))
+                            !transformSpellInfo->HasAttribute(SpellAttr0(SPELL_ATTR0_CASTABLE_WHILE_MOUNTED | SPELL_ATTR0_NEGATIVE_1)))
                             return SPELL_FAILED_NOT_SHAPESHIFT;
-
                 break;
             }
             case SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS:
@@ -6494,6 +6523,9 @@ SpellCastResult Spell::CheckCasterAuras(bool preventionOnly) const
             prevented_reason = SPELL_FAILED_FLEEING;
     }
 
+    if (sBGIC->IsAllowed(m_caster, m_spellInfo->Id))
+        return SPELL_CAST_OK;
+
     // Xinef: if there is no prevented_reason, check prevention types
     if (prevented_reason == SPELL_CAST_OK)
     {
diff --git a/src/server/game/Spells/SpellInfo.cpp b/src/server/game/Spells/SpellInfo.cpp
index 70bd6fd..b858091 100644
--- a/src/server/game/Spells/SpellInfo.cpp
+++ b/src/server/game/Spells/SpellInfo.cpp
@@ -14,7 +14,7 @@
 #include "Player.h"
 #include "Battleground.h"
 #include "Chat.h"
-#include "BYcustom.h"
+#include "../Custom/SpellMod/SpellMod.h"
 
 uint32 GetTargetFlagMask(SpellTargetObjectTypes objType)
 {
@@ -497,7 +497,7 @@ int32 SpellEffectInfo::CalcValue(Unit const* caster, int32 const* bp, Unit const
     }
 
     if (Effect == SPELL_EFFECT_HEALTH_LEECH || Effect == SPELL_EFFECT_HEAL || ApplyAuraName == SPELL_AURA_PERIODIC_HEAL || ApplyAuraName == SPELL_AURA_PERIODIC_LEECH)
-        value = value * sCustomMgr->GetSpellModHeal(_spellInfo->Id);
+        value = value * sSpellMod->GetHealMod(_spellInfo->Id);
 
     return int32(value);
 }
@@ -848,6 +848,13 @@ SpellInfo::SpellInfo(SpellEntry const* spellEntry)
     _isSpellValid = true;
     _isCritCapable = false;
     _requireCooldownInfo = false;
+
+    {
+        CusTargetMask = SPELL_CUS_TARGET_MASK_NONE;
+        auto iter = SpellCusTargetMaskMap.find(Id);
+        if (iter != SpellCusTargetMaskMap.end())
+            CusTargetMask = iter->second;
+    }
 }
 
 SpellInfo::~SpellInfo()
@@ -2272,8 +2279,10 @@ float SpellInfo::GetMaxRange(bool positive, Unit* caster, Spell* spell) const
 
 int32 SpellInfo::GetDuration() const
 {
-    if (sCustomMgr->GetSpellModDuration(Id))
-        return sCustomMgr->GetSpellModDuration(Id);
+    auto iter = SpellModMap.find(Id);
+    if (iter != SpellModMap.end())
+        if (iter->second.duration != 0)
+            return iter->second.duration;
 
     if (!DurationEntry)
         return 0;
@@ -2289,7 +2298,11 @@ int32 SpellInfo::GetMaxDuration() const
 
 uint32 SpellInfo::CalcCastTime(Unit* caster, Spell* spell) const
 {
-    int32 custime = sCustomMgr->GetSpellModCastTime(Id);
+    int32 custime = -1;
+    auto iter = SpellModMap.find(Id);
+    if (iter != SpellModMap.end())
+        if (iter->second.castingtime != 0)
+            custime = iter->second.castingtime;
     // not all spells have cast time index and this is all is pasiive abilities
     if (!CastTimeEntry || custime == 0)
         return 0;
diff --git a/src/server/game/Spells/SpellInfo.h b/src/server/game/Spells/SpellInfo.h
index 589cc22..e59a3c0 100644
--- a/src/server/game/Spells/SpellInfo.h
+++ b/src/server/game/Spells/SpellInfo.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -399,6 +399,9 @@ public:
     inline bool HasAttribute(SpellAttr7 attribute) const { return AttributesEx7 & attribute; }
     inline bool HasAttribute(SpellCustomAttributes customAttribute) const { return AttributesCu & customAttribute; }
 
+    uint32 CusTargetMask;
+    inline bool HasCusTargetMask(SpellCusTargetMask mask) const { return CusTargetMask & mask; }
+
     bool IsExplicitDiscovery() const;
     bool IsLootCrafting() const;
     bool IsQuestTame() const;
diff --git a/src/server/game/Spells/SpellMgr.cpp b/src/server/game/Spells/SpellMgr.cpp
index f5a1e84..7b15fad 100644
--- a/src/server/game/Spells/SpellMgr.cpp
+++ b/src/server/game/Spells/SpellMgr.cpp
@@ -23,7 +23,8 @@
 #include "InstanceScript.h"
 #include "Player.h"
 #include "GameGraveyard.h"
-#include "BYcustom.h"
+#include "../Custom/SpellMod/SpellMod.h"
+
 
 bool IsPrimaryProfessionSkill(uint32 skill)
 {
@@ -3267,6 +3268,10 @@ void SpellMgr::LoadSpellCustomAttr()
 
 void SpellMgr::LoadDbcDataCorrections()
 {
+
+    //æ­¤å¤å è½½åç¯å½±åæè½
+    sSpellMod->Load();
+
     uint32 oldMSTime = getMSTime();
 
     SpellEntry* spellInfo = nullptr;
@@ -6365,6 +6370,9 @@ void SpellMgr::LoadDbcDataCorrections()
             spellInfo->EffectImplicitTargetA[EFFECT_1] = TARGET_UNIT_TARGET_ANY;
             spellInfo->EffectImplicitTargetA[EFFECT_2] = TARGET_UNIT_TARGET_ANY;
             break;
+        case 54710:
+            spellInfo->DurationIndex = 23;
+            break;
             // Check for SPELL_ATTR7_INTERRUPT_ONLY_NONPLAYER
         case 47476: // Deathknight - Strangulate
         case 15487: // Priest - Silence
@@ -6389,19 +6397,172 @@ void SpellMgr::LoadDbcDataCorrections()
                 break;
         }
 
-        //SpellCustomMod
         {
-            if (sCustomMgr->FindSpellCustomMod(spellInfo->Id))
+            //éè½½spellentry
+            std::unordered_map<uint32, SpellModBaseTemplate>::iterator iter = SpellModBaseMap.find(spellInfo->Id);
+
+            if (iter != SpellModBaseMap.end())
             {
-                if (sCustomMgr->FindSpellCustomMod(spellInfo->Id)->procChance != 0)
-                    spellInfo->procChance = sCustomMgr->FindSpellCustomMod(spellInfo->Id)->procChance;
+                if (iter->second.SpellFamilyName != 0)
+                    spellInfo->SpellFamilyName = iter->second.SpellFamilyName;
+
+                if (iter->second.procChance != 0)
+                    spellInfo->procChance = iter->second.procChance;
+
+                if (iter->second.procCharges != 0)
+                    spellInfo->procCharges = iter->second.procCharges;
+
+                spellInfo->procFlags = iter->second.procFlags;
+
+                if (iter->second.RecoveryTime != 0)
+                    spellInfo->RecoveryTime = iter->second.RecoveryTime;
+
+                for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
+                {
+                    if (iter->second.EffectImplicitTargetA[j] != 0)
+                        spellInfo->EffectImplicitTargetA[j] = iter->second.EffectImplicitTargetA[j];
 
-                if (sCustomMgr->FindSpellCustomMod(spellInfo->Id)->cooldown != 0)
-                    spellInfo->RecoveryTime = sCustomMgr->FindSpellCustomMod(spellInfo->Id)->cooldown;
+                    if (iter->second.Effect[j] != 0)
+                        spellInfo->Effect[j] = iter->second.Effect[j];
+
+                    if (iter->second.EffectApplyAuraName[j] != 0)
+                        spellInfo->EffectApplyAuraName[j] = iter->second.EffectApplyAuraName[j];
+
+                    if (iter->second.EffectMiscValue[j] != 0)
+                        spellInfo->EffectMiscValue[j] = iter->second.EffectMiscValue[j];
+
+                    if (iter->second.EffectBasePoints[j] != 0)
+                        spellInfo->EffectBasePoints[j] = iter->second.EffectBasePoints[j];
+
+                    if (iter->second.EffectTriggerSpell[j] != 0)
+                        spellInfo->EffectTriggerSpell[j] = iter->second.EffectTriggerSpell[j];
+
+                    if (iter->second.EffectSpellClassMask[j] != flag96(0, 0, 0))
+                        spellInfo->EffectSpellClassMask[j] = iter->second.EffectSpellClassMask[j];
+                }
+            }
+        }
+
+        //åç¯ä¿®æ¹æè½
+        {
+            std::unordered_map<uint32, AuraTriggerSpellTemplate>::iterator iter = AuraTriggerSpellMap.find(spellInfo->Id);
+
+            if (iter != AuraTriggerSpellMap.end())
+            {
+                spellInfo->Effect[0] = SPELL_EFFECT_APPLY_AURA;
+                spellInfo->procFlags = iter->second.procFlags;
+                spellInfo->procChance = 101;
+                spellInfo->EffectApplyAuraName[0] = SPELL_AURA_PROC_TRIGGER_SPELL;
+                spellInfo->EffectTriggerSpell[0] = 61456;
+            }
+        }
+
+        //SpellModTemplate
+        {
+            std::unordered_map<uint32, SpellModTemplate>::iterator iter = SpellModMap.find(spellInfo->Id);
+
+            if (iter != SpellModMap.end())
+            {
+                if (iter->second.procChance != 0)
+                    spellInfo->procChance = iter->second.procChance;
+
+                if (iter->second.cooldown != 0)
+                    spellInfo->RecoveryTime = iter->second.cooldown;
+
+                for (size_t i = 0; i < MAX_SPELL_EFFECTS; i++)
+                    if (iter->second.Periodic[i] != 0)
+                        spellInfo->EffectAmplitude[i] = iter->second.Periodic[i];
+            }
+        }
+
+        /*
+        //ä¿®æ¹æè½
+        {
+            for (auto iter = AuraModSpellVec.begin(); iter != AuraModSpellVec.end(); iter++)
+            {
+                if (spellInfo->Id != iter->AuraId)
+                    continue;
+
+                spellInfo->SpellFamilyName = iter->SpellFamilyName;
 
                 for (size_t i = 0; i < MAX_SPELL_EFFECTS; i++)
-                    if (sCustomMgr->FindSpellCustomMod(spellInfo->Id)->Periodic[i] != 0)
-                        spellInfo->EffectAmplitude[i] = sCustomMgr->FindSpellCustomMod(spellInfo->Id)->Periodic[i];
+                {
+                    if (iter->Value[i] == 0)
+                        continue;
+
+                    spellInfo->Effect[i] = SPELL_EFFECT_APPLY_AURA;
+
+                    for (auto itr = iter->SpellVec.begin(); itr != iter->SpellVec.end(); itr++)
+                        if (SpellEntry const* spell1 = sSpellStore.LookupEntry(*itr))
+                            spellInfo->EffectSpellClassMask[i] |= spell1->SpellFamilyFlags;
+
+                    spellInfo->EffectApplyAuraName[i] = iter->Type[i];
+                    spellInfo->EffectMiscValue[i] = iter->Op[i];
+                    spellInfo->EffectBasePoints[i] = iter->Value[i];
+                }
+            }
+        }
+        */
+        //ä¿®æ¹èä¸
+
+        {
+            std::unordered_map<uint32, AuraModClassSpellTemplate>::iterator iter = AuraModClassSpellMap.find(spellInfo->Id);
+
+            if (iter != AuraModClassSpellMap.end())
+            {
+                spellInfo->SpellFamilyName = iter->second.SpellFamilyName;
+
+                for (size_t i = 0; i < MAX_SPELL_EFFECTS; i++)
+                {
+                    if (iter->second.Value[i] == 0)
+                        continue;
+
+                    spellInfo->Effect[i] = SPELL_EFFECT_APPLY_AURA;
+                    spellInfo->EffectSpellClassMask[i] = flag96(0xffffffff, 0xffffffff, 0xffffffff);
+                    spellInfo->EffectApplyAuraName[i] = iter->second.Type[i];
+                    spellInfo->EffectMiscValue[i] = iter->second.Op[i];
+                    spellInfo->EffectBasePoints[i] = iter->second.Value[i];
+                }
+            }
+        }
+
+        {
+            std::unordered_map<uint32, AuraModStatTemplate>::iterator iter = AuraModStatMap.find(spellInfo->Id);
+
+            if (iter != AuraModStatMap.end())
+            {
+                for (size_t i = 0; i < MAX_SPELL_EFFECTS; i++)
+                {
+                    if (iter->second.auraType[i] == SPELL_AURA_NONE)
+                        continue;
+
+                    spellInfo->Effect[i] = SPELL_EFFECT_APPLY_AURA;
+                    spellInfo->EffectApplyAuraName[i] = iter->second.auraType[i];
+                    spellInfo->EffectBasePoints[i] = iter->second.basePoints[i];
+                    spellInfo->EffectMiscValue[i] = iter->second.misc[i];
+                    spellInfo->EffectMiscValueB[i] = iter->second.miscB[i];;
+                    spellInfo->EffectDieSides[i] = 0;
+                }
+            }
+        }
+
+        {
+            std::unordered_map<uint32, AuraPctTemplate>::iterator iter = AuraPctMap.find(spellInfo->Id);
+
+            if (iter != AuraPctMap.end())
+            {
+                for (size_t i = 0; i < MAX_SPELL_EFFECTS; i++)
+                {
+                    if (iter->second.auraType[i] == SPELL_AURA_NONE)
+                        continue;
+
+                    spellInfo->Effect[i] = SPELL_EFFECT_APPLY_AURA;
+                    spellInfo->EffectApplyAuraName[i] = iter->second.auraType[i];
+                    spellInfo->EffectBasePoints[i] = iter->second.basePoints[i];
+                    spellInfo->EffectMiscValue[i] = iter->second.misc[i];
+                    spellInfo->EffectMiscValueB[i] = iter->second.miscB[i];
+                    spellInfo->EffectDieSides[i] = 0;
+                }
             }
         }
     }
diff --git a/src/server/game/Tools/PlayerDump.cpp b/src/server/game/Tools/PlayerDump.cpp
index e33c6d7..0474375 100644
--- a/src/server/game/Tools/PlayerDump.cpp
+++ b/src/server/game/Tools/PlayerDump.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -664,7 +664,7 @@ DumpReturn PlayerDumpReader::LoadDump(const std::string& file, uint32 account, s
     CharacterDatabase.CommitTransaction(trans);
 
     // in case of name conflict player has to rename at login anyway
-    sWorld->AddGlobalPlayerData(guid, account, name, gender, race, playerClass, level, mails.size(), 0);
+    sWorld->AddGlobalPlayerData(guid, account, name, gender, race, playerClass, level, mails.size(), 0, "");
 
     sObjectMgr->_hiItemGuid += items.size();
     sObjectMgr->_mailId     += mails.size();
diff --git a/src/server/game/World/FrozenBot.cpp b/src/server/game/World/FrozenBot.cpp
new file mode 100644
index 0000000..ee8a5e0
--- /dev/null
+++ b/src/server/game/World/FrozenBot.cpp
@@ -0,0 +1,132 @@
+ï»¿#pragma execution_character_set("utf-8")
+#include "FrozenBot.h"
+#include "Player.h"
+#include "Config.h"
+
+
+FrozenBot::FrozenBot()
+{
+}
+
+FrozenBot::~FrozenBot()
+{
+}
+
+
+void FrozenBot::LogoutPlayerBot(uint64 guid, bool Save)
+{
+	if (Player *pPlayerBot = ObjectAccessor::FindPlayer(guid))
+	{
+		if (pPlayerBot && pPlayerBot->m_bot)
+		{
+			WorldSession* pPlayerBotWorldSession = pPlayerBot->GetSession();
+			uint32 guids = pPlayerBot->GetGUIDLow();
+			uint32 accids = pPlayerBot->GetSession()->GetAccountId();
+			pPlayerBotWorldSession->LogoutPlayer(Save);
+			delete pPlayerBotWorldSession;
+
+			CharacterDatabase.PExecute("UPDATE characters SET online = 0 WHERE guid = %u", guids);
+			LoginDatabase.PExecute("UPDATE account SET online = 0 WHERE id = %u", accids);
+			m_playerBots.erase(guid);
+			m_playerBottime.erase(guid);
+		}
+	}
+}
+
+void FrozenBot::PlBotupdate()
+{
+	//BOTä¸çº¿
+	if (_charBotLoginCallback.ready())
+	{
+		SQLQueryHolder* param;
+		_charBotLoginCallback.get(param);
+		HandlePlayerBotLogin((LoginQueryHolder*)param);
+		_charBotLoginCallback.cancel();
+	}
+
+	std::set<uint64> guids;
+	for (PlayerBotMap::const_iterator itr = m_playerBots.begin(); itr != m_playerBots.end(); ++itr)
+	{
+		m_playerBottime[itr->first] += 1;
+		if (m_playerBottime[itr->first] >= sConfigMgr->GetIntDefault("Frozen.BotoffTime", 10))
+			guids.insert(itr->first);
+	}
+
+	if (!guids.empty())
+	{
+		for (std::set<uint64>::const_iterator itr1 = guids.begin(); itr1 != guids.end(); ++itr1)
+			LogoutPlayerBot(*itr1, true);
+	}
+}
+
+
+//===============bot========================
+void FrozenBot::AddPlayerBot(uint32 accid, uint32 playerGuid)
+{
+	if (QueryResult aaaaa = CharacterDatabase.PQuery("SELECT guid FROM character_banned WHERE guid = %u", playerGuid))
+		return;
+
+	uint64 guid = MAKE_NEW_GUID(playerGuid, 0, HIGHGUID_PLAYER);
+
+	if (Player * botplr = ObjectAccessor::FindPlayerInOrOutOfWorld(guid))
+		return;
+
+
+	LoginQueryHolder *holder = new LoginQueryHolder(accid, guid);
+	if (!holder->Initialize())
+	{
+		delete holder;
+		return;
+	}
+	_charBotLoginCallback = CharacterDatabase.DelayQueryHolder((SQLQueryHolder*)holder);
+}
+
+void FrozenBot::HandlePlayerBotLogin(LoginQueryHolder* holder)
+{
+	if (!holder)
+		return;
+
+	LoginQueryHolder *lqh = (LoginQueryHolder *)holder;
+	if (!lqh)
+	{
+		if (holder)
+			delete holder;
+		return;
+	}
+
+	WorldSession *botSession = new WorldSession(lqh->GetAccountId(), NULL, SEC_PLAYER, 2, 0, LocaleConstant(4), 0, 0, 0, 0);
+	if (!botSession)
+	{
+		if (holder)
+			delete holder;
+		if (botSession)
+			delete botSession;
+		return;
+	}
+
+	botSession->SetAddress("playbot");
+	botSession->Setexpansion(2);
+	uint64 guid = lqh->GetGuid();
+	if (!guid)
+	{
+		if (holder)
+			delete holder;
+		if (botSession)
+			delete botSession;
+		return;
+	}
+
+	botSession->HandlePlayerLoginFromDB(lqh);
+	Player *botPlayer = botSession->GetPlayer();
+
+	if (!botPlayer)
+	{
+		if (holder)
+			delete holder;
+		if (botSession)
+			delete botSession;
+		return;
+	}
+
+	m_playerBots[guid] = botPlayer;
+}
diff --git a/src/server/game/World/FrozenBot.h b/src/server/game/World/FrozenBot.h
new file mode 100644
index 0000000..c10f202
--- /dev/null
+++ b/src/server/game/World/FrozenBot.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 
+ * Copyright (C) 
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/// \addtogroup world The World
+/// @{
+/// \file
+
+#ifndef __Frozen_H
+#define __Frozen_H
+
+#include "Common.h"
+#include "Timer.h"
+#include <ace/Singleton.h>
+#include <ace/Atomic_Op.h>
+#include "SharedDefines.h"
+#include "QueryResult.h"
+#include "Callback.h"
+#include "QueryResult.h"
+#include <map>
+#include <set>
+#include <list>
+
+class Object;
+class WorldPacket;
+class WorldSession;
+class Player;
+class WorldSocket;
+class SystemMgr;
+class LoginQueryHolder;
+
+/// The Bot
+class FrozenBot
+{
+	
+    public:
+
+		FrozenBot();
+		~FrozenBot();
+
+		typedef std::map<uint64, Player*> PlayerBotMap;
+		PlayerBotMap m_playerBots;
+
+		typedef std::map<uint64, uint32> PlayerBotTime;
+		PlayerBotTime m_playerBottime;
+
+		void PlBotupdate();
+		void AddPlayerBot(uint32 accid, uint32 playerGuid);
+		void LogoutPlayerBot(uint64 guid, bool Save);
+		void HandlePlayerBotLogin(LoginQueryHolder* holder);
+		QueryResultHolderFuture _charBotLoginCallback;
+
+		uint32 GetMaxBotCount() const { return m_MaxbotCount; }
+
+		/// Increase/Decrease number of players
+		inline void IncreaseBotCount()
+		{
+			uint32 botcout = m_playerBots.size();
+			m_MaxbotCount = std::max(m_MaxbotCount, botcout);
+		}
+		uint32 m_MaxbotCount;
+};
+
+#define sFbot ACE_Singleton<FrozenBot, ACE_Null_Mutex>::instance()
+#endif
+/// @}
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index ee8c2d5..2bcb498 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -78,7 +78,14 @@
 #include "ServerMotd.h"
 #include "GameGraveyard.h"
 #include <VMapManager2.h>
-#include "BYcustom.h"
+#pragma execution_character_set("utf-8")
+#include "../../scripts/Custom/AuthCheck/AuthCheck.h"
+#include "../../scripts/Custom/GCAddon/GCAddon.h"
+#include "../../scripts/Custom/Faker/Faker.h"
+#include "../Custom/ItemMod/ItemMod.h"
+#include "../../scripts/Custom/CharPvpTop/CharPvpTop.h"
+#include "../../scripts/Custom/GvgSys/GvgSys.h"
+#include "FrozenBot.h"
 
 #ifdef ELUNA
 #include "LuaEngine.h"
@@ -1380,6 +1387,24 @@ void World::LoadConfigSettings(bool reload)
     m_bool_configs[CONFIG_DEBUG_BATTLEGROUND] = sConfigMgr->GetBoolDefault("Debug.Battleground", false);
     m_bool_configs[CONFIG_DEBUG_ARENA]        = sConfigMgr->GetBoolDefault("Debug.Arena",        false);
 
+    //zhcn db
+    m_bool_configs[CONFIG_ZHCN_DB] = sConfigMgr->GetBoolDefault("DB.ZHCN.ENABLE", true);
+
+    //loot check
+    m_bool_configs[CONFIG_LOOTCHECK_ENABLED] = sConfigMgr->GetBoolDefault("LootCheckEnable", false);
+    m_int_configs[CONFIG_LOOTCHECK_TYPE] = sConfigMgr->GetIntDefault("LootCheckType", 1);
+    m_int_configs[CONFIG_LOOTCHECK_COUNT] = sConfigMgr->GetIntDefault("LootCheckCount", 40);
+    m_int_configs[CONFIG_LOOTCHECK_SECONDS] = sConfigMgr->GetIntDefault("LootCheckTime", 30);
+    m_int_configs[CONFIG_LOOTCHECK_MONEY] = sConfigMgr->GetIntDefault("LootCheckMoney", 10000);
+
+    m_bool_configs[CONFIG_ARENA_1V1_ENABLE] = sConfigMgr->GetBoolDefault("Arena.1v1.Enable", true);
+    m_bool_configs[CONFIG_ARENA_1V1_ANNOUNCER] = sConfigMgr->GetBoolDefault("Arena.1v1.Announcer", false);
+    m_int_configs[CONFIG_ARENA_1V1_MIN_LEVEL] = sConfigMgr->GetIntDefault("Arena.1v1.MinLevel", 80);
+    m_int_configs[CONFIG_ARENA_1V1_COSTS] = sConfigMgr->GetIntDefault("Arena.1v1.Costs", 400000);
+    m_bool_configs[CONFIG_ARENA_1V1_VENDOR_RATING] = sConfigMgr->GetBoolDefault("Arena.1v1.VendorRating", false);
+    m_float_configs[CONFIG_ARENA_1V1_ARENAPOINTS_MULTI] = sConfigMgr->GetFloatDefault("Arena.1v1.ArenaPointsMulti", 0.64f);
+    m_bool_configs[CONFIG_ARENA_1V1_BLOCK_FORBIDDEN_TALENTS] = sConfigMgr->GetBoolDefault("Arena.1v1.BlockForbiddenTalents", true);
+
     // call ScriptMgr if we're reloading the configuration
     sScriptMgr->OnAfterConfigLoad(reload);
 }
@@ -1922,7 +1947,8 @@ void World::SetInitialWorldSettings()
 
     // our speed up
     m_timers[WUPDATE_5_SECS].SetInterval(5*IN_MILLISECONDS);
-
+    m_timers[WUPDATE_1_SECS].SetInterval(1 * IN_MILLISECONDS);
+    m_timers[WUPDATE_CUSTOM_SECS].SetInterval(sConfigMgr->GetIntDefault("Frozen.BotupTime", 10) * IN_MILLISECONDS);
     mail_expire_check_timer = time(nullptr) + 6*3600;
 
     ///- Initilize static helper structures
@@ -2009,7 +2035,6 @@ void World::SetInitialWorldSettings()
     mgr = ChannelMgr::forTeam(TEAM_HORDE);
     mgr->LoadChannels();
 
-    sCustomMgr->LoadAllCustomData();
 #ifdef ELUNA
     ///- Run eluna scripts.
     // in multithread foreach: run scripts
@@ -2172,6 +2197,71 @@ void World::Update(uint32 diff)
         WhoListCacheMgr::Update();
     }
 
+    if (m_timers[WUPDATE_1_SECS].Passed())
+    {
+        m_timers[WUPDATE_1_SECS].Reset();
+        sCharPvpTop->PVPupdate();
+        sGvgSys->UpdateGvGevent();
+        sFbot->PlBotupdate();
+    }
+
+    if (m_timers[WUPDATE_CUSTOM_SECS].Passed())
+    {
+        uint32 rolltime = urand(1, sConfigMgr->GetIntDefault("Frozen.BotupTime", 10));
+        m_timers[WUPDATE_CUSTOM_SECS].SetInterval(rolltime * IN_MILLISECONDS);
+        m_timers[WUPDATE_CUSTOM_SECS].Reset();
+
+        uint32 serverpl = sWorld->GetPlayerCount() - sFbot->m_playerBots.size();
+
+        bool canaddbot = false;
+        if (sConfigMgr->GetIntDefault("Frozen.BotupPlayer", 10) == 0)
+            canaddbot = true;
+        if (serverpl >= sConfigMgr->GetIntDefault("Frozen.BotupPlayer", 10))
+            canaddbot = true;
+
+        if (sConfigMgr->GetBoolDefault("Frozen.BotSys", true) && sFbot->m_playerBots.size() < sConfigMgr->GetIntDefault("Frozen.BotupCount", 10) && canaddbot) //BOTä¸çº¿å¼å¯
+        {
+            SessionMap::const_iterator itr = sWorld->GetAllSessions().begin();
+            SessionMap::const_iterator itr2;
+            uint32 zoneid = sConfigMgr->GetIntDefault("Frozen.BotupZone", 10);
+            if (sConfigMgr->GetBoolDefault("Frozen.BotAcconut", true))
+            {
+                QueryResult mbotaddaccid = LoginDatabase.PQuery("select id from account where online = 0 ORDER BY RAND() LIMIT 1");
+                if (mbotaddaccid)
+                {
+                    uint32 onlineid = mbotaddaccid->Fetch()[0].GetUInt32();
+                    bool isup = false;
+                    if (!isup)
+                    {
+                        QueryResult mbotaddguid;
+
+                        if (zoneid)
+                            mbotaddguid = CharacterDatabase.PQuery("select guid from characters where account = %u and zone = %u ORDER BY RAND() LIMIT 1", onlineid, zoneid);
+                        else
+                            mbotaddguid = CharacterDatabase.PQuery("select guid from characters where account = %u ORDER BY RAND() LIMIT 1", onlineid);
+
+                        if (mbotaddguid)
+                        {
+                            uint32 guid = mbotaddguid->Fetch()[0].GetUInt32();
+                            sFbot->AddPlayerBot(onlineid, guid);
+
+                        }
+                    }
+                }
+            }
+            else
+            {
+                QueryResult mbotaddguid;
+                if (zoneid)
+                    mbotaddguid = CharacterDatabase.PQuery("select guid,account from characters where online = 0  and zone = %u ORDER BY RAND() LIMIT 1", zoneid);
+                else
+                    mbotaddguid = CharacterDatabase.PQuery("select guid,account from characters where online = 0 ORDER BY RAND() LIMIT 1");
+
+                if (mbotaddguid)
+                    sFbot->AddPlayerBot(mbotaddguid->Fetch()[1].GetUInt32(), mbotaddguid->Fetch()[0].GetUInt32());
+            }
+        }
+    }
     ///- Update the game time and check for shutdown time
     _UpdateGameTime();
 
@@ -2354,6 +2444,30 @@ void World::SendGlobalMessage(WorldPacket* packet, WorldSession* self, TeamId te
     }
 }
 
+void World::SendScreenMessage(const char *text, Player* target, bool GM, TeamId teamId)
+{
+    WorldPacket data;
+    ChatHandler::BuildChatPacket(data, CHAT_MSG_RAID_BOSS_EMOTE, LANG_UNIVERSAL,
+        NULL, target, text);
+
+    if (target && target->GetSession())
+        target->GetSession()->SendPacket(&data);
+    else if (GM)
+        SendGlobalGMMessage(&data, NULL, teamId);
+    else
+        SendGlobalMessage(&data, NULL, teamId);
+}
+
+void World::SendFactionMessage(ServerMessageType type, const char *text, TeamId teamid)
+{
+    WorldPacket data(SMSG_SERVER_MESSAGE, 50);              // guess size
+    data << uint32(type);
+    if (type <= SERVER_MSG_STRING)
+        data << text;
+
+    SendGlobalMessage(&data, NULL, teamid);
+}
+
 /// Send a packet to all GMs (except self if mentioned)
 void World::SendGlobalGMMessage(WorldPacket* packet, WorldSession* self, TeamId teamId)
 {
@@ -2651,6 +2765,8 @@ void World::SendServerMessage(ServerMessageType type, const char *text, Player*
 
 void World::UpdateSessions(uint32 diff)
 {
+
+    sFaker->UpdateAllSessions(diff);
     ///- Add new sessions
     WorldSession* sess = nullptr;
     while (addSessQueue.next(sess))
@@ -2949,6 +3065,7 @@ void World::ResetDailyQuests()
 
     // change available dailies
     sPoolMgr->ChangeDailyQuests();
+    sItemMod->ResetDayLimitItem();
 }
 
 void World::LoadDBAllowedSecurityLevel()
@@ -3187,6 +3304,18 @@ void World::LoadGlobalPlayerDataStore()
         while (mailCountResult->NextRow());
     }
 
+    std::map<uint32, std::string> _customtopname;
+    QueryResult resultcustom = CharacterDatabase.Query("SELECT guid, toptitle,lasttop FROM _xlchar GROUP BY guid");
+    if (resultcustom)
+    {
+        do
+        {
+            Field* fields = resultcustom->Fetch();
+            _customtopname[fields[0].GetUInt32()] = fields[1].GetString();
+            sCharPvpTop->m_playertopph[fields[2].GetUInt32()] = fields[0].GetUInt32();
+        } while (resultcustom->NextRow());
+    }
+
     do
     {
         Field* fields = result->Fetch();
@@ -3198,6 +3327,12 @@ void World::LoadGlobalPlayerDataStore()
         if (itr != _mailCountMap.end())
             mailCount = itr->second;
 
+        //topname
+        std::string topnames = "";
+        std::map<uint32, std::string>::const_iterator itr2 = _customtopname.find(guidLow);
+        if (itr2 != _customtopname.end())
+            topnames = itr2->second;
+
         AddGlobalPlayerData(
             guidLow,               /*guid*/
             fields[1].GetUInt32(), /*accountId*/
@@ -3207,7 +3342,8 @@ void World::LoadGlobalPlayerDataStore()
             fields[5].GetUInt8(),  /*class*/
             fields[6].GetUInt8(),  /*level*/
             mailCount,             /*mail count*/
-            0                      /*guild id*/);
+            0,                     /*guild id*/
+            topnames);
 
         ++count;
     }
@@ -3217,7 +3353,7 @@ void World::LoadGlobalPlayerDataStore()
     sLog->outString();
 }
 
-void World::AddGlobalPlayerData(uint32 guid, uint32 accountId, std::string const& name, uint8 gender, uint8 race, uint8 playerClass, uint8 level, uint16 mailCount, uint32 guildId)
+void World::AddGlobalPlayerData(uint32 guid, uint32 accountId, std::string const& name, uint8 gender, uint8 race, uint8 playerClass, uint8 level, uint16 mailCount, uint32 guildId, std::string const& topname)
 {
     GlobalPlayerData data;
 
@@ -3234,6 +3370,7 @@ void World::AddGlobalPlayerData(uint32 guid, uint32 accountId, std::string const
     data.arenaTeamId[0] = 0;
     data.arenaTeamId[1] = 0;
     data.arenaTeamId[2] = 0;
+    data.topname = topname;
 
     _globalPlayerDataStore[guid] = data;
     _globalPlayerNameStore[name] = guid;
@@ -3326,6 +3463,11 @@ GlobalPlayerData const* World::GetGlobalPlayerData(uint32 guid) const
     if (itr != _globalPlayerDataStore.end())
         return &itr->second;
 
+    std::string _customtopname = "";
+    QueryResult resultcustom = CharacterDatabase.PQuery("SELECT toptitle FROM _xlchar where guid = %u", guid);
+    if (resultcustom)
+        _customtopname = resultcustom->Fetch()[0].GetString();
+
     // Player is not in the global storage, try to get it from the Database
     PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_DATA_BY_GUID);
 
@@ -3352,7 +3494,8 @@ GlobalPlayerData const* World::GetGlobalPlayerData(uint32 guid) const
             fields[5].GetUInt8(),  /*class*/
             fields[6].GetUInt8(),  /*level*/
             0,                     /*mail count*/
-            0                      /*guild id*/
+            0,                      /*guild id*/
+            _customtopname
         );
 
         itr = _globalPlayerDataStore.find(guid);
@@ -3389,6 +3532,11 @@ uint32 World::GetGlobalPlayerGUID(std::string const& name) const
 
         uint32 guidLow = fields[0].GetUInt32();
 
+        std::string _customtopname = "";
+        QueryResult resultcustom = CharacterDatabase.PQuery("SELECT toptitle FROM _xlchar where guid = %u", guidLow);
+        if (resultcustom)
+            _customtopname = resultcustom->Fetch()[0].GetString();
+
         sLog->outString("Player %s [GUID: %u] was not found in the global storage, but it was found in the database.", name.c_str(), guidLow);
 
         sWorld->AddGlobalPlayerData(
@@ -3400,7 +3548,8 @@ uint32 World::GetGlobalPlayerGUID(std::string const& name) const
             fields[5].GetUInt8(),  /*class*/
             fields[6].GetUInt8(),  /*level*/
             0,                     /*mail count*/
-            0                      /*guild id*/
+            0,                     /*guild id*/
+            _customtopname
         );
 
         itr = _globalPlayerNameStore.find(name);
@@ -3415,3 +3564,62 @@ uint32 World::GetGlobalPlayerGUID(std::string const& name) const
     // Player not found
     return 0;
 }
+
+
+void World::UpdateNamePrefixSuffix(Player* player, std::string prefix, std::string suffix)
+{
+    GlobalPlayerDataMap::iterator itr = _globalPlayerDataStore.find(player->GetGUIDLow());
+    if (itr == _globalPlayerDataStore.end())
+        return;
+
+    itr->second.prefix = prefix;
+    itr->second.suffix = suffix;
+
+    WorldPacket data(SMSG_NAME_QUERY_RESPONSE, (8 + 1 + 1 + 1 + 1 + 1 + 10));
+    data.appendPackGUID(player->GetGUID());
+
+    data << uint8(0);
+    data << prefix + itr->second.name + suffix;
+    data << uint8(0);
+    data << uint8(itr->second.race);
+    data << uint8(itr->second.gender);
+    data << uint8(itr->second.playerClass);
+    data << uint8(0);
+
+    SessionMap const& smap = sWorld->GetAllSessions();
+    for (SessionMap::const_iterator itr = smap.begin(); itr != smap.end(); ++itr)
+        if (Player* pl = itr->second->GetPlayer())
+        {
+            pl->GetSession()->SendPacket(&data);
+
+            if (pl->GetAreaId() == player->GetAreaId())
+                sGCAddon->SendPacketTo(pl, "GC_S_NAME_UPDATE", " ");
+        }
+}
+
+void World::UpdateTopPlayerData(uint32 guid, std::string const& name)
+{
+    GlobalPlayerDataMap::iterator itr = _globalPlayerDataStore.find(guid);
+    if (itr == _globalPlayerDataStore.end())
+        return;
+
+    itr->second.topname = name;
+
+    WorldPacket data(SMSG_INVALIDATE_PLAYER, 8);
+    data << MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER);
+    SendGlobalMessage(&data);
+}
+
+void World::UpdateAllTopPlayerData()
+{
+    for (GlobalPlayerDataMap::iterator itr = _globalPlayerDataStore.begin(); itr != _globalPlayerDataStore.end(); ++itr)
+    {
+        if (itr->second.topname != "")
+        {
+            itr->second.topname = "";
+            WorldPacket data(SMSG_INVALIDATE_PLAYER, 8);
+            data << MAKE_NEW_GUID(itr->second.guidLow, 0, HIGHGUID_PLAYER);
+            SendGlobalMessage(&data);
+        }
+    }
+}
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
index dfdfecc..94d0aa1 100644
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -67,6 +67,8 @@ enum WorldTimers
     WUPDATE_MAILBOXQUEUE,
     WUPDATE_PINGDB,
     WUPDATE_5_SECS,
+    WUPDATE_1_SECS,
+    WUPDATE_CUSTOM_SECS,
     WUPDATE_COUNT
 };
 
@@ -178,6 +180,16 @@ enum WorldBoolConfigs
     CONFIG_SET_ALL_CREATURES_WITH_WAYPOINT_MOVEMENT_ACTIVE,
     CONFIG_DEBUG_BATTLEGROUND,
     CONFIG_DEBUG_ARENA,
+
+        CONFIG_ANTICHEAT_ENABLE,
+        CONFIG_ZHCN_DB,
+        CONFIG_LOOTCHECK_ENABLED,
+
+        CONFIG_ARENA_1V1_ENABLE,
+        CONFIG_ARENA_1V1_ANNOUNCER,
+        CONFIG_ARENA_1V1_VENDOR_RATING,
+        CONFIG_ARENA_1V1_BLOCK_FORBIDDEN_TALENTS,
+
     BOOL_CONFIG_VALUE_COUNT
 };
 
@@ -196,6 +208,7 @@ enum WorldFloatConfigs
     CONFIG_ARENA_WIN_RATING_MODIFIER_2,
     CONFIG_ARENA_LOSE_RATING_MODIFIER,
     CONFIG_ARENA_MATCHMAKER_RATING_MODIFIER,
+    CONFIG_ARENA_1V1_ARENAPOINTS_MULTI,
     FLOAT_CONFIG_VALUE_COUNT
 };
 
@@ -372,6 +385,19 @@ enum WorldIntConfigs
     CONFIG_CHARTER_COST_ARENA_5v5,
     CONFIG_MAX_WHO_LIST_RETURN,
     CONFIG_WAYPOINT_MOVEMENT_STOP_TIME_FOR_PLAYER,
+
+        //anticheat
+        CONFIG_ANTICHEAT_REPORTS_INGAME_NOTIFICATION,
+        CONFIG_ANTICHEAT_MAX_REPORTS_FOR_DAILY_REPORT,
+        CONFIG_ANTICHEAT_DETECTIONS_ENABLED,
+        AC_ACTION_TYPE,
+
+        CONFIG_LOOTCHECK_TYPE,
+        CONFIG_LOOTCHECK_COUNT,
+        CONFIG_LOOTCHECK_SECONDS,
+        CONFIG_LOOTCHECK_MONEY,
+        CONFIG_ARENA_1V1_COSTS,
+        CONFIG_ARENA_1V1_MIN_LEVEL,
     INT_CONFIG_VALUE_COUNT
 };
 
@@ -582,6 +608,9 @@ struct GlobalPlayerData
     uint32 guildId;
     uint32 groupId;
     uint32 arenaTeamId[3];
+    std::string topname;
+    std::string prefix;
+    std::string suffix;
 };
 
 enum GlobalPlayerUpdateMask
@@ -711,6 +740,8 @@ class World
         void SendGMText(uint32 string_id, ...);
         void SendGlobalMessage(WorldPacket* packet, WorldSession* self = 0, TeamId teamId = TEAM_NEUTRAL);
         void SendGlobalGMMessage(WorldPacket* packet, WorldSession* self = 0, TeamId teamId = TEAM_NEUTRAL);
+        void SendScreenMessage(const char *text, Player* player = NULL, bool GM = false, TeamId teamId = TEAM_NEUTRAL);
+        void SendFactionMessage(ServerMessageType type, const char *text = "", TeamId teamid = TEAM_NEUTRAL);
         bool SendZoneMessage(uint32 zone, WorldPacket* packet, WorldSession* self = 0, TeamId teamId = TEAM_NEUTRAL);
         void SendZoneText(uint32 zone, const char *text, WorldSession* self = 0, TeamId teamId = TEAM_NEUTRAL);
         void SendServerMessage(ServerMessageType type, const char *text = "", Player* player = nullptr);
@@ -802,7 +833,10 @@ class World
         void LoadGlobalPlayerDataStore();
         uint32 GetGlobalPlayerGUID(std::string const& name) const;
         GlobalPlayerData const* GetGlobalPlayerData(uint32 guid) const;
-        void AddGlobalPlayerData(uint32 guid, uint32 accountId, std::string const& name, uint8 gender, uint8 race, uint8 playerClass, uint8 level, uint16 mailCount, uint32 guildId);
+        void AddGlobalPlayerData(uint32 guid, uint32 accountId, std::string const& name, uint8 gender, uint8 race, uint8 playerClass, uint8 level, uint16 mailCount, uint32 guildId, std::string const& topname);
+        void UpdateNamePrefixSuffix(Player* player, std::string prefix, std::string suffix);
+        void UpdateTopPlayerData(uint32 guid, std::string const& name);
+        void UpdateAllTopPlayerData();
         void UpdateGlobalPlayerData(uint32 guid, uint8 mask, std::string const& name, uint8 level = 0, uint8 gender = 0, uint8 race = 0, uint8 playerClass = 0);
         void UpdateGlobalPlayerMails(uint32 guid, int16 count, bool add = true);
         void UpdateGlobalPlayerGuild(uint32 guid, uint32 guildId);
diff --git a/src/server/scripts/Commands/cs_ban.cpp b/src/server/scripts/Commands/cs_ban.cpp
index 40182aa..40147af 100644
--- a/src/server/scripts/Commands/cs_ban.cpp
+++ b/src/server/scripts/Commands/cs_ban.cpp
@@ -19,7 +19,7 @@ EndScriptData */
 #include "Player.h"
 #include "ScriptMgr.h"
 #include "BanManager.h"
-
+#include "../Custom/GateWay/GateWay.h"
 /// Ban function modes
 enum BanMode
 {
@@ -40,7 +40,8 @@ public:
             { "account",        SEC_GAMEMASTER,  true,  &HandleUnBanAccountCommand,          "" },
             { "character",      SEC_GAMEMASTER,  true,  &HandleUnBanCharacterCommand,        "" },
             { "playeraccount",  SEC_GAMEMASTER,  true,  &HandleUnBanAccountByCharCommand,    "" },
-            { "ip",             SEC_GAMEMASTER,  true,  &HandleUnBanIPCommand,               "" }
+            { "ip",             SEC_GAMEMASTER,  true,  &HandleUnBanIPCommand,               "" },
+            { "pc",             SEC_GAMEMASTER,  true,  &HandleUnBanPCCommand,               "" }
         };
 
         static std::vector<ChatCommand> banlistCommandTable =
@@ -62,7 +63,8 @@ public:
             { "account",        SEC_GAMEMASTER,  true,  &HandleBanAccountCommand,            "" },
             { "character",      SEC_GAMEMASTER,  true,  &HandleBanCharacterCommand,          "" },
             { "playeraccount",  SEC_GAMEMASTER,  true,  &HandleBanAccountByCharCommand,      "" },
-            { "ip",             SEC_GAMEMASTER,  true,  &HandleBanIPCommand,                 "" }
+            { "ip",             SEC_GAMEMASTER,  true,  &HandleBanIPCommand,                 "" },
+            { "pc",             SEC_GAMEMASTER,  true,  &HandleBanPCCommand,                 "" }
         };
 
         static std::vector<ChatCommand> commandTable =
@@ -76,6 +78,48 @@ public:
         return commandTable;
     }
 
+    static bool HandleBanPCCommand(ChatHandler* handler, char const* args)
+    {
+        char* nameStr = strtok((char*)args, " ");
+        if (!nameStr)
+            return false;
+
+        std::string name = nameStr;
+
+        if (!normalizePlayerName(name))
+        {
+            handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        sGateWay->BanPc(name);
+
+        ChatHandler(handler->GetSession()).PSendSysMessage("%sæºå¨ç å·²è¢«å°ç¦", name.c_str());
+
+        return true;
+    }
+
+    static bool HandleUnBanPCCommand(ChatHandler* handler, char const* args)
+    {
+        char* nameStr = strtok((char*)args, " ");
+        if (!nameStr)
+            return false;
+
+        std::string name = nameStr;
+
+        if (!normalizePlayerName(name))
+        {
+            handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        sGateWay->UnBanPc(name);
+        ChatHandler(handler->GetSession()).PSendSysMessage("%sæºå¨ç å·²è¢«è§£å°", name.c_str());
+        return true;
+    }
+
     static bool HandleBanAccountCommand(ChatHandler* handler, char const* args)
     {
         return HandleBanHelper(BAN_ACCOUNT, args, handler);
diff --git a/src/server/scripts/Commands/cs_character.cpp b/src/server/scripts/Commands/cs_character.cpp
index d4c824d..2bf0e27 100644
--- a/src/server/scripts/Commands/cs_character.cpp
+++ b/src/server/scripts/Commands/cs_character.cpp
@@ -221,7 +221,7 @@ public:
         stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_NAME_DATA);
         stmt->setUInt32(0, delInfo.lowGuid);
         if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
-            sWorld->AddGlobalPlayerData(delInfo.lowGuid, delInfo.accountId, delInfo.name, (*result)[2].GetUInt8(), (*result)[0].GetUInt8(), (*result)[1].GetUInt8(), (*result)[3].GetUInt8(), 0, 0);
+            sWorld->AddGlobalPlayerData(delInfo.lowGuid, delInfo.accountId, delInfo.name, (*result)[2].GetUInt8(), (*result)[0].GetUInt8(), (*result)[1].GetUInt8(), (*result)[3].GetUInt8(), 0, 0, "");
 
     }
 
diff --git a/src/server/scripts/Commands/cs_gm.cpp b/src/server/scripts/Commands/cs_gm.cpp
index 6ca2f8b..6686c94 100644
--- a/src/server/scripts/Commands/cs_gm.cpp
+++ b/src/server/scripts/Commands/cs_gm.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -88,9 +88,16 @@ public:
 
         WorldPacket data(12);
         if (strncmp(args, "on", 3) == 0)
+        {
+            target->GMFlyON = true;
             data.SetOpcode(SMSG_MOVE_SET_CAN_FLY);
+        }
         else if (strncmp(args, "off", 4) == 0)
+        {
+            target->GMFlyON = false;
+            target->SetUnderACKmount();
             data.SetOpcode(SMSG_MOVE_UNSET_CAN_FLY);
+        }
         else
         {
             handler->SendSysMessage(LANG_USE_BOL);
diff --git a/src/server/scripts/Commands/cs_npc.cpp b/src/server/scripts/Commands/cs_npc.cpp
index 772899a..070bb81 100644
--- a/src/server/scripts/Commands/cs_npc.cpp
+++ b/src/server/scripts/Commands/cs_npc.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -288,9 +288,6 @@ public:
         char* fextendedcost = strtok(nullptr, " ");                //add ExtendedCost, default: 0
         uint32 extendedcost = fextendedcost ? atol(fextendedcost) : 0;
 
-        char* fneedcost = strtok(nullptr, " ");                //add ExtendedCost, default: 0
-        uint32 needcost = fneedcost ? atol(fneedcost) : 0;
-
         Creature* vendor = handler->getSelectedCreature();
         if (!vendor)
         {
@@ -300,7 +297,7 @@ public:
         }
 
         char* addMulti = strtok(nullptr, " ");
-        uint32 vendor_entry = addMulti ? handler->GetSession()->GetCurrentVendor() : vendor->GetEntry();
+        uint32 vendor_entry = addMulti ? handler->GetSession()->GetCurrentVendorEntry() : vendor->GetEntry();
 
         if (!sObjectMgr->IsVendorItemValid(vendor_entry, itemId, maxcount, incrtime, extendedcost, handler->GetSession()->GetPlayer()))
         {
@@ -308,7 +305,7 @@ public:
             return false;
         }
 
-        sObjectMgr->AddVendorItem(vendor_entry, itemId, maxcount, incrtime, extendedcost, needcost);
+        sObjectMgr->AddVendorItem(vendor_entry, itemId, maxcount, incrtime, extendedcost);
 
         ItemTemplate const* itemTemplate = sObjectMgr->GetItemTemplate(itemId);
 
@@ -524,7 +521,7 @@ public:
         uint32 itemId = atol(pitem);
 
         char* addMulti = strtok(NULL, " ");
-        if (!sObjectMgr->RemoveVendorItem(addMulti ? handler->GetSession()->GetCurrentVendor() : vendor->GetEntry(), itemId))
+        if (!sObjectMgr->RemoveVendorItem(addMulti ? handler->GetSession()->GetCurrentVendorEntry() : vendor->GetEntry(), itemId))
         {
             handler->PSendSysMessage(LANG_ITEM_NOT_IN_LIST, itemId);
             handler->SetSentErrorMessage(true);
diff --git a/src/server/scripts/Commands/cs_reload.cpp b/src/server/scripts/Commands/cs_reload.cpp
index 5f3e5e3..a27defa 100644
--- a/src/server/scripts/Commands/cs_reload.cpp
+++ b/src/server/scripts/Commands/cs_reload.cpp
@@ -30,7 +30,7 @@ EndScriptData */
 #include "WardenCheckMgr.h"
 #include "WaypointManager.h"
 #include "GameGraveyard.h"
-#include "BYcustom.h"
+
 
 class reload_commandscript : public CommandScript
 {
@@ -147,7 +147,6 @@ public:
             { "waypoint_data",                SEC_ADMINISTRATOR, true,  &HandleReloadWpCommand,                         "" },
             { "vehicle_accessory",            SEC_ADMINISTRATOR, true,  &HandleReloadVehicleAccessoryCommand,           "" },
             { "vehicle_template_accessory",   SEC_ADMINISTRATOR, true,  &HandleReloadVehicleTemplateAccessoryCommand,   "" },
-            { "_all",                         SEC_ADMINISTRATOR, true,  &HandleReloadCustomCommand,                     "" },
             { "spellcool",                    SEC_ADMINISTRATOR, true,  &HandleReloadSpellxgCommand,                    "" }
         };
         static std::vector<ChatCommand> commandTable =
@@ -157,12 +156,6 @@ public:
         return commandTable;
     }
 
-    static bool HandleReloadCustomCommand(ChatHandler* /*handler*/, const char* /*args*/)
-    {
-        sCustomMgr->LoadAllCustomData();
-        return true;
-    }
-
     static bool HandleReloadSpellxgCommand(ChatHandler* handler, const char* args)
     {
         if (!*args)
diff --git a/src/server/scripts/Custom/AesEncryptor/aes.cpp b/src/server/scripts/Custom/AesEncryptor/aes.cpp
new file mode 100644
index 0000000..af10468
--- /dev/null
+++ b/src/server/scripts/Custom/AesEncryptor/aes.cpp
@@ -0,0 +1,321 @@
+#include "aes.h"
+#include "string.h"
+
+AES::AES(unsigned char* key)
+{
+	unsigned char sBox[] =
+	{ /*  0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f */
+		0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, /*0*/
+		0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, /*1*/
+		0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, /*2*/
+		0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, /*3*/
+		0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, /*4*/
+		0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, /*5*/
+		0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, /*6*/
+		0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, /*7*/
+		0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, /*8*/
+		0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, /*9*/
+		0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, /*a*/
+		0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, /*b*/
+		0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, /*c*/
+		0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, /*d*/
+		0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, /*e*/
+		0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16  /*f*/
+	};
+	unsigned char invsBox[256] =
+	{ /*  0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f  */
+		0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, /*0*/
+		0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, /*1*/
+		0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, /*2*/
+		0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, /*3*/
+		0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, /*4*/
+		0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, /*5*/
+		0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, /*6*/
+		0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, /*7*/
+		0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, /*8*/
+		0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, /*9*/
+		0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, /*a*/
+		0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, /*b*/
+		0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, /*c*/
+		0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, /*d*/
+		0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, /*e*/
+		0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d  /*f*/
+	};
+	memcpy(Sbox, sBox, 256);
+	memcpy(InvSbox, invsBox, 256);
+	KeyExpansion(key, w);
+}
+
+AES::~AES()
+{
+
+}
+
+unsigned char* AES::Cipher(unsigned char* input)
+{
+	unsigned char state[4][4];
+	int i, r, c;
+
+	for (r = 0; r<4; r++)
+	{
+		for (c = 0; c<4; c++)
+		{
+			state[r][c] = input[c * 4 + r];
+		}
+	}
+
+	AddRoundKey(state, w[0]);
+
+	for (i = 1; i <= 10; i++)
+	{
+		SubBytes(state);
+		ShiftRows(state);
+		if (i != 10)MixColumns(state);
+		AddRoundKey(state, w[i]);
+	}
+
+	for (r = 0; r<4; r++)
+	{
+		for (c = 0; c<4; c++)
+		{
+			input[c * 4 + r] = state[r][c];
+		}
+	}
+
+	return input;
+}
+
+unsigned char* AES::InvCipher(unsigned char* input)
+{
+	unsigned char state[4][4];
+	int i, r, c;
+
+	for (r = 0; r<4; r++)
+	{
+		for (c = 0; c<4; c++)
+		{
+			state[r][c] = input[c * 4 + r];
+		}
+	}
+
+	AddRoundKey(state, w[10]);
+	for (i = 9; i >= 0; i--)
+	{
+		InvShiftRows(state);
+		InvSubBytes(state);
+		AddRoundKey(state, w[i]);
+		if (i)
+		{
+			InvMixColumns(state);
+		}
+	}
+
+	for (r = 0; r<4; r++)
+	{
+		for (c = 0; c<4; c++)
+		{
+			input[c * 4 + r] = state[r][c];
+		}
+	}
+
+	return input;
+}
+
+void* AES::Cipher(void* input, int length)
+{
+	unsigned char* in = (unsigned char*)input;
+	int i;
+	if (!length)        // å¦ææ¯0åå½åå­ç¬¦ä¸²å¤ç
+	{
+		while (*(in + length++));
+		in = (unsigned char*)input;
+	}
+	for (i = 0; i<length; i += 16)
+	{
+		Cipher(in + i);
+	}
+	return input;
+}
+
+void* AES::InvCipher(void* input, int length)
+{
+	unsigned char* in = (unsigned char*)input;
+	int i;
+	for (i = 0; i<length; i += 16)
+	{
+		InvCipher(in + i);
+	}
+	return input;
+}
+
+void AES::KeyExpansion(unsigned char* key, unsigned char w[][4][4])
+{
+	int i, j, r, c;
+	unsigned char rc[] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36 };
+	for (r = 0; r<4; r++)
+	{
+		for (c = 0; c<4; c++)
+		{
+			w[0][r][c] = key[r + c * 4];
+		}
+	}
+	for (i = 1; i <= 10; i++)
+	{
+		for (j = 0; j<4; j++)
+		{
+			unsigned char t[4];
+			for (r = 0; r<4; r++)
+			{
+				t[r] = j ? w[i][r][j - 1] : w[i - 1][r][3];
+			}
+			if (j == 0)
+			{
+				unsigned char temp = t[0];
+				for (r = 0; r<3; r++)
+				{
+					t[r] = Sbox[t[(r + 1) % 4]];
+				}
+				t[3] = Sbox[temp];
+				t[0] ^= rc[i - 1];
+			}
+			for (r = 0; r<4; r++)
+			{
+				w[i][r][j] = w[i - 1][r][j] ^ t[r];
+			}
+		}
+	}
+}
+
+unsigned char AES::FFmul(unsigned char a, unsigned char b)
+{
+	unsigned char bw[4];
+	unsigned char res = 0;
+	int i;
+	bw[0] = b;
+	for (i = 1; i<4; i++)
+	{
+		bw[i] = bw[i - 1] << 1;
+		if (bw[i - 1] & 0x80)
+		{
+			bw[i] ^= 0x1b;
+		}
+	}
+	for (i = 0; i<4; i++)
+	{
+		if ((a >> i) & 0x01)
+		{
+			res ^= bw[i];
+		}
+	}
+	return res;
+}
+
+void AES::SubBytes(unsigned char state[][4])
+{
+	int r, c;
+	for (r = 0; r<4; r++)
+	{
+		for (c = 0; c<4; c++)
+		{
+			state[r][c] = Sbox[state[r][c]];
+		}
+	}
+}
+
+void AES::ShiftRows(unsigned char state[][4])
+{
+	unsigned char t[4];
+	int r, c;
+	for (r = 1; r<4; r++)
+	{
+		for (c = 0; c<4; c++)
+		{
+			t[c] = state[r][(c + r) % 4];
+		}
+		for (c = 0; c<4; c++)
+		{
+			state[r][c] = t[c];
+		}
+	}
+}
+
+void AES::MixColumns(unsigned char state[][4])
+{
+	unsigned char t[4];
+	int r, c;
+	for (c = 0; c< 4; c++)
+	{
+		for (r = 0; r<4; r++)
+		{
+			t[r] = state[r][c];
+		}
+		for (r = 0; r<4; r++)
+		{
+			state[r][c] = FFmul(0x02, t[r])
+				^ FFmul(0x03, t[(r + 1) % 4])
+				^ FFmul(0x01, t[(r + 2) % 4])
+				^ FFmul(0x01, t[(r + 3) % 4]);
+		}
+	}
+}
+
+void AES::AddRoundKey(unsigned char state[][4], unsigned char k[][4])
+{
+	int r, c;
+	for (c = 0; c<4; c++)
+	{
+		for (r = 0; r<4; r++)
+		{
+			state[r][c] ^= k[r][c];
+		}
+	}
+}
+
+void AES::InvSubBytes(unsigned char state[][4])
+{
+	int r, c;
+	for (r = 0; r<4; r++)
+	{
+		for (c = 0; c<4; c++)
+		{
+			state[r][c] = InvSbox[state[r][c]];
+		}
+	}
+}
+
+void AES::InvShiftRows(unsigned char state[][4])
+{
+	unsigned char t[4];
+	int r, c;
+	for (r = 1; r<4; r++)
+	{
+		for (c = 0; c<4; c++)
+		{
+			t[c] = state[r][(c - r + 4) % 4];
+		}
+		for (c = 0; c<4; c++)
+		{
+			state[r][c] = t[c];
+		}
+	}
+}
+
+void AES::InvMixColumns(unsigned char state[][4])
+{
+	unsigned char t[4];
+	int r, c;
+	for (c = 0; c< 4; c++)
+	{
+		for (r = 0; r<4; r++)
+		{
+			t[r] = state[r][c];
+		}
+		for (r = 0; r<4; r++)
+		{
+			state[r][c] = FFmul(0x0e, t[r])
+				^ FFmul(0x0b, t[(r + 1) % 4])
+				^ FFmul(0x0d, t[(r + 2) % 4])
+				^ FFmul(0x09, t[(r + 3) % 4]);
+		}
+	}
+}
diff --git a/src/server/scripts/Custom/AesEncryptor/aes.h b/src/server/scripts/Custom/AesEncryptor/aes.h
new file mode 100644
index 0000000..93733a1
--- /dev/null
+++ b/src/server/scripts/Custom/AesEncryptor/aes.h
@@ -0,0 +1,32 @@
+#ifndef aes_h__
+#define aes_h__
+
+class AES
+{
+public:
+	AES(unsigned char* key);
+	virtual ~AES();
+	unsigned char* Cipher(unsigned char* input);    // å å¯ï¼ä¼ å¥çæ°ç»å¤§å°å¿é¡»æ¯16å­è
+	unsigned char* InvCipher(unsigned char* input);  // è§£å¯ï¼ä¼ å¥çæ°ç»ä¹å¿é¡»æ¯16å­è
+	void* Cipher(void* input, int length = 0);  // å¯ä»¥ä¼ å¥æ°ç»ï¼å¤§å°å¿é¡»æ¯16çæ´æ°åï¼å¦æä¸æ¯å°ä¼è¶çæä½ï¼å¦æä¸ä¼ lengthèé»è®¤ä¸º0ï¼é£ä¹å°æç§å­ç¬¦ä¸²å¤çï¼é'\0'ç»æ
+	void* InvCipher(void* input, int length);  // å¿é¡»ä¼ å¥æ°ç»åå¤§å°ï¼å¿é¡»æ¯16çæ´æ°å
+
+private:
+	unsigned char Sbox[256];
+	unsigned char InvSbox[256];
+	unsigned char w[11][4][4];
+
+	void KeyExpansion(unsigned char* key, unsigned char w[][4][4]);
+	unsigned char FFmul(unsigned char a, unsigned char b);
+
+	void SubBytes(unsigned char state[][4]);
+	void ShiftRows(unsigned char state[][4]);
+	void MixColumns(unsigned char state[][4]);
+	void AddRoundKey(unsigned char state[][4], unsigned char k[][4]);
+
+	void InvSubBytes(unsigned char state[][4]);
+	void InvShiftRows(unsigned char state[][4]);
+	void InvMixColumns(unsigned char state[][4]);
+};
+
+#endif // aes_h__
diff --git a/src/server/scripts/Custom/AesEncryptor/aes_encryptor.cpp b/src/server/scripts/Custom/AesEncryptor/aes_encryptor.cpp
new file mode 100644
index 0000000..3b27146
--- /dev/null
+++ b/src/server/scripts/Custom/AesEncryptor/aes_encryptor.cpp
@@ -0,0 +1,145 @@
+#include "aes.h"
+#include "aes_encryptor.h"
+//#include "log.h"
+
+#include <fstream>
+using namespace std;
+
+AesEncryptor::AesEncryptor(unsigned char* key)
+{
+	m_pEncryptor = new AES(key);
+}
+
+
+AesEncryptor::~AesEncryptor(void)
+{
+	delete m_pEncryptor;
+}
+
+void AesEncryptor::Byte2Hex(const unsigned char* src, int len, char* dest) {
+	for (int i = 0; i<len; ++i) {
+		sprintf_s(dest + i * 2, 3, "%02X", src[i]);
+	}
+}
+
+void AesEncryptor::Hex2Byte(const char* src, int len, unsigned char* dest) {
+	int length = len / 2;
+	for (int i = 0; i<length; ++i) {
+		dest[i] = Char2Int(src[i * 2]) * 16 + Char2Int(src[i * 2 + 1]);
+	}
+}
+
+int AesEncryptor::Char2Int(char c) {
+	if ('0' <= c && c <= '9') {
+		return (c - '0');
+	}
+	else if ('a' <= c && c <= 'f') {
+		return (c - 'a' + 10);
+	}
+	else if ('A' <= c && c <= 'F') {
+		return (c - 'A' + 10);
+	}
+	return -1;
+}
+
+string AesEncryptor::EncryptString(string strInfor)
+{
+	int nLength = strInfor.length();
+	int spaceLength = 16 - (nLength % 16);
+	unsigned char* pBuffer = new unsigned char[nLength + spaceLength];
+	memset(pBuffer, '\0', nLength + spaceLength);
+	memcpy_s(pBuffer, nLength + spaceLength, strInfor.c_str(), nLength);
+	m_pEncryptor->Cipher(pBuffer, nLength + spaceLength);
+
+	// è¿ééè¦æå¾å°çå­ç¬¦æ°ç»è½¬æ¢æåå­è¿å¶å­ç¬¦ä¸² 
+	char* pOut = new char[2 * (nLength + spaceLength)];
+	memset(pOut, '\0', 2 * (nLength + spaceLength));
+	Byte2Hex(pBuffer, nLength + spaceLength, pOut);
+
+	string retValue(pOut);
+	delete[] pBuffer;
+	//delete[] pOut;
+	return retValue;
+}
+
+string AesEncryptor::DecryptString(string strMessage) {
+	int nLength = strMessage.length() / 2;
+	unsigned char* pBuffer = new unsigned char[nLength];
+	memset(pBuffer, '\0', nLength);
+	Hex2Byte(strMessage.c_str(), strMessage.length(), pBuffer);
+
+	m_pEncryptor->InvCipher(pBuffer, nLength);
+	string retValue((char*)pBuffer);
+	delete[] pBuffer;
+	return retValue;
+}
+
+void AesEncryptor::EncryptTxtFile(const char* inputFileName, const char* outputFileName) {
+	ifstream ifs;
+
+	// Open file:
+	ifs.open(inputFileName);
+	if (!ifs) {
+		//UNILOGW("AesEncryptor::EncryptTxtFile() - Open input file failed!");
+		return;
+	}
+
+	// Read config data:
+	string strInfor;
+	string strLine;
+	while (!ifs.eof()) {
+		char temp[1024];
+		memset(temp, '\0', 1024);
+		ifs.read(temp, 1000);
+		strInfor += temp;
+	}
+	ifs.close();
+
+	// Encrypt
+	strLine = EncryptString(strInfor);
+
+	// Writefile 
+	ofstream ofs;
+	ofs.open(outputFileName);
+	if (!ofs) {
+		//UNILOGW("AesEncryptor::EncryptTxtFile() - Open output file failed!");
+		return;
+	}
+	ofs << strLine;
+	ofs.close();
+}
+
+void AesEncryptor::DecryptTxtFile(const char* inputFile, const char* outputFile) {
+	ifstream ifs;
+
+	// Open file:
+	ifs.open(inputFile);
+	if (!ifs) {
+		//UNILOGW("AesEncryptor::DecryptTxtFile() - Open input file failed!");
+		return;
+	}
+
+	// Read config data:
+	string strInfor;
+	string strLine;
+	while (!ifs.eof()) {
+		char temp[1024];
+		memset(temp, '\0', 1024);
+		ifs.read(temp, 1000);
+		strInfor += temp;
+	}
+	ifs.close();
+
+	// Encrypt
+	strLine = DecryptString(strInfor);
+
+	// Writefile 
+	ofstream ofs;
+	ofs.open(outputFile);
+	if (!ofs) {
+		//UNILOGW("AesEncryptor::DecryptTxtFile() - Open output file failed!");
+		return;
+	}
+	ofs << strLine;
+	ofs.close();
+}
diff --git a/src/server/scripts/Custom/AesEncryptor/aes_encryptor.h b/src/server/scripts/Custom/AesEncryptor/aes_encryptor.h
new file mode 100644
index 0000000..0188ade
--- /dev/null
+++ b/src/server/scripts/Custom/AesEncryptor/aes_encryptor.h
@@ -0,0 +1,28 @@
+#ifndef AES_Encryptor_h__
+#define AES_Encryptor_h__
+
+#include <string>
+
+class AES;
+
+class AesEncryptor
+{
+public:
+	AesEncryptor(unsigned char* key);
+	~AesEncryptor(void);
+
+	std::string EncryptString(std::string strInfor);
+	std::string DecryptString(std::string strMessage);
+
+	void EncryptTxtFile(const char* inputFileName, const char* outputFileName);
+	void DecryptTxtFile(const char* inputFileName, const char* outputFileName);
+
+private:
+	void Byte2Hex(const unsigned char* src, int len, char* dest);
+	void Hex2Byte(const char* src, int len, unsigned char* dest);
+	int  Char2Int(char c);
+
+private:
+	AES* m_pEncryptor;
+};
+#endif // AES_Encryptor_h__
diff --git a/src/server/scripts/Custom/AntiCheat/AntiCheat.cpp b/src/server/scripts/Custom/AntiCheat/AntiCheat.cpp
new file mode 100644
index 0000000..a5be29c
--- /dev/null
+++ b/src/server/scripts/Custom/AntiCheat/AntiCheat.cpp
@@ -0,0 +1,292 @@
+#pragma execution_character_set("utf-8")
+#include "AntiCheat.h"
+#include "../Switch/Switch.h"
+#include "AccountMgr.h"
+#include "../Command/CustomCommand.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../CustomEvent/Event.h"
+
+void AntiCheat::CreatureReset(Creature* creature,uint32 diff)
+{
+	if (creature->C_ResetDistance <= 0 || !creature->IsInCombat())
+		return;
+
+	creature->reset_timer += diff;
+
+	if (creature->reset_timer > 3000)
+	{
+		creature->reset_timer = 0;
+
+		if (creature->GetHomePosition().GetExactDist2d(creature) > creature->C_ResetDistance)
+		{
+			creature->CombatStop(true);
+			creature->DeleteThreatList();
+			creature->GetMotionMaster()->MoveTargetedHome();
+			creature->GetAI()->Reset();
+		}
+	}
+}
+
+std::string AntiCheat::GetTimeString()
+{
+	time_t t = time(NULL);
+	tm localTime;
+	ACE_OS::localtime_r(&t, &localTime);
+
+	int year = localTime.tm_year % 100;
+	int month = localTime.tm_mon + 1;
+	int day = localTime.tm_mday;
+	int hour = localTime.tm_hour;
+	int min = localTime.tm_min;
+	int sec = localTime.tm_sec;
+	int wday = localTime.tm_wday;
+	std::ostringstream oss;
+
+	oss << "20" << year << "Äê" << month << "ÔÂ" << day << "ÈÕ" << "ÐÇÆÚ";
+
+	switch (wday)
+	{
+	case 1:
+		oss << "Ò»";
+		break;
+	case 2:
+		oss << "¶þ";
+		break;
+	case 3:
+		oss << "Èý";
+		break;
+	case 4:
+		oss << "ËÄ";
+		break;
+	case 5:
+		oss << "Îå";
+		break;
+	case 6:
+		oss << "Áù";
+		break;
+	default:
+		oss << "ÈÕ";
+		break;
+	}
+	
+	oss << " " << hour << "Ê±" << min << "·Ö";
+
+	return oss.str();
+}
+
+void AntiCheat::SaveAndNotice(Player* player, AC_TYPES type, float z)
+{
+	std::string text = "";
+	bool save = false;
+	AC_ACTION_TYPES actionType = AC_ACTION_TYPES(AntiCheatType);
+
+	switch (type)
+	{
+	case AC_FLY:
+		if (urand(0, 3) == 1)
+			save = true;
+		text = "·ÉÌì";
+		actionType = AC_ACTION_FALL;
+		break;
+	case AC_OTHER:
+		text = "ÆäËû";
+		save = false;
+		actionType = AC_ACTION_FALL;
+		break;
+	case AC_SPEED:
+		if (actionType == AC_ACTION_IGNORE_SPEED)
+			return;
+		if (urand(0, 3) == 1)
+			save = true;
+		text = "¼ÓËÙ";
+		actionType = AC_ACTION_PULL;
+		break;
+	case AC_TELE:
+		text = "´«ËÍ";
+		save = true;
+		break;
+	}
+
+	std::ostringstream oss;
+	oss << "|cFFFFFC00<Íâ¹Ò¼ì²â>|r |cFF60FF00" << sCF->GetNameLink(player) << "|r |cFFFFFC00Ê¹ÓÃ|r<" << text << ">";
+	WorldPacket data(SMSG_NOTIFICATION, (oss.str().size() + 1));
+	data << oss.str();
+	sWorld->SendGlobalGMMessage(&data);
+	//sWorld->SendGlobalGMText(oss.str().c_str());
+
+	player->SetOrientation(frand(-3, 3));
+
+	switch (actionType)
+	{	
+	case AC_ACTION_PULL:
+		player->TeleportTo(player->GetMapId(), player->m_positionX, player->m_positionY, player->m_positionZ, player->GetOrientation());
+		break;
+	case AC_ACTION_TELE_HOME:
+		player->TeleportTo(player->m_homebindMapId, player->m_homebindX, player->m_homebindY, player->m_homebindZ, player->GetOrientation());
+		break;
+	case AC_ACTION_PRISION:
+		player->TeleportTo(1, 16230.157227, 16406.478516, -64.37920, player->GetOrientation());
+		break;
+	case AC_ACTION_KICK:
+		player->GetSession()->KickPlayer(true);
+		break;
+	case AC_ACTION_BAN_CHAR:
+		break;
+	case AC_ACTION_BAN_ACC:
+		break;
+	case AC_ACTION_FALL:
+		player->TeleportTo(player->GetMapId(), player->m_positionX, player->m_positionY, z, player->GetOrientation());
+		break;
+	}
+
+	if (save)
+	{
+		SQLTransaction trans = CharacterDatabase.BeginTransaction();
+		PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_AC);
+		stmt->setString(0, player->GetName());
+		stmt->setUInt32(1, player->GetSession()->GetAccountId());
+		stmt->setString(2, text);
+		stmt->setString(3, GetTimeString());
+		trans->Append(stmt);
+		CharacterDatabase.CommitTransaction(trans);
+	}
+}
+
+bool AntiCheat::CheckMovementInfo(Unit* unit, MovementInfo const& movementInfo)
+{
+	if (!unit)
+		return false;
+
+	Player* pl = unit->ToPlayer();
+
+	if (!pl)
+		return false;
+
+	time_t t = time(NULL);
+	if (t - unit->GetSpeedHackCooldown() < 1)
+		return false;
+	unit->SetSpeedHackCooldown(t);
+
+	if (float timer = pl->GetLastMoveClientTimestamp())
+	{
+		if (pl->IsFalling() ||
+			pl->IsInFlight() || 
+			pl->GetTransport() ||
+			pl->HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT) ||
+			pl->HasUnitState(UNIT_STATE_IGNORE_ANTISPEEDHACK) ||
+			pl->IsGameMaster()
+			)
+			return false;
+
+		if (pl->IsSkipOnePacket())
+		{
+			pl->SetSkipOnePacket(false);
+			return false;
+		}
+
+		float realping = pl->GetSession()->GetLatency();
+		float ping = realping < 60.0f ? 60.0f : realping;
+		float speed = (pl->IsFlying() || pl->CanFly()) ? pl->GetSpeed(MOVE_FLIGHT) : pl->GetSpeed(MOVE_RUN);
+		float difftime = (movementInfo.time - timer) * 0.001f + (getMSTime() - movementInfo.time) / 10000000000 + (ping * 0.001f);
+		float normaldistance = speed * difftime + 0.1f;
+
+		Position npos = movementInfo.pos;
+		float distance = pl->GetExactDist2d(&npos);
+
+		float diffdist = distance - normaldistance;
+
+		if (diffdist < 0 || distance < 5.6f)
+			return false;
+
+		if (pl->UnderACKmount())
+		{
+			if (diffdist > 70.0f)
+			{
+				SaveAndNotice(pl, AC_TELE);
+				return true;
+			}
+		}
+		else
+		{
+			if (diffdist > 70.0f)
+				SaveAndNotice(pl, AC_TELE);
+			else
+				SaveAndNotice(pl, AC_SPEED);
+			return true;
+		}	
+	}
+
+	return false;
+}
+
+void AntiCheat::CheckMovementInfo(Player* pl)
+{
+	if (pl->IsFalling() ||
+		pl->IsInFlight() ||
+		pl->GetTransport() ||
+		pl->HasUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT) ||
+		pl->HasUnitState(UNIT_STATE_IGNORE_ANTISPEEDHACK) ||
+		pl->UnderACKmount() ||
+		pl->IsGameMaster() || 
+		pl->IsInWater()
+		)
+		return;
+
+	const bool no_fly_auras = !(pl->HasAuraType(SPELL_AURA_FLY) || pl->HasAuraType(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED)
+		|| pl->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) || pl->HasAuraType(SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED)
+		|| pl->HasAuraType(SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS) || pl->HasAuraType(SPELL_AURA_MOD_FLIGHT_SPEED_NOT_STACK));
+	const bool no_fly_flags = (pl->GetUnitMovementFlags() & (MOVEMENTFLAG_DESCENDING | MOVEMENTFLAG_ASCENDING | MOVEMENTFLAG_CAN_FLY | MOVEMENTFLAG_FLYING)) == 0;
+
+	float z = pl->GetMap()->GetHeight(pl->GetPhaseMask(), pl->m_positionX, pl->m_positionY, pl->m_positionZ + 1.8f, true);
+
+	if (no_fly_auras && !no_fly_flags && !pl->GMFlyON)
+	{
+		SaveAndNotice(pl, AC_FLY, z);
+		return;
+	}
+	//if (!pl->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && no_fly_auras && !pl->GMFlyON && !pl->HasAuraType(SPELL_AURA_WATER_WALK))
+	//if (pl->m_positionZ - z > 4.8f && !pl->IsInWater() && no_fly_auras)
+	//		if (!pl->GetMap()->IsInWater(pl->m_positionX, pl->m_positionX, z))
+	//			SaveAndNotice(pl, AC_OTHER, z);
+}
+
+
+std::unordered_map<BattlegroundTypeId, std::vector<uint32>>FixtimeBGMap;
+
+void FixtimeBG::Load()
+{
+	FixtimeBGMap.clear();
+	return;
+	QueryResult result = WorldDatabase.PQuery("SELECT id, events from xy_battleground_reward");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			
+			BattlegroundTypeId bgt = BattlegroundTypeId(fields[0].GetUInt32());
+			std::vector<uint32> events;
+			Tokenizer data(fields[1].GetString(), ' ');
+			for (Tokenizer::const_iterator itr = data.begin(); itr != data.end(); ++itr)
+				events.push_back(atoi(*itr));
+			FixtimeBGMap.insert(std::make_pair(bgt, events));
+		} while (result->NextRow());
+	}
+}
+
+bool FixtimeBG::IsActive(Player* pl, BattlegroundTypeId bgt)
+{
+	auto itr = FixtimeBGMap.find(bgt);
+	if (itr == FixtimeBGMap.end())
+		return true;
+
+	if (itr->second.empty())
+		return true;
+
+	for (auto it = itr->second.begin(); it != itr->second.end(); it++)
+		if (sGameEventMgr->IsActiveEvent(*it))
+			return true;
+
+	ChatHandler(pl->GetSession()).PSendSysMessage("¸ÃÕ½³¡Î´¼¤»î£¡");
+	return false;
+}
diff --git a/src/server/scripts/Custom/AntiCheat/AntiCheat.h b/src/server/scripts/Custom/AntiCheat/AntiCheat.h
new file mode 100644
index 0000000..528a039
--- /dev/null
+++ b/src/server/scripts/Custom/AntiCheat/AntiCheat.h
@@ -0,0 +1,57 @@
+enum AC_TYPES
+{
+	AC_FLY,
+	AC_SPEED,
+	AC_TELE,
+	AC_OTHER,
+};
+
+enum AC_ACTION_TYPES
+{
+	AC_ACTION_NONE,
+	AC_ACTION_PULL,
+	AC_ACTION_TELE_HOME,
+	AC_ACTION_PRISION,
+	AC_ACTION_KICK,
+	AC_ACTION_BAN_CHAR,
+	AC_ACTION_BAN_ACC,
+	AC_ACTION_FALL,
+	AC_ACTION_IGNORE_SPEED = 100,
+};
+
+class AntiCheat
+{
+public:
+	static AntiCheat* instance()
+	{
+		static AntiCheat instance;
+		return &instance;
+	}
+	void CreatureReset(Creature* creature, uint32 diff);
+	std::string GetTimeString();
+	void SaveAndNotice(Player* player, AC_TYPES type, float z = 0);
+	bool CheckMovementInfo(Unit* unit, MovementInfo const& movementInfo);
+	void CheckMovementInfo(Player* pl);
+private:
+
+};
+#define sAntiCheat AntiCheat::instance()
+
+
+
+extern std::unordered_map<BattlegroundTypeId, std::vector<uint32>>FixtimeBGMap;
+
+class FixtimeBG
+{
+public:
+	static FixtimeBG* instance()
+	{
+		static FixtimeBG instance;
+		return &instance;
+	}
+	void Load();
+	bool IsActive(Player* pl, BattlegroundTypeId bgt);
+private:
+
+};
+#define sFixtimeBG FixtimeBG::instance()
diff --git a/src/server/scripts/Custom/AntiFarm/AntiFarm.cpp b/src/server/scripts/Custom/AntiFarm/AntiFarm.cpp
new file mode 100644
index 0000000..d8dc9d7
--- /dev/null
+++ b/src/server/scripts/Custom/AntiFarm/AntiFarm.cpp
@@ -0,0 +1,152 @@
+#pragma execution_character_set("utf-8")
+#include "AntiFarm.h"
+#include "../GCAddon/GCAddon.h"
+#include "../Reward/Reward.h"
+#include "../Switch/Switch.h"
+
+void AntiFarm::SetParams()
+{
+	_interval = atoi(sSwitch->GetFlagByIndex(ST_ANTFARM, 1).c_str())  * IN_MILLISECONDS;
+
+	if (_interval <= 0)
+		_interval = 1800 * IN_MILLISECONDS;
+
+	_timeout = atoi(sSwitch->GetFlagByIndex(ST_ANTFARM, 2).c_str()) * IN_MILLISECONDS;
+
+	if (_timeout <= 0)
+		_timeout = 30 * IN_MILLISECONDS;
+
+	_rewId = uint32(atoi(sSwitch->GetFlagByIndex(ST_ANTFARM, 3).c_str()));
+
+	_onoff = sSwitch->GetOnOff(ST_ANTFARM);
+}
+
+uint32 AntiFarm::GetInterval()
+{
+	return _interval;
+}
+
+uint32 AntiFarm::GetTimeOut()
+{
+	return _timeout;
+}
+
+bool AntiFarm::GetOnOff()
+{
+	return _onoff;
+}
+
+void AntiFarm::SendCheck(Player* player)
+{
+	player->AntiFarmCount++;
+	player->AntiFarmNum = urand(1, 9);
+
+	std::ostringstream oss;
+	
+	oss << player->AntiFarmNum << "#";
+
+	std::vector<uint32> NumVec;
+
+	while (NumVec.empty() || NumVec.size() < 9)
+	{
+		uint32 i = urand(1, 9);
+
+		if (std::find(NumVec.begin(), NumVec.end(), i) == NumVec.end())
+			NumVec.push_back(i);
+	}
+
+	for (std::vector<uint32>::iterator it = NumVec.begin(); it != NumVec.end(); it++)
+		oss << *it << ":";
+
+	sGCAddon->SendPacketTo(player, "GC_S_ANTIFARM", oss.str());
+}
+
+void AntiFarm::DoCheck(Player* player, uint32 num)
+{
+	if (player->AntiFarmNum == num)
+		Action(player, AF_CHECK_SUCCESS);
+	else if (player->AntiFarmCount < 3)
+		Action(player, AF_CHECK_REPEAT);
+	else
+		Action(player, AF_CHECK_FAIL);
+}
+
+void AntiFarm::Action(Player* player, AntiFarmActions action)
+{
+	switch (action)
+	{
+	case AF_CHECK_SUCCESS:
+		player->GetSession()->SendAreaTriggerMessage("ÈË»úÑéÖ¤³É¹¦£¬¸ÐÐ»ÄúµÄÅäºÏ£¬×£ÓÎÏ·Óä¿ì£¡");
+		UnBan(player);
+		sRew->Rew(player, _rewId);
+		break;
+	case AF_CHECK_REPEAT:
+		player->GetSession()->SendNotification("µÚ%u´ÎÈË»úÑéÖ¤Ê§°Ü£¬ÇëÖØÐÂÑéÖ¤£¡", player->AntiFarmCount);
+		player->AntiFarmTimer = 0;
+		SendCheck(player);
+		break;
+	case AF_CHECK_FAIL:
+		player->GetSession()->SendNotification("µÚ%u´ÎÈË»úÑéÖ¤Ê§°Ü£¬ÎÞ·¨¼ÌÐøÓÎÏ·£¡ÇëÖØÐÂÉÏÏß£¡", player->AntiFarmCount);
+		Ban(player);
+		break;
+	case AF_CHECK_TIME_OUT:
+		player->GetSession()->SendNotification("ÈË»úÑéÖ¤³¬Ê±£¬ÄãµÄÓÎÏ·ÒÑ±»ÔÝÍ££¡");
+		Ban(player);
+		SendCheck(player);
+		break;
+	default:
+		break;
+	}
+}
+
+void AntiFarm::Ban(Player* player)
+{
+	player->AntiFarmNum = 0;
+	player->AntiFarmCount = 0;
+	player->AntiFarmTimer = 0;
+	player->AntiFarmBaned = true;
+
+	player->SetMovement(MOVE_ROOT);
+	player->SetStandState(UNIT_STAND_STATE_SIT);
+	player->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_UNK24);
+}
+
+void AntiFarm::UnBan(Player* player)
+{
+	player->AntiFarmNum = 0;
+	player->AntiFarmCount = 0;
+	player->AntiFarmTimer = 0;
+	player->AntiFarmBaned = false;
+
+	player->SetMovement(MOVE_UNROOT);
+	player->RemoveFlag(PLAYER_FLAGS, PLAYER_FLAGS_UNK24);
+}
+
+bool AntiFarm::DisableCombat(Player* player)
+{
+	if (!player->AntiFarmBaned)
+		return false;
+
+	player->GetSession()->SendNotification("ÈË»úÑéÖ¤Î´Í¨¹ý£¬ÎÞ·¨¼ÌÐøÓÎÏ·£¡ÇëÖØÐÂµÇÂ¼ÓÎÏ·£¡");
+	player->SetMovement(MOVE_ROOT);
+	player->SetStandState(UNIT_STAND_STATE_SIT);
+	player->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_UNK24);
+
+	return true;
+}
+
+class AntiFarmPlayerScript : PlayerScript
+{
+public:
+	AntiFarmPlayerScript() : PlayerScript("AntiFarmPlayerScript") {}
+
+	void OnLogin(Player* player)
+	{
+		sAntiFarm->UnBan(player);
+	}
+};
+
+void AddSC_AntiFarm()
+{
+	new AntiFarmPlayerScript();
+}
diff --git a/src/server/scripts/Custom/AntiFarm/AntiFarm.h b/src/server/scripts/Custom/AntiFarm/AntiFarm.h
new file mode 100644
index 0000000..525bbe1
--- /dev/null
+++ b/src/server/scripts/Custom/AntiFarm/AntiFarm.h
@@ -0,0 +1,37 @@
+#define AntiFarmCheckInterval	60000
+#define AntiFarmTimeOut			30000
+
+enum AntiFarmActions
+{
+	AF_CHECK_SUCCESS,
+	AF_CHECK_REPEAT,
+	AF_CHECK_FAIL,
+	AF_CHECK_TIME_OUT,
+};
+
+class AntiFarm
+{
+public:
+	static AntiFarm* instance()
+	{
+		static AntiFarm instance;
+		return &instance;
+	}
+
+	void SetParams();
+	uint32 GetInterval();
+	uint32 GetTimeOut();
+	bool GetOnOff();
+	void SendCheck(Player* player);
+	void DoCheck(Player* player, uint32 num);
+	void Action(Player* player, AntiFarmActions action);
+	void Ban(Player* player);
+	void UnBan(Player* player);
+	bool DisableCombat(Player* player);
+private:
+	uint32 _interval;
+	uint32 _timeout;
+	uint32 _rewId;
+	bool _onoff;
+};
+#define sAntiFarm AntiFarm::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Armory/Armory.cpp b/src/server/scripts/Custom/Armory/Armory.cpp
new file mode 100644
index 0000000..8628aea
--- /dev/null
+++ b/src/server/scripts/Custom/Armory/Armory.cpp
@@ -0,0 +1,530 @@
+#pragma execution_character_set("utf-8")
+#include "Armory.h"
+#include "../GCAddon/GCAddon.h"
+#include "GuildMgr.h"
+#include "../CharNameMod/CharNameMod.h"
+
+std::vector<ArmoryTokenTemplate> ArmoryTokenVec;
+std::vector<ArmorySigilTemplate> ArmorySigilVec;
+std::vector<ArmoryPvpTemplate> ArmoryPvpVec;
+
+bool TokenSort(ArmoryTokenTemplate a, ArmoryTokenTemplate b) { return (a.amount < b.amount); }
+bool TokenSortDown(ArmoryTokenTemplate a, ArmoryTokenTemplate b) { return (a.amount > b.amount); }
+bool SigilSort(ArmorySigilTemplate a, ArmorySigilTemplate b) { return (a.amount < b.amount); }
+bool SigilSortDown(ArmorySigilTemplate a, ArmorySigilTemplate b) { return (a.amount > b.amount); }
+bool PvpSort(ArmoryPvpTemplate a, ArmoryPvpTemplate b) { return (a.amount < b.amount); }
+bool PvpSortDown(ArmoryPvpTemplate a, ArmoryPvpTemplate b) { return (a.amount > b.amount); }
+
+const int SigilArray[44] = 
+{ 
+	125000, 125001, 125002, 125003, 125004, 125005, 125006, 125007, 125008, 125009, 125010,
+	126000, 126001, 126002, 126003, 126004, 126005, 126006, 126007, 126008, 126009, 126010,
+	127000, 127001, 127002, 127003, 127004, 127005, 127006, 127007, 127008, 127009, 127010,
+	128000, 128001, 128002, 128003, 128004, 128005, 128006, 128007, 128008, 128009, 128010
+};
+
+void Armory::Load()
+{
+	ArmoryTokenVec.clear();
+	QueryResult result1 = CharacterDatabase.PQuery("SELECT guid,account,amount from armory_token");
+	if (result1)
+	{
+		do
+		{
+			Field* fields = result1->Fetch();
+			ArmoryTokenTemplate Temp;
+			Temp.guid		= fields[0].GetUInt32();
+			Temp.account	= fields[1].GetUInt32();
+			Temp.amount		= fields[2].GetUInt32();
+			ArmoryTokenVec.push_back(Temp);
+		} while (result1->NextRow());
+	}
+
+	ArmorySigilVec.clear();
+	QueryResult result2 = CharacterDatabase.PQuery("SELECT guid,account,amount from armory_sigil");
+	if (result2)
+	{
+		do
+		{
+			Field* fields = result2->Fetch();
+			ArmorySigilTemplate Temp;
+			Temp.guid = fields[0].GetUInt32();
+			Temp.account = fields[1].GetUInt32();
+			Temp.amount = fields[2].GetUInt32();
+			ArmorySigilVec.push_back(Temp);
+		} while (result2->NextRow());
+	}
+
+	ArmoryPvpVec.clear();
+	QueryResult result3 = CharacterDatabase.PQuery("SELECT guid,account,amount from armory_pvp");
+	if (result3)
+	{
+		do
+		{
+			Field* fields = result3->Fetch();
+			ArmoryPvpTemplate Temp;
+			Temp.guid = fields[0].GetUInt32();
+			Temp.account = fields[1].GetUInt32();
+			Temp.amount = fields[2].GetUInt32();
+			ArmoryPvpVec.push_back(Temp);
+		} while (result3->NextRow());
+	}
+}
+
+uint32 Armory::QueryToken(Player* player)
+{
+	return player->totalTokenAmount;
+}
+
+uint32 Armory::QuerySigil(Player* player)
+{
+	uint32 count = 0;
+
+	//Ö÷±³°ü
+	for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
+		if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+		{
+			uint32 entry = item->GetEntry();
+			for (size_t k = 0; k < 44; k++)
+				if (entry == SigilArray[k])
+				{
+					count++;
+					break;
+				}
+		}
+
+	//¶îÍâÈý¸ö±³°ü
+	for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+		if (Bag* pBag = player->GetBagByPos(i))
+			for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+				if (Item* item = player->GetItemByPos(i, j))
+				{
+					uint32 entry = item->GetEntry();
+					for (size_t k = 0; k < 44; k++)
+						if (entry == SigilArray[k])
+						{
+							count++;
+							break;
+						}
+				}
+
+	//ÒøÐÐ
+	for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
+		if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+		{
+			uint32 entry = item->GetEntry();
+			for (size_t k = 0; k < 44; k++)
+				if (entry == SigilArray[k])
+				{
+					count++;
+					break;
+				}
+		}
+	//ÒøÐÐ±³°ü
+	for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+		if (Bag* pBag = player->GetBagByPos(i))
+			for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+				if (Item* item = player->GetItemByPos(i, j))
+				{
+					uint32 entry = item->GetEntry();
+					for (size_t k = 0; k < 44; k++)
+						if (entry == SigilArray[k])
+						{
+							count++;
+							break;
+						}
+				}
+	return count;
+}
+
+uint32 Armory::QueryPvp(Player* player)
+{
+	return player->GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS);
+}
+
+
+void Armory::UpdateTokenArmory(Player* player)
+{
+	uint32 account = player->GetSession()->GetAccountId();
+	uint32 guid = player->GetGUIDLow();
+	uint32 amount = QueryToken(player); 
+
+	std::vector<ArmoryTokenTemplate>::iterator itr;
+	for (itr = ArmoryTokenVec.begin(); itr != ArmoryTokenVec.end(); ++itr)
+		if (account == itr->account)
+		{
+			SQLTransaction trans = CharacterDatabase.BeginTransaction();
+			PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ARMORY_TOKEN);
+			stmt->setUInt32(0, guid);
+			stmt->setUInt32(1, amount);
+			stmt->setUInt32(2, account);
+			trans->Append(stmt);
+			CharacterDatabase.CommitTransaction(trans);
+
+			itr->guid = guid;
+			itr->amount = amount;
+			return;
+		}
+
+
+	if (ArmoryTokenVec.size() < 5)
+	{
+		SQLTransaction trans = CharacterDatabase.BeginTransaction();
+		PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_ARMORY_TOKEN);
+		stmt->setUInt32(0, guid);
+		stmt->setUInt32(1, account);
+		stmt->setUInt32(2, amount);
+		trans->Append(stmt);
+		CharacterDatabase.CommitTransaction(trans);
+
+		ArmoryTokenTemplate Temp;
+		Temp.guid = guid;
+		Temp.account = account;
+		Temp.amount = amount;
+		ArmoryTokenVec.push_back(Temp);
+		return;
+	}
+
+	std::sort(ArmoryTokenVec.begin(), ArmoryTokenVec.end(), TokenSort);
+
+	for (itr = ArmoryTokenVec.begin(); itr != ArmoryTokenVec.end(); ++itr)
+	{
+		if (amount > itr->amount)
+		{
+			SQLTransaction trans = CharacterDatabase.BeginTransaction();
+			PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ARMORY_TOKEN);
+			stmt->setUInt32(0, itr->account);
+			trans->Append(stmt);
+
+			stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_ARMORY_TOKEN);
+			stmt->setUInt32(0, guid);
+			stmt->setUInt32(1, account);
+			stmt->setUInt32(2, amount);
+			trans->Append(stmt);
+			CharacterDatabase.CommitTransaction(trans);
+
+			itr->guid = guid;
+			itr->account = account;
+			itr->amount = amount;
+			return;
+		}
+	}
+
+	std::sort(ArmoryTokenVec.begin(), ArmoryTokenVec.end(), TokenSort);
+}
+
+void Armory::UpdateSigilArmory(Player* player)
+{
+	uint32 account = player->GetSession()->GetAccountId();
+	uint32 guid = player->GetGUIDLow();
+	uint32 amount = QuerySigil(player);
+
+	std::vector<ArmorySigilTemplate>::iterator itr;
+	for (itr = ArmorySigilVec.begin(); itr != ArmorySigilVec.end(); ++itr)
+		if (account == itr->account)
+		{
+			//Èç¹ûµ±Ç°Íæ¼ÒÊ¥ÎïÊýÁ¿Ð¡ÓÚ°ñÖÐÍ¬Ò»ÕËºÅÏÂµÄÍæ¼ÒÊ¥ÎïÊýÁ¿£¬Ôò·µ»Ø ·ñÔò Ìæ»»°ñÖÐÍ¬Ò»ÕËºÅÏÂµÄÍæ¼ÒÊý¾Ý
+			if (itr->amount > amount)
+				return;
+
+			SQLTransaction trans = CharacterDatabase.BeginTransaction();
+			PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ARMORY_SIGIL);
+			stmt->setUInt32(0, guid);
+			stmt->setUInt32(1, amount);
+			stmt->setUInt32(2, account);
+			trans->Append(stmt);
+			CharacterDatabase.CommitTransaction(trans);
+
+			itr->guid = guid;
+			itr->amount = amount;
+			return;
+		}
+
+
+	if (ArmorySigilVec.size() < 5)
+	{
+		SQLTransaction trans = CharacterDatabase.BeginTransaction();
+		PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_ARMORY_SIGIL);
+		stmt->setUInt32(0, guid);
+		stmt->setUInt32(1, account);
+		stmt->setUInt32(2, amount);
+		trans->Append(stmt);
+		CharacterDatabase.CommitTransaction(trans);
+
+		ArmorySigilTemplate Temp;
+		Temp.guid = guid;
+		Temp.account = account;
+		Temp.amount = amount;
+		ArmorySigilVec.push_back(Temp);
+		return;
+	}
+
+	std::sort(ArmorySigilVec.begin(), ArmorySigilVec.end(), SigilSort);
+
+	for (itr = ArmorySigilVec.begin(); itr != ArmorySigilVec.end(); ++itr)
+	{
+		if (amount > itr->amount)
+		{
+			SQLTransaction trans = CharacterDatabase.BeginTransaction();
+			PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ARMORY_SIGIL);
+			stmt->setUInt32(0, itr->account);
+			trans->Append(stmt);
+
+			stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_ARMORY_SIGIL);
+			stmt->setUInt32(0, guid);
+			stmt->setUInt32(1, account);
+			stmt->setUInt32(2, amount);
+			trans->Append(stmt);
+			CharacterDatabase.CommitTransaction(trans);
+
+			itr->guid = guid;
+			itr->account = account;
+			itr->amount = amount;
+			return;
+		}
+	}
+
+	std::sort(ArmorySigilVec.begin(), ArmorySigilVec.end(), SigilSort);
+}
+
+void Armory::UpdatePvpArmory(Player* player)
+{
+	uint32 account = player->GetSession()->GetAccountId();
+	uint32 guid = player->GetGUIDLow();
+	uint32 amount = QueryPvp(player);
+
+	std::vector<ArmoryPvpTemplate>::iterator itr;
+	//for (itr = ArmoryPvpVec.begin(); itr != ArmoryPvpVec.end(); ++itr)
+	//	if (account == itr->account)
+	//	{
+	//		//Èç¹ûµ±Ç°Íæ¼Ò»÷É±ÊýÁ¿Ð¡ÓÚ°ñÖÐÍ¬Ò»ÕËºÅÏÂµÄÍæ¼Ò»÷É±ÊýÁ¿£¬Ôò·µ»Ø ·ñÔò Ìæ»»°ñÖÐÍ¬Ò»ÕËºÅÏÂµÄÍæ¼ÒÊý¾Ý
+	//		if (itr->amount > amount)
+	//			return;
+	//
+	//		SQLTransaction trans = CharacterDatabase.BeginTransaction();
+	//		PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ARMORY_PVP);
+	//		stmt->setUInt32(0, guid);
+	//		stmt->setUInt32(1, amount);
+	//		stmt->setUInt32(2, account);
+	//		trans->Append(stmt);
+	//		CharacterDatabase.CommitTransaction(trans);
+	//
+	//		itr->guid = guid;
+	//		itr->amount = amount;
+	//		return;
+	//	}
+	for (itr = ArmoryPvpVec.begin(); itr != ArmoryPvpVec.end(); ++itr)
+	if (guid == itr->guid)
+	{
+		SQLTransaction trans = CharacterDatabase.BeginTransaction();
+		PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ARMORY_PVP);
+		stmt->setUInt32(0, amount);
+		stmt->setUInt32(1, guid);
+		trans->Append(stmt);
+		CharacterDatabase.CommitTransaction(trans);
+		
+		itr->amount = amount;
+		return;
+	}
+
+	if (ArmoryPvpVec.size() < 5)
+	{
+		SQLTransaction trans = CharacterDatabase.BeginTransaction();
+		PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_ARMORY_PVP);
+		stmt->setUInt32(0, guid);
+		stmt->setUInt32(1, account);
+		stmt->setUInt32(2, amount);
+		trans->Append(stmt);
+		CharacterDatabase.CommitTransaction(trans);
+
+		ArmoryPvpTemplate Temp;
+		Temp.guid = guid;
+		Temp.account = account;
+		Temp.amount = amount;
+		ArmoryPvpVec.push_back(Temp);
+		return;
+	}
+
+	std::sort(ArmoryPvpVec.begin(), ArmoryPvpVec.end(), PvpSort);
+
+	for (itr = ArmoryPvpVec.begin(); itr != ArmoryPvpVec.end(); ++itr)
+	{
+		if (amount > itr->amount)
+		{
+			SQLTransaction trans = CharacterDatabase.BeginTransaction();
+			PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ARMORY_PVP);
+			stmt->setUInt32(0, itr->account);
+			trans->Append(stmt);
+
+			stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_ARMORY_PVP);
+			stmt->setUInt32(0, guid);
+			stmt->setUInt32(1, account);
+			stmt->setUInt32(2, amount);
+			trans->Append(stmt);
+			CharacterDatabase.CommitTransaction(trans);
+
+			itr->guid = guid;
+			itr->account = account;
+			itr->amount = amount;
+			return;
+		}
+	}
+
+	std::sort(ArmoryPvpVec.begin(), ArmoryPvpVec.end(), PvpSort);
+}
+
+void Armory::SendArmoryTokenMsg(Player* player)
+{
+	std::sort(ArmoryTokenVec.begin(), ArmoryTokenVec.end(), TokenSortDown);
+
+	std::ostringstream oss;
+	oss << "GC_SMSG_OPC_ARMORY_TOKEN@";
+	std::vector<ArmoryTokenTemplate>::iterator itr;
+	for (itr = ArmoryTokenVec.begin(); itr != ArmoryTokenVec.end(); ++itr)
+	{
+		GlobalPlayerData const* playerData = sWorld->GetGlobalPlayerData(itr->guid);
+		if (!playerData)
+			continue;
+
+		std::string guildName = sGuildMgr->GetGuildNameById(playerData->guildId);
+
+		if (guildName.empty())
+			guildName = "ÎÞ";
+
+		oss << sCharNameMod->GetPureName(playerData->name) << "-" << playerData->name << "-" << GetGender(playerData->gender) << "-" << GetRace(playerData->race) << "-" << GetClass(playerData->playerClass) << "-" << guildName << "-" << itr->amount << ":";
+	}
+	//sGCAddon->SendPacket(player, oss.str());
+}
+
+void Armory::SendArmorySigilMsg(Player* player)
+{
+	std::sort(ArmorySigilVec.begin(), ArmorySigilVec.end(), SigilSortDown);
+
+	std::ostringstream oss;
+	oss << "GC_SMSG_OPC_ARMORY_SIGIL@";
+	std::vector<ArmorySigilTemplate>::iterator itr;
+	for (itr = ArmorySigilVec.begin(); itr != ArmorySigilVec.end(); ++itr)
+	{
+		GlobalPlayerData const* playerData = sWorld->GetGlobalPlayerData(itr->guid);
+		if (!playerData)
+			continue;
+
+		std::string guildName = sGuildMgr->GetGuildNameById(playerData->guildId);
+
+		if (guildName.empty())
+			guildName = "ÎÞ";
+
+		oss << sCharNameMod->GetPureName(playerData->name) << "-" << playerData->name << "-" << GetGender(playerData->gender) << "-" << GetRace(playerData->race) << "-" << GetClass(playerData->playerClass) << "-" << guildName << "-" << itr->amount << ":";
+	}
+	//sGCAddon->SendPacket(player, oss.str());
+}
+
+void Armory::SendArmoryPvpMsg(Player* player)
+{
+	std::sort(ArmoryPvpVec.begin(), ArmoryPvpVec.end(), PvpSortDown);
+
+	std::ostringstream oss;
+	oss << "GC_SMSG_OPC_ARMORY_PVP@";
+	std::vector<ArmoryPvpTemplate>::iterator itr;
+	for (itr = ArmoryPvpVec.begin(); itr != ArmoryPvpVec.end(); ++itr)
+	{
+		GlobalPlayerData const* playerData = sWorld->GetGlobalPlayerData(itr->guid);
+		if (!playerData)
+			continue;
+
+		std::string guildName = sGuildMgr->GetGuildNameById(playerData->guildId);
+
+		if (guildName.empty())
+			guildName = "ÎÞ";
+
+		oss << sCharNameMod->GetPureName(playerData->name) << "-" << playerData->name << "-" << GetGender(playerData->gender) << "-" << GetRace(playerData->race) << "-" << GetClass(playerData->playerClass) << "-" << guildName << "-" << itr->amount << ":";
+	}
+	//sGCAddon->SendPacket(player, oss.str());
+}
+
+class ArmoryPlayerScript : PlayerScript
+{
+public:
+	ArmoryPlayerScript() : PlayerScript("ArmoryPlayerScript") {}
+	void OnLogin(Player* player)
+	{
+		sArmory->UpdateTokenArmory(player);
+		sArmory->UpdateSigilArmory(player);
+		sArmory->UpdatePvpArmory(player);
+	}
+};
+
+void AddSC_Armory()
+{
+	//new ArmoryPlayerScript();
+}
+
+std::string Armory::GetRace(uint8 race)
+{
+	switch (race)
+	{
+	case 1:
+		return "Human";
+	case 2:
+		return "Orc";
+	case 3:
+		return "Dwarf";
+	case 4:
+		return "NightElf";
+	case 5:
+		return "Scourge";
+	case 6:
+		return "Tauren";
+	case 7:
+		return "Gnome";
+	case 8:
+		return "Troll";
+	case 10:
+		return "BloodElf";
+	case 11:
+		return "Draenei";
+	default:
+		break;
+	}
+
+	return "";
+}
+
+std::string Armory::GetGender(uint8 gender)
+{
+	if (gender == 0)
+		return "Male";
+
+	return "Female";
+}
+
+std::string Armory::GetClass(uint8 playerClass)
+{
+	switch (playerClass)
+	{
+	case 1:
+		return "Õ½Ê¿";
+	case 2:
+		return "Ê¥ÆïÊ¿";
+	case 3:
+		return "ÁÔÈË";
+	case 4:
+		return "µÁÔô";
+	case 5:
+		return "ÄÁÊ¦";
+	case 6:
+		return "ËÀÍöÆïÊ¿";
+	case 7:
+		return "ÈøÂú¼ÀË¾";
+	case 8:
+		return "·¨Ê¦";
+	case 9:
+		return "ÊõÊ¿";
+	case 11:
+		return "µÂÂ³ÒÁ";
+	default:
+		break;
+	}
+
+	return "";
+}
diff --git a/src/server/scripts/Custom/Armory/Armory.h b/src/server/scripts/Custom/Armory/Armory.h
new file mode 100644
index 0000000..8702911
--- /dev/null
+++ b/src/server/scripts/Custom/Armory/Armory.h
@@ -0,0 +1,55 @@
+struct ArmoryTokenTemplate
+{
+	uint32 guid;
+	uint32 account;
+	uint32 amount;
+};
+
+extern std::vector<ArmoryTokenTemplate> ArmoryTokenVec;
+
+struct ArmorySigilTemplate
+{
+	uint32 guid;
+	uint32 account;
+	uint32 amount;
+};
+
+extern std::vector<ArmorySigilTemplate> ArmorySigilVec;
+
+struct ArmoryPvpTemplate
+{
+	uint32 guid;
+	uint32 account;
+	uint32 amount;
+};
+
+extern std::vector<ArmoryPvpTemplate> ArmoryPvpVec;
+
+class Armory
+{
+public:
+	static Armory* instance()
+	{
+		static Armory instance;
+		return &instance;
+	}
+	void Load();
+	uint32 QueryToken(Player* player);
+	uint32 QuerySigil(Player* player);
+	uint32 QueryPvp(Player* player);
+
+	void UpdateTokenArmory(Player* player);
+	void UpdateSigilArmory(Player* player);
+	void UpdatePvpArmory(Player* player);
+
+	void SendArmoryTokenMsg(Player* player);
+	void SendArmorySigilMsg(Player* player);
+	void SendArmoryPvpMsg(Player* player);
+
+	std::string GetRace(uint8 race);
+	std::string GetGender(uint8 gender);
+	std::string GetClass(uint8 playerClass);
+private:
+
+};
+#define sArmory Armory::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/AuthCheck/APXPERBWIOGUUBPP.cpp b/src/server/scripts/Custom/AuthCheck/APXPERBWIOGUUBPP.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/src/server/scripts/Custom/AuthCheck/AuthCheck.cpp b/src/server/scripts/Custom/AuthCheck/AuthCheck.cpp
new file mode 100644
index 0000000..5f28270
--- /dev/null
+++ b/src/server/scripts/Custom/AuthCheck/AuthCheck.cpp
@@ -0,0 +1 @@
+ï»¿
\ No newline at end of file
diff --git a/src/server/scripts/Custom/AuthCheck/AuthCheck.h b/src/server/scripts/Custom/AuthCheck/AuthCheck.h
new file mode 100644
index 0000000..5f28270
--- /dev/null
+++ b/src/server/scripts/Custom/AuthCheck/AuthCheck.h
@@ -0,0 +1 @@
+ï»¿
\ No newline at end of file
diff --git a/src/server/scripts/Custom/AuthCheck/CMMWALRYPHYOLJQU.cpp b/src/server/scripts/Custom/AuthCheck/CMMWALRYPHYOLJQU.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/src/server/scripts/Custom/AuthCheck/FKCSOMADULBOPWHQ.cpp b/src/server/scripts/Custom/AuthCheck/FKCSOMADULBOPWHQ.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/src/server/scripts/Custom/AuthCheck/GJRAPOPOQRWFLCQX.cpp b/src/server/scripts/Custom/AuthCheck/GJRAPOPOQRWFLCQX.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/src/server/scripts/Custom/AuthCheck/IOHTXNRXWNKMZJJB.cpp b/src/server/scripts/Custom/AuthCheck/IOHTXNRXWNKMZJJB.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/src/server/scripts/Custom/AuthCheck/IQQFPVNNSDLLFRFS.cpp b/src/server/scripts/Custom/AuthCheck/IQQFPVNNSDLLFRFS.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/src/server/scripts/Custom/AuthCheck/JWNWPVYQJKBZUOVR.cpp b/src/server/scripts/Custom/AuthCheck/JWNWPVYQJKBZUOVR.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/src/server/scripts/Custom/AuthCheck/RWSEHJWVYWRCDRDT.cpp b/src/server/scripts/Custom/AuthCheck/RWSEHJWVYWRCDRDT.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/src/server/scripts/Custom/AuthCheck/ZKFNHNFCQRZAEMVK.cpp b/src/server/scripts/Custom/AuthCheck/ZKFNHNFCQRZAEMVK.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/src/server/scripts/Custom/Boss/boss_bartimus.cpp b/src/server/scripts/Custom/Boss/boss_bartimus.cpp
new file mode 100644
index 0000000..a6a495d
--- /dev/null
+++ b/src/server/scripts/Custom/Boss/boss_bartimus.cpp
@@ -0,0 +1,292 @@
+#pragma execution_character_set("utf-8")
+#include "../PrecompiledHeaders/ScriptPCH.h"
+enum Spells
+{
+	SPELL_STEALTH = 30991,
+	SPELL_INSANITY = 57496, //Dummy
+	INSANITY_VISUAL = 57561,
+	SPELL_INSANITY_TARGET = 57508,
+	SPELL_SLICEANDDICE = 6434,
+	SPELL_SLASH = 71623,
+	SPELL_FRENZY = 58841,
+	SPELL_CLONE_PLAYER = 57507, //casted on player during insanity
+	SPELL_INSANITY_PHASING_1 = 57508,
+	SPELL_INSANITY_PHASING_2 = 57509,
+	SPELL_INSANITY_PHASING_3 = 57510,
+	SPELL_INSANITY_PHASING_4 = 57511,
+	SPELL_INSANITY_PHASING_5 = 57512
+};
+
+enum Creatures
+{
+	NPC_TWISTED_VISAGE = 30625
+};
+
+
+
+
+class boss_bartimus : public CreatureScript
+{
+public:
+	boss_bartimus() : CreatureScript("boss_bartimus") { }
+
+	struct boss_bartimusAI : public ScriptedAI
+	{
+		boss_bartimusAI(Creature* creature) : ScriptedAI(creature), Summons(me)
+		{
+			instance = creature->GetInstanceScript();
+		}
+
+		InstanceScript* instance;
+
+		uint32 Slash_Timer;
+		uint32 Sliceanddice_Timer;
+		uint32 Frenzy_Timer;
+		uint32 insanityHandled;
+		SummonList Summons;
+
+		// returns the percentage of health after taking the given damage.
+		uint32 GetHealthPct(uint32 damage)
+		{
+			if (damage > me->GetHealth())
+				return 0;
+			return 100 * (me->GetHealth() - damage) / me->GetMaxHealth();
+		}
+
+		void DamageTaken(Unit* /*attacker*/, uint32& damage, DamageEffectType, SpellSchoolMask)
+		{
+			if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
+				damage = 0;
+
+			if ((GetHealthPct(0) >= 33 && GetHealthPct(damage) < 33))
+			{
+				me->MonsterYell("ÀíÖÇ..ÀíÖÇ£¿»ìÂÒ£¡·è¿ñ£¡", LANG_UNIVERSAL, NULL);
+				me->InterruptNonMeleeSpells(false);
+				me->MonsterYell("°¡..°¡.. ÎÒµÄÍ·..", LANG_UNIVERSAL, NULL);
+				DoCast(me, SPELL_INSANITY, false);
+			}
+		}
+
+		void SpellHitTarget(Unit* target, const SpellInfo* spell)
+		{
+			if (spell->Id == SPELL_INSANITY)
+			{
+				// Not good target or too many players
+				if (target->GetTypeId() != TYPEID_PLAYER || insanityHandled > 4)
+					return;
+				// First target - start channel visual and set self as unnattackable
+				if (!insanityHandled)
+				{
+					// Channel visual
+					DoCast(me, INSANITY_VISUAL, true);
+					// Unattackable
+					me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+					me->SetControlled(true, UNIT_STATE_STUNNED);
+				}
+				// phase mask
+				target->CastSpell(target, SPELL_INSANITY_TARGET + insanityHandled, true);
+				// Summon essence of insanity in target's phase
+				Map::PlayerList const &players = me->GetMap()->GetPlayers();
+				for (Map::PlayerList::const_iterator i = players.begin(); i != players.end(); ++i)
+				{
+					Player* player = i->GetSource();
+					if (!player || !player->IsAlive())
+						continue;
+					// Summon insanity
+					if (Unit* summon = me->SummonCreature(NPC_TWISTED_VISAGE, me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), me->GetOrientation(), TEMPSUMMON_CORPSE_DESPAWN, 0))
+					{
+						player->CastSpell(summon, SPELL_CLONE_PLAYER, true);
+						// set phase
+						summon->SetPhaseMask((1 << (4 + insanityHandled)), true);
+					}
+				}
+				++insanityHandled;
+			}
+		}
+
+		void ResetPlayersPhaseMask()
+		{
+			Map::PlayerList const &players = me->GetMap()->GetPlayers();
+			for (Map::PlayerList::const_iterator i = players.begin(); i != players.end(); ++i)
+			{
+				Player* player = i->GetSource();
+				player->RemoveAurasDueToSpell(GetSpellForPhaseMask(player->GetPhaseMask()));
+			}
+		}
+
+		void Reset()
+		{
+			Slash_Timer = 4000;
+			Sliceanddice_Timer = 8000;
+			Frenzy_Timer = 20000;
+
+
+			// Visible for all players in insanity
+			me->SetPhaseMask((1 | 16 | 32 | 64 | 128 | 256), true);
+			// Used for Insanity handling
+			insanityHandled = 0;
+
+			ResetPlayersPhaseMask();
+
+			// Cleanup
+			Summons.DespawnAll();
+			me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+			me->SetControlled(false, UNIT_STATE_STUNNED);
+		}
+
+		void EnterCombat(Unit* /*who*/)
+		{
+			me->RemoveAurasDueToSpell(SPELL_STEALTH);
+			me->MonsterYell("ÄãºÃ£¬ÕâÎ»ÅóÓÑ£¬ÇëÔÊÐíÎÒ¸øÄãÒ»¸ö¾ªÏ²£¡", LANG_UNIVERSAL, NULL);
+		}
+
+		void JustSummoned(Creature* summon)
+		{
+			Summons.Summon(summon);
+		}
+
+		uint32 GetSpellForPhaseMask(uint32 phase)
+		{
+			uint32 spell = 0;
+			switch (phase)
+			{
+			case 16:
+				spell = SPELL_INSANITY_PHASING_1;
+				break;
+			case 32:
+				spell = SPELL_INSANITY_PHASING_2;
+				break;
+			case 64:
+				spell = SPELL_INSANITY_PHASING_3;
+				break;
+			case 128:
+				spell = SPELL_INSANITY_PHASING_4;
+				break;
+			case 256:
+				spell = SPELL_INSANITY_PHASING_5;
+				break;
+			}
+			return spell;
+		}
+
+		void SummonedCreatureDespawn(Creature* summon)
+		{
+			uint32 phase = summon->GetPhaseMask();
+			uint32 nextPhase = 0;
+			Summons.Despawn(summon);
+
+			// Check if all summons in this phase killed
+			for (SummonList::const_iterator iter = Summons.begin(); iter != Summons.end(); ++iter)
+			{
+				if (Creature* visage = ObjectAccessor::GetCreature(*me, *iter))
+				{
+					// Not all are dead
+					if (phase == visage->GetPhaseMask())
+						return;
+					else
+						nextPhase = visage->GetPhaseMask();
+				}
+			}
+
+			// Roll Insanity
+			uint32 spell = GetSpellForPhaseMask(phase);
+			uint32 spell2 = GetSpellForPhaseMask(nextPhase);
+			Map* map = me->GetMap();
+			if (!map)
+				return;
+
+			Map::PlayerList const &PlayerList = map->GetPlayers();
+			if (!PlayerList.isEmpty())
+			{
+				for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+				{
+					if (Player* player = i->GetSource())
+					{
+						if (player->HasAura(spell))
+						{
+							player->RemoveAurasDueToSpell(spell);
+							if (spell2) // if there is still some different mask cast spell for it
+								player->CastSpell(player, spell2, true);
+						}
+					}
+				}
+			}
+		}
+
+		void UpdateAI(uint32 diff)
+
+		{
+			if (!me->GetVictim())
+			{
+				DoCast(me, SPELL_STEALTH);
+			}
+
+			//Return since we have no target
+			if (!UpdateVictim())
+				return;
+
+			if (insanityHandled)
+			{
+				if (!Summons.empty())
+					return;
+
+				insanityHandled = 0;
+				me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+				me->SetControlled(false, UNIT_STATE_STUNNED);
+				me->RemoveAurasDueToSpell(INSANITY_VISUAL);
+			}
+
+			if (Slash_Timer <= diff)
+			{
+				DoCast(me->GetVictim(), SPELL_SLASH);
+				Slash_Timer = 5000;
+			}
+			else Slash_Timer -= diff;
+
+			if (Sliceanddice_Timer <= diff)
+			{
+				DoCast(me, SPELL_SLICEANDDICE);
+				Sliceanddice_Timer = 20 * IN_MILLISECONDS;
+			}
+			else Sliceanddice_Timer -= diff;
+
+			if (Frenzy_Timer <= diff)
+			{
+				DoCast(me, SPELL_FRENZY);
+				Frenzy_Timer = 50 * IN_MILLISECONDS;
+			}
+			else Frenzy_Timer -= diff;
+
+			DoMeleeAttackIfReady();
+		}
+
+		void JustDied(Unit* /*killer*/)
+		{
+			me->MonsterYell("°²Ï¢...", LANG_UNIVERSAL, NULL);
+			Summons.DespawnAll();
+			ResetPlayersPhaseMask();
+
+			Map::PlayerList const &players = me->GetMap()->GetPlayers();
+			for (Map::PlayerList::const_iterator i = players.begin(); i != players.end(); ++i)
+			{
+				Player* player = i->GetSource();
+				player->AddItem(44990, 7);
+			}
+		}
+
+		void KilledUnit(Unit* /*victim*/)
+		{
+
+		}
+	};
+
+	CreatureAI* GetAI(Creature* creature) const
+	{
+		return new boss_bartimusAI(creature);
+	}
+};
+
+void AddSC_boss_bartimus()
+{
+	new boss_bartimus();
+}
diff --git a/src/server/scripts/Custom/Boss/boss_collection.cpp b/src/server/scripts/Custom/Boss/boss_collection.cpp
new file mode 100644
index 0000000..df4a26a
--- /dev/null
+++ b/src/server/scripts/Custom/Boss/boss_collection.cpp
@@ -0,0 +1,578 @@
+/*
+ *¨X¨T¨j¨T¨j¨T¨j¨j¨j¨T¨T¨j¨T¨j¨[©¤¨X¨j¨T¨T¨[ 
+ *¨U¨j¨g¨U¨U¨U¨U¨U¨d¨[¨[¨U¨j¨g¨^¨j¨a¨U¨T¨T¨g
+ *¨U¨m¨g¨U¨U¨U¨U¨U¨d¨m¨a¨U¨m¨p¨[¨U¨X¨p¨T¨T¨U
+ *¨^¨T¨m¨m¨T¨m¨m¨T¨m¨T¨T¨m¨T¨a¨^¨T¨a¨^¨T¨T¨a
+ *           (http://emudevs.com)
+ GameObject: (Burning Tree;191160)
+ GameObject: (Burning Blaze;190570) - Deals Damage if near
+ NPC DisplayID: 24905
+*/
+
+
+#pragma execution_character_set("utf-8")
+#include "../PrecompiledHeaders/ScriptPCH.h"
+
+enum SpellIds
+{
+/*     NAME                       SPELLID    CAST-TIME     DAMAGE   */
+    SPELL_FIREBALL               = 70282, //  3 sec       6198-7202
+    SPELL_FIRE_SPIT              = 66796, //  1 sec       5088-5912
+    SPELL_BLAST_NOVA             = 74392, //  2 sec       5688-7312
+	SPELL_MONEN					=60745,
+};
+
+enum EventIds
+{
+    EVENT_NONE,
+    EVENT_FIREBALL,
+    EVENT_FIRE_SPIT,
+    EVENT_BLAST_NOVA,
+    EVENT_SPAWN_FIRE,
+    EVENT_SPAWN_FIRE_CLEANUP
+};
+
+class boss_3 : public CreatureScript
+{
+public:
+	boss_3() : CreatureScript("boss_3") { }
+
+    struct boss_3AI : public ScriptedAI
+    {
+        boss_3AI(Creature* creature) : ScriptedAI(creature) { }
+
+		std::vector<GameObject*> ObjVec;
+
+        void Reset()
+        {
+			ClearFire();
+            events.Reset();         
+        }
+
+		void EnterCombat(Unit* /*who*/)
+		{
+			events.ScheduleEvent(EVENT_FIREBALL, urand(3000, 4000));
+			events.ScheduleEvent(EVENT_FIRE_SPIT, urand(2000, 9000));
+			events.ScheduleEvent(EVENT_BLAST_NOVA, urand(10000, 19000));
+			events.ScheduleEvent(EVENT_SPAWN_FIRE, urand(1000, 5000));
+		}
+
+        void UpdateAI(uint32 diff)
+        {
+			if (!UpdateVictim())
+				return;
+
+			events.Update(diff);
+			if (me->HasUnitState(UNIT_STATE_CASTING))
+				return;
+
+            while (uint32 eventId = events.ExecuteEvent())
+            {
+                switch(eventId)
+                {
+                    case EVENT_FIREBALL:
+                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM))
+                            DoCast(target, SPELL_FIREBALL);
+                        events.ScheduleEvent(EVENT_FIREBALL, urand(3000, 6000));
+                        break;
+                    case EVENT_FIRE_SPIT:
+                        DoCast(me->GetVictim(), SPELL_FIRE_SPIT, true);
+                        events.ScheduleEvent(EVENT_FIRE_SPIT, urand(2000, 5000));
+                        break;
+                    case EVENT_BLAST_NOVA:
+                        DoCast(SPELL_BLAST_NOVA);
+                        events.ScheduleEvent(EVENT_BLAST_NOVA, urand(5000, 8000));
+                        break;
+                    case EVENT_SPAWN_FIRE:
+                        me->MonsterYell("»Ò½ý...»ÙÃð...", LANG_UNIVERSAL, 0);
+						events.ScheduleEvent(EVENT_SPAWN_FIRE_CLEANUP, 30000);
+                        events.ScheduleEvent(EVENT_SPAWN_FIRE, urand(10000, 15000));
+                        SpawnFire();
+                        break;
+                    case EVENT_SPAWN_FIRE_CLEANUP:
+                        ClearFire();
+                        break;
+                }
+            }
+            DoMeleeAttackIfReady();
+        }
+
+        void SpawnFire()
+        {
+            float x, y, z;
+            me->GetPosition(x, y, z);
+
+			if (GameObject* obj = me->SummonGameObject(191160, x, y, z, 0, 0, 0, 0, 0, 0))
+				ObjVec.push_back(obj);
+			if (GameObject* obj = me->SummonGameObject(190570, x, y + 10, z, 0, 0, 0, 0, 0, 0))
+				ObjVec.push_back(obj);
+			if (GameObject* obj = me->SummonGameObject(190570, x, y - 10, z, 0, 0, 0, 0, 0, 0))
+				ObjVec.push_back(obj);
+			if (GameObject* obj = me->SummonGameObject(190570, x + 10, y, z, 0, 0, 0, 0, 0, 0))
+				ObjVec.push_back(obj);
+			if (GameObject* obj = me->SummonGameObject(190570, x - 10, y, z, 0, 0, 0, 0, 0, 0))
+				ObjVec.push_back(obj);
+        }
+
+        void ClearFire()
+        {
+			for (size_t i = 0; i < ObjVec.size(); i++)
+			{
+				if (ObjVec[i]->IsInWorld())
+					ObjVec[i]->RemoveFromWorld();
+			}
+
+			ObjVec.clear();
+        }
+
+        void JustDied(Unit* /* victim */)
+        {
+            ClearFire();
+        }
+    private:
+        EventMap events;
+	};
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new boss_3AI(creature);
+    }
+};
+
+
+enum Event
+{
+	EVENT_PRINCE_FLAME_SPHERES = 1,
+	EVENT_PRINCE_VANISH = 2,
+	EVENT_PRINCE_BLOODTHIRST = 3,
+	EVENT_PRINCE_VANISH_RUN = 4,
+	EVENT_PRINCE_RESCHEDULE = 5,
+};
+enum Spells
+{
+	SPELL_BLOODTHIRST = 55968, //Trigger Spell + add aura
+	SPELL_CONJURE_FLAME_SPHERE = 55931,
+	SPELL_FLAME_SPHERE_SPAWN_EFFECT = 55891,
+	SPELL_FLAME_SPHERE_VISUAL = 55928,
+	SPELL_FLAME_SPHERE_PERIODIC = 55926,
+	SPELL_FLAME_SPHERE_PERIODIC_H = 59508,
+	SPELL_FLAME_SPHERE_DEATH_EFFECT = 55947,
+	SPELL_BEAM_VISUAL = 60342,
+	SPELL_EMBRACE_OF_THE_VAMPYR = 55959,
+	SPELL_EMBRACE_OF_THE_VAMPYR_H = 59513,
+	SPELL_VANISH = 55964,
+	CREATURE_FLAME_SPHERE = 30106,
+	CREATURE_FLAME_SPHERE_1 = 31686,
+	CREATURE_FLAME_SPHERE_2 = 31687,
+};
+
+enum Misc
+{
+	DATA_EMBRACE_DMG = 20000,
+	DATA_EMBRACE_DMG_H = 40000,
+	DATA_SPHERE_DISTANCE = 30,
+	ACTION_FREE = 1,
+	ACTION_SPHERE = 2,
+};
+
+class boss_1 : public CreatureScript
+{
+public:
+	boss_1() : CreatureScript("boss_1") { }
+
+	struct boss_1AI : public ScriptedAI
+	{
+		boss_1AI(Creature *c) : ScriptedAI(c), summons(me)
+		{
+			
+		}
+
+		EventMap events;
+		SummonList summons;
+		uint64 vanishTarget;
+		uint32 vanishDamage;
+
+		void Reset()
+		{
+			if (me->GetPositionZ() > 15.0f)
+				me->CastSpell(me, SPELL_BEAM_VISUAL, true);
+
+			events.Reset();
+			summons.DespawnAll();
+			vanishDamage = 0;
+			vanishTarget = 0;
+		}
+
+		void DoAction(int32 param)
+		{
+			
+		}
+
+		void EnterCombat(Unit* /*who*/)
+		{
+			ScheduleEvents();
+			me->RemoveAllAuras();
+			me->InterruptNonMeleeSpells(true);
+		}
+
+		void ScheduleEvents()
+		{
+			events.Reset();
+			events.ScheduleEvent(EVENT_PRINCE_FLAME_SPHERES, 10000);
+			events.ScheduleEvent(EVENT_PRINCE_BLOODTHIRST, 10000);
+			vanishTarget = 0;
+			vanishDamage = 0;
+		}
+
+		void SpellHitTarget(Unit *, const SpellInfo *spellInfo)
+		{
+			if (spellInfo->Id == SPELL_CONJURE_FLAME_SPHERE)
+				summons.DoAction(ACTION_SPHERE);
+		}
+
+		void UpdateAI(uint32 diff)
+		{
+			if (!UpdateVictim())
+				return;
+
+			events.Update(diff);
+			if (me->HasUnitState(UNIT_STATE_CASTING))
+				return;
+
+			switch (events.GetEvent())
+			{
+			case EVENT_PRINCE_BLOODTHIRST:
+			{
+				me->CastSpell(me->GetVictim(), SPELL_BLOODTHIRST, false);
+				events.RepeatEvent(10000);
+				break;
+			}
+			case EVENT_PRINCE_FLAME_SPHERES:
+			{
+				me->CastSpell(me->GetVictim(), SPELL_CONJURE_FLAME_SPHERE, false);
+				events.RescheduleEvent(EVENT_PRINCE_VANISH, 14000);
+				Creature *cr;
+				if (cr = me->SummonCreature(CREATURE_FLAME_SPHERE, me->GetPositionX(), me->GetPositionY(), me->GetPositionZ() + 5.0f, 0.0f, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 10 * IN_MILLISECONDS))
+					summons.Summon(cr);
+
+				if (cr = me->SummonCreature(CREATURE_FLAME_SPHERE_1, me->GetPositionX(), me->GetPositionY(), me->GetPositionZ() + 5.0f, 0.0f, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 10 * IN_MILLISECONDS))
+					summons.Summon(cr);
+
+				if (cr = me->SummonCreature(CREATURE_FLAME_SPHERE_2, me->GetPositionX(), me->GetPositionY(), me->GetPositionZ() + 5.0f, 0.0f, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 10 * IN_MILLISECONDS))
+					summons.Summon(cr);
+
+				events.RepeatEvent(15000);
+				break;
+			}
+			case EVENT_PRINCE_VANISH:
+			{
+				events.PopEvent();
+				//Count alive players
+				uint8 count = 0;
+				Unit *pTarget;
+				std::list<HostileReference *> t_list = me->getThreatManager().getThreatList();
+				for (std::list<HostileReference *>::const_iterator itr = t_list.begin(); itr != t_list.end(); ++itr)
+				{
+					pTarget = ObjectAccessor::GetUnit(*me, (*itr)->getUnitGuid());
+					if (pTarget && pTarget->GetTypeId() == TYPEID_PLAYER && pTarget->IsAlive())
+						count++;
+				}
+				//He only vanishes if there are 3 or more alive players
+				if (count > 1)
+				{
+					me->CastSpell(me, SPELL_VANISH, false);
+
+					events.CancelEvent(EVENT_PRINCE_FLAME_SPHERES);
+					events.CancelEvent(EVENT_PRINCE_BLOODTHIRST);
+					events.ScheduleEvent(EVENT_PRINCE_VANISH_RUN, 2499);
+					if (Unit* pEmbraceTarget = SelectTarget(SELECT_TARGET_RANDOM, 0, 100, true))
+						vanishTarget = pEmbraceTarget->GetGUID();
+				}
+				break;
+			}
+			case EVENT_PRINCE_VANISH_RUN:
+			{
+				if (Unit *vT = ObjectAccessor::GetUnit(*me, vanishTarget))
+				{
+					me->UpdatePosition(vT->GetPositionX(), vT->GetPositionY(), vT->GetPositionZ(), me->GetAngle(vT), true);
+					me->CastSpell(vT, SPELL_EMBRACE_OF_THE_VAMPYR, false);
+					me->RemoveAura(SPELL_VANISH);
+				}
+
+				events.PopEvent();
+				events.ScheduleEvent(EVENT_PRINCE_RESCHEDULE, 20000);
+				break;
+			}
+			case EVENT_PRINCE_RESCHEDULE:
+			{
+				events.PopEvent();
+				ScheduleEvents();
+				break;
+			}
+			}
+
+			if (me->IsVisible())
+				DoMeleeAttackIfReady();
+		}
+
+		void DamageTaken(Unit*, uint32 &damage, DamageEffectType, SpellSchoolMask)
+		{
+			if (vanishTarget)
+			{
+				vanishDamage += damage;
+				if (vanishDamage > (uint32)DUNGEON_MODE(DATA_EMBRACE_DMG, DATA_EMBRACE_DMG_H))
+				{
+					ScheduleEvents();
+					me->CastStop();
+				}
+			}
+		}
+
+		void JustDied(Unit* /*killer*/)
+		{
+			summons.DespawnAll();
+		}
+
+		void KilledUnit(Unit * victim)
+		{
+			if (urand(0, 1))
+				return;
+
+			if (vanishTarget && victim->GetGUID() == vanishTarget)
+				ScheduleEvents();
+		}
+	};
+
+	CreatureAI *GetAI(Creature *creature) const
+	{
+		return new boss_1AI(creature);
+	}
+};
+
+
+
+
+enum spells
+{
+	// NADOX
+	SPELL_BROOD_PLAGUE = 56130,
+	SPELL_BROOD_PLAGUE_H = 59467,
+	SPELL_BROOD_RAGE_H = 59465,
+	SPELL_ENRAGE = 26662, // Enraged if too far away from home
+	//SPELL_SUMMON_SWARMERS			= 56119, //2x 30178  -- 2x every 10secs, spell works fine but i need specific coords
+	//SPELL_SUMMON_SWARM_GUARD		= 56120, //1x 30176  -- at 50%hp, spell works fine but i need specific coords
+
+	// ADDS
+	SPELL_SPRINT = 56354,
+	SPELL_GUARDIAN_AURA = 56151,
+	SPELL_SWARMER_AURA = 56158,
+};
+
+enum creatures
+{
+	NPC_AHNKAHAR_SWARMER = 30178,
+	NPC_AHNKAHAR_GUARDIAN_ENTRY = 30176,
+};
+
+enum events
+{
+	EVENT_CHECK_HEALTH = 1,
+	EVENT_CHECK_HOME = 2,
+	EVENT_PLAGUE = 3,
+	EVENT_BROOD_RAGE = 4,
+	EVENT_SWARMER = 5,
+	EVENT_SUMMON_GUARD = 6,
+};
+
+enum sounds
+{
+	SOUND_AGGRO = 14033,
+	SOUND_SUMMON1 = 14034,
+	SOUND_SUMMON2 = 14035,
+	SOUND_SLAY1 = 14036,
+	SOUND_SLAY2 = 14037,
+	SOUND_SLAY3 = 14038,
+	SOUND_DEATH = 14039,
+};
+
+class boss_2 : public CreatureScript
+{
+public:
+	boss_2() : CreatureScript("boss_2") { }
+
+	struct boss_2AI : public ScriptedAI
+	{
+		boss_2AI(Creature *c) : ScriptedAI(c), summons(me)
+		{
+			pInstance = c->GetInstanceScript();
+		}
+
+		EventMap events;
+		InstanceScript *pInstance;
+		SummonList summons;
+
+		void SummonHelpers(bool swarm)
+		{
+			Creature *cr;
+			if (swarm)
+			{
+				if (cr = me->SummonCreature(NPC_AHNKAHAR_SWARMER, me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), 2.56563f))
+					summons.Summon(cr);
+				if (cr = me->SummonCreature(NPC_AHNKAHAR_SWARMER, me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), 3.64774f))
+					summons.Summon(cr);
+			}
+			else
+			{
+				if (cr = me->SummonCreature(NPC_AHNKAHAR_GUARDIAN_ENTRY, me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), 3.03687f))
+					summons.Summon(cr);
+			}
+		}
+
+		void Reset()
+		{
+			events.Reset();
+			summons.DespawnAll();
+		}
+
+		void EnterCombat(Unit * /*who*/)
+		{
+			me->PlayDirectSound(SOUND_AGGRO);
+			events.ScheduleEvent(EVENT_CHECK_HEALTH, 1000);
+			events.ScheduleEvent(EVENT_SWARMER, 10000);
+			events.ScheduleEvent(EVENT_CHECK_HOME, 2000);
+			events.ScheduleEvent(EVENT_PLAGUE, 5000 + rand() % 3000);
+			events.ScheduleEvent(EVENT_BROOD_RAGE, 5000);
+		}
+
+		void DoAction(int32 param)
+		{
+			
+		}
+
+		void KilledUnit(Unit * /*victim*/)
+		{
+			if (urand(0, 1))
+				return;
+
+			switch (rand() % 3)
+			{
+			case 0:
+				me->PlayDirectSound(SOUND_SLAY1);
+				break;
+			case 1:
+				me->PlayDirectSound(SOUND_SLAY2);
+				break;
+			case 2:
+				me->PlayDirectSound(SOUND_SLAY3);
+				break;
+			}
+		}
+
+		void JustDied(Unit* /*killer*/)
+		{
+			events.Reset();
+			summons.DespawnAll();
+			me->PlayDirectSound(SOUND_DEATH);
+		}
+
+		void JustSummoned(Creature* cr)
+		{
+			if (cr)
+			{
+				if (cr->GetEntry() == NPC_AHNKAHAR_GUARDIAN_ENTRY)
+				{
+					switch (rand() % 2)
+					{
+					case 0:
+						me->PlayDirectSound(SOUND_SUMMON1);
+						break;
+					case 1:
+						me->PlayDirectSound(SOUND_SUMMON2);
+						break;
+					}
+				}
+
+				summons.Summon(cr);
+			}
+		}
+		void UpdateAI(uint32 diff)
+		{
+			if (!UpdateVictim())
+				return;
+
+			events.Update(diff);
+
+			if (me->HasUnitState(UNIT_STATE_CASTING))
+				return;
+
+			switch (events.GetEvent())
+			{
+			case EVENT_CHECK_HEALTH:
+			{
+				events.RepeatEvent(1000);
+				if (HealthBelowPct(50))
+				{
+					events.CancelEvent(EVENT_CHECK_HEALTH);
+					events.ScheduleEvent(EVENT_SUMMON_GUARD, 100);
+				}
+				break;
+			}
+			case EVENT_SUMMON_GUARD:
+			{
+				SummonHelpers(false);
+				events.PopEvent();
+				break;
+			}
+			case EVENT_BROOD_RAGE:
+			{
+				if (Creature *pSwarmer = me->FindNearestCreature(NPC_AHNKAHAR_SWARMER, 40, true))
+					me->CastSpell(pSwarmer, SPELL_BROOD_RAGE_H, true);
+
+				events.RepeatEvent(10000);
+				break;
+			}
+			case EVENT_PLAGUE:
+			{
+				me->CastSpell(me->GetVictim(), DUNGEON_MODE(SPELL_BROOD_PLAGUE, SPELL_BROOD_PLAGUE_H), false);
+				events.RepeatEvent(12000 + rand() % 5000);
+				break;
+			}
+			case EVENT_SWARMER:
+			{
+				SummonHelpers(true);
+				events.RepeatEvent(10000);
+				break;
+			}
+			case EVENT_CHECK_HOME:
+			{
+				if (me->HasAura(SPELL_ENRAGE))
+					break;
+
+				if (me->GetPositionZ() < 24)
+				{
+					me->CastSpell(me, SPELL_ENRAGE, true);
+					events.PopEvent();
+					break;
+				}
+
+				events.RepeatEvent(2000);
+				break;
+			}
+			}
+
+			DoMeleeAttackIfReady();
+		}
+	};
+
+	CreatureAI *GetAI(Creature *creature) const
+	{
+		return new boss_2AI(creature);
+	}
+};
+
+void AddSC_BossScript_Collection()
+{
+	new boss_3;
+	new boss_1;
+	new boss_2;
+}
diff --git a/src/server/scripts/Custom/Boss/boss_darksaw.cpp b/src/server/scripts/Custom/Boss/boss_darksaw.cpp
new file mode 100644
index 0000000..4dde67d
--- /dev/null
+++ b/src/server/scripts/Custom/Boss/boss_darksaw.cpp
@@ -0,0 +1,727 @@
+#pragma execution_character_set("utf-8")
+#include "../PrecompiledHeaders/ScriptPCH.h"
+
+
+
+
+/***********************************************,
+* Creator: Zeau (Molten WoW - Deathwing)  *
+* Creature: The Dark SAW - My First Boss!  *
+* Made because: Eductional purposes.   *
+* I learned a lot by creating this script and *
+* I hope it will be usefull to you too. Enjoy! *
+************************************************'
+
+/* ScriptData
+SDName: boss_darksaw
+SD%Complete: 90
+SDComment: I believe some (if not all) sounds the boss produces will be played amongst all the players @ current map. Im not 100 % sure of this,
+anyway it is not a priority to me. (If this 'problem' is true and u fixed it, drop it in comments
+SDCategory: Custom Boss
+EndScriptData */
+
+/* SQLData README:
+
+For the dialogues to work (most of his talking) you will have to:
+1 replace the '99xxx' with your own creatures GUID,
+1b Only if your World database name differs from 'world', change 'world.creature_text' also.
+2 execute the next query on your database:
+
+REPLACE INTO `world.creature_text` (`entry`, `groupid`, `id`, `text`, `type`, `language`, `probability`, `emote`, `duration`, `sound`, `comment`) VALUES
+(99xxx, 0, 0, 'So the Light''s vaunted justice has finally arrived? Shall I lay down Frostmourne and throw myself at your mercy, Fordring?', 14, 0, 0, 0, 0, 17349, 'The Lich King - SAY_LK_INTRO_1'),
+(99xxx, 1, 0, 'You''ll learn of that first hand. When my work is complete, you will beg for mercy -- and I will deny you. Your anguished cries will be testament to my unbridled power...', 14, 0, 0, 22, 0, 17350, 'The Lich King - SAY_LK_INTRO_2'),
+(99xxx, 2, 0, 'I''ll keep you alive to witness the end, Fordring. I would not want the Light''s greatest champion to miss seeing this wretched world remade in my image.', 14, 0, 0, 0, 0, 17351, 'The Lich King - SAY_LK_INTRO_3'),
+(99xxx, 3, 0, 'Come then champions, feed me your rage!', 14, 0, 0, 0, 0, 0, 'The Lich King - SAY_LK_AGGRO'),
+(99xxx, 4, 0, 'I will freeze you from within until all that remains is an icy husk!', 14, 0, 0, 0, 0, 17369, 'The Lich King - SAY_LK_REMORSELESS_WINTER'),
+(99xxx, 5, 0, 'Watch as the world around you collapses!', 14, 0, 0, 0, 0, 17370, 'The Lich King - SAY_LK_QUAKE'),
+(99xxx, 6, 0, 'Val''kyr, your master calls!', 14, 0, 0, 0, 0, 17373, 'The Lich King - SAY_LK_SUMMON_VALKYR'),
+(99xxx, 7, 0, 'Frostmourne hungers...', 14, 0, 0, 0, 0, 17366, 'The Lich King - SAY_LK_HARVEST_SOUL'),
+(99xxx, 8, 0, 'Argh... Frostmourne, obey me!', 14, 0, 0, 0, 0, 17367, 'The Lich King - SAY_LK_FROSTMOURNE_ESCAPE'),
+(99xxx, 9, 0, 'Frostmourne feeds on the soul of your fallen ally!', 14, 0, 0, 0, 0, 17368, 'The Lich King - SAY_LK_FROSTMOURNE_KILL'),
+(99xxx, 10, 0, 'Hope wanes!', 14, 0, 0, 0, 0, 17363, 'The Lich King - SAY_LK_KILL'),
+(99xxx, 10, 1, 'The end has come!', 14, 0, 0, 0, 0, 17364, 'The Lich King - SAY_LK_KILL'),
+(99xxx, 11, 0, 'Face now your tragic end!', 14, 0, 0, 0, 0, 17365, 'The Lich King - SAY_LK_BERSERK'),
+(99xxx, 12, 0, '%s begins to cast Defile!', 41, 0, 0, 0, 0, 0, 'The Lich King - EMOTE_DEFILE_WARNING'),
+(99xxx, 13, 0, '|TInterface\\Icons\\ability_creature_disease_02.blp:16|tYou have been infected by |cFFCF00FFNecrotic Plague!|r', 42, 0, 0, 0, 0, 0, 'The Lich King - EMOTE_NECROTIC_PLAGUE_WARNING'),
+(99xxx, 14, 0, 'No questions remain unanswered. No doubts linger. You ARE Azeroth''s greatest champions. You overcame every challenge I laid before you. My mightiest servants have fallen before your relentless onslaught... your unbridled fury...', 14, 0, 0, 0, 0, 17353, 'The Lich King - SAY_LK_OUTRO_1'),
+(99xxx, 15, 0, 'Is it truly the righteousness that drives you? I wonder...', 14, 0, 0, 0, 0, 17354, 'The Lich King - SAY_LK_OUTRO_2'),
+(99xxx, 16, 0, 'You trained them well, Fordring. You delivered the greatest fighting force this world has ever known... right into my hands -- exactly as I intended. You shall be rewarded for your unwitting sacrifice.', 14, 0, 0, 0, 0, 17355, 'The Lich King - SAY_LK_OUTRO_3'),
+(99xxx, 17, 0, 'Watch now as I raise them from the dead to become masters of the Scourge. They will shroud this world in chaos and destruction. Azeroth''s fall will come at their hands -- and you will be the first to die.', 14, 0, 0, 0, 0, 17356, 'The Lich King - SAY_LK_OUTRO_4'),
+(99xxx, 18, 0, 'I delight in the irony...', 14, 0, 0, 0, 0, 17357, 'The Lich King - SAY_LK_OUTRO_5'),
+(99xxx, 19, 0, 'Impossible...', 14, 0, 0, 0, 0, 17358, 'The Lich King - SAY_LK_OUTRO_6'),
+(99xxx, 20, 0, 'Now I stand, the lion before the lambs... and they do not fear.', 14, 0, 0, 0, 0, 17361, 'The Lich King - SAY_LK_OUTRO_7'),
+(99xxx, 21, 0, 'They cannot fear.', 14, 0, 0, 0, 0, 17362, 'The Lich King - SAY_LK_OUTRO_8');
+
+And you are good to go
+*/
+
+//Spells
+#define SPELL_ICE_ARMOR     36881
+#define SPELL_LIGHTNING_BOLT        548
+#define SPELL_BLISTERING_COLD       71049
+#define SPELL_DARKWINTER   74275
+#define SPELL_SHADOW_SPIKE   46589
+#define SPELL_BERSERK               45078
+#define SPELL_SINBEAM    40827
+#define SPELL_SOULSTORM             68872
+#define SPELL_SOULSTORM_CHANNEL     69008
+#define SPELL_SOULSTORM_VISUAL      68870
+#define SPELL_FEAR     68950
+#define SPELL_FROST_BEACON   70126
+#define SPELL_FRENZY                8269
+#define SPELL_WHITEOUT    72034 // 30 % Debuff
+#define SPELL_FROZEN_MALLET   71993
+#define SPELL_CHAIN_LIGHTNING  33665
+#define SPELL_HARVEST_SOUL   68980
+#define SPELL_FURY_ANTICHEAT  72350
+#define SPELL_RAISE_DEAD   71769
+#define SPELL_DRAIN_MANA   5138
+#define SPELL_BLIZZARD    26607
+#define SPELL_JUMP_TO_TARGET  64430
+#define DEATH_GRIP     64431
+#define MIRROR_IMAGE    55342
+#define MIRROR_IMAGE_PREEFFECT  8677
+#define MIRROR_IMAGE_TIMER   180000
+// Orb spell info
+#define SPELL_ORB_FLARE_PASSIVE   30234
+
+enum Events
+{
+	// Global Events:
+	EVENT_WHITEOUT = 1,
+	EVENT_BERSERK = 2,
+	EVENT_BLISTER = 3,
+
+	// Phase 1
+	EVENT_SHADOW_SPIKE = 4,
+	EVENT_SOULSTORM = 5,
+	EVENT_FEAR = 6,
+	EVENT_FRENZY = 7,
+	EVENT_CHAIN_LIGHTNING = 8,
+
+	// Phase 2
+	EVENT_BLISTERING_COLD = 9,
+	EVENT_DRAIN_MANA = 10,
+	EVENT_FROZEN_ORB = 11,
+	EVENT_SINBEAM = 12,
+	EVENT_FROST_BEACON = 13,
+
+	// Common Events:
+	EVENT_RANDOM_CHAT = 14,
+	EVENT_INTRO = 15,
+	EVENT_COMBAT = 16,
+	EVENT_INTROB = 17,
+	EVENT_INTROC = 18,
+	EVENT_PAYBACK = 19,
+	EVENT_HARVEST_SOUL = 20,
+	EVENT_REVIVE = 21,
+	EVENT_PLAYSOUND_CAST1A = 22,
+	EVENT_PLAYSOUND_CAST1B = 23,
+	EVENT_SOULFRAGMENT = 24,
+	EVENT_MIRROR_IMAGE = 25,
+	EVENT_MIRROR_IMAGE_MAINSPELL = 26,
+	EVENT_GHOSTLY = 27,
+};
+
+// FYI: You can have 1-8 phases max.
+enum Phases
+{
+	PHASE_NONE = 1,
+	PHASE_ONE = 2,
+	PHASE_TWO = 3,
+	PHASE_OWNED = 4,
+	PHASE_OUTRO = 5,
+};
+
+//Chats
+enum Texts
+{
+	// The Lich King
+	SAY_LK_INTRO_1 = 0,
+	SAY_LK_INTRO_2 = 1,
+	SAY_LK_INTRO_3 = 2,
+	SAY_LK_AGGRO = 3,
+	SAY_LK_REMORSELESS_WINTER = 4,
+	SAY_LK_QUAKE = 5,
+	SAY_LK_SUMMON_VALKYR = 6,
+	SAY_LK_HARVEST_SOUL = 7,
+	SAY_LK_FROSTMOURNE_ESCAPE = 8,
+	SAY_LK_FROSTMOURNE_KILL = 9,
+	SAY_LK_KILL = 10,
+	SAY_LK_BERSERK = 11,
+	EMOTE_DEFILE_WARNING = 12,
+	EMOTE_NECROTIC_PLAGUE_WARNING = 13,
+	SAY_LK_OUTRO_1 = 14,
+	SAY_LK_OUTRO_2 = 15,
+	SAY_LK_OUTRO_3 = 16,
+	SAY_LK_OUTRO_4 = 17,
+	SAY_LK_OUTRO_5 = 18,
+	SAY_LK_OUTRO_6 = 19,
+	SAY_LK_OUTRO_7 = 20,
+	SAY_LK_OUTRO_8 = 21,
+};
+
+enum MiscData
+{
+	MUSIC_FROZEN_THRONE = 17457,
+	MUSIC_SPECIAL = 17458,
+	MUSIC_FURY_OF_FROSTMOURNE = 17459,
+	MUSIC_FINAL = 17460,
+	EQUIP_ASHBRINGER_GLOWING = 50442,
+	EQUIP_BROKEN_FROSTMOURNE = 50840,
+};
+
+enum AuraSpells
+{
+	AURA_TWISTER = 13913,
+	AURA_SHADOW = 16592,
+	AURA_REFLECTION = 10831,
+	AURA_SOULFRAGMENT = 71905,
+	AURA_GHOSTLY = 16713,
+};
+
+enum AuraSpells_Timers
+{
+	AURA_SOULFRAGMENT_timer = 6000,
+};
+
+// Adds Settings
+#define ADD_ID_TOSPAWN   17096
+#define ADD_MAX_ADDS   14
+#define MIN_PAUSE_CHATTER  16000 // Timer of the random chatter (Do not set too low or you will get crazy).
+
+// Declarations
+bool _soulstormed;
+bool _frenzied;
+bool _berserking; // The scripting for this is not compltete yet so I recommend nog using the according phase yet or write it yourself it is not hard.
+bool _reflectdmg; // Same --^
+bool _has_orb_adds = false;
+bool _playerscheating = false;
+
+int _current_orbs;
+int _ticks;
+uint32 _inMeleeRange;
+uint32 _lasthp;
+uint32 _newhp, _hplost;
+uint32 _totaldmgtaken;
+uint32 _chatter_timer;
+uint32 t;
+
+//Modelsmorph
+#define MODEL_DARKSAW  30721 // LichKing. In my case not needed, because my creature already has value 30721 as displayID in the database.
+#define MODEL_CLONE_DIED 24641 // The spawned Arthas Mirages. We change their model @ death (mostly for visual enjoyment).
+
+// The actual Boss Class:
+class boss_darksaw : public CreatureScript
+{
+public:
+	boss_darksaw() : CreatureScript("boss_darksaw"){}
+
+	CreatureAI* GetAI(Creature* pCreature) const
+	{
+		return new boss_darksawAI(pCreature);
+	}
+
+	struct boss_darksawAI : public ScriptedAI
+	{
+		boss_darksawAI(Creature *c) : ScriptedAI(c) {}
+
+		// Class Inits (Occurs only once @ script init:
+		EventMap events;
+
+		uint32 addztimer;
+		uint32 _last_lk_special; // Also chatter.
+
+
+		// What to reset @ first init, after boss died, players died or fled:
+		void Reset()
+		{
+			// First, reset eventsmap
+			events.Reset();
+			// Walk Speed (Or set in in DB, but do NOT do that is you choose other Model ID than Lich King as I dids):
+			me->SetSpeed(MOVE_WALK, 2.6f, false);
+			// Act cool:
+			me->SetWalk(false);
+
+			// Remove all spells and auras from previous attempts
+			me->RemoveAllAuras();
+
+			// set some used variables
+			_berserking = false;
+			_frenzied = false;
+			_soulstormed = false;
+			_has_orb_adds = false;
+			_playerscheating = false;
+			_ticks = 0;
+
+			events.SetPhase(PHASE_NONE);
+			me->SetReactState(REACT_AGGRESSIVE);
+
+			// Ghost Effect
+			me->AddAura(AURA_GHOSTLY, me);
+		}
+
+		void EnterCombat(Unit* who)
+		{
+			// Stay relaxed:
+			me->SetWalk(true);
+
+			// Remove Ghost effect
+			events.CancelEvent(EVENT_GHOSTLY);
+			me->RemoveAura(AURA_GHOSTLY);
+
+			// Some fool pulled,. (: start the war:
+			events.SetPhase(PHASE_ONE);
+
+			DoPlaySoundToSet(me, 17458); // Some intromusic, does not interrupt current music and does not loop.
+			me->AddThreat(who, 30.0f);
+			me->AI()->AttackStart(me);
+			me->setActive(true);
+
+			events.ScheduleEvent(EVENT_INTRO, 100);
+		}
+		void DamageTaken(Unit* attacker, uint32& damage, DamageEffectType, SpellSchoolMask)
+		{
+			/* // Not Finished yet,.
+			// Cannot lose 1 % HP in 1 tick.. I will cheat!
+			if ((me->GetMaxHealth() / 100) <= damage) {
+			events.ScheduleEvent(EVENT_PAYBACK, 2500);
+			me->Yell("Your end is nigh!",LANG_UNIVERSAL,NULL);
+			_playerscheating = true;
+			}
+			*/
+
+
+			if (damage > 0) {
+
+				me->AddThreat(me->GetVictim(), 1.0f);
+
+				if (_reflectdmg && attacker->HasAura(AURA_REFLECTION))
+				{ // When reflect avtive, cast 10% of damage done back to boss. 
+					attacker->DealDamage(attacker,attacker->GetVictim(), damage * 0.1, 0, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_ALL, 0, true);
+					// me->MonsterSay("Debug: Aura Powered!..",LANG_UNIVERSAL,NULL);
+				}
+				/*
+				_totaldmgtaken = _totaldmgtaken + damage;
+				if (_ticks == 10)
+				{
+				// After
+				}
+				*/
+			}
+
+			if (!_frenzied && !HealthAbovePct(75))
+			{
+				// add the shadowaura if not already present:
+				if (!me->HasAura(AURA_REFLECTION)) { me->AddAura(AURA_SHADOW, me); }
+			}
+			if (!_frenzied && !HealthAbovePct(50))
+			{
+				// schedule the event that changes our phase
+				_frenzied = true;
+				events.ScheduleEvent(EVENT_FRENZY, 100);
+			}
+			if (!_berserking && !HealthAbovePct(24))
+			{
+				// schedule the event that also changes our phase:
+				_berserking = true;
+				// It works, but atm not recommended. It gives 900% damage buff 
+				// Just leave the boolean True at all times.
+				// events.ScheduleEvent(EVENT_BERSERK, 100);
+			}
+			// we're losing health bad, go insane!
+			if (!_soulstormed && !HealthAbovePct(15))
+			{
+				_soulstormed = true;
+				events.ScheduleEvent(EVENT_SOULSTORM, 100);
+			}
+		}
+
+		void JustDied(Unit* /*killer*/)
+		{
+			events.Reset();
+			if (RAND(1, 2) == 1) { Talk(SAY_LK_FROSTMOURNE_ESCAPE); _chatter_timer = 0; } // 50 % chance he will comment on death.
+			me->RemoveAllAuras();
+		}
+
+		void KilledUnit(Unit* victim)
+		{
+			if (victim->GetGUID() == me->GetEntry()) // Wanneer een Clone.
+			{
+				victim->SetDisplayId(MODEL_CLONE_DIED);
+			}
+			if (victim && victim->GetCreatureType() == CREATURE_TYPE_HUMANOID) //GetTypeId() == TYPEID_PLAYER && me->IsValidAttackTarget(victim))
+			{
+				me->MonsterSay("¹þ...ÄãÍêµ°ÁË...", LANG_UNIVERSAL, NULL);
+				if (RAND(1, 2) == 1) Talk(RAND(SAY_LK_FROSTMOURNE_KILL, SAY_LK_HARVEST_SOUL, SAY_LK_KILL)); // 50 % Kans dat er een opmerking komt.
+				_chatter_timer = 0;
+			}
+		}
+
+		//--
+
+		void UpdateAI(uint32 diff)
+		{
+			// Updates Out of Combat
+			if (me->GetAuraCount(AURA_GHOSTLY) < 1)
+			{
+				if (!UpdateVictim()) { me->AddAura(AURA_GHOSTLY, me); }
+			}
+
+			if (!UpdateVictim()) return;
+
+
+			// Updates IN Combat
+			events.Update(diff);
+
+			//Timers Updates/Reset:
+			_ticks++;
+			_current_orbs = 0;
+			_last_lk_special += diff;
+			_chatter_timer += diff;
+
+
+			// Adds and other EVENTless stuff:
+			if (_has_orb_adds == true && addztimer <= diff)
+			{
+				std::list<Creature*> IcicleAddsList;
+				GetCreatureListWithEntryInGrid(IcicleAddsList, me, ADD_ID_TOSPAWN, 100.0f);
+				for (std::list<Creature*>::iterator itr = IcicleAddsList.begin(); itr != IcicleAddsList.end(); ++itr)
+				{
+					/*(*itr)->*/ ++_current_orbs; // Optionally, you also can do stuff with (*itr)-> here.
+				}
+
+				if (_current_orbs < ADD_MAX_ADDS)
+				{
+					if (RAND(1, 4) == 1) { events.ScheduleEvent(EVENT_PLAYSOUND_CAST1A, 10); _chatter_timer = 0; }
+
+					//Summon Orb Add
+					Creature* AstralOrb = DoSpawnCreature(17096, float(rand() % 47), float(rand() % 47), 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+					Unit* target = NULL; target = SelectTarget(SELECT_TARGET_TOPAGGRO, 0);
+
+					if (AstralOrb && target)
+					{
+						AstralOrb->CastSpell(AstralOrb, SPELL_ORB_FLARE_PASSIVE, false);
+						AstralOrb->AI()->AttackStart(target);
+					}
+				}
+				addztimer = 10000;
+			}
+			else addztimer -= diff;
+
+
+			// return back to main code if we're still casting
+			if (me->HasUnitState(UNIT_STATE_CASTING))
+				return;
+
+			while (uint32 eventId = events.ExecuteEvent())
+			{
+				switch (eventId)
+				{
+					// CasterSounds:
+				case EVENT_PLAYSOUND_CAST1A:
+					t = RAND(14803, 14771, 14751);
+					if (t == 14803) { me->MonsterYell("ÓÃÉíÌåÈ¥¸ÐÊÜ£¡", LANG_UNIVERSAL, NULL); }
+					if (t == 14771) { me->MonsterYell("¾ø²»ÁôÇé£¡", LANG_UNIVERSAL, NULL); }
+					if (t == 14751) { me->MonsterYell("ÄãµÄ¶ÓÎéÒ»ÎÞÊÇ´¦£¡", LANG_UNIVERSAL, NULL); }
+					events.ScheduleEvent(EVENT_PLAYSOUND_CAST1B, 2500);
+					DoPlaySoundToSet(me, t); // Touchy.. / No Mercy. / Your.. Army..
+					_chatter_timer = 0;
+					break;
+				case EVENT_PLAYSOUND_CAST1B:
+					_chatter_timer = 0;
+					t = RAND(14795, 14786, 14787);
+					if (t == 14795) { me->MonsterYell("ÄÇÃ´, ÄãµÄÓÂÆøºÎÔÚ£¿", LANG_UNIVERSAL, NULL); }
+					if (t == 14786) { me->MonsterYell("ÎÞÂÛÊÇÉúÊÇËÀ£¬Äã½«ÓÀÎÞÄþÈÕ£¡", LANG_UNIVERSAL, NULL); }
+					if (t == 14787) { me->MonsterYell("Í´¿à£¬ÕÛÄ¥!", LANG_UNIVERSAL, NULL); }
+					DoPlaySoundToSet(me, t); // Where is your light now crusaders? / 14786 u will serve me ..
+					_chatter_timer = 0;
+					break;
+
+					// Berserk Handler:
+				case EVENT_BERSERK:
+					_reflectdmg = true; // Now reflecting big portion of damage back to LK.
+
+					// Our positive BUFF:
+					me->AddAura(AURA_REFLECTION, me->GetVictim());
+					me->GetVictim()->BuildAuraStateUpdateForTarget(me->GetVictim());
+
+					// Bosses Negative buff:
+					me->RemoveAurasDueToSpell(SPELL_BERSERK);
+					me->CastSpell(me, SPELL_BERSERK);
+
+					DoPlaySoundToSet(me, 13878);// Buff Sound
+					DoPlaySoundToSet(me, 14805); // LK Sound
+
+
+					_chatter_timer = 0;
+					break;
+
+					// Cheaters payback! ^^ (Disabled)
+				case EVENT_PAYBACK:
+					/*
+					_has_orb_adds = false; // No adds now.
+					events.SetPhase(PHASE_OWNED);
+					DoCastAOE(SPELL_FURY_ANTICHEAT,true); // Some more overkill
+					me->Yell("So, Too can play that game, nib! ;)",LANG_UNIVERSAL,NULL);
+					_chatter_timer = 0;
+					me->SetWalk(true);
+					Talk(SAY_LK_OUTRO_2); // Fake outro,.
+					_chatter_timer = 0;
+					*/
+					break;
+
+					// Random Chatter:
+				case EVENT_RANDOM_CHAT:
+					if (_chatter_timer > MIN_PAUSE_CHATTER)
+					{
+						_chatter_timer = 0;
+						t = RAND(1, 4);
+						if (t == 1){
+							Talk(RAND(
+								SAY_LK_OUTRO_5,
+								SAY_LK_KILL,
+								SAY_LK_FROSTMOURNE_KILL,
+								SAY_LK_AGGRO));
+						}
+						else{
+							t = RAND(
+								14738, // "You have crossed into the world of the dead in search of answers. You wish to save you ally, and have risked life and limb to be here. Allow me to help."
+								14745, // "But.. It is not yet your time to serve the Lich King. Yes, a greater destiny awaits you. Power.. You must become more powerful before you are to serve me."
+								14754, // "Fail me and it shall be your undoing.."
+								14755, // "Succeed and even greater power shall be yours!"
+
+								14760, // Random,. 
+								//14770, // "Very well.. warriors of the frozen wastes, rise up! I command you to fight, kill, and die for your master. Let none survive.."
+								14773,  // "Mercy is for the weak!"
+								14792,  // "Let the destruction of this place, serve as a lesson.. To all those who would dare oppose the scourge.."
+
+								//14799,  // "Come to me, crusaders. I will remake you!"
+								14802,  // "Lay down your arms, and surrender your souls."
+								14766); // "Be warned.."
+
+							if (t == 14738) { me->MonsterYell("Äã¾ÓÈ»µ¨¸ÒÌôÕ½ÎÒ£¬ÈÃÄãËÀÎÞÔáÉíÖ®µØ£¡", LANG_UNIVERSAL, NULL); }
+							if (t == 14745) { me->MonsterYell("ÏÖÔÚÊÇÊ±ºò¸¶³ö´ú¼ÛÁË£¡", LANG_UNIVERSAL, NULL); }
+							if (t == 14754) { me->MonsterYell("Çë´ò°ÜÎÒ°É£¬ÎÞµÐÊÇ¶àÃ´¼ÅÄ¯...", LANG_UNIVERSAL, NULL); }
+							if (t == 14755) { me->MonsterYell("ÄãµÄÁ¦Á¿½«ÎªÎÒ´øÀ´ÎÞ¾¡Ï²ÔÃ...", LANG_UNIVERSAL, NULL); }
+
+							if (t == 14760) { me->MonsterYell("LOL...", LANG_UNIVERSAL, NULL); }
+							//if (t==14770) { me->Yell("Very well.. warriors of the frozen wastes, rise up! I command you to fight, kill, and die for your master. Let none survive..",LANG_UNIVERSAL,NULL); }
+							if (t == 14773) { me->MonsterYell("ÈõÈâÇ¿Ê³£¡", LANG_UNIVERSAL, NULL); }
+							if (t == 14792) { me->MonsterYell("ÎÒÀ´´ËÖ»ÊÇÎªÁË±»ÌôÕ½...", LANG_UNIVERSAL, NULL); }
+
+							//if (t==14799) { me->Yell("Come to me, crusaders. I will remake you!",LANG_UNIVERSAL,NULL); }
+							if (t == 14802) { me->MonsterYell("¼´Ê¹ÊÇÁé»ê£¬Ò²ÒªÏòÎÒµÍÍ·£¡", LANG_UNIVERSAL, NULL); }
+							if (t == 14766) { me->MonsterYell("ÄãËÀ¶¨ÁË...", LANG_UNIVERSAL, NULL); }
+
+							DoPlaySoundToSet(me, t); // Touchy.. / No Mercy. / Your.. Army..
+							_chatter_timer = 0;
+						}
+					}
+					events.ScheduleEvent(EVENT_RANDOM_CHAT, urand(14000, 16000));
+					break;
+
+					// PHASE_ONE:
+				case EVENT_CHAIN_LIGHTNING:
+					if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM))
+						//me->CastCustomSpell(SPELL_CHAIN_LIGHTNING, SPELLVALUE_MAX_TARGETS, 1, target, false);
+						DoCast(me->GetVictim(), SPELL_CHAIN_LIGHTNING);
+					events.ScheduleEvent(EVENT_CHAIN_LIGHTNING, urand(7000, 11000), 0, PHASE_ONE);
+					break;
+
+				case EVENT_WHITEOUT:
+					Talk(RAND(SAY_LK_FROSTMOURNE_ESCAPE, SAY_LK_HARVEST_SOUL)); // Warning - Important.
+					DoCast(me, SPELL_WHITEOUT);
+					events.ScheduleEvent(EVENT_WHITEOUT, 120000, 0, PHASE_ONE);
+					break;
+
+				case EVENT_BLISTERING_COLD:
+					_inMeleeRange = 0;
+					for (uint8 i = 0; i < 10; ++i)
+					{
+						if (Unit* target = SelectTarget(SELECT_TARGET_TOPAGGRO, i))
+							// check if target is within melee-distance
+							if (me->IsWithinMeleeRange(target))
+								++_inMeleeRange;
+					}
+					// trigger spellcast only if we have 1 or more targets to affect..
+					if (_inMeleeRange >= 1)
+					{ // ..and only if a frost add is near:
+						if (Creature *SummonedAdd = GetClosestCreatureWithEntry(me, ADD_ID_TOSPAWN, 3.0f))
+						{
+							Talk(RAND(SAY_LK_OUTRO_5, SAY_LK_BERSERK));   // Warning - Important.
+							DoCast(me->GetVictim(), SPELL_BLISTERING_COLD);
+							_chatter_timer = 0;
+						}
+						else
+						{
+							//me->Yell("<Blistering Cold Evaded>",LANG_UNIVERSAL,NULL); // Debug.
+						}
+
+					}
+					events.ScheduleEvent(EVENT_BLISTERING_COLD, urand(10000, 20000));
+					break;
+
+				case EVENT_SHADOW_SPIKE:
+					if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM))
+						DoCast(target, SPELL_SHADOW_SPIKE);
+					events.ScheduleEvent(EVENT_SHADOW_SPIKE, urand(4500, 6000), 0, PHASE_ONE);
+					break;
+
+				case EVENT_FEAR:
+					//me->Yell("Hahaha...",LANG_UNIVERSAL,NULL);
+					DoPlaySoundToSet(me, 14820);
+					_chatter_timer = 0;
+					if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM))
+						me->CastCustomSpell(SPELL_FEAR, SPELLVALUE_MAX_TARGETS, 1, target, false);
+					events.ScheduleEvent(EVENT_FEAR, urand(12000, 48000), 0, PHASE_ONE);
+					break;
+
+				case EVENT_DRAIN_MANA:
+					DoCastAOE(SPELL_DRAIN_MANA);
+					events.ScheduleEvent(EVENT_DRAIN_MANA, urand(10000, 12000), 0, PHASE_TWO);
+					break;
+
+				case EVENT_SINBEAM:
+					DoCast(me->GetVictim(), SPELL_SINBEAM);
+					events.ScheduleEvent(EVENT_SINBEAM, urand(4000, 6000), 0, PHASE_TWO);
+					break;
+
+				case EVENT_GHOSTLY:
+					me->AddAura(AURA_GHOSTLY, me);
+					events.ScheduleEvent(EVENT_GHOSTLY, 55);
+					break;
+
+				case EVENT_SOULSTORM:
+					_has_orb_adds = false; // From now on, no more ads that cause Blistering Cold explosions.
+					// Notice: Resetting all current auras on boss, if you dont, the Soulstorm will most likely crash the client.
+					me->RemoveAura(SPELL_BERSERK); // Extra, might not be neccesary.
+					me->RemoveAura(AURA_SHADOW); // Extra, better safe than sorry.
+					me->RemoveAllAuras();
+
+					Talk(SAY_LK_QUAKE); _chatter_timer = 0;
+					me->CastSpell(me, SPELL_SOULSTORM_VISUAL, true);
+					me->CastSpell(me, SPELL_SOULSTORM, false);
+					break;
+
+				case EVENT_FROST_BEACON:
+					if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM))
+						DoCast(target, SPELL_FROST_BEACON);
+					events.ScheduleEvent(EVENT_FROST_BEACON, urand(40000, 75000), 0, PHASE_TWO);
+					break;
+
+				case EVENT_HARVEST_SOUL:
+					Talk(SAY_LK_HARVEST_SOUL); _chatter_timer = 0;
+					if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM))
+						// DoCast(target, SPELL_HARVEST_SOUL);
+						DoCastAOE(SPELL_HARVEST_SOUL);
+					events.ScheduleEvent(EVENT_HARVEST_SOUL, urand(40000, 75000), 0, PHASE_TWO);
+					break;
+
+				case EVENT_SOULFRAGMENT:
+					if (me->GetAuraCount(AURA_SOULFRAGMENT) < 9)
+					{
+						events.CancelEvent(EVENT_SOULFRAGMENT);
+						DoCast(me, AURA_SOULFRAGMENT);
+					}
+					events.ScheduleEvent(EVENT_SOULFRAGMENT, AURA_SOULFRAGMENT_timer); // Lasts untill cancelled 
+					break;
+
+				case EVENT_MIRROR_IMAGE:
+					DoCast(me, MIRROR_IMAGE_PREEFFECT);
+					events.ScheduleEvent(EVENT_MIRROR_IMAGE_MAINSPELL, 4800);
+					break;
+				case EVENT_MIRROR_IMAGE_MAINSPELL:
+					for (uint8 i = 0; i < 2; ++i)
+					{
+						// DoCast(me, MIRROR_IMAGE);
+						//Summon Clone, will dissappear after a short while when out of combat.
+						Creature* MyDarkClone = DoSpawnCreature(me->GetEntry(), float(rand() % 47), float(rand() % 47), 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 5000);
+						Unit* Clonetarget = NULL;
+						Clonetarget = SelectTarget(SELECT_TARGET_TOPAGGRO, 0);
+
+						if (MyDarkClone && Clonetarget)
+						{
+							// MyDarkClone->CastSpell(MyDarkClone, SPELL_ORB_FLARE_PASSIVE, false);
+							MyDarkClone->AddAura(AURA_GHOSTLY, MyDarkClone);
+							MyDarkClone->AI()->AttackStart(Clonetarget);
+						}
+						events.ScheduleEvent(EVENT_MIRROR_IMAGE, MIRROR_IMAGE_TIMER); // Lasts untill cancelled 
+					}
+					break;
+
+					//
+					// Defining Phases:
+					//
+
+					// Phase 2 Events:
+				case EVENT_FRENZY:
+					events.SetPhase(PHASE_TWO);
+
+					events.ScheduleEvent(EVENT_DRAIN_MANA, 5000, 0, PHASE_TWO);
+					events.ScheduleEvent(EVENT_SINBEAM, 2000, 0, PHASE_TWO);
+					events.ScheduleEvent(EVENT_FROZEN_ORB, 1500, 0, PHASE_TWO);
+					events.ScheduleEvent(EVENT_HARVEST_SOUL, urand(40000, 75000), 0, PHASE_TWO);
+					events.ScheduleEvent(EVENT_BLISTERING_COLD, 120000, 0, PHASE_TWO);
+
+					t = RAND(14808, 14800, 14787);
+					if (t == 14808) { me->MonsterYell("ÎÒÒªÄãÖÂÇ¸£¡£¡£¡", LANG_UNIVERSAL, NULL); }
+					if (t == 14800) { me->MonsterYell("²ü¶¶°É£¬·²ÈË£¡", LANG_UNIVERSAL, NULL); }
+					if (t == 14787) { me->MonsterYell("Í´¿à£¬ÕÛÄ¥£¡", LANG_UNIVERSAL, NULL); }
+					DoPlaySoundToSet(me, t);
+					_chatter_timer = 0;
+					DoCast(me, SPELL_FRENZY, true);
+					break;
+
+					// Phase 1 Events:
+				case EVENT_COMBAT:
+					me->SetWalk(false);
+
+					// Always running events
+					_has_orb_adds = true;
+					addztimer = 10000;
+
+					// Starten random chats:
+					events.ScheduleEvent(EVENT_RANDOM_CHAT, 21000);
+
+					// If you uncomment next line, you will most certainly die (fast).
+					// DoCast(me, SPELL_FROZEN_MALLET); // Will go insane with stacks...
+
+					events.ScheduleEvent(EVENT_SOULFRAGMENT, 100);
+
+					// Phase one events (regular form)
+					events.ScheduleEvent(EVENT_MIRROR_IMAGE, 4000);
+					events.ScheduleEvent(EVENT_SHADOW_SPIKE, 5000, 0, PHASE_ONE);
+					events.ScheduleEvent(EVENT_CHAIN_LIGHTNING, 9000, 0, PHASE_ONE);
+					events.ScheduleEvent(EVENT_FEAR, 25000, 0, PHASE_ONE);
+					events.ScheduleEvent(EVENT_BLISTERING_COLD, urand(10000, 20000), 0, PHASE_ONE);
+					events.ScheduleEvent(EVENT_WHITEOUT, 120000, 0, PHASE_ONE);
+					break;
+
+					// Intro Events:
+				case EVENT_INTRO:
+					Talk(SAY_LK_INTRO_1);
+					events.ScheduleEvent(EVENT_INTROB, 12500);
+					break;
+
+				case EVENT_INTROB:
+					Talk(SAY_LK_INTRO_2);
+					events.ScheduleEvent(EVENT_COMBAT, 12500);
+					break;
+
+				default:
+					break;
+
+				}
+			}
+			DoMeleeAttackIfReady();
+		}
+	};
+};
+
+
+void AddSC_boss_darksaw()
+{
+	new boss_darksaw();
+}
+
diff --git a/src/server/scripts/Custom/CDK/CDK.cpp b/src/server/scripts/Custom/CDK/CDK.cpp
new file mode 100644
index 0000000..d293380
--- /dev/null
+++ b/src/server/scripts/Custom/CDK/CDK.cpp
@@ -0,0 +1,111 @@
+#pragma execution_character_set("utf-8")
+#include "CDK.h"
+#include "../Reward/Reward.h"
+#include <fstream>
+#include <iostream>
+
+std::unordered_map<std::string, uint32> CDKMap;
+
+void CDKC::Load()
+{
+	CDKMap.clear();
+
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ¶Ò»»Âë, ½±ÀøÄ£°åID FROM __¶Ò»»Âë" :
+		"SELECT cdk, rewId FROM _cdk");
+
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			CDKMap.insert(std::make_pair(fields[0].GetString(), fields[1].GetUInt32()));
+
+		} while (result->NextRow());
+	}
+}
+
+std::string CDKC::Create()
+{
+	int name_len = 10;
+	char buff[128];
+	char metachar[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
+
+	for (int i = 0; i < name_len - 1; i++)
+		buff[i] = metachar[urand(0, 61)];
+
+	buff[name_len - 1] = '\0';
+
+	std::string s = buff;
+
+	return s;
+}
+
+void CDKC::Create(uint32 count, uint32 rewId, std::string comment)
+{
+	for (size_t i = 0; i < count; i++)
+		WorldDatabase.DirectPExecute(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"INSERT INTO __¶Ò»»Âë(±¸×¢,¶Ò»»Âë,½±ÀøÄ£°åID) VALUES ('%s','%s','%u')" :
+		"INSERT INTO _cdk(comment,cdk,rewId) VALUES ('%s','%s','%u')", comment, Create(), rewId);
+
+	Load();
+}
+
+void CDKC::OutPut()
+{
+	std::ofstream outfile;
+	outfile.open("¶Ò»»Âë.txt");
+
+	if (outfile.is_open())
+	{
+		if (QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+			"SELECT ±¸×¢,ID,¶Ò»»Âë,½±ÀøÄ£°åID FROM __¶Ò»»Âë ORDER BY ±¸×¢,ID" :
+			"SELECT comment,id,cdk,rewId FROM _cdk ORDER BY comment,id"))
+		{
+			do
+			{
+				Field* fields = result->Fetch();
+				outfile << "[" << fields[0].GetString() << "][±àºÅ" << fields[1].GetUInt32() << "][½±Àø" << fields[3].GetUInt32() << "][" << fields[2].GetString() << "]" << std::endl;
+			} while (result->NextRow());
+		}
+
+		outfile.close();
+	}
+}
+
+void CDKC::AddGossip(Player* player, Object* obj)
+{
+	player->PlayerTalkClass->ClearMenus();
+	player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_BATTLE, "", 9991, 9991, "", 0, true);
+
+	if (obj->ToCreature())
+		player->SEND_GOSSIP_MENU(obj->GetEntry(), obj->GetGUID());
+	else
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+
+	ChatHandler(player->GetSession()).PSendSysMessage("[¶Ò»»Âë]£ºÇëÊäÈëÕýÈ·µÄ¶Ò»»ÂëÀ´»»È¡½±Àø£¡");
+}
+
+bool CDKC::Redeem(Player* player, uint32 sender, uint32 action, std::string cdk)
+{
+	if (sender == 9991 && action == 9991)
+	{
+		player->CLOSE_GOSSIP_MENU();
+
+		auto itr = CDKMap.find(cdk);
+
+		if (itr != CDKMap.end())
+		{
+			sRew->Rew(player, itr->second);
+			WorldDatabase.PExecute(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? "DELETE FROM __¶Ò»»Âë WHERE ¶Ò»»Âë = '%s'" : "DELETE FROM _CDK WHERE cdk = '%s'", cdk);
+			ChatHandler(player->GetSession()).PSendSysMessage("[¶Ò»»Âë]£º¶Ò»»Íê³É");
+			CDKMap.erase(itr++);
+			return true;
+		}
+
+		ChatHandler(player->GetSession()).PSendSysMessage("[¶Ò»»Âë]£º¶Ò»»Âë´íÎó");
+		return true;
+	}
+
+	return false;
+}
diff --git a/src/server/scripts/Custom/CDK/CDK.h b/src/server/scripts/Custom/CDK/CDK.h
new file mode 100644
index 0000000..10247fe
--- /dev/null
+++ b/src/server/scripts/Custom/CDK/CDK.h
@@ -0,0 +1,21 @@
+extern std::unordered_map<std::string, uint32> CDKMap;
+
+class CDKC
+{
+public:
+	static CDKC* instance()
+	{
+		static CDKC instance;
+		return &instance;
+	}
+
+	void Load();
+	std::string Create();
+	void Create(uint32 count, uint32 rewId, std::string comment);
+	void OutPut();
+	void AddGossip(Player* player, Object* obj);
+	bool Redeem(Player* player, uint32 sender, uint32 action, std::string cdk);
+private:
+
+};
+#define sCDK CDKC::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/CMakeLists.txt b/src/server/scripts/Custom/CMakeLists.txt
index 545b660..29038ab 100644
--- a/src/server/scripts/Custom/CMakeLists.txt
+++ b/src/server/scripts/Custom/CMakeLists.txt
@@ -1,13 +1,18 @@
+# Copyright (C) 
+#
+# This file is free software; as a special exception the author gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+file(GLOB_RECURSE sources_Custom Custom/*.cpp Custom/*.h)
+
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
-  ${AC_SCRIPTS_DIR}/Custom/conf/customconf.cpp
-  ${AC_SCRIPTS_DIR}/Custom/conf/customconf.h
-  ${AC_SCRIPTS_DIR}/Custom/SpellMod/SpellMod.cpp
-  ${AC_SCRIPTS_DIR}/Custom/SpellMod/SpellMod.h
-  ${AC_SCRIPTS_DIR}/Custom/dqsys/dqsys.cpp
-  ${AC_SCRIPTS_DIR}/Custom/dqsys/dqsys.h
-  ${AC_SCRIPTS_DIR}/Custom/dqsys/dqscript.cpp
+  ${sources_Custom}
 )
 
-
-message("  -> Prepared: Frozen")
+message("  -> Prepared: Custom")
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Challenge/challenge.cpp b/src/server/scripts/Custom/Challenge/challenge.cpp
new file mode 100644
index 0000000..0ade456
--- /dev/null
+++ b/src/server/scripts/Custom/Challenge/challenge.cpp
@@ -0,0 +1,388 @@
+#pragma execution_character_set("utf-8")
+#include "challenge.h"
+#include "Group.h"
+#include "MapManager.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../AuthCheck/AuthCheck.h"
+#include "../Requirement/Requirement.h"
+#include "../String/myString.h"
+#include "../Switch/Switch.h"
+
+std::vector<ChallengeTemplate> ChallengeVec;
+std::vector<PlayerChallengeTemplate> PlayerChallengeVec;
+
+void ChallengeMod::Load()
+{
+	ChallengeVec.clear();
+
+	if (QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+		//		0		1			2			3
+		"SELECT µØÍ¼ID, ÌôÕ½µÈ¼¶, ÐèÇóÄ£°åID, ²Ëµ¥ÎÄ±¾ FROM _¸±±¾_ÌôÕ½Ä£Ê½" :
+		//		0		1			2			3
+		"SELECT MapId, ChallengeLv, ReqId, GossipText FROM _challenge"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			ChallengeTemplate Temp;
+			Temp.MapId = fields[0].GetUInt32();
+			Temp.Level = fields[1].GetUInt32();
+			Temp.ReqId = fields[2].GetInt32();
+			Temp.GossipText = fields[3].GetString();
+			ChallengeVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+}
+
+void ChallengeMod::ReplaceChallenge(Player* player, uint32 mapId, uint32 challengeLv)
+{
+	player->SetDungeonDifficulty(Difficulty(BIND_INSTANCE_DIFF));
+	player->SetRaidDifficulty(Difficulty(BIND_INSTANCE_DIFF));
+	player->ChallengeLv = challengeLv;
+
+	bool exsist = false;
+	for (auto itr = PlayerChallengeVec.begin(); itr != PlayerChallengeVec.end(); itr++)
+	{
+		if (player->GetGUIDLow() == itr->guid && mapId == itr->mapId)
+		{
+			itr->challengeLv = challengeLv;
+			exsist = true;
+		}
+	}
+
+	if (!exsist)
+	{
+		PlayerChallengeTemplate temp;
+		temp.guid = player->GetGUIDLow();
+		temp.mapId = mapId;
+		temp.challengeLv = challengeLv;
+		PlayerChallengeVec.push_back(temp);
+	}
+}
+
+bool ChallengeMod::HasChallenge(Player* player, uint32 mapId, uint32 challengeLv)
+{
+	for (auto itr = PlayerChallengeVec.begin(); itr != PlayerChallengeVec.end(); itr++)
+		if (player->GetGUIDLow() == itr->guid && mapId == itr->mapId && itr->challengeLv == challengeLv)
+			return true;
+
+	return false;
+}
+
+void ChallengeMod::ResetChallenge(uint32 guidlow, uint32 mapId)
+{
+	for (auto itr = PlayerChallengeVec.begin(); itr != PlayerChallengeVec.end();)
+	{
+		if (guidlow == itr->guid && mapId == itr->mapId)
+			itr = PlayerChallengeVec.erase(itr);
+		else
+			++itr;
+	}
+}
+
+
+int32 ChallengeMod::GetReqId(uint32 mapId, uint32 challengeLv)
+{
+	for (auto itr = ChallengeVec.begin(); itr != ChallengeVec.end(); itr++)
+		if (mapId == itr->MapId && challengeLv == itr->Level)
+			return itr->ReqId;
+
+	return 0;
+}
+
+std::string ChallengeMod::GetGossipText(uint32 mapId, uint32 challengeLv)
+{
+	for (auto itr = ChallengeVec.begin(); itr != ChallengeVec.end(); itr++)
+		if (mapId == itr->MapId && challengeLv == itr->Level)
+			return itr->GossipText;
+
+	return "";
+}
+
+void ChallengeMod::ChangeLevel(Player* leader, uint32 triggerId, uint32 challengeLv)
+{
+    AreaTriggerTeleport const* at = sObjectMgr->GetAreaTriggerTeleport(triggerId);
+	if (!at)
+		return;
+
+	uint32 mapId = at->target_mapId;
+	int32 reqId = GetReqId(mapId, challengeLv);
+	bool teleport = true;
+
+	Group* group = leader->GetGroup();
+
+	//¼ì²â¶ÓÎé³ÉÔ±ÊÇ·ñÔÚFBÖÐ
+	if (group)
+	{
+		for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+		{
+			if (Player* member = itr->GetSource())
+			{
+				if (member->GetMap()->IsDungeon())
+				{
+					teleport = false;
+					ChatHandler(member->GetSession()).PSendSysMessage("ÄãÔÚ¸±±¾ÖÐ£¬Ñ¡ÔñÄÑ¶ÈÊ§°Ü");
+					if (leader->GetGUID() != member->GetGUID())
+						ChatHandler(leader->GetSession()).PSendSysMessage("%sÔÚ¸±±¾ÖÐ£¬Ñ¡ÔñÄÑ¶ÈÊ§°Ü", sCF->GetNameLink(member).c_str());
+				}
+
+				if (reqId > 0)
+				{
+					if (!HasChallenge(member, mapId, challengeLv) && !sReq->Check(member, abs(reqId)))
+					{
+						teleport = false;
+						ChatHandler(member->GetSession()).PSendSysMessage("Î´´ïµ½½øÈëÌõ¼þ£¬Ñ¡ÔñÄÑ¶ÈÊ§°Ü");
+						if (leader->GetGUID() != member->GetGUID())
+							ChatHandler(leader->GetSession()).PSendSysMessage("Î´´ïµ½½øÈëÌõ¼þ£¬Ñ¡ÔñÄÑ¶ÈÊ§°Ü");
+					}
+				}
+			}
+
+		}
+
+		if (reqId < 0)
+		{
+			if (!HasChallenge(leader, mapId, challengeLv) && !sReq->Check(leader, abs(reqId)))
+			{
+				teleport = false;
+				ChatHandler(leader->GetSession()).PSendSysMessage("Î´´ïµ½½øÈëÌõ¼þ£¬Ñ¡ÔñÄÑ¶ÈÊ§°Ü");
+			}
+		}
+	}
+	else if (!HasChallenge(leader, mapId, challengeLv) && !sReq->Check(leader, abs(reqId)))
+	{
+		teleport = false;
+		ChatHandler(leader->GetSession()).PSendSysMessage("Î´´ïµ½½øÈëÌõ¼þ£¬Ñ¡ÔñÄÑ¶ÈÊ§°Ü");
+	}
+
+	if (!teleport)
+		return;
+
+	if (group)
+	{
+		group->SetDungeonDifficulty(Difficulty(BIND_INSTANCE_DIFF));
+		group->SetRaidDifficulty(Difficulty(BIND_INSTANCE_DIFF));
+
+		for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+		{
+			if (Player* member = itr->GetSource())
+			{
+				bool haschallenge = HasChallenge(member, mapId, challengeLv);
+
+				if (!haschallenge)
+				{
+					if (MapEntry const* mapEntry = sMapStore.LookupEntry(mapId))
+					{
+						sCF->ResetInstance(member, Difficulty(0), mapEntry->IsRaid(), mapId);
+						sCF->ResetInstance(member, Difficulty(1), mapEntry->IsRaid(), mapId);
+					}
+				}
+
+				if (!haschallenge && reqId > 0)
+					sReq->Des(member, abs(reqId));
+
+				ReplaceChallenge(member, mapId, challengeLv);
+				member->TeleportTo(at->target_mapId, at->target_X, at->target_Y, at->target_Z, at->target_Orientation, TELE_TO_NOT_LEAVE_TRANSPORT);
+			}
+		}
+
+		if (!HasChallenge(leader, mapId, challengeLv) && reqId < 0)
+			sReq->Des(leader, abs(reqId));
+	}
+	else
+	{
+		bool haschallenge = HasChallenge(leader, mapId, challengeLv);
+
+		if (!haschallenge)
+		{
+			if (MapEntry const* mapEntry = sMapStore.LookupEntry(mapId))
+			{
+				sCF->ResetInstance(leader, Difficulty(0), mapEntry->IsRaid(), mapId);
+				sCF->ResetInstance(leader, Difficulty(1), mapEntry->IsRaid(), mapId);
+			}
+		}
+
+		if (!haschallenge)
+			sReq->Des(leader, abs(reqId));
+
+		ReplaceChallenge(leader, mapId, challengeLv);
+		leader->TeleportTo(at->target_mapId, at->target_X, at->target_Y, at->target_Z, at->target_Orientation, TELE_TO_NOT_LEAVE_TRANSPORT);
+	}
+}
+
+bool ChallengeMod::IsChallengeMap(Player* player, uint32 mapId)
+{
+	if (player->GetMap()->IsDungeon() && player->GetMapId() != 230)
+		return false;
+
+	for (auto itr = ChallengeVec.begin(); itr != ChallengeVec.end(); itr++)
+		if (mapId == itr->MapId)
+			return true;
+
+	return false;
+}
+
+bool ChallengeMod::AddGossipOrTele(Player* player, uint32 triggerId)
+{
+	if (!player->GetMap()->IsDungeon())
+		player->ChallengeLv = 0;
+
+    AreaTriggerTeleport const* at = sObjectMgr->GetAreaTriggerTeleport(triggerId);
+	if (!at)
+		return false;
+
+	uint32 mapId = at->target_mapId;
+
+	if (!IsChallengeMap(player, mapId))
+	{
+		//player->TeleportTo(at->target_mapId, at->target_X, at->target_Y, at->target_Z, at->target_Orientation, TELE_TO_NOT_LEAVE_TRANSPORT);
+		return false;
+	}
+
+	if (Group* group = player->GetGroup())
+	{
+		if (Player* leader = ObjectAccessor::FindPlayerInOrOutOfWorld(group->GetLeaderGUID()))
+		{
+			if (leader->GetGUID() != player->GetGUID())
+			{
+				if (leader->GetMapId() == mapId)
+				{
+					bool haschallenge = HasChallenge(player, mapId, leader->GetMap()->challengeLv);
+
+					int32 reqId = GetReqId(mapId, leader->GetMap()->challengeLv);
+
+					if (!haschallenge && reqId > 0)
+					{
+						if (sReq->Check(player, abs(reqId)))
+						{
+							sReq->Des(player, abs(reqId));
+
+							if (MapEntry const* mapEntry = sMapStore.LookupEntry(mapId))
+							{
+								sCF->ResetInstance(player, Difficulty(0), mapEntry->IsRaid(), mapId);
+								sCF->ResetInstance(player, Difficulty(1), mapEntry->IsRaid(), mapId);
+							}
+							ReplaceChallenge(player, mapId, leader->GetMap()->challengeLv);
+							player->TeleportTo(at->target_mapId, at->target_X, at->target_Y, at->target_Z, at->target_Orientation, TELE_TO_NOT_LEAVE_TRANSPORT);
+						}
+					}
+					else
+					{
+						if (MapEntry const* mapEntry = sMapStore.LookupEntry(mapId))
+						{
+							sCF->ResetInstance(player, Difficulty(0), mapEntry->IsRaid(), mapId);
+							sCF->ResetInstance(player, Difficulty(1), mapEntry->IsRaid(), mapId);
+						}
+						ReplaceChallenge(player, mapId, leader->GetMap()->challengeLv);
+						player->TeleportTo(at->target_mapId, at->target_X, at->target_Y, at->target_Z, at->target_Orientation, TELE_TO_NOT_LEAVE_TRANSPORT);
+					}
+				}
+				else
+					ChatHandler(player->GetSession()).PSendSysMessage("µÈ´ý¶Ó³¤Ñ¡ÔñÄÑ¶È");
+
+				return true;
+			}
+		}
+	}
+
+	player->PlayerTalkClass->ClearMenus();
+
+
+	//ÍÅ¶Ó¸±±¾²»ÔÊÐíÇÐ»»ÄÑ¶È
+	//for (auto itr = ChallengeVec.begin(); itr != ChallengeVec.end(); itr++)
+	//	if (mapId == itr->MapId)
+	//	{
+	//		if (MapEntry const* mapEntry = sMapStore.LookupEntry(mapId))
+	//		{
+	//			if (HasChallenge(player, itr->MapId, itr->Level) && mapEntry->IsRaid())
+	//			{
+	//				player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, itr->GossipText + " - ÒÑ°ó¶¨¸ÃÄÑ¶È", triggerId, itr->Level);
+	//				player->PlayerTalkClass->GetGossipMenu().SetMenuId(7891);
+	//				player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+	//				return true;
+	//			}
+	//		}
+	//	}
+
+	std::string text = "";
+
+	for (auto itr = ChallengeVec.begin(); itr != ChallengeVec.end(); itr++)
+		if (mapId == itr->MapId)
+			if (HasChallenge(player, itr->MapId, itr->Level))
+				text = itr->GossipText;
+
+
+	if (!text.empty())
+		player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, text + " - ÖØÖÃ¸ÃÄÑ¶È", triggerId, 10000, "ÖØÖÃ" + text + "\n½«½â³ý°ó¶¨£¬È·¶¨ÖØÖÃÂð£¿", 0, false);
+
+	for (auto itr = ChallengeVec.begin(); itr != ChallengeVec.end(); itr++)
+		if (mapId == itr->MapId)
+		{
+			if (HasChallenge(player, itr->MapId, itr->Level))
+				player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, itr->GossipText + " - ÒÑ°ó¶¨¸ÃÄÑ¶È", triggerId, itr->Level);
+			else// if (sReq->Check(player, abs(itr->ReqId), 1, false))
+				player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, itr->GossipText, triggerId, itr->Level, sReq->Notice(player, abs(itr->ReqId), "Ñ¡Ôñ", itr->GossipText), sReq->Golds(abs(itr->ReqId)), false);
+		}
+
+	player->PlayerTalkClass->GetGossipMenu().SetMenuId(7891);
+	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+
+	return true;
+}
+
+
+class ChallengePlayerScript : public PlayerScript
+{
+public:
+	ChallengePlayerScript() : PlayerScript("ChallengePlayerScript") {}
+
+	void OnGossipSelect(Player* player, uint32 menu_id, uint32 triggerId, uint32 action) override
+	{
+		if (menu_id != 7891)
+			return;
+
+		if (action == 10000)
+		{
+            AreaTriggerTeleport const* at = sObjectMgr->GetAreaTriggerTeleport(triggerId);
+			if (!at)
+				return;
+
+			uint32 mapId = at->target_mapId;
+
+			if (Group* group = player->GetGroup())
+			{
+				for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+					if (Player* member = itr->GetSource())
+					{
+						if (MapEntry const* mapEntry = sMapStore.LookupEntry(mapId))
+						{
+							sCF->ResetInstance(member, Difficulty(0), mapEntry->IsRaid(), mapId);
+							sCF->ResetInstance(member, Difficulty(1), mapEntry->IsRaid(), mapId);
+						}
+
+						sChallengeMod->ResetChallenge(member->GetGUIDLow(), mapId);
+					}
+
+			}
+			else
+			{
+				if (MapEntry const* mapEntry = sMapStore.LookupEntry(mapId))
+				{
+					sCF->ResetInstance(player, Difficulty(0), mapEntry->IsRaid(), mapId);
+					sCF->ResetInstance(player, Difficulty(1), mapEntry->IsRaid(), mapId);
+				}
+
+				sChallengeMod->ResetChallenge(player->GetGUIDLow(), mapId);
+			}
+
+			sChallengeMod->AddGossipOrTele(player, triggerId);
+		}
+		else
+			sChallengeMod->ChangeLevel(player, triggerId, action);
+	}
+};
+
+void AddSC_Challenge()
+{
+	new ChallengePlayerScript();
+}
diff --git a/src/server/scripts/Custom/Challenge/challenge.h b/src/server/scripts/Custom/Challenge/challenge.h
new file mode 100644
index 0000000..4d20ea3
--- /dev/null
+++ b/src/server/scripts/Custom/Challenge/challenge.h
@@ -0,0 +1,43 @@
+#define BIND_INSTANCE_DIFF 0
+
+struct ChallengeTemplate
+{
+	uint32 MapId;
+	uint32 Level;
+	int32 ReqId;
+	std::string GossipText;
+};
+extern std::vector<ChallengeTemplate> ChallengeVec;
+
+struct PlayerChallengeTemplate
+{
+	uint32 guid;
+	uint32 mapId;
+	uint32 challengeLv;
+};
+
+extern std::vector<PlayerChallengeTemplate> PlayerChallengeVec;
+
+class ChallengeMod
+{
+public:
+	static ChallengeMod* instance()
+	{
+		static ChallengeMod instance;
+		return &instance;
+	}
+
+	void Load();
+	std::string GetGossipText(uint32 mapId, uint32 challengeLv);
+	int32 GetReqId(uint32 mapId, uint32 challengeLv);
+	bool IsChallengeMap(Player* player, uint32 mapId);
+	void ChangeLevel(Player* player, uint32 triggerId, uint32 challengeLv);
+	bool AddGossipOrTele(Player* player, uint32 triggerId);
+
+	void ReplaceChallenge(Player* player, uint32 mapId, uint32 challengeLv);
+	bool HasChallenge(Player* player, uint32 mapId, uint32 challengeLv);
+	void ResetChallenge(uint32 guidlow, uint32 mapId);
+private:
+
+};
+#define sChallengeMod ChallengeMod::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Challenge/stage.cpp b/src/server/scripts/Custom/Challenge/stage.cpp
new file mode 100644
index 0000000..b400e4f
--- /dev/null
+++ b/src/server/scripts/Custom/Challenge/stage.cpp
@@ -0,0 +1,198 @@
+#pragma execution_character_set("utf-8")
+#include "../Switch/Switch.h"
+#include "stage.h"
+
+std::vector<StageTemplate> StageVec;
+
+void Stage::Load()
+{
+	StageVec.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//		0			1		2				3
+		"SELECT ¹Ø¿¨ID,ÕÙ»½ÉúÎï×éID,Í¨¹ØÕÙ»½ÎïÌåID,²Ëµ¥ÎÄ±¾ FROM _¸±±¾_´³¹ØÄ£Ê½" :
+		//			0		1				2		3
+		"SELECT stageRank,summonsGroupId,rewGobId,description FROM _stage");
+
+	if (!result) return;
+	do
+	{
+		Field* fields = result->Fetch();
+		StageTemplate Temp;
+		Temp.stageRank = fields[0].GetUInt32();
+		Temp.summonsGroupId = fields[1].GetUInt32();
+		Temp.rewardGameobjectId = fields[2].GetUInt32();
+		Temp.description = fields[3].GetString();
+		StageVec.push_back(Temp);
+	} while (result->NextRow());
+}
+
+std::string Stage::GetDescription(uint32 stage)
+{
+	uint32 len = StageVec.size();
+
+	for (size_t i = 0; i < len; i++)
+	{
+		if (stage == StageVec[i].stageRank)
+			return StageVec[i].description;
+	}
+
+	return "";
+}
+
+uint32 Stage::GetSumId(uint32 stage)
+{
+	uint32 len = StageVec.size();
+
+	for (size_t i = 0; i < len; i++)
+	{
+		if (stage == StageVec[i].stageRank)
+			return StageVec[i].summonsGroupId;
+	}
+
+	return 1;
+}
+
+uint32 Stage::GetGobId(uint32 stage)
+{
+	uint32 len = StageVec.size();
+
+	for (size_t i = 0; i < len; i++)
+	{
+		if (stage == StageVec[i].stageRank)
+			return StageVec[i].rewardGameobjectId;
+	}
+
+	return 0;
+}
+
+class StageNPC : public CreatureScript
+{
+public:
+	StageNPC() : CreatureScript("StageNPC") { }
+ 
+	bool OnGossipHello(Player* player, Creature* creature) override
+	{
+		player->PlayerTalkClass->ClearMenus();
+
+		uint32 eventid = atoi(sSwitch->GetFlagByIndex(ST_STAGE, 1).c_str());
+
+		if (eventid != 0 && !sGameEventMgr->IsActiveEvent(eventid))
+		{
+			ChatHandler(player->GetSession()).PSendSysMessage("µ±Ç°Ê±¼ä²»ÔÊÐíÌôÕ½£¡");
+			return false;
+		}
+
+		if (creature->summonsClear && creature->stage <= StageVec.size())
+		{
+			std::ostringstream oss;
+			oss << "ÌôÕ½µÈ¼¶:" << creature->stage;
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss.str(), creature->stage, GOSSIP_ACTION_INFO_DEF + 1);
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sStage->GetDescription(creature->stage), creature->stage, GOSSIP_ACTION_INFO_DEF);
+		}
+
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+		return true;
+	}
+
+	bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action) override
+	{
+		if (action == GOSSIP_ACTION_INFO_DEF + 1)
+		{
+			OnGossipHello(player, creature);
+			return true;
+		}
+		creature->SummonCreatureGroup(sStage->GetSumId(creature->stage));
+		creature->summonsClear = false;
+		player->CLOSE_GOSSIP_MENU();
+		return true;
+	}
+
+	struct StageNPCAI : public ScriptedAI
+	{
+		StageNPCAI(Creature* creature) : ScriptedAI(creature), Summons(me){}
+
+		SummonList Summons;
+		void JustSummoned(Creature* summon) override
+		{
+			summon->GetMotionMaster()->MoveRandom(5.0f);
+			Summons.Summon(summon);
+		}
+
+		void Reset() override
+		{
+			me->summonsClear = true;
+			me->stage = 1;
+			Summons.DespawnAll();
+		}
+
+		void MoveInLineOfSight(Unit* who)
+		{
+		}
+
+		void SummonedCreatureDies(Creature* summon, Unit* killer)  override
+		{
+			std::ostringstream oss;
+			oss << "ÌôÕ½µÈ¼¶£º" << me->stage;
+			me->MonsterSay(oss.str().c_str(), LANG_UNIVERSAL, 0);
+
+			Summons.Despawn(summon);
+
+			if (Summons.empty())
+			{
+				uint32 gobEntry = sStage->GetGobId(me->stage);
+
+				if (sObjectMgr->GetGameObjectTemplate(gobEntry))
+					me->SummonGameObject(gobEntry, killer->GetPositionX(), killer->GetPositionY(), killer->GetPositionZ(), 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0);
+
+				me->stage++;
+				me->summonsClear = true;
+			}	
+		}
+	};
+
+	CreatureAI* GetAI(Creature* creature) const override
+	{
+		return new StageNPCAI(creature);
+	}
+};
+
+class StagePlayerScript : public PlayerScript
+{
+public:
+	StagePlayerScript() : PlayerScript("StagePlayerScript") {}
+
+	void OnMapChanged(Player* player) override
+	{
+		uint32 mapId = atoi(sSwitch->GetFlagByIndex(ST_STAGE, 2).c_str());
+
+		if (player->GetMapId() != mapId)
+			return;
+
+		uint32 size = atoi(sSwitch->GetFlagByIndex(ST_STAGE, 4).c_str());
+
+		if (Map* map = player->GetMap())
+		{
+			uint32 count = map->GetPlayersCountExceptGMs();
+
+			if (count > size)
+			{
+				player->RepopAtGraveyard();
+				return;
+			}
+
+			if (count == 1)
+			{
+				uint32 npcId = atoi(sSwitch->GetFlagByIndex(ST_STAGE, 3).c_str());
+
+				if (Creature* creature = player->FindNearestCreature(npcId, 150))
+					creature->AI()->Reset();
+			}
+		}
+	}
+};
+
+void AddSC_Stage()
+{
+	new StageNPC();
+	new StagePlayerScript();
+}
diff --git a/src/server/scripts/Custom/Challenge/stage.h b/src/server/scripts/Custom/Challenge/stage.h
new file mode 100644
index 0000000..6d90be6
--- /dev/null
+++ b/src/server/scripts/Custom/Challenge/stage.h
@@ -0,0 +1,26 @@
+struct StageTemplate
+{
+	uint32 stageRank;
+	uint32 summonsGroupId;
+	uint32 rewardGameobjectId;
+	std::string description;
+};
+extern std::vector<StageTemplate> StageVec;
+
+class Stage
+{
+public:
+	static Stage* instance()
+	{
+		static Stage instance;
+		return &instance;
+	}
+
+	void Load();
+
+	uint32 GetSumId(uint32 stage);
+	uint32 GetGobId(uint32 stage);
+	std::string GetDescription(uint32 stage);
+};
+
+#define sStage Stage::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/CharNameMod/CharNameMod.cpp b/src/server/scripts/Custom/CharNameMod/CharNameMod.cpp
new file mode 100644
index 0000000..c83bebb
--- /dev/null
+++ b/src/server/scripts/Custom/CharNameMod/CharNameMod.cpp
@@ -0,0 +1,99 @@
+#pragma execution_character_set("utf-8")
+#include "CharNameMod.h"
+#include "World.h"
+#include "../Switch/Switch.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../PvP/PvP.h"
+#include "../String/myString.h"
+#include "../GCAddon/GCAddon.h"
+#include "../GS/GS.h"
+
+void CharNameMod::UpdatePrefix(Player* player, std::string namePrefix)
+{
+	std::string FFAPvP = (player->GetUInt32Value(PLAYER_DUEL_TEAM) == player->GetGUIDLow()) ? sString->GetText(CORE_STR_TYPES(STR_FFAPVP)) : "";
+
+	if (!namePrefix.empty())
+		player->namePrefix = namePrefix + sSwitch->GetFlagByIndex(ST_SEP_PREFIX_SUFFIX, 1);
+	else
+		player->namePrefix = "";
+
+    sWorld->UpdateNamePrefixSuffix(player, FFAPvP + player->namePrefix, player->nameSuffix);
+
+	SQLTransaction trans = CharacterDatabase.BeginTransaction();
+	PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NAME_PREFIX);
+	stmt->setString(0, namePrefix);
+	stmt->setUInt32(1, player->GetGUIDLow());
+	trans->Append(stmt);
+	CharacterDatabase.CommitTransaction(trans);
+}
+
+void CharNameMod::UpdateSuffix(Player* player, std::string nameSuffix)
+{
+	std::string FFAPvP = (player->GetUInt32Value(PLAYER_DUEL_TEAM) == player->GetGUIDLow()) ? sString->GetText(CORE_STR_TYPES(STR_FFAPVP)) : "";
+
+	if (!nameSuffix.empty())
+		player->nameSuffix = sSwitch->GetFlagByIndex(ST_SEP_PREFIX_SUFFIX, 2) + nameSuffix;
+	else
+		player->nameSuffix = "";
+
+	sWorld->UpdateNamePrefixSuffix(player, FFAPvP + player->namePrefix, player->nameSuffix);
+
+	SQLTransaction trans = CharacterDatabase.BeginTransaction();
+	PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NAME_SUFFIX);
+	stmt->setString(0, nameSuffix);
+	stmt->setUInt32(1, player->GetGUIDLow());
+	trans->Append(stmt);
+	CharacterDatabase.CommitTransaction(trans);
+}
+
+std::string CharNameMod::GetPureName(std::string name)
+{
+	std::vector<std::string> vec = sCF->SplitStr(name, sSwitch->GetFlagByIndex(ST_SEP_PREFIX_SUFFIX, 1));
+
+	if (vec.size() > 1)
+		name = vec[1];
+	else
+		name = vec[0];
+
+	vec.clear();
+
+	vec = sCF->SplitStr(name, sSwitch->GetFlagByIndex(ST_SEP_PREFIX_SUFFIX, 2));
+
+	return vec[0];
+}
+
+class CharNameModPlayerScript : PlayerScript
+{
+public:
+	CharNameModPlayerScript() : PlayerScript("CharNameModPlayerScript") {}
+
+	void OnLogin(Player* player)
+	{
+		std::string namePrefix = "";
+		std::string nameSuffix = "";
+
+		QueryResult result = CharacterDatabase.PQuery("SELECT namePrefix,nameSuffix FROM characters WHERE guid = '%u'",player->GetGUIDLow());
+
+		if (result)
+		{
+			Field* fields = result->Fetch();
+			namePrefix = fields[0].GetString();
+			nameSuffix = fields[1].GetString();
+		}
+
+		if (!namePrefix.empty())
+			player->namePrefix = namePrefix + sSwitch->GetFlagByIndex(ST_SEP_PREFIX_SUFFIX, 1);
+
+		if (!nameSuffix.empty())
+			player->nameSuffix = sSwitch->GetFlagByIndex(ST_SEP_PREFIX_SUFFIX, 2) + nameSuffix;
+
+		if (!namePrefix.empty() || !nameSuffix.empty())
+			sWorld->UpdateNamePrefixSuffix(player, player->namePrefix, player->nameSuffix);
+
+		sGS->UpdateGS(player);
+	}
+};
+void AddSC_CharNameMod()
+{
+	new CharNameModPlayerScript();
+}
diff --git a/src/server/scripts/Custom/CharNameMod/CharNameMod.h b/src/server/scripts/Custom/CharNameMod/CharNameMod.h
new file mode 100644
index 0000000..c0f9594
--- /dev/null
+++ b/src/server/scripts/Custom/CharNameMod/CharNameMod.h
@@ -0,0 +1,15 @@
+class CharNameMod
+{
+public:
+	static CharNameMod* instance()
+	{
+		static CharNameMod instance;
+		return &instance;
+	}
+	void UpdatePrefix(Player* player, std::string namePrefix);
+	void UpdateSuffix(Player* player, std::string nameSuffix);
+	std::string GetPureName(std::string name);
+private:
+
+};
+#define sCharNameMod CharNameMod::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/CharPvpTop/CharPvpTop.cpp b/src/server/scripts/Custom/CharPvpTop/CharPvpTop.cpp
new file mode 100644
index 0000000..bf92e90
--- /dev/null
+++ b/src/server/scripts/Custom/CharPvpTop/CharPvpTop.cpp
@@ -0,0 +1,507 @@
+#pragma execution_character_set("utf-8")
+#include "CharPvpTop.h"
+#include "MapManager.h"
+#include "../Switch/Switch.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../PvP/PvP.h"
+#include "../String/myString.h"
+#include "../GCAddon/GCAddon.h"
+#include "../GS/GS.h"
+
+CharPvpTop::CharPvpTop()
+{
+	topevent = false;
+	topGobGuid = 0;
+	isfirst = false;
+	pvpcount = 0;
+}
+
+CharPvpTop::~CharPvpTop()
+{
+
+}
+void CharPvpTop::LoadTopSys()
+{
+	VCTopSys.clear();
+	topbufflists.clear();
+
+	QueryResult areaidcustom = WorldDatabase.PQuery("SELECT entry,name,itemid,buff from _»î¶¯_±ÈÎä´ó»á");
+	if (areaidcustom)
+	{
+		int nCount = 1;
+		do
+		{
+			Field * fields = areaidcustom->Fetch();
+			CTopSys tmpmorph;
+
+			tmpmorph.entry = fields[0].GetUInt32();
+			tmpmorph.text = fields[1].GetString();
+			tmpmorph.itemid = fields[2].GetUInt32();
+			tmpmorph.buffs = fields[3].GetUInt32();
+
+			topbufflists.push_back(tmpmorph.buffs);
+			VCTopSys.insert(CTopSys_t::value_type(nCount, tmpmorph));
+
+			nCount++;
+
+		} while (areaidcustom->NextRow());
+		sLog->outString(">> ¶ÁÈ¡×Ô¶¨Òå¹¦ÄÜÊý¾Ý±í1_topsys,¹²%uÌõÊý¾Ý¶ÁÈ¡¼ÓÔØ...", nCount);
+	}
+	else
+		sLog->outString(">> ¶ÁÈ¡×Ô¶¨Òå¹¦ÄÜÊý¾Ý±í1_topsys,¹²0ÌõÊý¾Ý¶ÁÈ¡¼ÓÔØ...");
+}
+
+GameObject* CharPvpTop::SpawnGob(uint32 guid, bool created)
+{
+
+	GameObject* creature = NULL;
+
+	GameObjectData const* data = sObjectMgr->GetGOData(guid);
+	if (!data)
+		return creature;
+	//Get map object
+	Map* map = sMapMgr->CreateBaseMap(data->mapid);
+	if (!map)
+		return creature;
+
+	if (created)
+	{
+		creature = new GameObject;
+		if (!creature->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_GAMEOBJECT), data->id, map, data->phaseMask, data->posX, data->posY, data->posZ, data->orientation, G3D::Quat(), 0, GO_STATE_READY))
+		{
+			delete creature;
+			return NULL;
+		}
+
+		map->AddToMap(creature);
+		creature->setActive(true);
+		creature->SetPhaseMask(1, true);
+		topGobGuid = creature->GetGUID();
+	}
+	else
+	{
+		creature = map->GetGameObject(topGobGuid);
+	}
+	return creature;
+}
+
+
+void CharPvpTop::RollTopTeamID()
+{
+	if (!topevent)
+		return;
+
+	UpdateCharTopData();
+
+	if (!pvpcount)
+	{
+		if (uint32(sSwitch->GetValue(TOP_97)) > GetTopMax())
+		{
+			sWorld->SendServerMessage(SERVER_MSG_STRING, sString->Format(sString->GetText(TOP_STR_102), sSwitch->GetValue(TOP_97)));
+			sGameEventMgr->StopEvent(sSwitch->GetValue(TOP_93), true);
+			return;
+		}
+	}
+	else
+	{
+		sWorld->SendServerMessage(SERVER_MSG_STRING, sString->Format(sString->GetText(TOP_STR_100), pvpcount + 1));
+	}
+	pvpcount++;
+	uint32 maxcount = _charTopDataMap.size() / 2;
+	for (uint32 i = 1; i < maxcount + 1; ++i)
+	{
+		uint32 pl1, pl2;
+		uint32 rollid1 = irand(0, _charTopDataMap.size() - 1);
+		uint32 myid1 = 0;
+		for (std::vector<uint32>::iterator itr1 = _charTopDataMap.begin(); itr1 != _charTopDataMap.end(); itr1++)
+		{
+			if (myid1 == rollid1)
+			{
+				pl1 = *itr1;
+				_charTopDataMap.erase(itr1);
+				break;
+			}
+			myid1++;
+		}
+
+		uint32 rollid2 = irand(0, _charTopDataMap.size() - 1);
+		uint32 myid2 = 0;
+		for (std::vector<uint32>::iterator itr2 = _charTopDataMap.begin(); itr2 != _charTopDataMap.end(); itr2++)
+		{
+			if (myid2 == rollid2)
+			{
+				pl2 = *itr2;
+				_charTopDataMap.erase(itr2);
+				break;
+			}
+			myid2++;
+		}
+
+		AddTopTeam(i, pl1, pl2);
+		SengPVPgo(i);
+	}
+}
+
+void CharPvpTop::UpdateCharTopData()
+{
+	_charTopDataMap.clear();
+	_charTopMaxMap.clear();
+	SessionMap::const_iterator itr1;
+	for (itr1 = sWorld->GetAllSessions().begin(); itr1 != sWorld->GetAllSessions().end(); ++itr1)
+	{
+		if (itr1->second && itr1->second->GetPlayer() && itr1->second->GetPlayer()->IsInWorld())
+		{
+			if (itr1->second->GetPlayer()->GetAreaId() != sSwitch->GetValue(TOP_94) && itr1->second->GetPlayer()->m_topmc == 999) //²»ÔÚÇøÓò²¢ÇÒ ²Å±¨Ãû)
+			{
+				itr1->second->GetPlayer()->m_topmc = 0; //ÎÞÃû´Î
+				itr1->second->GetPlayer()->m_lasttopmc = 0; //ÎÞÃû´Î
+				continue;
+			}
+
+			if (itr1->second->GetPlayer()->m_topmc != 999) //Ã»ÓÐ¾ö¶·³öÃû´Î
+				continue;
+
+			uint32 guid = itr1->second->GetPlayer()->GetGUIDLow();
+			_charTopDataMap.push_back(guid);
+			_charTopMaxMap.push_back(guid);
+		}
+	}
+}
+
+void CharPvpTop::SengPVPgo(uint32 teamid)
+{
+	Player * pl1 = sObjectMgr->GetPlayerByLowGUID(VCtopCustom[teamid].pl1);
+	Player * pl2 = sObjectMgr->GetPlayerByLowGUID(VCtopCustom[teamid].pl2);
+
+	if (!pl1 || !pl2)
+		return;
+
+	if (pl1->duel || pl2->duel)
+		return;
+
+	pl1->m_topteam = pl2->m_topteam = teamid;
+
+	GameObject* obj = pl1->GetMap()->GetGameObject(topGobGuid);
+	if (!obj)
+		return;
+
+	DuelInfo* duel = new DuelInfo;
+	duel->initiator = pl1;
+	duel->opponent = pl2;
+	duel->startTime = 0;
+	duel->startTimer = 0;
+	duel->isMounted = 0; // Mounted Duel
+	duel->istop = true;
+	pl1->duel = duel;
+
+	DuelInfo* duel2 = new DuelInfo;
+	duel2->initiator = pl1;
+	duel2->opponent = pl1;
+	duel2->startTime = 0;
+	duel2->startTimer = 0;
+	duel2->isMounted = 0; // Mounted Duel
+	duel2->istop = true;
+	pl2->duel = duel2;
+
+	pl1->SetUInt64Value(PLAYER_DUEL_ARBITER, obj->GetGUID());
+	pl2->SetUInt64Value(PLAYER_DUEL_ARBITER, obj->GetGUID());
+
+	time_t now = time(NULL);
+	pl1->duel->startTimer = now;
+	pl2->duel->startTimer = now;
+	pl1->setpvptime = true;
+	pl2->setpvptime = true;
+	pl1->SendDuelCountdown(10000);
+	pl2->SendDuelCountdown(10000);
+	return;
+}
+
+void CharPvpTop::PVPupdate()
+{
+	time_t now = time(NULL);
+	if (topevent) //±ÈÎä¿ªÊ¼
+	{
+		if (now >= pvptime + sSwitch->GetValue(TOP_95))
+		{
+			SessionMap::const_iterator itr1;
+			for (itr1 = sWorld->GetAllSessions().begin(); itr1 != sWorld->GetAllSessions().end(); ++itr1)
+			{
+				if (itr1->second && itr1->second->GetPlayer() && itr1->second->GetPlayer()->IsInWorld())
+				{
+					if (itr1->second->GetPlayer()->GetAreaId() == sSwitch->GetValue(TOP_94))
+					{
+						if (itr1->second->GetPlayer()->duel && Isintop(itr1->second->GetPlayer()->GetGUIDLow()))
+						{
+							if (itr1->second->GetPlayer()->GetHealthPct() < itr1->second->GetPlayer()->duel->opponent->GetHealthPct())
+								itr1->second->GetPlayer()->DuelComplete(DUEL_FLED);
+							else if (itr1->second->GetPlayer()->GetHealthPct() == itr1->second->GetPlayer()->duel->opponent->GetHealthPct())
+							{
+								if (itr1->second->GetPlayer()->GetHealth() < itr1->second->GetPlayer()->duel->opponent->GetHealth())
+									itr1->second->GetPlayer()->DuelComplete(DUEL_FLED);
+							}
+
+						}
+					}
+				}
+			}
+			RollTopTeamID();
+			pvptime = now;
+		}
+	}
+}
+
+void CharPvpTop::SendTopTitle(bool apple)
+{
+	if (apple)
+	{
+		std::list<uint64> guids;
+		for (SessionMap::const_iterator itr2 = sWorld->GetAllSessions().begin(); itr2 != sWorld->GetAllSessions().end(); ++itr2)
+		{
+			if (itr2->second && itr2->second->GetPlayer() && itr2->second->GetPlayer()->IsInWorld())
+			{
+				if (itr2->second->GetPlayer()->m_toptitle != "")
+				{
+					itr2->second->GetPlayer()->m_toptitle = "";
+					guids.push_back(itr2->second->GetPlayer()->GetGUID());
+				}
+				itr2->second->GetPlayer()->m_lasttopmc = 0;
+				SendAndClearTopBuff(itr2->second->GetPlayer());
+			}
+		}
+
+		if (guids.size())
+		{
+			for (std::list<uint64>::const_iterator itr = guids.begin(); itr != guids.end(); ++itr)
+			{
+				Player* player = ObjectAccessor::FindPlayerInOrOutOfWorld(*itr);
+				if (player)
+				{
+					sWorld->UpdateTopPlayerData(player->GetGUIDLow(), "");
+					for (SessionMap::const_iterator itr22 = sWorld->GetAllSessions().begin(); itr22 != sWorld->GetAllSessions().end(); ++itr22)
+					{
+						if (itr22->second && itr22->second->GetPlayer() && itr22->second->GetPlayer()->IsInWorld())
+							itr22->second->SendNameQueryOpcode(player->GetGUID());
+					}
+					player->ToggleDND();
+					player->m_toptime = time(NULL);
+					player->m_sendtoptitle = true;
+				}
+			}
+		}
+
+		sWorld->UpdateAllTopPlayerData();
+		CharacterDatabase.PExecute("update _xlchar set lasttop = 0,toptitle =''");
+	}
+	else
+	{
+		std::list<uint64> guids;
+		//sWorld->UpdateGlobalPlayerData(player->GetGUIDLow(), PLAYER_UPDATE_DATA_NAME, player->GetName());
+		for (SessionMap::const_iterator itr2 = sWorld->GetAllSessions().begin(); itr2 != sWorld->GetAllSessions().end(); ++itr2)
+		{
+			if (itr2->second && itr2->second->GetPlayer() && itr2->second->GetPlayer()->IsInWorld())
+			{
+				SendAndClearTopBuff(itr2->second->GetPlayer());
+
+				if (itr2->second->GetPlayer()->m_lasttopmc)
+				{
+					const CTopSys *cccc = FindTopSys(itr2->second->GetPlayer()->m_lasttopmc);
+					if (cccc)
+					{
+						if (cccc->text != "")
+						{
+							guids.push_back(itr2->second->GetPlayer()->GetGUID());
+							itr2->second->GetPlayer()->m_toptitle = cccc->text;
+						}
+						if (cccc->buffs)
+							itr2->second->GetPlayer()->AddAura(cccc->buffs, itr2->second->GetPlayer());
+					}
+
+				}
+			}
+		}
+
+		if (guids.size())
+		{
+			for (std::list<uint64>::const_iterator itr = guids.begin(); itr != guids.end(); ++itr)
+			{
+				Player* player = ObjectAccessor::FindPlayerInOrOutOfWorld(*itr);
+				if (player)
+				{
+					sWorld->UpdateTopPlayerData(player->GetGUIDLow(), player->m_toptitle);
+					for (SessionMap::const_iterator itr22 = sWorld->GetAllSessions().begin(); itr22 != sWorld->GetAllSessions().end(); ++itr22)
+					{
+						if (itr22->second && itr22->second->GetPlayer() && itr22->second->GetPlayer()->IsInWorld())
+							itr22->second->SendNameQueryOpcode(player->GetGUID());
+					}
+					player->ToggleDND();
+					player->m_toptime = time(NULL);
+					player->m_sendtoptitle = true;
+				}
+			}
+		}
+	}
+}
+
+void CharPvpTop::SendAndClearTopBuff(Player * pl, bool onlyph)
+{
+	uint32 buffid = 0;
+	const CTopSys *cccc = FindTopSys(pl->m_lasttopmc);
+	if (cccc && cccc->buffs)
+		buffid = cccc->buffs;
+
+	if (!buffid)
+	{
+		for (std::vector<uint32>::iterator itr1 = topbufflists.begin(); itr1 != topbufflists.end(); itr1++)
+		{
+			if (pl->HasAura(*itr1))
+				pl->RemoveAurasDueToSpell(*itr1);
+		}
+	}
+	else
+	{
+		for (std::vector<uint32>::iterator itr1 = topbufflists.begin(); itr1 != topbufflists.end(); itr1++)
+		{
+			if (buffid == *itr1 && !pl->HasAura(*itr1))
+				pl->AddAura(buffid, pl);
+			else if (buffid != *itr1 && pl->HasAura(*itr1))
+				pl->RemoveAurasDueToSpell(*itr1);
+		}
+	}
+}
+
+
+class custom_top_group : public CreatureScript
+{
+public:
+	custom_top_group() : CreatureScript("npc_top")
+	{
+	}
+
+	bool OnGossipHello(Player* player, Creature* creature) override
+	{
+		player->PlayerTalkClass->ClearMenus();
+
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "±ÈÎä´ó»áÅÅÐÐ°ñ", 1, 4);
+
+		if (player->m_topmc == 999)
+		{
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "ÄãÒÑ±¨Ãû", 1, 1);
+		}
+		else if (player->m_topmc > 0 && player->m_topmc < 999)
+		{
+			if (IsEventActive(sSwitch->GetValue(TOP_93)))
+			{
+				player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "±ÈÎä´ó»áÒÑ¾­¿ªÊ¼", 1, 1);
+			}
+			else
+			{
+				const CTopSys *cccc = sCharPvpTop->FindTopSys(player->m_topmc);
+				if (cccc && cccc->itemid)
+				{
+					if (ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(cccc->itemid))
+					{
+						player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "ÁìÈ¡±ÈÎä´ó»á½±Àø", 1, 2);
+					}
+					else
+					{
+						creature->MonsterSay("½±ÀøÎïÆ·IDÉèÖÃ³ö´í...", LANG_UNIVERSAL, 0);
+						return false;
+					}
+				}
+				else
+					player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "±ÈÎä´ó»á±¨Ãû", 1, 3);
+			}
+
+		}
+		else if (!player->m_topmc)
+		{
+			if (!IsEventActive(sSwitch->GetValue(TOP_93)))
+				player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "±ÈÎä´ó»á±¨Ãû", 1, 3);
+			else
+				player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "±ÈÎä´ó»áÒÑ¾­¿ªÊ¼", 1, 1);
+		}
+
+
+		player->SEND_GOSSIP_MENU(20000, creature->GetGUID());
+		return true;
+	}
+
+	bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action) override
+	{
+		if (action == 1)
+			OnGossipHello(player, creature);
+		else if (action == 2)
+		{
+			const CTopSys *cccc = sCharPvpTop->FindTopSys(player->m_topmc);
+			if (cccc && cccc->itemid)
+			{
+				if (ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(cccc->itemid))
+					player->AddItem(cccc->itemid, 1);
+			}
+
+			player->m_topmc = 0;
+			CharacterDatabase.PExecute("update _xlchar set top = %u where guid = %u", player->m_topmc, player->GetGUIDLow());
+			creature->MonsterWhisper("±ÈÎä´ó»á½±ÀøÁìÈ¡³É¹¦...", player);
+			OnGossipHello(player, creature);
+			return false;
+		}
+		else if (action == 3)
+		{
+			player->m_topmc = 999;
+			CharacterDatabase.PExecute("update _xlchar set top = %u where guid = %u", player->m_topmc, player->GetGUIDLow());
+			creature->MonsterWhisper("±ÈÎä´ó»á±¨Ãû³É¹¦...", player);
+			OnGossipHello(player, creature);
+			return false;
+		}
+		else if (action == 4)
+		{
+			player->PlayerTalkClass->ClearMenus();
+			if (sCharPvpTop->m_playertopph.size())
+			{
+				for (int i = 1; i < sCharPvpTop->m_playertopph.size() + 1; i++)
+				{
+					if (i > 10)
+						continue;
+
+					uint32 guid = sCharPvpTop->m_playertopph[i];
+					if (guid)
+					{
+						GlobalPlayerData const* playerData = sWorld->GetGlobalPlayerData(guid);
+						if (playerData)
+						{
+							std::ostringstream hsfdata;
+
+							bool hastouxian = false;
+							const CTopSys *cccc = sCharPvpTop->FindTopSys(i);
+							if (cccc && cccc->text != "")
+								hastouxian = true;
+
+							if (hastouxian)
+								hsfdata << cccc->text << ";" << playerData->name.c_str();
+							else
+								hsfdata << "µÚ" << i << "Ãû;" << playerData->name.c_str();
+
+							player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, hsfdata.str().c_str(), 1, 5);
+						}
+
+					}
+				}
+			}
+			else
+				player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "ÔÝÎÞÅÅÐÐ°ñ", 1, 5);
+
+			player->SEND_GOSSIP_MENU(20000, creature->GetGUID());
+		}
+		else if (action == 5)
+		{
+			OnGossipHello(player, creature);
+			return false;
+		}
+		return true;
+	}
+};
+
+void AddSC_CharPvpTop()
+{
+	new custom_top_group();
+}
diff --git a/src/server/scripts/Custom/CharPvpTop/CharPvpTop.h b/src/server/scripts/Custom/CharPvpTop/CharPvpTop.h
new file mode 100644
index 0000000..a657105
--- /dev/null
+++ b/src/server/scripts/Custom/CharPvpTop/CharPvpTop.h
@@ -0,0 +1,92 @@
+ï»¿struct CTOPCustom
+{
+	uint32 entry;
+	uint32 pl1;
+	uint32 pl2;
+};
+
+struct CTopSys
+{
+	uint32 entry;
+	std::string text;
+	uint32 itemid;
+	uint32 buffs;
+};
+
+class CharPvpTop
+{
+public: //å®å¨è®¿é®æé
+	CharPvpTop();
+	~CharPvpTop();
+
+	static CharPvpTop* instance()
+	{
+		static CharPvpTop instance;
+		return &instance;
+	}
+
+	
+	typedef std::map<uint32, CTOPCustom> CTOPCustom_t;
+	CTOPCustom_t VCtopCustom;
+
+	void AddTopTeam(uint32 entry, uint32 pl1, uint32 pl2)
+	{
+		CTOPCustom sc;
+		sc.entry = entry;
+		sc.pl1 = pl1;
+		sc.pl2 = pl2;
+		VCtopCustom[entry] = sc;
+	}
+	std::vector<uint32> _charTopDataMap;
+	std::vector<uint32> _charTopMaxMap;
+	void RollTopTeamID();
+	void UpdateCharTopData();
+	void SengPVPgo(uint32 entry);
+	uint64 topGobGuid;
+	time_t pvptime;
+	void PVPupdate();
+	void SendTopTitle(bool isin);
+	uint32 GetTopMax() const { return _charTopMaxMap.size(); }
+	void DeleteTopData(uint32 guid)
+	{
+		for (std::vector<uint32>::iterator iter = _charTopMaxMap.begin(); iter != _charTopMaxMap.end();)
+		{
+			if (*iter == guid)
+				iter = _charTopMaxMap.erase(iter);
+			else
+				iter++;
+		}
+	}
+	bool Isintop(uint32 guid)
+	{
+		for (std::vector<uint32>::iterator iter = _charTopMaxMap.begin(); iter != _charTopMaxMap.end(); ++iter)
+		{
+			if (*iter == guid)
+				return true;
+		}
+		return false;
+	}
+	bool isfirst;
+	bool topevent;
+	uint32 pvpcount;
+
+
+	typedef std::map<uint32, CTopSys> CTopSys_t;
+	CTopSys_t VCTopSys;
+	const CTopSys * FindTopSys(const uint32  entryID)
+	{
+		CTopSys_t::const_iterator It = VCTopSys.find(entryID);
+
+		return (It != VCTopSys.end() ? &It->second : NULL);
+	}
+
+	std::vector<uint32> topbufflists;
+	void SendAndClearTopBuff(Player * pl, bool onlyph = false);
+	GameObject* SpawnGob(uint32 guid, bool created);
+	typedef std::map<uint32, uint32> PlayerTopPhMap;
+	PlayerTopPhMap m_playertopph;
+	void LoadTopSys();
+private:
+
+};
+#define sCharPvpTop CharPvpTop::instance()
diff --git a/src/server/scripts/Custom/Command/CustomCommand.cpp b/src/server/scripts/Custom/Command/CustomCommand.cpp
new file mode 100644
index 0000000..eeee135
--- /dev/null
+++ b/src/server/scripts/Custom/Command/CustomCommand.cpp
@@ -0,0 +1,2154 @@
+ï»¿#pragma execution_character_set("utf-8")
+#include "CustomCommand.h"
+#include "Chat.h"
+#include "Transport.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "Chat.h"
+#include "ObjectMgr.h"
+#include "Opcodes.h"
+#include "Pet.h"
+#include "Player.h"
+#include "ReputationMgr.h"
+#include "ScriptMgr.h"
+#include "../Switch/Switch.h"
+#include "../StatPoints/StatPoints.h"
+#include "../FunctionCollection/FunctionCollection.h"
+#include "../VIP/VIP.h"
+#include "../String/myString.h"
+#include "../CustomEvent/Event.h"
+#include "../CharNameMod/CharNameMod.h"
+#include "../Reward/Reward.h"
+#include "../DBCCreate/DBCCreate.h"
+#include "../Skill/Skill.h"
+#include "../Rank/Rank.h"
+#include "../SpiritPower/SpiritPower.h"
+#include "../Morph/Morph.h"
+#include "../ItemMod/ItemMod.h"
+#include "../Faker/Faker.h"
+#include "../Talisman/Talisman.h"
+#include "AccountMgr.h"
+#include "../GCAddon/GCAddon.h"
+#include "../CDK/CDK.h"
+#include "../UI/Rune/Rune.h"
+#include "../UI/BlackMarket/BlackMarket.h"
+#include "../AuthCheck/AuthCheck.h"
+#include "group.h"
+#include <fstream>
+#include "MapManager.h"
+#include "..\..\server\scripts\Custom\DataLoader\DataLoader.h"
+
+std::vector<CommandTemplate> CommandVec;
+
+void CustomCommand::Load()
+{
+	return;
+	CommandVec.clear();
+	QueryResult result = WorldDatabase.PQuery("SELECT ID,command FROM _command");
+	if (!result) return;
+	do
+	{
+		Field* fields = result->Fetch();
+		CommandTemplate Temp;
+		Temp.ID = fields[0].GetUInt32();
+		Temp.command = fields[1].GetString();
+
+		CommandVec.push_back(Temp);
+	} while (result->NextRow());
+}
+
+void CustomCommand::DoCommandByID(Player* player, uint32 ID)
+{
+	std::string command = "";
+
+	for (std::vector<CommandTemplate>::iterator iter = CommandVec.begin(); iter != CommandVec.end(); ++iter)
+	{
+		if (ID == iter->ID)
+		{
+			command = iter->command;
+			break;
+		}
+	}
+
+	DoCommand(player, command);
+}
+
+void CustomCommand::DoCommand(Player* player, std::string command)
+{
+	if (command.empty())
+		return;
+
+	player->CastStop();
+
+	uint64 oriTarget = player->GetTarget();
+
+	std::vector<std::string> commandsVec = sCF->SplitStr(command, "#");
+
+	AccountTypes security = player->GetSession()->GetSecurity();
+
+	player->GetSession()->SetSecurity(SEC_CONSOLE);
+
+	for (std::vector<std::string>::iterator iter = commandsVec.begin(); iter != commandsVec.end(); ++iter)
+	{
+		std::string command = *iter;
+
+		std::string::size_type p = command.find("&");
+
+		if (p == std::string::npos)
+			player->SetSelection(player->GetGUID());
+		else
+		{
+			command = sCF->SplitStr(command, "&")[1];
+			player->SetSelection(oriTarget);
+		}
+			
+		if (!ChatHandler(player->GetSession()).ParseCommands(command.c_str(), false))
+		{
+			std::ostringstream oss;
+			oss << "å½ä»¤éç½®åºé:" << (*iter);
+			player->GetSession()->SendNotification(oss.str().c_str());
+		}
+	}
+
+	player->SetSelection(oriTarget);
+
+	player->GetSession()->SetSecurity(security);	
+}
+
+class custom_commandscript : public CommandScript
+{
+public:
+	custom_commandscript() : CommandScript("custom_commandscript") { }
+
+    std::vector<ChatCommand> GetCommands() const override
+	{
+        static std::vector<ChatCommand> cdkCommandTable =
+		{
+			{ "create", SEC_CONSOLE, true, &HandleCreateCDKCommand, "" },
+			{ "out",	SEC_CONSOLE, true, &HandleOutCDKCommand, "" }
+		};
+
+        static std::vector<ChatCommand> addCommandTable =
+		{
+			{ "xp",				SEC_GAMEMASTER,			false,		&HandleAddXPCommand,				"" },
+			{ "token",			SEC_GAMEMASTER,			false,		&HandleAddTokenCommand,				"" },
+			{ "sps",			SEC_GAMEMASTER,			false,		&HandleAddStatPointCommand,			"" },
+			{ "tps",			SEC_GAMEMASTER,			false,		&HandleAddTalentPointCommand,		"" },
+			{ "viptps",			SEC_GAMEMASTER,			false,		&HandleAddVIPTalentPointCommand,	"" },
+			{ "cps",			SEC_GAMEMASTER,			false,		&HandleAddCommercePointCommand,		"" },
+			{ "pos",			SEC_GAMEMASTER,			false,		&HandleAddPosCommand,				"" },
+			{ "inerpos",		SEC_GAMEMASTER,			false,		&HandleAddInerPosCommand,			"" },
+			{ "skill",			SEC_GAMEMASTER,			false,		&HandleAddSkillCommand,				"" },
+			{ "rankvalue",		SEC_GAMEMASTER,			false,		&HandleAddRankValueCommand,			"" },
+			{ "spiritpower",	SEC_GAMEMASTER,			false,		&HandleAddSpiritPowerCommand,		"" },
+			{ "maxspiritpower", SEC_GAMEMASTER,			false,		&HandleAddMaxSpiritPowerCommand,	"" },
+			{ "gob",			SEC_GAMEMASTER,			false,		&HandleAddGameObjectCommand,		"" },
+			{ "items",			SEC_GAMEMASTER,			false,		&HandleAddItemsCommand,				"" },
+			{ "talismanvalue",	SEC_GAMEMASTER,			false,		&HandleAddTalismanValueCommand,		"" },
+			{ "faker",			SEC_GAMEMASTER,			false,		&HandleAddFakerCommand,				"" },
+			{ "rune",			SEC_GAMEMASTER,			false,		&HandleAddRuneCommand,				"" },
+			{ "aura",			SEC_GAMEMASTER,			false,		&HandleAddAuraCommand,				"" }
+		};
+
+        static std::vector<ChatCommand> rewCommandTable =
+		{
+			{ "ip",			SEC_GAMEMASTER,			false,		&HandleRewIpCommand,				"" },
+			{ "rewId",		SEC_GAMEMASTER,			false,		&HandleRewIdCommand,				"" }
+		};
+
+        static std::vector<ChatCommand> setCommandTable =
+		{
+			{ "viplevel",			SEC_GAMEMASTER,			false,		&HandleSetVIPCommand,				"" },
+            { "acc",                SEC_GAMEMASTER,         false,      &HandleSetCCCommand,                "" },
+			{ "faction",			SEC_GAMEMASTER,			false,		&HandleSetFactionCommand,			"" },
+			{ "prefix",				SEC_GAMEMASTER,			false,		&HandleSetNamePrefixCommand,		"" },
+			{ "suffix",				SEC_GAMEMASTER,			false,		&HandleSetNameSuffixCommand,		"" },
+			{ "skill",				SEC_GAMEMASTER,			false,		&HandleSetSkillCommand,				"" },
+			{ "duel",				SEC_GAMEMASTER,			false,		&HandleSetDuelCommand,				"" },
+			{ "maxspiritpower",		SEC_GAMEMASTER,			false,		&HandleSetMaxSpiritPowerCommand,	"" },
+			{ "morph",				SEC_GAMEMASTER,			false,		&HandleSetMorphCommand,				"" },
+			{ "scale",				SEC_GAMEMASTER,			false,		&HandleSetScaleCommand,				"" },
+			{ "display",			SEC_GAMEMASTER,			false,		&HandleSetDisplayCommand,			"" },
+			{ "name",				SEC_GAMEMASTER,			false,		&HandleSetNameCommand,				"" },
+			{ "subname",			SEC_GAMEMASTER,			false,		&HandleSetSubNameCommand,			"" },
+			{ "npcflag",			SEC_GAMEMASTER,			false,		&HandleSetNPCFlagCommand,			"" }
+		};
+
+        static std::vector<ChatCommand> resetCommandTable =
+		{
+			{ "sps",		SEC_GAMEMASTER,			false,		&HandleResetStatPointsCommand,		"" },
+			{ "daily",		SEC_GAMEMASTER,			false,		&HandleResetDailyQuestCommand,		"" },
+			{ "weekly",		SEC_GAMEMASTER,			false,		&HandleResetWeeklyQuestCommand,		"" }
+		};
+
+        static std::vector<ChatCommand> dbcCommandTable =
+		{
+			{ "item",					SEC_CONSOLE,		true,	&HandleCreateItemDBCCommand,					"" },
+			{ "charstartoutfit",		SEC_CONSOLE,		true,	&HandleCreateCharStartOutfitDBCCommand,			"" },
+			{ "itemdisplayinfo",		SEC_CONSOLE,		true,	&HandleCreateItemDisplayInfoDBCCommand,			"" },
+			{ "itemextendedcost",		SEC_CONSOLE,		true,	&HandleCreateItemExtendedCostDBCCommand,		"" },
+			{ "spell",					SEC_CONSOLE,		true,	&HandleCreateSpellDBCCommand,					"" },
+			{ "spellitemenchantment",	SEC_CONSOLE,		true,	&HandleCreateSpellItemEnchantmentDBCCommand,	"" },
+			{ "talent",					SEC_CONSOLE,		true,	&HandleCreateTalentDBCCommand,					"" },
+			{ "spellicon",				SEC_CONSOLE,		true,	&HandleCreateSpellIconDBCCommand,				"" }
+		};
+
+        static std::vector<ChatCommand> sqlCommandTable =
+		{
+			{ "charstartoutfit",		SEC_CONSOLE,		true,	&HandleCreateCharStartOutfitSQLCommand,			"" },
+			{ "itemdisplayinfo",		SEC_CONSOLE,		true,	&HandleCreateItemDisplayInfoSQLCommand,			"" },
+			{ "itemextendedcost",		SEC_CONSOLE,		true,	&HandleCreateItemExtendedCostSQLCommand,		"" },
+			{ "spell",					SEC_CONSOLE,		true,	&HandleCreateSpellSQLCommand,					"" },
+			{ "spellitemenchantment",	SEC_CONSOLE,		true,	&HandleCreateSpellItemEnchantmentSQLCommand,	"" },
+			{ "talent",					SEC_CONSOLE,		true,	&HandleCreateTalentSQLCommand,					"" },
+			{ "spellicon",				SEC_CONSOLE,		true,	&HandleCreateSpellIconSQLCommand,				"" }
+		};
+
+        static std::vector<ChatCommand> commandTable =
+		{
+			{ "_vendor",	SEC_GAMEMASTER,			false,		&HandleVendorCommand,				"" },
+			{ "_add",		SEC_GAMEMASTER,			false,		NULL,								"", addCommandTable },
+			{ "_reward",	SEC_GAMEMASTER,			false,		NULL,								"", rewCommandTable },
+			{ "_set",		SEC_GAMEMASTER,			false,		NULL,								"", setCommandTable },
+			{ "_reset",		SEC_GAMEMASTER,			false,		NULL,								"", resetCommandTable },
+			{ "_tele",		SEC_GAMEMASTER,			false,		&HandleTeleCommand,					"" },
+			{ "jk",			SEC_PLAYER,				false,		&HandleJKCommand,					"" },
+			{ "_summon",	SEC_GAMEMASTER,			false,		&HandleSummonCommand,				"" },
+			{ "_db_clear",	SEC_CONSOLE,			true,		&HandleDBClearCommand,				"" },
+			{ "pl",			SEC_CONSOLE,			true,		&HandlePlayerDataCommand,			"" },
+			{ "_loot",		SEC_CONSOLE,			true,		&HandleAOELootCommand,				"" },
+			{ "dbc",		SEC_GAMEMASTER,			true,		NULL,								"", dbcCommandTable },
+			{ "sql",		SEC_GAMEMASTER,			true,		NULL,								"", sqlCommandTable },
+			{ "_morpet",	SEC_GAMEMASTER,			false,		&HandlePetMorphCommand,				"" },
+			{ "cdk",		SEC_CONSOLE,			true,		NULL,								"", cdkCommandTable },
+			{ "_blackmarket",	SEC_GAMEMASTER,		false,		&HandleBlackMarketCommand,			"" },
+			{ "outpos",		SEC_GAMEMASTER,			false,		&HandleOutPosCommand,				"" },
+			{ "emote",		SEC_GAMEMASTER,			false,		&HandleEmoteCommand,				"" },
+			{ "clearbag",	SEC_GAMEMASTER,			false,		&HandleClearBagCommand,				"" },
+			{ "_group",		SEC_GAMEMASTER,			false,		&HandleGroupCommand,				"" },
+			{ "_heal",		SEC_GAMEMASTER,			false,		&HandleHealCommand,					"" },
+			{ "_level",		SEC_GAMEMASTER,			false,		&HandleLevelCommand,				"" },
+			{ "_enchantlua", SEC_CONSOLE,			true,		&HandleEnchantLuaCommand,			"" },
+			{ "_go",		SEC_CONSOLE,			true,		&HandleGoCommand,					"" }
+		};
+		return commandTable;
+	}
+
+	static bool HandleGoCommand(ChatHandler* handler, char const* args)
+	{
+		if (!*args)
+			return false;
+
+		Player* player = handler->GetSession()->GetPlayer();
+
+		char* goX = strtok((char*)args, " ");
+		char* goY = strtok(NULL, " ");
+		char* goZ = strtok(NULL, " ");
+		char* id = strtok(NULL, " ");
+		char* s_diff = strtok(NULL, " ");
+		char* s_challengelv = strtok(NULL, " ");
+
+		if (!goX || !goY)
+			return false;
+
+		float x = (float)atof(goX);
+		float y = (float)atof(goY);
+		float z;
+		float ort = player->GetOrientation();
+		uint32 mapId = id ? (uint32)atoi(id) : player->GetMapId();
+
+		if (goZ)
+		{
+			z = (float)atof(goZ);
+			if (!MapManager::IsValidMapCoord(mapId, x, y, z))
+			{
+				handler->PSendSysMessage(LANG_INVALID_TARGET_COORD, x, y, mapId);
+				handler->SetSentErrorMessage(true);
+				return false;
+			}
+		}
+		else
+		{
+			if (!MapManager::IsValidMapCoord(mapId, x, y))
+			{
+				handler->PSendSysMessage(LANG_INVALID_TARGET_COORD, x, y, mapId);
+				handler->SetSentErrorMessage(true);
+				return false;
+			}
+			Map const* map = sMapMgr->CreateBaseMap(mapId);
+			z = std::max(map->GetHeight(x, y, MAX_HEIGHT), map->GetWaterLevel(x, y));
+		}
+
+		// stop flight if need
+		if (player->IsInFlight())
+		{
+			player->GetMotionMaster()->MovementExpired();
+			player->CleanupAfterTaxiFlight();
+		}
+		// save only in non-flight case
+		else
+			player->SaveRecallPosition();
+
+		player->SetDungeonDifficulty(Difficulty(atoi(s_diff)));
+		player->ChallengeLv = atoi(s_challengelv);
+
+		player->TeleportTo(mapId, x, y, z, ort);
+		return true;
+	}
+
+
+	static bool HandleEnchantLuaCommand(ChatHandler* handler, char const* args)
+	{
+		ofstream outfile("GhostEnchantData.lua");
+
+		outfile << "GhostEnchantData = {" << std::endl;
+
+		for (uint32 id = 0; id < sSpellItemEnchantmentStore.GetNumRows(); id++)
+		{
+
+			SpellItemEnchantmentEntry const* info = sSpellItemEnchantmentStore.LookupEntry(id);
+
+			if (!info)
+				continue;
+
+			outfile << "[\"" << info->ID << "\"] = \"" << info->description[4] << "\"," << std::endl;
+
+		}
+
+		outfile << "}" << std::endl;
+		outfile.close();
+
+		if (handler->GetSession())
+			ChatHandler(handler->GetSession()).PSendSysMessage("éé­ä¿¡æ¯å¯¼åºå®æï¼ä¿å­äºæ ¸å¿æ ¹ç®å½GhostEnchantData.Luaï¼å°å¶å¤å¶å°Interface/Addons/GhostPanelæä»¶å¤¹ä¸");
+		else
+			sLog->outString("éé­ä¿¡æ¯å¯¼åºå®æï¼ä¿å­äºæ ¸å¿æ ¹ç®å½GhostEnchantData.Luaï¼å°å¶å¤å¶å°Interface/Addons/GhostPanelæä»¶å¤¹ä¸");
+
+		return true;
+	}
+
+	static bool HandleGroupCommand(ChatHandler* handler, char const* args)
+	{
+		Player* player = handler->GetSession()->GetPlayer();
+
+		if (!player)
+			return false;
+
+		if (!*args)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("å½ä»¤æ ¼å¼._group summon/revive");
+			return false;
+		}
+
+		Group* group = player->GetGroup();
+
+		if (!group)
+			return true;
+
+		std::string param = (char*)args;
+
+		if (param == "summon")
+		{
+			for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+				if (Player* member = itr->GetSource())
+					if (member->IsInWorld() && member->GetGUID() != player->GetGUID())
+						member->TeleportTo(player->GetMapId(), player->GetPositionX(), player->GetPositionY(), player->GetPositionZ(), player->GetOrientation());
+			return true;
+		}
+
+		if (param == "revive")
+		{
+			for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+				if (Player* member = itr->GetSource())
+					if (member->IsInWorld() && !member->IsAlive())
+					{
+						member->ResurrectPlayer(1.0f);
+						member->SpawnCorpseBones();
+					}
+
+			return true;
+		}
+
+		ChatHandler(handler->GetSession()).PSendSysMessage("å½ä»¤æ ¼å¼._group summon/revive");
+		return false;
+	}
+
+	static bool HandleHealCommand(ChatHandler* handler, const char* args)
+	{
+		Player* player = handler->GetSession()->GetPlayer();
+
+		if (!player)
+			return false;
+
+		if (!*args)
+		{	
+			ChatHandler(handler->GetSession()).PSendSysMessage("è¯­æ³æ ¼å¼:._heal çç©ç¼å· è¡é");
+			return false;
+		}
+
+		char* s_entry = strtok((char*)args, " ");
+		char* s_health = strtok(NULL, " ");
+
+		if (!s_entry || !s_health)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("è¯­æ³æ ¼å¼:._heal çç©ç¼å· è¡é");
+			return false;
+		}
+
+		uint32 entry = atoi(s_entry);
+		uint32 health = atoi(s_health);
+
+		if (Creature* c = player->FindNearestCreature(entry, 1000.0f))
+			c->ModifyHealth(health);
+
+		return true;
+	}
+
+	static bool HandleLevelCommand(ChatHandler* handler, const char* args)
+	{
+		Player* player = handler->GetSession()->GetPlayer();
+
+		if (!player)
+			return false;
+
+		if (!*args)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("è¯­æ³æ ¼å¼:._level ç­çº§");
+			return false;
+		}
+
+		uint32 level = atoi(args);
+		if (player->getLevel() >= level)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("ä½ å½åç­çº§%uå¤§äºæç­äºè¦æåçç­çº§%u", player->getLevel(), level);
+			return true;
+		}
+
+		std::string cmd = ".char level " + std::string(args);
+		sCustomCommand->DoCommand(player, cmd);
+
+		return true;
+	}
+
+	static bool HandleBlackMarketCommand(ChatHandler* handler, char const* args)
+	{
+		if (!*args)
+			return false;
+
+
+		std::string param = (char*)args;
+
+		if (param == "on")
+		{
+			sBlackMarket->Start();
+			return true;
+		}
+
+		if (param == "off")
+		{
+			sBlackMarket->Stop();
+			return true;
+		}
+
+		handler->SendSysMessage(LANG_USE_BOL);
+		handler->SetSentErrorMessage(true);
+		return false;
+	}
+
+	static bool HandleSetScaleCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		float Scale = (float)atof((char*)args);
+		if (Scale > 10.0f || Scale < 0.1f)
+		{
+			handler->SendSysMessage(LANG_BAD_VALUE);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		Unit* target = handler->getSelectedUnit();
+		if (!target || target->GetTypeId() != TYPEID_UNIT)
+		{
+			handler->SendSysMessage(LANG_SELECT_CREATURE);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+
+		target->SetObjectScale(Scale);
+		WorldDatabase.PExecute("Update creature_template Set scale = %f WHERE entry = %u", Scale, target->GetEntry());
+		ChatHandler(handler->GetSession()).PSendSysMessage("[%s][Scale]è®¾ç½®ä¸º%f", target->GetName().c_str(), Scale);
+		return true;
+	}
+
+	static bool HandleOutPosCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		OutPos(atoi(args));
+		return true;
+	}
+
+	static bool HandleEmoteCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+		Unit* target = handler->getSelectedUnit();
+		
+		if (!target)
+			target = handler->GetSession()->GetPlayer();
+
+		target->HandleEmoteCommand(atoi(args));
+
+		return true;
+	}
+
+	static bool HandleClearBagCommand(ChatHandler* handler, const char* args)
+	{
+		if (Player* player = handler->GetSession()->GetPlayer())
+			for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+				if (Bag* pBag = player->GetBagByPos(i))
+					for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+						if (Item* item = player->GetItemByPos(i, j))
+							player->DestroyItem(item->GetBagSlot(), item->GetSlot(), true);
+		
+		return true;
+	}
+
+	static bool HandleSetDisplayCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		uint32 displayId = atoi(args);
+
+		Unit* target = handler->getSelectedUnit();
+		if (!target || target->GetTypeId() != TYPEID_UNIT)
+		{
+			handler->SendSysMessage(LANG_SELECT_CREATURE);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		target->SetDisplayId(displayId);
+		WorldDatabase.PExecute("Update creature_template Set modelid1 = %u,modelid2 = 0,modelid3 = 0,modelid4 = 0 WHERE entry = %u", displayId, target->GetEntry());
+		ChatHandler(handler->GetSession()).PSendSysMessage("[%s][DisplayId]è®¾ç½®ä¸º%d", target->GetName().c_str(), displayId);
+		return true;
+	}
+
+	static bool HandleSetNPCFlagCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		uint32 npcflag = atoi(args);
+
+		Unit* target = handler->getSelectedUnit();
+		if (!target || target->GetTypeId() != TYPEID_UNIT)
+		{
+			handler->SendSysMessage(LANG_SELECT_CREATURE);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		target->SetUInt32Value(UNIT_NPC_FLAGS, npcflag);
+		WorldDatabase.PExecute("Update creature_template Set npcflag = %u WHERE entry = %u", npcflag, target->GetEntry());
+		ChatHandler(handler->GetSession()).PSendSysMessage("[%s][NpcFlag]è®¾ç½®ä¸º%d", target->GetName().c_str(), npcflag);
+		return true;
+	}
+
+	static bool HandleSetSubNameCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		std::string subName = args;
+
+		Unit* target = handler->getSelectedUnit();
+		if (!target || target->GetTypeId() != TYPEID_UNIT)
+		{
+			handler->SendSysMessage(LANG_SELECT_CREATURE);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		if (CreatureTemplate const* ci = sObjectMgr->GetCreatureTemplate(target->GetEntry()))
+		{
+			WorldPacket queryData;
+			queryData.Initialize(SMSG_CREATURE_QUERY_RESPONSE, 1);
+		
+			queryData << uint32(target->GetEntry());                 // creature entry
+			queryData << ci->Name;
+			queryData << uint8(0) << uint8(0) << uint8(0);           // name2, name3, name4, always empty
+			queryData << subName;
+			queryData << ci->IconName;                               // "Directions" for guard, string for Icons 2.3.0
+			queryData << uint32(ci->type_flags);                     // flags
+			queryData << uint32(ci->type);                           // CreatureType.dbc
+			queryData << uint32(ci->family);                         // CreatureFamily.dbc
+			queryData << uint32(ci->rank);                           // Creature Rank (elite, boss, etc)
+			queryData << uint32(ci->KillCredit[0]);                  // new in 3.1, kill credit
+			queryData << uint32(ci->KillCredit[1]);                  // new in 3.1, kill credit
+			queryData << uint32(ci->Modelid1);                       // Modelid1
+			queryData << uint32(ci->Modelid2);                       // Modelid2
+			queryData << uint32(ci->Modelid3);                       // Modelid3
+			queryData << uint32(ci->Modelid4);                       // Modelid4
+			queryData << float(ci->ModHealth);                       // dmg/hp modifier
+			queryData << float(ci->ModMana);                         // dmg/mana modifier
+			queryData << uint8(ci->RacialLeader);
+			for (uint32 i = 0; i < MAX_CREATURE_QUEST_ITEMS; ++i)
+				queryData << uint32(0);              // itemId[6], quest drop
+			queryData << uint32(ci->movementId);                     // CreatureMovementInfo.dbc
+		
+			handler->GetSession()->SendPacket(&queryData);
+		}
+		
+		WorldDatabase.PExecute("Update creature_template Set subname = '%s' WHERE entry = %u", subName.c_str(), target->GetEntry());
+		ChatHandler(handler->GetSession()).PSendSysMessage("[%s][SubName]è®¾ç½®ä¸º%s", target->GetName().c_str(), subName.c_str());
+
+		return true;
+	}
+
+	static bool HandleSetNameCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		std::string name = args;
+
+		Unit* target = handler->getSelectedUnit();
+		if (!target || target->GetTypeId() != TYPEID_UNIT)
+		{
+			handler->SendSysMessage(LANG_SELECT_CREATURE);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		ChatHandler(handler->GetSession()).PSendSysMessage("[%s][Name]è®¾ç½®ä¸º%s", target->GetName().c_str(), name.c_str());
+		target->SetName(name);
+
+		if (CreatureTemplate const* ci = sObjectMgr->GetCreatureTemplate(target->GetEntry()))
+		{
+			WorldPacket queryData;
+			queryData.Initialize(SMSG_CREATURE_QUERY_RESPONSE, 1);
+		
+			queryData << uint32(target->GetEntry());                  // creature entry
+			queryData << name;
+			queryData << uint8(0) << uint8(0) << uint8(0);           // name2, name3, name4, always empty
+			queryData << ci->SubName;
+			queryData << ci->IconName;                               // "Directions" for guard, string for Icons 2.3.0
+			queryData << uint32(ci->type_flags);                     // flags
+			queryData << uint32(ci->type);                           // CreatureType.dbc
+			queryData << uint32(ci->family);                         // CreatureFamily.dbc
+			queryData << uint32(ci->rank);                           // Creature Rank (elite, boss, etc)
+			queryData << uint32(ci->KillCredit[0]);                  // new in 3.1, kill credit
+			queryData << uint32(ci->KillCredit[1]);                  // new in 3.1, kill credit
+			queryData << uint32(ci->Modelid1);                       // Modelid1
+			queryData << uint32(ci->Modelid2);                       // Modelid2
+			queryData << uint32(ci->Modelid3);                       // Modelid3
+			queryData << uint32(ci->Modelid4);                       // Modelid4
+			queryData << float(ci->ModHealth);                       // dmg/hp modifier
+			queryData << float(ci->ModMana);                         // dmg/mana modifier
+			queryData << uint8(ci->RacialLeader);
+			for (uint32 i = 0; i < MAX_CREATURE_QUEST_ITEMS; ++i)
+				queryData << uint32(0);              // itemId[6], quest drop
+			queryData << uint32(ci->movementId);                     // CreatureMovementInfo.dbc
+		
+			handler->GetSession()->SendPacket(&queryData);
+		}
+
+		WorldDatabase.PExecute("Update creature_template Set name = '%s' WHERE entry = %u", name.c_str(), target->GetEntry());
+		
+		return true;
+	}
+
+	static bool HandleDBClearCommand(ChatHandler* handler, const char* args)
+	{
+		QueryResult result = LoginDatabase.PQuery("SELECT MAX(id) FROM account");
+
+		if (!result)
+			return true;
+
+		uint32 max = result->Fetch()[0].GetUInt32();
+
+		for (size_t i = 0; i < max + 1; i++)
+			AccountMgr::DeleteAccount(i);
+
+		LoginDatabase.DirectExecute("TRUNCATE account_rank");
+		sLog->outString(">> Delete account_rank..");
+
+		LoginDatabase.DirectExecute("TRUNCATE account_spells");
+		sLog->outString(">> Delete account_spells..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE account_instance_times");
+		sLog->outString(">> Delete account_instance_times..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE challenge");
+		sLog->outString(">> Delete challenge..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE character_talisman");
+		sLog->outString(">> Delete character_talisman..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE characters_extra_equipments");
+		sLog->outString(">> Delete characters_extra_equipments..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE chatacters_anticheat");
+		sLog->outString(">> Delete chatacters_anticheat..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE chatacters_token_monitor");
+		sLog->outString(">> Delete chatacters_token_monitor..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE character_recruit");
+		sLog->outString(">> Delete character_recruit..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE character_lottery");
+		sLog->outString(">> Delete character_lottery..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE character_day_item");
+		sLog->outString(">> Delete character_day_item..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE character_achievement_progress");
+		sLog->outString(">> Delete character_custom_skill..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE characters_talent_req");
+		sLog->outString(">> Delete characters_talent_req..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE character_achievement");
+		sLog->outString(">> Delete character_achievement..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE guild");
+		sLog->outString(">> Delete guild..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE guild_bank_eventlog");
+		sLog->outString(">> Delete guild_bank_eventlog..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE guild_bank_item");
+		sLog->outString(">> Delete guild_bank_item..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE guild_bank_right");
+		sLog->outString(">> Delete guild_bank_right..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE guild_bank_tab");
+		sLog->outString(">> Delete guild_bank_tab..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE guild_eventlog");
+		sLog->outString(">> Delete guild_eventlog..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE guild_member");
+		sLog->outString(">> Delete guild_member..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE guild_member_withdraw");
+		sLog->outString(">> Delete guild_member_withdraw..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE guild_rank");
+		sLog->outString(">> Delete guild_rank..");
+
+		CharacterDatabase.DirectExecute("TRUNCATE character_rank");
+		sLog->outString(">> Delete character_rank..");
+
+		sLog->outString(">> è´¦å·åºãè§è²åºæ¸çå®æ¯ï¼");
+		return true;
+	}
+
+	static bool HandlePlayerDataCommand(ChatHandler* handler, const char* args)
+	{
+		uint32 playerCount = 0;
+		uint32 fakerCount = 0;
+
+		std::vector<std::string> IPVec;
+
+		SessionMap::const_iterator itr;
+		for (itr = sWorld->GetAllSessions().begin(); itr != sWorld->GetAllSessions().end(); ++itr)
+		{
+			if (itr->second &&
+				itr->second->GetPlayer() &&
+				itr->second->GetPlayer()->IsInWorld())
+			{
+				std::string ip = itr->second->GetRemoteAddress();
+
+				if (std::find(IPVec.begin(), IPVec.end(), ip) == IPVec.end())
+					IPVec.push_back(ip);
+
+				playerCount++;
+			}
+				
+		}
+
+		fakerCount = sWorld->GetPlayerCount() - playerCount;
+		if (handler->GetSession())
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("æå¡å¨è¿è¡æ¶é´: %s", secsToTimeString(sWorld->GetUptime()).append("."));
+			ChatHandler(handler->GetSession()).PSendSysMessage("ç©å®¶æ°é[%u]ï¼IPæ°é[%u]ï¼åäººæ°é[%u]", playerCount, IPVec.size(), fakerCount);
+		}	
+		else
+		{
+			sLog->outString("æå¡å¨è¿è¡æ¶é´: %s", secsToTimeString(sWorld->GetUptime()).append("."));
+			sLog->outString("ç©å®¶æ°é[%u]ï¼IPæ°é[%u]ï¼åäººæ°é[%u]", playerCount, IPVec.size(), fakerCount);
+		}
+			
+		return true;
+	}
+
+
+	static bool HandleCreateCDKCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+		{
+			if (handler->GetSession())
+				ChatHandler(handler->GetSession()).PSendSysMessage("è¯­æ³æ ¼å¼:.cdk create [count] [rewId] [comment]");
+			else
+				sLog->outString("è¯­æ³æ ¼å¼:.cdk create [count] [rewId] [comment]");
+
+			return false;
+		}
+
+		char* s_count = strtok((char*)args, " ");
+		char* s_rewId = strtok(NULL, " ");
+		char* s_comment = strtok(NULL, " ");
+
+		if (!s_count || !s_rewId || !s_comment)
+		{
+			if (handler->GetSession())
+				ChatHandler(handler->GetSession()).PSendSysMessage("è¯­æ³æ ¼å¼:.cdk create [count] [rewId] [comment]");
+			else
+				sLog->outString("è¯­æ³æ ¼å¼:.cdk create [count] [rewId] [comment]");
+
+			return false;
+		}
+
+		uint32 count = atoi(s_count);
+		uint32 rewId = atoi(s_rewId);
+		std::string comment = s_comment;
+		sCDK->Create(count, rewId, comment);
+
+		std::ostringstream oss;
+		sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+			oss << "[åæ¢ç å·¥å·][__åæ¢ç ]è¡¨æ°å¢" << count << "ä¸ªåæ¢ç ï¼å¤æ³¨å[" << comment << "]ï¼å¥å±æ¨¡æ¿ID[" << rewId << "]" :
+			oss << "[åæ¢ç å·¥å·][_cdk]è¡¨æ°å¢" << count << "ä¸ªåæ¢ç ï¼å¤æ³¨å[" << comment << "]ï¼å¥å±æ¨¡æ¿ID[" << rewId << "]";
+
+		if (handler->GetSession())
+			ChatHandler(handler->GetSession()).PSendSysMessage(oss.str().c_str());
+		else
+			sLog->outString(oss.str().c_str());
+
+		return true;
+	}
+
+	static bool HandleOutCDKCommand(ChatHandler* handler, const char* args)
+	{
+		sCDK->OutPut();
+		
+		std::ostringstream oss;
+		oss << "[åæ¢ç å·¥å·]åæ¢ç å¯¼åºå®æï¼ä¿å­äºæ ¸å¿æ ¹ç®å½åæ¢ç .txt";
+
+		if (handler->GetSession())
+			ChatHandler(handler->GetSession()).PSendSysMessage(oss.str().c_str());
+		else
+			sLog->outString(oss.str().c_str());
+
+		return true;
+	}
+
+	static bool HandleAddAuraCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("è¯­æ³æ ¼å¼:._add aura mapid/-zoneid/all(æ­£æ° - mapid;è´æ° - zoneid;all - å¨æ) spell_id(æ­£æ°-æ¬æ¹éµè¥;è´å¼-ææ¹éµè¥)");
+			return false;
+		}
+
+		Player* player = handler->GetSession()->GetPlayer();
+
+		if (!player)
+			return false;
+
+		char* s_zone = strtok((char*)args, " ");
+		char* s_spell = strtok(NULL, " ");
+
+		if (!s_zone || !s_spell)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("è¯­æ³æ ¼å¼:._add aura mapid/-zoneid/all(æ­£æ° - mapid;è´æ° - zoneid;all - å¨æ) spell_id(æ­£æ°-æ¬æ¹éµè¥;è´å¼-ææ¹éµè¥)");
+			return false;
+		}
+
+		int32 spellid = atoi(s_spell);
+		int32 zoneid = atoi(s_zone);
+
+		const SpellInfo * spellInfo = sSpellMgr->GetSpellInfo(abs(spellid));
+
+		if (!spellInfo)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("åç¯æè½ -%u ä¸å­å¨", abs(spellid));
+			return false;
+		}
+			
+		SessionMap const& smap = sWorld->GetAllSessions();
+		for (SessionMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+			if (Player* pl = iter->second->GetPlayer())
+			{
+				if (pl->GetSession())
+				{
+					if (pl->IsSpectator())
+						continue;
+
+					if (pl->isDead())
+						continue;
+
+					if (spellid > 0 && pl->GetTeamId() != player->GetTeamId())
+						continue;
+
+					if (spellid < 0 && pl->GetTeamId() == player->GetTeamId())
+						continue;
+
+					if (strcmp("all", s_zone) == 0)
+					{
+						pl->AddAura(abs(spellid), pl);
+						continue;
+					}
+
+					if (zoneid >= 0 && pl->GetMapId() != zoneid)
+						continue;
+
+					if (zoneid < 0 && pl->GetZoneId() != abs(zoneid))
+						continue;
+
+					pl->AddAura(abs(spellid), pl);
+				}
+			}
+
+		return true;
+
+		return true;
+	}
+
+	static bool HandleAddPosCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("è¯­æ³æ ¼å¼:._add pos å¤æ³¨ï¼å¦._add pos ä¸»å");
+			return false;
+		}
+
+		Player* player = handler->GetSession()->GetPlayer();
+
+		uint32 posId = 1;
+
+		if (QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+			"SELECT max(åæ ID) FROM _æ¨¡æ¿_åæ " :
+			"SELECT max(posId) FROM _position"))
+			posId = result->Fetch()[0].GetUInt32() + 1;
+
+		WorldDatabase.DirectPExecute(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+			"INSERT INTO _æ¨¡æ¿_åæ (å¤æ³¨,åæ ID,å°å¾ID,Xåæ ,Yåæ ,Zåæ ,Oåæ ) VALUES ('%s','%u','%u','%f','%f','%f','%f')" :
+			"INSERT INTO _position(comment,posId,map,x,y,z,o) VALUES ('%s','%u','%u','%f','%f','%f','%f')", args, posId, player->GetMapId(), player->GetPositionX(), player->GetPositionY(), player->GetPositionZ(), player->GetOrientation());
+
+		std::ostringstream oss;
+		sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+			oss << "[_æ¨¡æ¿_åæ ]æ°å¢ID:" << posId << "å¤æ³¨:" << args :
+			oss << "[_position]æ°å¢ID:" << posId << "å¤æ³¨:" << args;
+
+		ChatHandler(player->GetSession()).PSendSysMessage(oss.str().c_str());
+
+		sCustomCommand->DoCommand(player, ".rl all");
+
+		return true;
+	}
+
+	static bool HandleAddInerPosCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("è¯­æ³æ ¼å¼:._add inerpos å¤æ³¨ï¼å¦._add inerpos posId1 posId2 count");
+			return false;
+		}
+
+		Player* player = handler->GetSession()->GetPlayer();
+
+		uint32 posId1 = atol(strtok((char*)args, " "));
+		uint32 posId2 = atoi(strtok(NULL, " "));
+		uint32 count = atoi(strtok(NULL, " "));
+
+		//sEvent->PrintPos(player, posId1, posId2, count, true);
+		sCustomCommand->DoCommand(player, ".rl all");
+		return true;
+	}
+
+	static bool HandleAddSkillCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		uint32 skillId = atol(strtok((char*)args, " "));
+		int unlearn = atoi(strtok(NULL, " "));
+
+		if (unlearn == -1)
+			sCustomSkill->LearnSkill(target, skillId, false);
+		else
+			sCustomSkill->LearnSkill(target, skillId);
+			
+		return true;
+	}
+
+	static bool HandleAddFakerCommand(ChatHandler* handler, const char* args)
+	{
+		sFaker->Add(true);
+		return true;
+	}
+
+	static bool HandleAddRuneCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("è¯­æ³æ ¼å¼:._add rune [spellid]");
+			return false;
+		}
+
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		if (!args)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("è¯­æ³æ ¼å¼:._add rune [spellid]");
+			return false;
+		}
+
+		uint32 spellid = atoi(args);
+		sRune->Add(target, spellid);
+		return true;
+	}
+
+	static bool HandleAddItemsCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		Player* target = handler->getSelectedPlayer();
+
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		uint32 categoryId = atoi(args);
+
+		sItemMod->AddCategoryItem(handler->GetSession()->GetPlayer(), target, categoryId);
+
+		return true;
+	}
+
+	static bool HandleAddTalismanValueCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		Player* target = handler->getSelectedPlayer();
+
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		uint32 value = atoi(args);
+
+		sTalisman->AddTalismanValue(target, value, false);
+		sTalisman->SaveTalisManValue(target);
+
+		return true;
+	}
+
+	static bool HandleCreateItemDBCCommand(ChatHandler* handler, const char* args)
+	{
+		sDBCCreate->GenerateItemDBC();
+		return true;
+	}
+	
+	static bool HandleCreateItemDisplayInfoDBCCommand(ChatHandler* handler, const char* args)
+	{
+		sDBCCreate->GenerateItemDisplayInfoDBC();
+		return true;
+	}
+
+	static bool HandleCreateItemDisplayInfoSQLCommand(ChatHandler* handler, const char* args)
+	{
+		sDBCCreate->GenerateItemDisplayInfoSql();
+		return true;
+	}
+
+	static bool HandleCreateItemExtendedCostDBCCommand(ChatHandler* handler, const char* args)
+	{
+		sDBCCreate->GenerateItemExtendCostDBC();
+		return true;
+	}
+
+	static bool HandleCreateItemExtendedCostSQLCommand(ChatHandler* handler, const char* args)
+	{
+		sDBCCreate->GenerateItemExtendCostSql();
+		return true;
+	}
+
+	static bool HandleCreateSpellDBCCommand(ChatHandler* handler, const char* args)
+	{
+		sDBCCreate->GenerateSpellDBC();
+		return true;
+	}
+
+	static bool HandleCreateSpellSQLCommand(ChatHandler* handler, const char* args)
+	{
+		sDBCCreate->GenerateSpellSql();
+		return true;
+	}
+
+	static bool HandleCreateSpellItemEnchantmentDBCCommand(ChatHandler* handler, const char* args)
+	{
+		sDBCCreate->GenerateSpellItemEnchantmentDBC();
+		return true;
+	}
+
+	static bool HandleCreateSpellItemEnchantmentSQLCommand(ChatHandler* handler, const char* args)
+	{
+		sDBCCreate->GenerateSpellItemEnchantmentSql();
+		return true;
+	}
+
+	static bool HandleCreateCharStartOutfitDBCCommand(ChatHandler* handler, const char* args)
+	{
+		sDBCCreate->GenerateCharStartOutfitDBC();
+		return true;
+	}
+
+	static bool HandleCreateCharStartOutfitSQLCommand(ChatHandler* handler, const char* args)
+	{
+		sDBCCreate->GenerateCharStartOutfitSql();
+		return true;
+	}
+
+	static bool HandleCreateTalentDBCCommand(ChatHandler* handler, const char* args)
+	{
+		sDBCCreate->GenerateTalentDBC();
+		return true;
+	}
+
+	static bool HandleCreateTalentSQLCommand(ChatHandler* handler, const char* args)
+	{
+		sDBCCreate->GenerateTalentSql();
+		return true;
+	}
+
+	static bool HandleCreateSpellIconDBCCommand(ChatHandler* handler, const char* args)
+	{
+		sDBCCreate->GenerateSpellIconDBC();
+		return true;
+	}
+
+	static bool HandleCreateSpellIconSQLCommand(ChatHandler* handler, const char* args)
+	{
+		sDBCCreate->GenerateSpellIconSql();
+		return true;
+	}
+
+	static bool HandleAddXPCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		int32 xp = atoi(args);
+
+		if (xp < 0)
+			return false;
+
+		uint32 curXP = target->GetUInt32Value(PLAYER_XP);
+		uint32 nextLvlXP = target->GetUInt32Value(PLAYER_NEXT_LEVEL_XP);
+		uint32 newXP = curXP + xp;
+		uint32 level = target->getLevel();
+
+		bool flag = false;
+
+		while (newXP >= nextLvlXP && level < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+		{
+			newXP -= nextLvlXP;
+
+			if (level < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+			{
+				if (level < sSwitch->GetValue(ST_XP_MAX_LV))
+					target->GiveLevel(level + 1);
+				else
+					flag = true;
+			}
+
+			level = target->getLevel();
+			nextLvlXP = target->GetUInt32Value(PLAYER_NEXT_LEVEL_XP);
+		}
+
+		target->SetUInt32Value(PLAYER_XP, newXP);
+
+		if (flag)
+			target->SetUInt32Value(PLAYER_XP, target->GetUInt32Value(PLAYER_NEXT_LEVEL_XP));
+
+		std::ostringstream oss;
+		oss << sCF->GetNameLink(target) << "è·å¾" << "[ç»éª] X " << xp;
+		ChatHandler(target->GetSession()).PSendSysMessage(oss.str().c_str());
+		if (handler->GetSession()->GetPlayer()->GetGUID() != target->GetGUID())
+			ChatHandler(handler->GetSession()).PSendSysMessage(oss.str().c_str());
+
+		return true;
+	}
+
+	static bool HandleAddRankValueCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		uint32 value = (uint32)atoi(args);
+		if (value == 0)
+			return false;
+
+		ChatHandler(target->GetSession()).PSendSysMessage("ä½ è·å¾äº%dç¹æå¡å¨ç»éªå¼", value);
+
+		sRank->Update(target, value, true);
+		return true;
+	}
+
+	static bool HandleAddSpiritPowerCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		int32 value = atoi(args);
+
+		if (value == 0)
+			return false;
+		if (value > 0)
+			sSpiritPower->Update(target, value, true);
+		else
+			sSpiritPower->Update(target, abs(value), false);
+
+		return true;
+	}
+
+	static bool HandleAddMaxSpiritPowerCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		int32 value = atoi(args);
+
+		if (value == 0)
+			return false;
+
+		int32 max = target->MaxSpiritPower + value;
+
+		if (max <= 0)
+			max = 0;
+
+		sSpiritPower->UpdateMax(target, max);
+
+		return true;
+	}
+
+	static bool HandleAddTokenCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		int32 token = atoi(args);
+		std::ostringstream oss;
+
+		if (token > 0)
+		{
+			sCF->UpdateTokenAmount(target, token, true, "[å½ä»¤]è·å¾");
+			oss << sCF->GetNameLink(target) << "è·å¾[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "] X " << token;
+		}
+		else
+		{
+			sCF->UpdateTokenAmount(target, abs(token), false, "[å½ä»¤]æ¶è");
+			oss << sCF->GetNameLink(target) << "æ£é¤[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "] X " << abs(token);
+		}
+
+		ChatHandler(target->GetSession()).PSendSysMessage(oss.str().c_str());
+		if (handler->GetSession()->GetPlayer()->GetGUID() != target->GetGUID())
+			ChatHandler(handler->GetSession()).PSendSysMessage(oss.str().c_str());
+
+		return true;
+	}
+
+	static bool HandleSetNamePrefixCommand(ChatHandler* handler, const char* args)
+	{
+
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		std::string namePrefix;
+
+		if (*args)
+			namePrefix = args;
+		else
+			namePrefix = "";
+
+		sCharNameMod->UpdatePrefix(target, namePrefix);
+
+		std::ostringstream oss;
+		oss << sCF->GetNameLink(target) << "è·å¾[å§ååç¼]" << namePrefix;
+		ChatHandler(target->GetSession()).PSendSysMessage(oss.str().c_str());
+		if (handler->GetSession()->GetPlayer()->GetGUID() != target->GetGUID())
+			ChatHandler(handler->GetSession()).PSendSysMessage(oss.str().c_str());
+
+		return true;
+	}
+
+	static bool HandleSetNameSuffixCommand(ChatHandler* handler, const char* args)
+	{
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		std::string nameSuffix;
+
+		if (*args)
+			nameSuffix = args;
+		else
+			nameSuffix = "";
+
+		sCharNameMod->UpdateSuffix(target, nameSuffix);
+
+		std::ostringstream oss;
+		oss << sCF->GetNameLink(target) << "è·å¾[å§ååç¼]" << nameSuffix;
+		ChatHandler(target->GetSession()).PSendSysMessage(oss.str().c_str());
+		if (handler->GetSession()->GetPlayer()->GetGUID() != target->GetGUID())
+			ChatHandler(handler->GetSession()).PSendSysMessage(oss.str().c_str());
+
+		return true;
+	}
+
+	static bool HandleAddStatPointCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		int32 statpoint = atoi(args);
+
+		if (statpoint < 0)
+			return false;
+
+		uint32 total = 0;
+
+		for (size_t i = 0; i < MAX_STAT_POINTS_TYPE; i++)
+			total += target->stat_points[i];
+
+		total += statpoint;
+
+		if (total >= sSwitch->GetValue(ST_SPS_LIMIT))
+		{
+			ChatHandler(target->GetSession()).PSendSysMessage("ææ°ç¹æ°å·²è¾¾å°æå¤§å¼%d", sSwitch->GetValue(ST_SPS_LIMIT));
+			statpoint = sSwitch->GetValue(ST_SPS_LIMIT) - (total - statpoint);
+		}
+
+		if (statpoint <= 0)
+			return false;
+
+		target->stat_points[SPT_TOTLAL] += statpoint;
+
+		sStatPoints->UpdateDB(target);
+
+		std::ostringstream oss;
+		oss << sCF->GetNameLink(target) << "è·å¾[ææ°ç¹] X " << statpoint;
+		ChatHandler(target->GetSession()).PSendSysMessage(oss.str().c_str());
+		if (handler->GetSession()->GetPlayer()->GetGUID() != target->GetGUID())
+			ChatHandler(handler->GetSession()).PSendSysMessage(oss.str().c_str());
+
+		return true;
+	}
+
+	static bool HandleResetStatPointsCommand(ChatHandler* handler, const char* args)
+	{
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		sStatPoints->ResetPoints(target);
+
+		ChatHandler(target->GetSession()).PSendSysMessage("%s[ææ°ç¹]å·²ç»éç½®", sCF->GetNameLink(target).c_str());
+		if (handler->GetSession()->GetPlayer()->GetGUID() != target->GetGUID())
+			ChatHandler(handler->GetSession()).PSendSysMessage("%s[ææ°ç¹]å·²ç»éç½®", sCF->GetNameLink(target).c_str());
+
+		return true;
+	}
+
+	static bool HandleResetDailyQuestCommand(ChatHandler* handler, const char* args)
+	{
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		target->ResetDailyQuestStatus();
+		return true;
+	}
+
+	static bool HandleResetWeeklyQuestCommand(ChatHandler* handler, const char* args)
+	{
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		target->ResetWeeklyQuestStatus();
+		return true;
+	}
+
+	static bool HandleRewIdCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("è¯­æ³æ ¼å¼:._rew rewId æ°å¼");
+			return false;
+		}
+
+		if (Player* target = handler->getSelectedPlayerOrSelf())
+			sRew->Rew(target, atoi(args));
+
+		return true;
+	}
+
+	static bool HandleRewIpCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("è¯­æ³æ ¼å¼:._rew ip rewId æ°å¼ æ ._rew ip item æ°å¼");
+			return false;
+		}
+
+		char* type = strtok((char*)args, " ");
+		char* value = strtok(NULL, " ");
+		if (!type || !value)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("è¯­æ³æ ¼å¼:._rew ip rewId æ°å¼ æ ._rew ip item æ°å¼");
+			return false;
+		}
+
+		int i = 0;
+
+		if (strcmp(type, "rewId") == 0)		i = 1;
+		else if (strcmp(type, "item") == 0)	i = 2;
+
+		if (i == 0)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("è¯­æ³æ ¼å¼:._rew ip rewId æ°å¼ æ ._rew ip item æ°å¼");
+			return false;
+		}
+
+		uint32 id = atoi(value);
+
+		std::vector<std::string> IpVec;
+		IpVec.clear();
+
+		SessionMap const& smap = sWorld->GetAllSessions();
+		for (SessionMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+			if (Player* pl = iter->second->GetPlayer())
+			{
+				std::string ip = pl->GetSession()->GetRemoteAddress();
+
+				if (std::find(IpVec.begin(), IpVec.end(), ip) == IpVec.end())
+				{
+					if(i == 1) sRew->Rew(pl, id);
+					else if (i == 2) pl->AddItem(id, 1);
+					IpVec.push_back(ip);
+				}
+			}
+
+		if (handler->GetSession())
+			ChatHandler(handler->GetSession()).PSendSysMessage("IPå¥å±å·²åæ¾");
+
+		return true;
+	}
+
+	static bool HandleVendorCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+		handler->GetSession()->SendCommandListInventory(atoi(args));
+		return true;
+	}
+
+	
+	static bool HandleTeleCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		uint32 posId = atoi(args);
+
+		Player* target = handler->GetSession()->GetPlayer();
+
+		std::unordered_map<uint32, PosTemplate>::iterator it = PosMap.find(posId);
+
+		if (it != PosMap.end())
+			target->TeleportTo(it->second.map, it->second.x, it->second.y, it->second.z, it->second.o);
+		else
+			ChatHandler(handler->GetSession()).PSendSysMessage("ä¼ éç¹ä¸å­å¨");
+
+		return true;
+	}
+
+	static bool HandleJKCommand(ChatHandler* handler, const char* args)
+	{
+		Player* target = handler->GetSession()->GetPlayer();
+
+		if (!target)
+			return true;
+
+		if (target->IsAlive())
+		{
+			target->GetSession()->SendNotification("æ­»äº¡ç¶ææå¯ä»¥ä½¿ç¨è¯¥å½ä»¤ï¼");
+			return true;
+		}
+	
+		target->TeleportTo(target->m_homebindMapId, target->m_homebindX, target->m_homebindY, target->m_homebindZ, target->GetOrientation());
+		return true;
+	}
+
+	static void AoeLoot(Player* player, float range)
+	{
+		if (!player->IsAlive())
+		{
+			ChatHandler(player->GetSession()).PSendSysMessage("ä½ å·²ç»æ­»äº¡");
+			return;
+		}
+
+		if (player->IsNonMeleeSpellCast(false))
+			player->InterruptNonMeleeSpells(false);
+
+		std::list<Creature*> list;
+		player->GetCreatureListInGrid(list, range);
+		if (!list.empty())
+		{
+			for (std::list<Creature*>::iterator itr = list.begin(); itr != list.end(); ++itr)
+			{
+				Creature* c = *itr;
+
+				if (c->IsAlive())
+					continue;
+
+				uint64 guid = c->GetGUID();
+				Loot* loot = &c->loot;
+				float range = 100.0f;
+
+				WorldPacket p1(CMSG_LOOT);
+				p1 << guid;
+				player->GetSession()->HandleLootFarOpcode(p1, range);
+
+				for (size_t lootSlot = 0; lootSlot < loot->GetMaxSlotInLootFor(player); lootSlot++)
+				{
+					WorldPacket p(CMSG_AUTOSTORE_LOOT_ITEM);
+					p << lootSlot;
+					player->GetSession()->HandleAutostoreLootItemFarOpcode(p, range);
+				}
+
+				WorldPacket p2(CMSG_LOOT_MONEY);
+				player->GetSession()->HandleLootMoneyFarOpcode(p2, range);
+			}
+		}
+	}
+
+	static bool HandleAOELootCommand(ChatHandler* handler, const char* args)
+	{
+		if (Player* player = handler->GetSession()->GetPlayer())
+			AoeLoot(player, 1000.0f);
+
+		return true;
+	}
+
+	static bool HandleSummonCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("è¯­æ³æ ¼å¼:._summon id(æ­£æ° - Creature Entry;è´æ° - Gameobject Entry) time(CreatureæGameobjectæç»­çæ¶é´ï¼åä½ ç§");
+			return false;
+		}
+
+		char* s_entry = strtok((char*)args, " ");
+		char* s_time	= strtok(NULL, " ");
+
+		if (!s_entry || !s_time)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("è¯­æ³æ ¼å¼:._summon id(æ­£æ° - Creature Entry;è´æ° - Gameobject Entry) time(CreatureæGameobjectæç»­çæ¶é´ï¼åä½ ç§");
+			return false;
+		}
+
+		int32 entry = atoi(s_entry);
+		uint32 time = atoi(s_time);
+
+		Player* target = handler->GetSession()->GetPlayer();
+
+		if (entry > 0)
+			target->SummonCreature(entry, target->GetPositionX(), target->GetPositionY(), target->GetPositionZ(), target->GetOrientation(), TEMPSUMMON_TIMED_DESPAWN, time * IN_MILLISECONDS);
+		else if (entry < 0)
+			target->SummonGameObject(abs(entry), target->GetPositionX(), target->GetPositionY(), target->GetPositionZ(), target->GetOrientation(), 0, 0, 0, 0, time);
+		
+		return true;
+	}
+
+	static bool HandlePetMorphCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		Player* target = handler->GetSession()->GetPlayer();
+
+		if (!target)
+			return false;
+
+		uint32 displayID = atoi(args);
+
+		CreatureModelInfo const* minfo = sObjectMgr->GetCreatureModelInfo(displayID);
+
+		if (!minfo)
+		{
+			ChatHandler(target->GetSession()).PSendSysMessage("%u - ä¸æ¯ä¸ä¸ªææçæ¨¡åID", displayID);
+			return true;
+		}
+
+		if (Pet * pet = target->GetPet())
+		{
+			pet->SetDisplayId(displayID);
+			pet->SetNativeDisplayId(displayID);
+			CharacterDatabase.DirectPExecute("UPDATE character_pet SET modelid = '%u' WHERE owner = '%u' AND entry = '%u'", displayID, target->GetGUIDLow(), pet->GetEntry());
+			ChatHandler(target->GetSession()).PSendSysMessage("æ¹åå® ç©æ¨¡åä¸º - %u", displayID);
+			return true;
+		}else
+			ChatHandler(target->GetSession()).PSendSysMessage("ä½ æ²¡æå¬å¤ä¸ä¸ªå® ç©", displayID);
+
+		return true;
+	}
+
+	static bool HandleSetFactionCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		Unit* target = handler->getSelectedUnit();
+		if (!target)
+		{
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		uint32 faction = atoi(args);
+
+		target->setFaction(faction);
+
+		if (target->GetTypeId() == TYPEID_UNIT)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("[%s][Faction]è®¾ç½®ä¸º%d", target->GetName().c_str(), faction);
+			WorldDatabase.PExecute("Update creature_template Set faction = %u WHERE entry = %u", faction, target->GetEntry());
+		}
+		else if (target->GetTypeId() == TYPEID_PLAYER)
+		{
+			ChatHandler(target->ToPlayer()->GetSession()).PSendSysMessage("[%s][éµè¥]è®¾ç½®ä¸º%d", target->GetName().c_str(), faction);
+			if (handler->GetSession()->GetPlayer()->GetGUID() != target->GetGUID())
+				ChatHandler(handler->GetSession()).PSendSysMessage("[%s][éµè¥]è®¾ç½®ä¸º%d", target->GetName().c_str(), faction);
+		}
+
+		return true;
+	}
+
+	static bool HandleSetDuelCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		int32 duel = atoi(args);
+
+		target->SetInt32Value(PLAYER_DUEL_TEAM, duel);
+
+		ChatHandler(target->GetSession()).PSendSysMessage("[Duelç»å«]è®¾ç½®ä¸º%d", duel);
+		if (handler->GetSession()->GetPlayer()->GetGUID() != target->GetGUID())
+			ChatHandler(handler->GetSession()).PSendSysMessage("[Duelç»å«]è®¾ç½®ä¸º%d", duel);
+
+		return true;
+	}
+
+	static bool HandleSetMorphCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		int32 morphId = atoi(args);
+
+		target->RemoveAura(MORPH_SPELLID);
+		//sMorph->SetMorphId(target, morphId);
+		//sMorph->SetMorphDuration(target, sMorph->GetDuration(morphId));
+		target->CastSpell(target, MORPH_SPELLID);
+
+		return true;
+	}
+
+	static bool HandleSetMaxSpiritPowerCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		int32 maxspiritpower = atoi(args);
+
+		sSpiritPower->UpdateMax(target, maxspiritpower);
+		return true;
+	}
+
+	static bool HandleAddTalentPointCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		int32 tp = atoi(args);
+
+		if (tp < 0)
+			return false;
+
+		uint32 extraTps = sCF->GetExtraTalentPoints(target);
+		uint32 maxExTps = sSwitch->GetValue(ST_EXTRA_TPS);
+
+		if (extraTps + tp >= maxExTps)
+		{
+			target->SetFreeTalentPoints(target->GetFreeTalentPoints() + uint32(maxExTps - extraTps));
+			target->SendTalentsInfoData(false);
+
+			ChatHandler(target->GetSession()).PSendSysMessage("%sè·å¾é¢å¤%uä¸ªå¤©èµç¹", sCF->GetNameLink(target).c_str(), uint32(maxExTps - extraTps));
+			if (handler->GetSession()->GetPlayer()->GetGUID() != target->GetGUID())
+				ChatHandler(handler->GetSession()).PSendSysMessage("%sè·å¾é¢å¤%uä¸ªå¤©èµç¹", sCF->GetNameLink(target).c_str(), uint32(maxExTps - extraTps));
+
+			if (sSwitch->GetOnOff(ST_TP_ACCOUNT_BIND))
+				LoginDatabase.DirectPExecute("UPDATE account SET extraTalentPoints = '%u' WHERE id = '%u'", maxExTps, target->GetSession()->GetAccountId());
+			else
+				CharacterDatabase.DirectPExecute("UPDATE characters SET extraTalentPoints = '%u' WHERE guid = '%u'", maxExTps, target->GetGUIDLow());
+			return true;
+		}
+
+		ChatHandler(target->GetSession()).PSendSysMessage("%sè·å¾é¢å¤%uä¸ªå¤©èµç¹", sCF->GetNameLink(target).c_str(), tp);
+		if (handler->GetSession()->GetPlayer()->GetGUID() != target->GetGUID())
+			ChatHandler(handler->GetSession()).PSendSysMessage("%sè·å¾é¢å¤%uä¸ªå¤©èµç¹", sCF->GetNameLink(target).c_str(), tp);
+
+		target->SetFreeTalentPoints(target->GetFreeTalentPoints() + tp);
+		target->SendTalentsInfoData(false);
+
+		if (sSwitch->GetOnOff(ST_TP_ACCOUNT_BIND))
+			LoginDatabase.DirectPExecute("UPDATE account SET extraTalentPoints = extraTalentPoints + '%u' WHERE id = '%u'", tp, target->GetSession()->GetAccountId());
+		else
+			CharacterDatabase.DirectPExecute("UPDATE characters SET extraTalentPoints = extraTalentPoints + '%u' WHERE guid = '%u'", tp, target->GetGUIDLow());
+		return true;
+	}
+
+	static bool HandleAddVIPTalentPointCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		int32 tp = atoi(args);
+
+		if (tp < 0)
+			return false;
+
+		uint32 extraTps = sCF->GetExtraTalentPoints(target);
+		uint32 maxExTps = 0;
+
+		switch (target->vipLevel)
+		{
+		case 1: maxExTps = 3; break;
+		case 2: maxExTps = 8; break;
+		case 3: maxExTps = 15; break;
+		case 4: maxExTps = 24; break;
+		case 5: maxExTps = 36; break;
+		case 6: maxExTps = 50; break;
+		default:break;	
+		}
+
+		if (extraTps + tp >= maxExTps)
+		{
+			target->SetFreeTalentPoints(target->GetFreeTalentPoints() + uint32(maxExTps - extraTps));
+			target->SendTalentsInfoData(false);
+
+			ChatHandler(target->GetSession()).PSendSysMessage("%sè·å¾é¢å¤%uä¸ªå¤©èµç¹", sCF->GetNameLink(target).c_str(), uint32(maxExTps - extraTps));
+			if (handler->GetSession()->GetPlayer()->GetGUID() != target->GetGUID())
+				ChatHandler(handler->GetSession()).PSendSysMessage("%sè·å¾é¢å¤%uä¸ªå¤©èµç¹", sCF->GetNameLink(target).c_str(), uint32(maxExTps - extraTps));
+
+			if (sSwitch->GetOnOff(ST_TP_ACCOUNT_BIND))
+				LoginDatabase.DirectPExecute("UPDATE account SET extraTalentPoints = '%u' WHERE id = '%u'", maxExTps, target->GetSession()->GetAccountId());
+			else
+				CharacterDatabase.DirectPExecute("UPDATE characters SET extraTalentPoints = '%u' WHERE guid = '%u'", maxExTps, target->GetGUIDLow());
+			return true;
+		}
+
+		ChatHandler(target->GetSession()).PSendSysMessage("%sè·å¾é¢å¤%uä¸ªå¤©èµç¹", sCF->GetNameLink(target).c_str(), tp);
+		if (handler->GetSession()->GetPlayer()->GetGUID() != target->GetGUID())
+			ChatHandler(handler->GetSession()).PSendSysMessage("%sè·å¾é¢å¤%uä¸ªå¤©èµç¹", sCF->GetNameLink(target).c_str(), tp);
+
+		target->SetFreeTalentPoints(target->GetFreeTalentPoints() + tp);
+		target->SendTalentsInfoData(false);
+
+		if (sSwitch->GetOnOff(ST_TP_ACCOUNT_BIND))
+			LoginDatabase.DirectPExecute("UPDATE account SET extraTalentPoints = extraTalentPoints + '%u' WHERE id = '%u'", tp, target->GetSession()->GetAccountId());
+		else
+			CharacterDatabase.DirectPExecute("UPDATE characters SET extraTalentPoints = extraTalentPoints + '%u' WHERE guid = '%u'", tp, target->GetGUIDLow());
+		return true;
+	}
+
+
+	static bool HandleAddCommercePointCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		int32 cp = atoi(args);
+
+		if (cp < 0)
+			return false;
+
+		uint32 extraCps = 0;
+
+		QueryResult result = CharacterDatabase.PQuery("SELECT extraPrimaryTradeSkills FROM characters WHERE guid = '%u'", target->GetGUIDLow());
+		if (result)
+		{
+			Field* fields = result->Fetch();
+			extraCps = fields[0].GetInt32();
+		}
+
+
+		if (extraCps + cp > uint32(sSwitch->GetValue(ST_EXTRA_CPS_LIMIT)))
+		{
+			CharacterDatabase.DirectPExecute("UPDATE characters SET extraPrimaryTradeSkills ='%u' WHERE guid = '%u'", sSwitch->GetValue(ST_EXTRA_CPS_LIMIT), target->GetGUIDLow());
+			target->maxPrimaryTradeSkills = target->maxPrimaryTradeSkills + uint32(sSwitch->GetValue(ST_EXTRA_CPS_LIMIT) - extraCps);
+			if (target->maxPrimaryTradeSkills >= sCF->GetCommercePoints(target))
+				target->SetFreePrimaryProfessions(target->maxPrimaryTradeSkills - sCF->GetCommercePoints(target));
+
+			ChatHandler(target->GetSession()).PSendSysMessage("%sè·å¾é¢å¤%uä¸ªåä¸æè½ç¹", sCF->GetNameLink(target).c_str(), uint32(sSwitch->GetValue(ST_EXTRA_CPS_LIMIT) - extraCps));
+			if (handler->GetSession()->GetPlayer()->GetGUID() != target->GetGUID())
+				ChatHandler(handler->GetSession()).PSendSysMessage("%sè·å¾é¢å¤%uä¸ªåä¸æè½ç¹", sCF->GetNameLink(target).c_str(), uint32(sSwitch->GetValue(ST_EXTRA_CPS_LIMIT) - extraCps));
+
+			return true;
+		}
+
+		target->maxPrimaryTradeSkills += cp;
+		if (target->maxPrimaryTradeSkills >= sCF->GetCommercePoints(target))
+			target->SetFreePrimaryProfessions(target->maxPrimaryTradeSkills - sCF->GetCommercePoints(target));
+		CharacterDatabase.PExecute("update characters set extraPrimaryTradeSkills = extraPrimaryTradeSkills + '%u' where guid = %u", cp, target->GetGUIDLow());
+
+		ChatHandler(target->GetSession()).PSendSysMessage("%sè·å¾é¢å¤%uä¸ªåä¸æè½ç¹", sCF->GetNameLink(target).c_str(), cp);
+		if (handler->GetSession()->GetPlayer()->GetGUID() != target->GetGUID())
+			ChatHandler(handler->GetSession()).PSendSysMessage("%sè·å¾é¢å¤%uä¸ªåä¸æè½ç¹", sCF->GetNameLink(target).c_str(), cp);
+
+		return true;
+	}
+
+    static bool HandleSetCCCommand(ChatHandler* handler, const char* args)
+    {
+        if (!*args)
+            return false;
+
+        Player* target = handler->getSelectedPlayer();
+        if (!target)
+        {
+            handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        int32 vip = atoi(args);
+        if (vip < 1)
+        {
+            ChatHandler(target->GetSession()).PSendSysMessage("ççä¸è½ä½äº1å");
+            return false;
+        }
+        sDataLoader->AddLootPl(target, vip);
+        sCF->SetLootRate(target);
+
+        ChatHandler(target->GetSession()).PSendSysMessage("%sè·å¾%uåççï¼å°éåå¨ä¸çæ", sCF->GetNameLink(target).c_str(), vip);
+        return true;
+    }
+
+	static bool HandleSetVIPCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+			return false;
+
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		int32 vip = atoi(args);
+
+		if (vip < 1)
+			return false;
+
+        if (target->vipLevel >= vip)
+        {
+            ChatHandler(handler->GetSession()).PSendSysMessage("%sVIPç­çº§å·²ç»å¤§äºæèç­äºè¿ä¸ªç­çº§äºæ æ³å¨ä½¿ç¨.", sCF->GetNameLink(target).c_str());
+            return false;
+        }
+
+		if (vip <= target->vipLevel)
+			vip = target->vipLevel;
+
+		LoginDatabase.DirectPExecute("UPDATE account SET viplevel = '%u' WHERE id = '%u'", vip, target->GetSession()->GetAccountId());
+		target->vipLevel = vip;
+
+		ChatHandler(target->GetSession()).PSendSysMessage("%sè·å¾VIPç­çº§%u", sCF->GetNameLink(target).c_str(), vip);
+		if (handler->GetSession()->GetPlayer()->GetGUID() != target->GetGUID())
+			ChatHandler(handler->GetSession()).PSendSysMessage("%sè·å¾VIPç­çº§%u", sCF->GetNameLink(target).c_str(), vip);
+
+
+		std::string title = "";
+		std::string icon = "";
+
+		sVIP->GetVIPTitle(target, title, icon);
+		target->CastSpell(target, 61456, true, NULL, NULL, target->GetGUID());
+
+        
+		const char*  msg = sString->Format(sString->GetText(CORE_STR_TYPES(STR_VIP_UP)), sCF->GetNameLink(target).c_str(), title.c_str());
+		sWorld->SendScreenMessage(msg);
+
+		return true;
+	}
+
+	static bool HandleSetSkillCommand(ChatHandler* handler, const char* args)
+	{
+		if (!*args)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("è¯­æ³æ ¼å¼:._set skill ä¸ä¸ä¸­ææ¼é³ç¼©å æ°å¼ï¼å¦._set skill cy 450");
+			return false;
+		}	
+
+		Player* target = handler->getSelectedPlayer();
+		if (!target)
+		{
+			handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+			handler->SetSentErrorMessage(true);
+			return false;
+		}
+
+		char* skillName = strtok((char*)args, " ");
+		char* value = strtok(NULL, " ");
+		if (!skillName || !value)
+		{
+			ChatHandler(handler->GetSession()).PSendSysMessage("è¯­æ³æ ¼å¼:._set skill ä¸ä¸ä¸­ææ¼é³ç¼©å æ°å¼ï¼å¦._set skill cy 450");
+			return false;
+		}
+			
+		uint32 skillid = 0;
+
+		if (strcmp(skillName, "cy") == 0)		skillid = 182;
+		else if (strcmp(skillName, "ck") == 0)	skillid = 186;
+		else if (strcmp(skillName, "bp") == 0)	skillid = 393;
+		else if (strcmp(skillName, "dz") == 0)	skillid = 164;
+		else if (strcmp(skillName, "cf") == 0)	skillid = 197;
+		else if (strcmp(skillName, "zp") == 0)	skillid = 165;
+		else if (strcmp(skillName, "gc") == 0)	skillid = 202;
+		else if (strcmp(skillName, "lj") == 0)	skillid = 171;
+		else if (strcmp(skillName, "mw") == 0)	skillid = 773;
+		else if (strcmp(skillName, "fm") == 0)	skillid = 333;
+		else if (strcmp(skillName, "zb") == 0)	skillid = 129;
+		else if (strcmp(skillName, "jj") == 0)	skillid = 333;
+		else if (strcmp(skillName, "pr") == 0)	skillid = 185;
+		else if (strcmp(skillName, "dy") == 0)	skillid = 356;
+
+		int32 point = atoi(value);
+
+		if (skillid == 0 || point <= 0)
+			return false;
+
+		if (target->HasSkill(skillid) && target->GetSkillValue(skillid) < point)
+			target->SetSkill(skillid, 1, point, point);
+
+		return true;
+	}
+
+	//._add id r count z_offset scale ori temp
+
+	static bool HandleAddGameObjectCommand(ChatHandler* handler, const char* args)
+	{
+		uint32 objectId = atol(strtok((char*)args, " "));
+		uint32 count = atol(strtok(NULL, " "));
+		float r = (float)atof(strtok(NULL, " "));
+		float z_offset = (float)atof(strtok(NULL, " "));
+		float o = (float)atof(strtok(NULL, " "));
+		uint32 temp = atol(strtok(NULL, " "));
+
+		Player* player = handler->GetSession()->GetPlayer();
+
+		for (size_t i = 0; i < count; i++)
+		{
+			float x = player->GetPositionX() + (i * r)  * cos(player->GetOrientation());
+			float y = player->GetPositionY() + (i * r)  * sin(player->GetOrientation());
+			float z = player->GetPositionZ() + z_offset;
+
+			if (temp == 0)
+			{
+				player->SummonGameObject(objectId, x, y, z, o, 0, 0, 0, 0, 30);
+				handler->PSendSysMessage("åå»ºä¸´æ¶GAMEOBJECT");
+				continue;
+			}
+				
+			Map* map = player->GetMap();
+			GameObject* object = sObjectMgr->IsGameObjectStaticTransport(objectId) ? new StaticTransport() : new GameObject();
+			uint32 guidLow = sObjectMgr->GenerateLowGuid(HIGHGUID_GAMEOBJECT);
+
+			if (!object->Create(guidLow, objectId, map, player->GetPhaseMaskForSpawn(), x, y, z, o, G3D::Quat(), 0, GO_STATE_READY))
+			{
+				delete object;
+				return false;
+			}
+
+			object->SaveToDB(map->GetId(), (1 << map->GetSpawnMode()), player->GetPhaseMaskForSpawn());
+			delete object;
+
+			object = sObjectMgr->IsGameObjectStaticTransport(objectId) ? new StaticTransport() : new GameObject();
+			if (!object->LoadGameObjectFromDB(guidLow, map))
+			{
+				delete object;
+				return false;
+			}
+			sObjectMgr->AddGameobjectToGrid(guidLow, sObjectMgr->GetGOData(guidLow));
+			handler->PSendSysMessage("æ·»å GAMEOBJECTè³æ°æ®åº");
+		}
+
+		return true;
+	}
+};
+
+void AddSC_custom_commandscript()
+{
+	new custom_commandscript();
+}
diff --git a/src/server/scripts/Custom/Command/CustomCommand.h b/src/server/scripts/Custom/Command/CustomCommand.h
new file mode 100644
index 0000000..58f48a5
--- /dev/null
+++ b/src/server/scripts/Custom/Command/CustomCommand.h
@@ -0,0 +1,24 @@
+struct CommandTemplate
+{
+	uint32 ID;
+	std::string command;
+};
+
+extern std::vector<CommandTemplate> CommandVec;
+
+class CustomCommand
+{
+public:
+	static CustomCommand* instance()
+	{
+		static CustomCommand instance;
+		return &instance;
+	}
+
+	void Load();
+	void DoCommandByID(Player* player, uint32 ID);
+	void DoCommand(Player* player, std::string command);
+private:
+
+};
+#define sCustomCommand CustomCommand::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/CommonFunc/CommonFunc.cpp b/src/server/scripts/Custom/CommonFunc/CommonFunc.cpp
new file mode 100644
index 0000000..a47eb0a
--- /dev/null
+++ b/src/server/scripts/Custom/CommonFunc/CommonFunc.cpp
@@ -0,0 +1,1548 @@
+#pragma execution_character_set("utf-8")
+#include "CommonFunc.h"
+#include "../PrecompiledHeaders/ScriptPCH.h"
+#include "BattlegroundMgr.h"
+#include "AchievementMgr.h"
+#include "AccountMgr.h"
+#include "Group.h"
+#include "../Requirement/Requirement.h"
+#include "../Reward/Reward.h"
+#include "../DataLoader/DataLoader.h"
+#include "../SellReward/SellReward.h"
+#include "../ItemMod/ItemMod.h"
+#include "../VIP/VIP.h"
+#include "../HonorRank/HonorRank.h"
+#include "../Switch/Switch.h"
+#include "../GCAddon/GCAddon.h"
+#include "../ItemSet/ItemSet.h"
+#include "../CustomEvent/Event.h"
+#include "../Recovery/Recovery.h"
+#include "../AntiCheat/AntiCheat.h"
+#include "../String/myString.h"
+#include "../TalentReq/TalentReq.h"
+#include <fstream>
+
+bool CommonFunc::IsInclude(uint32 mask, uint32 totalMask)
+{
+	return (totalMask & mask) == mask;
+}
+
+bool CampAttackStartFlag = false;
+
+void CommonFunc::StartCamAttack()
+{
+	CampAttackStartFlag = true;
+}
+
+uint32 CommonFunc::GetExtraTalentPoints(Player* player)
+{
+	QueryResult resultExtraTPs;
+
+	if (sSwitch->GetOnOff(ST_TP_ACCOUNT_BIND))
+		resultExtraTPs = LoginDatabase.PQuery("SELECT extraTalentPoints FROM account WHERE id = '%u'", player->GetSession()->GetAccountId());
+	else 
+		resultExtraTPs = CharacterDatabase.PQuery("SELECT extraTalentPoints FROM characters WHERE guid = '%u'", player->GetGUIDLow());
+
+	if (!resultExtraTPs) 
+		return 0;
+	else
+	{
+		Field* fields = resultExtraTPs->Fetch();
+		return fields[0].GetInt32();
+	}
+}
+
+uint32 CommonFunc::GetTokenAmount(Player* player)
+{
+	QueryResult result = LoginDatabase.PQuery("SELECT tokenAmount FROM account WHERE id = '%u'", player->GetSession()->GetAccountId());
+	if (!result) return 0;
+	else
+	{
+		Field* fields1 = result->Fetch();
+		return fields1[0].GetInt32();
+	}
+}
+
+uint32 CommonFunc::GetTotalTokenAmount(Player* player)
+{
+	QueryResult result = LoginDatabase.PQuery("SELECT totalTokenAmount FROM account WHERE id = '%u'", player->GetSession()->GetAccountId());
+	if (!result) return 0;
+	else
+	{
+		Field* fields1 = result->Fetch();
+		return fields1[0].GetInt32();
+	}
+}
+
+void CommonFunc::UpdateTokenAmount(Player* player, uint32 amount, bool ins, std::string action)
+{
+	if (ins)
+		LoginDatabase.DirectPExecute("UPDATE account SET tokenAmount = tokenAmount + '%u' WHERE id = '%u'", amount, player->GetSession()->GetAccountId());
+	else
+		LoginDatabase.DirectPExecute("UPDATE account SET tokenAmount = tokenAmount - '%u' WHERE id = '%u'", amount, player->GetSession()->GetAccountId());
+
+	sGCAddon->SendTokenUpdateData(player, amount, ins);
+
+	//»ý·Ö¼àÊÓ
+	SQLTransaction trans = CharacterDatabase.BeginTransaction();
+	PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_TOKEN);
+	stmt->setString(0, sAntiCheat->GetTimeString());
+	stmt->setString(1, player->GetName());
+	stmt->setUInt32(2, player->GetGUIDLow());
+	stmt->setUInt32(3, player->GetSession()->GetAccountId());
+	stmt->setString(4, action);
+	if (ins)
+		stmt->setInt32(5, amount);
+	else
+		stmt->setInt32(5, -amount);
+	trans->Append(stmt);
+	CharacterDatabase.CommitTransaction(trans);
+}
+
+void CommonFunc::SetOnlineRewardedCount(Player* player, uint32 count)
+{
+	player->onlineRewardedCount = count;
+	CharacterDatabase.DirectPExecute("UPDATE characters SET onlineRewardedCount = '%u' WHERE guid = '%u'", count, player->GetGUIDLow());
+}
+
+//µ¯´°
+void CommonFunc::SendAcceptOrCancel(Player* player, uint32 id, std::string text, bool quest)
+{
+	if (quest)
+	{
+		WorldPacket data(SMSG_QUEST_CONFIRM_ACCEPT, (4 + text.size() + 8));
+		data << uint32(id);
+		data << text;
+		data << uint64(player->GetGUID());
+		player->GetSession()->SendPacket(&data);
+		return;
+	}
+	
+	WorldPacket data(SMSG_GOSSIP_MESSAGE, 100);
+	data << uint64(player->GetGUID());
+	data << uint32(id);
+	data << uint32(1);
+	data << uint32(1);
+	data << uint32(1);
+	data << uint8(1);
+	data << uint8(0);
+	data << uint32(0);
+	data << "";
+	data << text;
+	player->GetSession()->SendPacket(&data);
+}
+
+//µ¯´°ÊÂ¼þ´¦Àí
+bool CommonFunc::DoAciotnAfterAccept(Player* player, uint32 id, bool quest)
+{
+	if (quest)
+	{
+		switch (id)
+		{
+		case 1000000://buy item 
+			if (sReq->Check(player, player->buy_reqId, player->buy_count))
+			{
+				if (player->AddItem(player->buy_item, player->buy_count))
+					sReq->Des(player, player->buy_reqId, player->buy_count);
+				else
+					player->GetSession()->SendNotification("¹ºÂòÊ§°Ü£¬±³°üÒÑÂú»òÎïÆ·Î¨Ò»");
+
+				player->buy_item = 0;
+				player->buy_count = 0;
+				player->buy_reqId = 0;
+			}
+			return true;
+		default:
+			return false;
+		}
+		return false;
+	}
+
+	switch (id)
+	{
+	case 994://½øÈëµØÍ¼
+		if (sReq->Check(player, player->enter_map_req))
+		{
+			sReq->Des(player, player->enter_map_req);
+			player->TeleportTo(player->enter_map_at->target_mapId, player->enter_map_at->target_X, player->enter_map_at->target_Y, player->enter_map_at->target_Z, player->enter_map_at->target_Orientation, TELE_TO_NOT_LEAVE_TRANSPORT);
+		}
+		return true;
+	case 995://Ìì¸³ÏûºÄ
+		sTalentReq->DoAction(player);
+		return true;
+	case 996://buy item 
+		if (sReq->Check(player, player->buy_reqId,player->buy_count))
+		{
+			if (player->AddItem(player->buy_item, player->buy_count))
+				sReq->Des(player, player->buy_reqId, player->buy_count);
+			else
+				player->GetSession()->SendNotification("±³°üÒÑÂú");
+
+			player->buy_item  = 0;
+			player->buy_count = 0;
+			player->buy_reqId = 0;
+		}
+		return true;
+	case 997://¹ºÂò×øÆï
+		if (sReq->Check(player, player->mountReqId))
+		{
+			sReq->Des(player, player->mountReqId);
+			player->learnSpell(player->mountSpellId);
+			player->mountSpellId = 0;
+			player->mountReqId = 0;
+		}
+		return true;
+	case 999://¹ºÂò»Ã»¯
+		if (sReq->Check(player, player->trans_reqId))
+		{
+			if (Item* item = player->AddItemById(player->trans_item, 1))
+			{
+				sReq->Des(player, player->trans_reqId);
+				//Ìí¼Ó»Ã»¯±ê¼Ç
+				//player->ApplyEnchantment(item, EnchantmentSlot(PERM_ENCHANTMENT_SLOT), false);
+				//item->SetEnchantment(EnchantmentSlot(PERM_ENCHANTMENT_SLOT), TRANS_FLAG_ENCHANT_ID, 0, 0);
+				//player->ApplyEnchantment(item, EnchantmentSlot(PERM_ENCHANTMENT_SLOT), true);
+			}
+			else
+			{
+				player->GetSession()->SendNotification("±³°üÒÑÂú");
+			}
+			player->trans_reqId = 0;
+			player->trans_item = 0;
+		}
+		return true;
+	default:
+		return false;
+	}
+	return false;
+}
+
+//²¥·ÅÉùÒô
+
+void CommonFunc::PlayCustomSound(Player* player, uint32 soundId)
+{
+	if (!sSoundEntriesStore.LookupEntry(soundId)) return;
+	WorldPacket data(SMSG_PLAY_SOUND, 4);
+	data << uint32(soundId);
+	sWorld->SendGlobalMessage(&data);
+}
+
+void CommonFunc::CompleteQuest(Player* player, uint32 questId)
+{
+	Quest const* quest = sObjectMgr->GetQuestTemplate(questId);
+	if (quest && player->GetQuestStatus(questId) == QUEST_STATUS_INCOMPLETE)
+		player->CompleteQuest(questId);
+}
+
+//»ñÈ¡ÎïÆ·Í¼±ê¡¢Ãû×Ö¼°Á´½Ó
+std::string CommonFunc::GetItemIcon(uint32 entry, uint32 width, uint32 height, int x, int y)
+{
+	std::ostringstream ss;
+	ss << "|TInterface";
+	const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+	const ItemDisplayInfoEntry* dispInfo = NULL;
+	if (temp)
+	{
+		dispInfo = sItemDisplayInfoStore.LookupEntry(temp->DisplayInfoID);
+		if (dispInfo)
+			ss << "/ICONS/" << dispInfo->inventoryIcon;
+	}
+	if (!dispInfo)
+		ss << "/InventoryItems/WoWUnknownItem01";
+	ss << ":" << width << ":" << height << ":" << x << ":" << y << "|t";
+	return ss.str();
+}
+
+std::string CommonFunc::GetItemLink(Item* item, WorldSession* session)
+{
+
+
+	int loc_idx = session->GetSessionDbLocaleIndex();
+	const ItemTemplate* temp = item->GetTemplate();
+	std::string name = temp->Name1;
+
+	if (int32 itemRandPropId = item->GetItemRandomPropertyId())
+	{
+		char* const* suffix = NULL;
+		if (itemRandPropId < 0)
+		{
+			const ItemRandomSuffixEntry* itemRandEntry = sItemRandomSuffixStore.LookupEntry(-item->GetItemRandomPropertyId());
+			if (itemRandEntry)
+				suffix = itemRandEntry->nameSuffix;
+		}
+		else
+		{
+			const ItemRandomPropertiesEntry* itemRandEntry = sItemRandomPropertiesStore.LookupEntry(item->GetItemRandomPropertyId());
+			if (itemRandEntry)
+				suffix = itemRandEntry->nameSuffix;
+		}
+		if (suffix)
+		{
+			std::string test(suffix[(name != temp->Name1) ? loc_idx : DEFAULT_LOCALE]);
+			if (!test.empty())
+			{
+				name += ' ';
+				name += test;
+			}
+		}
+	}
+
+	std::ostringstream oss;
+	oss << "|c" << std::hex << ItemQualityColors[temp->Quality] << std::dec <<
+		"|Hitem:" << temp->ItemId << ":" <<
+		item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ":" <<
+		item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT) << ":" <<
+		item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_2) << ":" <<
+		item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_3) << ":" <<
+		item->GetEnchantmentId(BONUS_ENCHANTMENT_SLOT) << ":" <<
+		item->GetItemRandomPropertyId() << ":" << item->GetItemSuffixFactor() << ":" <<
+		(uint32)item->GetOwner()->getLevel() << "|h[" << name << "]|h|r";
+
+	return oss.str();
+}
+
+std::string CommonFunc::GetItemLink(uint32 entry)
+{
+	const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+	if (!temp) return "";
+
+	std::string name = temp->Name1;
+
+	std::ostringstream oss;
+	oss << "|c" << std::hex << ItemQualityColors[temp->Quality] << std::dec <<
+		"|Hitem:" << entry << ":0:0:0:0:0:0:0:0:0|h[" << name << "]|h|r";
+
+	return oss.str();
+
+}
+
+//»ñÈ¡³É¾Íµã
+uint32 CommonFunc::GetAchievementPoints(Player* player)
+{
+	CompletedAchievementMap cam = player->getAchievementMgr()->get_m_completedAchievements();
+	uint32 points = 0;
+	for (CompletedAchievementMap::const_iterator itr = cam.begin(); itr != cam.end(); ++itr)
+		if (AchievementEntry const* completedAchievements = sAchievementStore.LookupEntry(itr->first))
+			points += completedAchievements->points;
+	return points;
+}
+
+//¶ÓÎé½±Àø
+void CommonFunc::GroupReward(Player* player, uint32 rewardTemplateId, uint32 chance)
+{
+	Group* grp = player->GetGroup();
+	if (!grp)
+	{
+		if (urand(1, 100) <= chance) sRew->Rew(player, rewardTemplateId);
+		return;
+	}
+	for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
+		if (Player* member = itr->GetSource())
+		{
+			if (member->GetDistance(player) > 75.0f) continue;
+			if (urand(1, 100) <= chance) sRew->Rew(member, rewardTemplateId);
+		}
+}
+
+//additem °ü°üÂúÊ±sendmail
+void CommonFunc::AddOrMailItem(Player* player, uint32 itemId, uint32 count)
+{
+
+}
+
+void CommonFunc::SetSpeed(Player* player, float multi)
+{
+	player->SetSpeed(MOVE_WALK, multi, true);
+	player->SetSpeed(MOVE_RUN, multi, true);
+	player->SetSpeed(MOVE_SWIM, multi, true);
+	player->SetSpeed(MOVE_FLIGHT, multi, true);
+}
+
+void CommonFunc::SendMsGToAll(std::string str, uint32 type)
+{
+	SessionMap const& smap = sWorld->GetAllSessions();//»ñÈ¡ËùÓÐÔÚÏßÍæ¼Ò
+	for (SessionMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+		if (Player* player = iter->second->GetPlayer())
+		{
+			if (player->GetSession())
+			{
+				switch (type)
+				{
+				case 0:
+					player->GetSession()->SendAreaTriggerMessage(str.c_str());
+					break;
+				case 1:
+					player->GetSession()->SendNotification(str.c_str());
+					break;
+				default:
+					break;
+				}
+			}
+		}
+}
+
+void CommonFunc::GetRace(Player* player, std::string &race, std::string &raceIcon, bool fakeplayer, uint8 fakerace,uint8 gender)
+{
+	uint8 player_race = fakeplayer ? fakerace : player->getRace();
+	uint8 player_gender = fakeplayer ? gender : player->getGender();
+
+
+	switch (player_race)
+	{
+	case RACE_BLOODELF:
+		race = "|cFFFF1717[Ñª¾«Áé]|r";
+		if (player_race == GENDER_MALE)
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Bloodelf_Male:14:14:0:-2|t";
+		else
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Bloodelf_Female:14:14:0:-2|t";
+		break;
+	case RACE_DRAENEI:
+		race = "|cFF0177EC[µÂÀ³Äá]|r";
+		if (player_race == GENDER_FEMALE)
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Draenei_Female:14:14:0:-2|t";
+		else
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Draenei_Male:14:14:0:-2|t";
+		break;
+	case RACE_DWARF:
+		race = "|cFF0177EC[°«ÈË]|r";
+		if (player_race == GENDER_FEMALE)
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Dwarf_Female:14:14:0:-2|t";
+		else
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Dwarf_Male:14:14:0:-2|t";
+		break;
+	case RACE_GNOME:
+		race = "|cFF0177EC[ÙªÈå]|r";
+		if (player_race == GENDER_FEMALE)
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Gnome_Female:14:14:0:-2|t";
+		else
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Gnome_Male:14:14:0:-2|t";
+		break;
+	case RACE_HUMAN:
+		race = "|cFF0177EC[ÈËÀà]|r";
+		if (player_race == GENDER_FEMALE)
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Human_Female:14:14:0:-2|t";
+		else
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Human_Male:14:14:0:-2|t";
+		break;
+	case RACE_NIGHTELF:
+		race = "|cFF0177EC[°µÒ¹¾«Áé]|r";
+		if (player_race == GENDER_FEMALE)
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Nightelf_Female:14:14:0:-2|t";
+		else
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Nightelf_Male:14:14:0:-2|t";
+		break;
+	case RACE_ORC:
+		race = "|cFFFF1717[ÊÞÈË]|r";
+		if (player_race == GENDER_FEMALE)
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Orc_Female:14:14:0:-2|t";
+		else
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Orc_Male:14:14:0:-2|t";
+		break;
+	case RACE_TAUREN:
+		race = "|cFFFF1717[Å£Í·ÈË]|r";
+		if (player_race == GENDER_FEMALE)
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Tauren_Female:14:14:0:-2|t";
+		else
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Tauren_Male:14:14:0:-2|t";
+		break;
+	case RACE_TROLL:
+		race = "|cFFFF1717[¾ÞÄ§]|r";
+		if (player_race == GENDER_FEMALE)
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Troll_Female:14:14:0:-2|t";
+		else
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Troll_Male:14:14:0:-2|t";
+		break;
+	case RACE_UNDEAD_PLAYER:
+		race = "|cFFFF1717[ÍöÁé]|r";
+		if (player_race == GENDER_FEMALE)
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Undead_Female:14:14:0:-2|t";
+		else
+			raceIcon = "|TInterface/ICONS/Achievement_Character_Undead_Male:14:14:0:-2|t";
+		break;
+	}
+}
+
+void CommonFunc::GetClass(Player* player, std::string &_class, std::string &classIcon, bool fakeplayer, uint8 fakeclass)
+{
+	uint8 player_class = fakeplayer ? fakeclass : player->getClass();
+
+	switch (player_class)
+	{
+	case CLASS_DEATH_KNIGHT:
+		_class = "|cffC41F3B[ËÀÍöÆïÊ¿]|r";
+		classIcon = "|TInterface\\icons\\Spell_Deathknight_ClassIcon:14:14:0:-2|t";
+		break;
+	case CLASS_DRUID:
+		_class = "|cffFF7D0A[µÂÂ³ÒÁ]|r";
+		classIcon = "|TInterface\\icons\\Ability_Druid_Maul:14:14:0:-2|t";
+		break;
+	case CLASS_HUNTER:
+		_class = "|cffABD473[ÁÔÈË]|r";
+		classIcon = "|TInterface\\icons\\INV_Weapon_Bow_07:14:14:0:-2|t";
+		break;
+	case CLASS_MAGE:
+		_class = "|cff69CCF0[·¨Ê¦]|r";
+		classIcon = "|TInterface\\icons\\INV_Staff_13:14:14:0:-2|t";
+		break;
+	case CLASS_PALADIN:
+		_class = "|cffF58CBA[Ê¥ÆïÊ¿]|r";
+		classIcon = "|TInterface\\icons\\INV_Hammer_01:14:14:0:-2|t";
+		break;
+	case CLASS_PRIEST:
+		_class = "|cffFFFFFF[ÄÁÊ¦]|r";
+		classIcon = "|TInterface\\icons\\INV_Staff_30:14:14:0:-2|t";
+		break;
+	case CLASS_ROGUE:
+		_class = "|cffFFF569[µÁÔô]|r";
+		classIcon = "|TInterface\\icons\\INV_ThrowingKnife_04:14:14:0:-2|t";
+		break;
+	case CLASS_SHAMAN:
+		_class = "|cff0070DE[ÈøÂú¼ÀË¾]|r";
+		classIcon = "|TInterface\\icons\\Spell_Nature_BloodLust:14:14:0:-2|t";
+		break;
+	case CLASS_WARLOCK:
+		_class = "|cff9482C9[ÊõÊ¿]|r";
+		classIcon = "|TInterface\\icons\\Spell_Nature_FaerieFire:14:14:0:-2|t";
+		break;
+	case CLASS_WARRIOR:
+		_class = "|cffC79C6E[Õ½Ê¿]|r";
+		classIcon = "|TInterface\\icons\\INV_Sword_27.png:14:14:0:-2|t";
+		break;
+	}
+}
+
+std::string CommonFunc::GetNameLink(Player* player)
+{
+	std::string name = player->GetName();
+	return "|Hplayer:" + name + "|h[" + name + "]|h";
+}
+
+void CommonFunc::GetNameLink(Player* player, std::string &nameLink, std::string &nameLinkWithColor, bool fakeplayer, uint8 fakeclass, std::string fakename)
+{
+	std::string color = "";
+
+	uint8 player_class = fakeplayer ? fakeclass : player->getClass();
+
+	switch (player_class)
+	{
+	case CLASS_WARRIOR:
+		color = "|cFFC79C6E";
+		break;
+	case CLASS_PALADIN:
+		color = "|cFFF58CBA";
+		break;
+	case CLASS_HUNTER:
+		color = "|cFFABD473";
+		break;
+	case CLASS_ROGUE:
+		color = "|cFFFFF569";
+		break;
+	case CLASS_PRIEST:
+		color = "|cFFFFFFFF";
+		break;
+	case CLASS_DEATH_KNIGHT:
+		color = "|cFFC41F3B";
+		break;
+	case CLASS_SHAMAN:
+		color = "|cFF0070DE";
+		break;
+	case CLASS_MAGE:
+		color = "|cFF69CCF0";
+		break;
+	case CLASS_WARLOCK:
+		color = "|cFF9482C9";
+		break;
+	case CLASS_DRUID:
+		color = "|cFFFF7d0A";
+		break;
+	default:
+		break;
+	}
+	std::string name = fakeplayer ? fakename : player->namePrefix + player->GetName() + player->nameSuffix;
+
+	nameLink = "|Hplayer:" + name + "|h[" + name + "]|h";
+
+	nameLinkWithColor = color + "|Hplayer:" + name + "|h[" + name + "]|h|r";
+}
+
+void CommonFunc::GetHRTitle(Player* player, std::string &hrTitle, std::string &hrIcon, bool fakeplayer, uint8 fakehr)
+{
+	if (fakeplayer)
+	{
+		switch (fakehr)
+		{
+		case 28:hrIcon = "|TInterface/ICONS/Achievement_PVP_H_14:14:14:0:-2|t"; hrTitle = "|cFFFF1717[¸ß½×¶½¾ü]|r"; break;
+		case 27:hrIcon = "|TInterface/ICONS/Achievement_PVP_H_13:14:14:0:-2|t"; hrTitle = "|cFFFF1717[¶½¾ü]|r"; break;
+		case 26:hrIcon = "|TInterface/ICONS/Achievement_PVP_H_12:14:14:0:-2|t"; hrTitle = "|cFFFF1717[½«¾ü]|r"; break;
+		case 25:hrIcon = "|TInterface/ICONS/Achievement_PVP_H_11:14:14:0:-2|t"; hrTitle = "|cFFFF1717[ÖÐ½«]|r"; break;
+		case 24:hrIcon = "|TInterface/ICONS/Achievement_PVP_H_10:14:14:0:-2|t"; hrTitle = "|cFFFF1717[ÓÂÊ¿]|r"; break;
+		case 23:hrIcon = "|TInterface/ICONS/Achievement_PVP_H_09:14:14:0:-2|t"; hrTitle = "|cFFFF1717[°Ù·ò³¤]|r"; break;
+		case 22:hrIcon = "|TInterface/ICONS/Achievement_PVP_H_08:14:14:0:-2|t"; hrTitle = "|cFFFF1717[¾üÍÅÊ¿±ø]|r"; break;
+		case 21:hrIcon = "|TInterface/ICONS/Achievement_PVP_H_07:14:14:0:-2|t"; hrTitle = "|cFFFF1717[ÑªÎÀÊ¿]|r"; break;
+		case 20:hrIcon = "|TInterface/ICONS/Achievement_PVP_H_06:14:14:0:-2|t"; hrTitle = "|cFFFF1717[Ê¯Í·ÊØÎÀ]|r"; break;
+		case 19:hrIcon = "|TInterface/ICONS/Achievement_PVP_H_05:14:14:0:-2|t"; hrTitle = "|cFFFF1717[Ò»µÈ¾üÊ¿³¤]|r"; break;
+		case 18:hrIcon = "|TInterface/ICONS/Achievement_PVP_H_04:14:14:0:-2|t"; hrTitle = "|cFFFF1717[¸ß½×¾üÊ¿]|r"; break;
+		case 17:hrIcon = "|TInterface/ICONS/Achievement_PVP_H_03:14:14:0:-2|t"; hrTitle = "|cFFFF1717[ÖÐÊ¿]|r"; break;
+		case 16:hrIcon = "|TInterface/ICONS/Achievement_PVP_H_02:14:14:0:-2|t"; hrTitle = "|cFFFF1717[²½±ø]|r"; break;
+		case 15:hrIcon = "|TInterface/ICONS/Achievement_PVP_H_01:14:14:0:-2|t"; hrTitle = "|cFFFF1717[³âºò]|r"; break;
+		case 14:hrIcon = "|TInterface/ICONS/Achievement_PVP_A_14:14:14:0:-2|t"; hrTitle = "|cFF0177EC[´óÔªË§]|r"; break;
+		case 13:hrIcon = "|TInterface/ICONS/Achievement_PVP_A_13:14:14:0:-2|t"; hrTitle = "|cFF0177EC[ÔªË§]|r"; break;
+		case 12:hrIcon = "|TInterface/ICONS/Achievement_PVP_A_12:14:14:0:-2|t"; hrTitle = "|cFF0177EC[Í³Ë§]|r"; break;
+		case 11:hrIcon = "|TInterface/ICONS/Achievement_PVP_A_11:14:14:0:-2|t"; hrTitle = "|cFF0177EC[Ë¾Áî]|r"; break;
+		case 10:hrIcon = "|TInterface/ICONS/Achievement_PVP_A_10:14:14:0:-2|t"; hrTitle = "|cFF0177EC[ÉÙÐ£]|r"; break;
+		case 9:hrIcon = "|TInterface/ICONS/Achievement_PVP_A_09:14:14:0:-2|t"; hrTitle = "|cFF0177EC[»¤ÎÀÆïÊ¿]|r"; break;
+		case 8:hrIcon = "|TInterface/ICONS/Achievement_PVP_A_08:14:14:0:-2|t"; hrTitle = "|cFF0177EC[ÆïÊ¿¶Ó³¤]|r"; break;
+		case 7:hrIcon = "|TInterface/ICONS/Achievement_PVP_A_07:14:14:0:-2|t"; hrTitle = "|cFF0177EC[ÆïÊ¿ÖÐÎ¾]|r"; break;
+		case 6:hrIcon = "|TInterface/ICONS/Achievement_PVP_A_06:14:14:0:-2|t"; hrTitle = "|cFF0177EC[ÆïÊ¿]|r"; break;
+		case 5:hrIcon = "|TInterface/ICONS/Achievement_PVP_A_05:14:14:0:-2|t"; hrTitle = "|cFF0177EC[Ê¿¹Ù³¤]|r"; break;
+		case 4:hrIcon = "|TInterface/ICONS/Achievement_PVP_A_04:14:14:0:-2|t"; hrTitle = "|cFF0177EC[¾üÊ¿³¤]|r"; break;
+		case 3:hrIcon = "|TInterface/ICONS/Achievement_PVP_A_03:14:14:0:-2|t"; hrTitle = "|cFF0177EC[ÖÐÊ¿]|r"; break;
+		case 2:hrIcon = "|TInterface/ICONS/Achievement_PVP_A_02:14:14:0:-2|t"; hrTitle = "|cFF0177EC[ÏÂÊ¿]|r"; break;
+		case 1:hrIcon = "|TInterface/ICONS/Achievement_PVP_A_01:14:14:0:-2|t"; hrTitle = "|cFF0177EC[ÁÐ±ø]|r"; break;
+		}
+
+		return;
+	}
+
+	if (player->GetTeamId() == TEAM_ALLIANCE)
+	{
+		if (player->HasTitle(14))		{ hrIcon = "|TInterface/ICONS/Achievement_PVP_A_14:14:14:0:-2|t"; hrTitle = "|cFF0177EC[´óÔªË§]|r";		}
+		else if (player->HasTitle(13))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_A_13:14:14:0:-2|t"; hrTitle = "|cFF0177EC[ÔªË§]|r";		}
+		else if (player->HasTitle(12))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_A_12:14:14:0:-2|t"; hrTitle = "|cFF0177EC[Í³Ë§]|r";		}
+		else if (player->HasTitle(11))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_A_11:14:14:0:-2|t"; hrTitle = "|cFF0177EC[Ë¾Áî]|r";		}
+		else if (player->HasTitle(10))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_A_10:14:14:0:-2|t"; hrTitle = "|cFF0177EC[ÉÙÐ£]|r";		}
+		else if (player->HasTitle(9))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_A_09:14:14:0:-2|t"; hrTitle = "|cFF0177EC[»¤ÎÀÆïÊ¿]|r";	}
+		else if (player->HasTitle(8))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_A_08:14:14:0:-2|t"; hrTitle = "|cFF0177EC[ÆïÊ¿¶Ó³¤]|r";	}
+		else if (player->HasTitle(7))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_A_07:14:14:0:-2|t"; hrTitle = "|cFF0177EC[ÆïÊ¿ÖÐÎ¾]|r";	}
+		else if (player->HasTitle(6))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_A_06:14:14:0:-2|t"; hrTitle = "|cFF0177EC[ÆïÊ¿]|r";		}
+		else if (player->HasTitle(5))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_A_05:14:14:0:-2|t"; hrTitle = "|cFF0177EC[Ê¿¹Ù³¤]|r";		}
+		else if (player->HasTitle(4))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_A_04:14:14:0:-2|t"; hrTitle = "|cFF0177EC[¾üÊ¿³¤]|r";		}
+		else if (player->HasTitle(3))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_A_03:14:14:0:-2|t"; hrTitle = "|cFF0177EC[ÖÐÊ¿]|r";		}
+		else if (player->HasTitle(2))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_A_02:14:14:0:-2|t"; hrTitle = "|cFF0177EC[ÏÂÊ¿]|r";		}
+		else							{ hrIcon = "|TInterface/ICONS/Achievement_PVP_A_01:14:14:0:-2|t"; hrTitle = "|cFF0177EC[ÁÐ±ø]|r";		}
+		if (player->IsGameMaster())		{ hrIcon = "|TInterface/ICONS/Achievement_PVP_A_16:14:14:0:-2|t"; hrTitle = "|cFF0177EC[GM]|r";			}
+	}
+	else
+	{
+		if (player->HasTitle(28))		{ hrIcon = "|TInterface/ICONS/Achievement_PVP_H_14:14:14:0:-2|t"; hrTitle = "|cFFFF1717[¸ß½×¶½¾ü]|r";	}
+		else if (player->HasTitle(27))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_H_13:14:14:0:-2|t"; hrTitle = "|cFFFF1717[¶½¾ü]|r";		}
+		else if (player->HasTitle(26))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_H_12:14:14:0:-2|t"; hrTitle = "|cFFFF1717[½«¾ü]|r";		}
+		else if (player->HasTitle(25))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_H_11:14:14:0:-2|t"; hrTitle = "|cFFFF1717[ÖÐ½«]|r";		}
+		else if (player->HasTitle(24))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_H_10:14:14:0:-2|t"; hrTitle = "|cFFFF1717[ÓÂÊ¿]|r";		}
+		else if (player->HasTitle(23))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_H_09:14:14:0:-2|t"; hrTitle = "|cFFFF1717[°Ù·ò³¤]|r";		}
+		else if (player->HasTitle(22))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_H_08:14:14:0:-2|t"; hrTitle = "|cFFFF1717[¾üÍÅÊ¿±ø]|r";	}
+		else if (player->HasTitle(21))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_H_07:14:14:0:-2|t"; hrTitle = "|cFFFF1717[ÑªÎÀÊ¿]|r";		}
+		else if (player->HasTitle(20))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_H_06:14:14:0:-2|t"; hrTitle = "|cFFFF1717[Ê¯Í·ÊØÎÀ]|r";	}
+		else if (player->HasTitle(19))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_H_05:14:14:0:-2|t"; hrTitle = "|cFFFF1717[Ò»µÈ¾üÊ¿³¤]|r";	}
+		else if (player->HasTitle(18))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_H_04:14:14:0:-2|t"; hrTitle = "|cFFFF1717[¸ß½×¾üÊ¿]|r";	}
+		else if (player->HasTitle(17))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_H_03:14:14:0:-2|t"; hrTitle = "|cFFFF1717[ÖÐÊ¿]|r";		}
+		else if (player->HasTitle(16))	{ hrIcon = "|TInterface/ICONS/Achievement_PVP_H_02:14:14:0:-2|t"; hrTitle = "|cFFFF1717[²½±ø]|r";		}
+		else							{ hrIcon = "|TInterface/ICONS/Achievement_PVP_H_01:14:14:0:-2|t"; hrTitle = "|cFFFF1717[³âºò]|r";		}
+		if (player->IsGameMaster())		{ hrIcon = "|TInterface/ICONS/Achievement_PVP_H_16:14:14:0:-2|t"; hrTitle = "|cFFFF1717[GM]|r";			}
+	}
+}
+
+std::string CommonFunc::GetHRTitle(uint32 rank)
+{
+	std::string hrTitle = "";
+	std::string hrTitle1 = "";
+
+	switch (rank)
+	{
+	case 14:hrTitle1 = "|cFFFF1717[¸ß½×¶½¾ü]|r"; break;
+	case 13:hrTitle1 = "|cFFFF1717[¶½¾ü]|r"; break;
+	case 12:hrTitle1 = "|cFFFF1717[½«¾ü]|r"; break;
+	case 11:hrTitle1 = "|cFFFF1717[ÖÐ½«]|r"; break;
+	case 10:hrTitle1 = "|cFFFF1717[ÓÂÊ¿]|r"; break;
+	case 9: hrTitle1 = "|cFFFF1717[°Ù·ò³¤]|r"; break;
+	case 8: hrTitle1 = "|cFFFF1717[¾üÍÅÊ¿±ø]|r"; break;
+	case 7: hrTitle1 = "|cFFFF1717[ÑªÎÀÊ¿]|r"; break;
+	case 6: hrTitle1 = "|cFFFF1717[Ê¯Í·ÊØÎÀ]|r"; break;
+	case 5: hrTitle1 = "|cFFFF1717[Ò»µÈ¾üÊ¿³¤]|r"; break;
+	case 4: hrTitle1 = "|cFFFF1717[¸ß½×¾üÊ¿]|r"; break;
+	case 3: hrTitle1 = "|cFFFF1717[ÖÐÊ¿]|r"; break;
+	case 2: hrTitle1 = "|cFFFF1717[²½±ø]|r"; break;
+	case 1: hrTitle1 = "|cFFFF1717[³âºò]|r"; break;
+	}
+
+	switch (rank)
+	{
+	case 14:hrTitle = "|cFF0177EC[´óÔªË§]|r"; break;
+	case 13:hrTitle = "|cFF0177EC[ÔªË§]|r"; break;
+	case 12:hrTitle = "|cFF0177EC[Í³Ë§]|r"; break;
+	case 11:hrTitle = "|cFF0177EC[Ë¾Áî]|r"; break;
+	case 10:hrTitle = "|cFF0177EC[ÉÙÐ£]|r"; break;
+	case 9: hrTitle = "|cFF0177EC[»¤ÎÀÆïÊ¿]|r"; break;
+	case 8: hrTitle = "|cFF0177EC[ÆïÊ¿¶Ó³¤]|r"; break;
+	case 7: hrTitle = "|cFF0177EC[ÆïÊ¿ÖÐÎ¾]|r"; break;
+	case 6: hrTitle = "|cFF0177EC[ÆïÊ¿]|r"; break;
+	case 5: hrTitle = "|cFF0177EC[Ê¿¹Ù³¤]|r"; break;
+	case 4: hrTitle = "|cFF0177EC[¾üÊ¿³¤]|r"; break;
+	case 3: hrTitle = "|cFF0177EC[ÖÐÊ¿]|r"; break;
+	case 2: hrTitle = "|cFF0177EC[ÏÂÊ¿]|r"; break;
+	case 1: hrTitle = "|cFF0177EC[ÁÐ±ø]|r"; break;
+	}
+
+	return hrTitle + "»ò" + hrTitle1;
+}
+
+void CommonFunc::UpdatePlayerNameWithHR(Player* player)
+{
+	//std::ostringstream oss;
+	//oss << player->GetName();
+	//oss << " ";
+	//oss << GetHRTitle(player);
+	//sWorld->UpdateGlobalNameData(player->GetGUIDLow(), player->GetName(), oss.str());
+	//sWorld->UpdateGlobalPlayerData(player->GetGUIDLow(), PLAYER_UPDATE_DATA_NAME, oss.str());
+	//player->ToggleDND();
+	//player->canUpdateName = true;
+}
+
+uint32 CommonFunc::GetHrTitleId(Player* player)
+{
+	uint32 id;
+	if (player->GetTeamId() == TEAM_ALLIANCE)
+	{
+		if (player->HasTitle(14)) id = 14;
+		else if (player->HasTitle(13)) id = 13;
+		else if (player->HasTitle(12)) id = 12;
+		else if (player->HasTitle(11)) id = 11;
+		else if (player->HasTitle(10)) id = 10;
+		else if (player->HasTitle(9)) id = 9;
+		else if (player->HasTitle(8)) id = 8;
+		else if (player->HasTitle(7)) id = 7;
+		else if (player->HasTitle(6)) id = 6;
+		else if (player->HasTitle(5)) id = 5;
+		else if (player->HasTitle(4)) id = 4;
+		else if (player->HasTitle(3)) id = 3;
+		else if (player->HasTitle(2)) id = 2;
+		else if (player->HasTitle(1)) id = 1;
+		else id = 0;
+	}
+	else
+	{
+		if (player->HasTitle(28)) id = 28;
+		else if (player->HasTitle(27)) id = 27;
+		else if (player->HasTitle(26)) id = 26;
+		else if (player->HasTitle(25)) id = 25;
+		else if (player->HasTitle(24)) id = 24;
+		else if (player->HasTitle(23)) id = 23;
+		else if (player->HasTitle(22)) id = 22;
+		else if (player->HasTitle(21)) id = 21;
+		else if (player->HasTitle(20)) id = 20;
+		else if (player->HasTitle(19)) id = 19;
+		else if (player->HasTitle(18)) id = 18;
+		else if (player->HasTitle(17)) id = 17;
+		else if (player->HasTitle(16)) id = 16;
+		else if (player->HasTitle(15)) id = 15;
+		else id = 0;
+	}
+	return id;
+}
+
+uint32 CommonFunc::GetOnlineIpCount(Player* player)
+{
+	uint32 count = 0;
+	std::string IP = player->GetSession()->GetRemoteAddress();
+
+	SessionMap const& smap = sWorld->GetAllSessions();
+	for (SessionMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+		if (Player* pPlayer = iter->second->GetPlayer())
+		{
+			if (pPlayer->GetSession())
+			{
+				if (strcmp(IP.c_str(), pPlayer->GetSession()->GetRemoteAddress().c_str()) == 0)
+					count++;
+			}
+		}
+
+	return count;
+}
+
+uint32 CommonFunc::GetBgIpCount(Player* player, Battleground* bg)
+{
+	uint32 count = 0;
+	std::string IP = player->GetSession()->GetRemoteAddress();
+
+	Battleground::BattlegroundPlayerMap const& pl = bg->GetPlayers();
+	for (Battleground::BattlegroundPlayerMap::const_iterator itr = pl.begin(); itr != pl.end(); ++itr)
+	{
+		if (itr->second->GetSession())
+		{
+			if (strcmp(IP.c_str(), itr->second->GetSession()->GetRemoteAddress().c_str()) == 0)
+				count++;
+		}
+	}
+	return count;
+}
+
+bool CommonFunc::onlineIsAllowed(Player* player)
+{
+	if (GetOnlineIpCount(player) > uint32(sSwitch->GetValue(ST_ONLINE_PLAYERS)))
+		return false;
+	else
+		return true;
+}
+
+bool CommonFunc::joinBgIsAllowed(Player* player, Battleground* bg)
+{
+	uint32 count = GetBgIpCount(player, bg);
+	uint32 max = sSwitch->GetValue(ST_BG_PLAYERS);
+
+	if (count > max)
+	{
+		std::ostringstream oss;
+		oss << "¼ÓÈëÕ½³¡µÄÍæ¼ÒÊýÁ¿ÒÑ´ïµ½ÉÏÏÞ£¬¼ÓÈëÊ§°Ü£¡" << count << "/" << max;
+		player->GetSession()->SendNotification(oss.str().c_str());
+		return false;
+	}
+		return true;
+}
+
+void CommonFunc::updateHRTitle(Player* player)
+{
+	uint32 playerHrTitleLevel = getPlayerHrTitleLevel(player);
+	uint32 accountHrTitleLevel = getAccountHrTitleLevel(player);
+
+	if (playerHrTitleLevel == accountHrTitleLevel)
+		return;
+
+	if (playerHrTitleLevel < accountHrTitleLevel)
+	{
+		CharTitlesEntry const* titleInfo;
+
+		for (uint32 i = playerHrTitleLevel + 1; i < accountHrTitleLevel + 1; i++)
+		{
+			player->realTeam == TEAM_ALLIANCE ? titleInfo = sCharTitlesStore.LookupEntry(i) : titleInfo = sCharTitlesStore.LookupEntry(i + 14);
+			if (!titleInfo) return;
+			player->SetTitle(titleInfo);
+		}
+	}
+	else
+		LoginDatabase.DirectPExecute("UPDATE account SET hrLevel = '%u' WHERE id = '%u'", playerHrTitleLevel, player->GetSession()->GetAccountId());
+}
+
+uint32 CommonFunc::getPlayerHrTitleLevel(Player* player)
+{
+	if (player->HasTitle(14) || player->HasTitle(28)) return 14;
+	else if (player->HasTitle(13) || player->HasTitle(27)) return 13;
+	else if (player->HasTitle(12) || player->HasTitle(26)) return 12;
+	else if (player->HasTitle(11) || player->HasTitle(25)) return 11;
+	else if (player->HasTitle(10) || player->HasTitle(24)) return 10;
+	else if (player->HasTitle(9) || player->HasTitle(23)) return 9;
+	else if (player->HasTitle(8) || player->HasTitle(22)) return 8;
+	else if (player->HasTitle(7) || player->HasTitle(21)) return 7;
+	else if (player->HasTitle(6) || player->HasTitle(20)) return 6;
+	else if (player->HasTitle(5) || player->HasTitle(19)) return 5;
+	else if (player->HasTitle(4) || player->HasTitle(18)) return 4;
+	else if (player->HasTitle(3) || player->HasTitle(17)) return 3;
+	else if (player->HasTitle(2) || player->HasTitle(16)) return 2;
+	else if (player->HasTitle(1) || player->HasTitle(15)) return 1;
+	else return 0;
+}
+
+uint32 CommonFunc::getAccountHrTitleLevel(Player* player)
+{
+	QueryResult result = LoginDatabase.PQuery("SELECT hrLevel FROM account WHERE id = '%u'", player->GetSession()->GetAccountId());
+	if (!result) return 0;
+	else
+	{
+		Field* fields = result->Fetch();
+		return fields[0].GetInt32();
+	}
+}
+
+void CommonFunc::SetLootRate(Player* player)
+{
+	player->SetCustomLootRate(1.0f);
+
+	float totalRate = 1.0f;
+	float factionRate = 1.0f;
+	float playerRate = 1.0f;
+	float hrRate = 1.0f;
+	float vipRate = 1.0f;
+
+	player->realTeam == TEAM_ALLIANCE ? factionRate = sSwitch->GetValue(ST_LOOT_RATE_A) : factionRate = sSwitch->GetValue(ST_LOOT_RATE_H);
+
+	std::unordered_map<uint32, float>::iterator iter = PlayerDropRateMap.find(player->GetGUIDLow());
+	if (iter != PlayerDropRateMap.end())
+		playerRate = iter->second;
+
+	if (!HRUpVec.empty())
+		hrRate = sHR->GetRate(player, HR_RATE_LOOT);
+
+	if (!VIPVec.empty())
+		vipRate = sVIP->GetLootRate(player);
+
+	if (vipRate == 0)
+		vipRate = 1.0f;
+
+	if (hrRate == 0)
+		hrRate = 1.0f;
+
+	if (factionRate == 0)
+		factionRate = 1.0f;
+
+	totalRate = factionRate * playerRate * hrRate * vipRate;
+
+	player->SetCustomLootRate(totalRate);
+}
+
+uint32 CommonFunc::GetGemCountByEntry(Player* player, uint32 itemEntry)
+{
+	uint32 count = 0;
+	for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
+		if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+			count += pItem->GetGemCountWithID(itemEntry);
+	return count;
+}
+
+void CommonFunc::ResetInstance(Player* player, Difficulty diff, bool isRaid, uint32 mapId)
+{
+	for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
+	{
+		BoundInstancesMap const& m_boundInstances = sInstanceSaveMgr->PlayerGetBoundInstances(player->GetGUIDLow(), Difficulty(i));
+		for (BoundInstancesMap::const_iterator itr = m_boundInstances.begin(); itr != m_boundInstances.end();)
+		{
+			InstanceSave* save = itr->second.save;
+			MapEntry const* mapEntry = sMapStore.LookupEntry(itr->first);
+			if (mapEntry && mapEntry->IsRaid() == isRaid && itr->first != player->GetMapId() && (!mapId || mapId == itr->first) && (diff == -1 || diff == save->GetDifficulty()))
+			{
+				sInstanceSaveMgr->PlayerUnbindInstance(player->GetGUIDLow(), itr->first, diff, true, player);
+				itr = m_boundInstances.begin();
+			}
+			else
+				++itr;
+		}
+	}
+}
+
+std::vector<std::string> CommonFunc::SplitStr(std::string str, std::string pattern)
+{
+	std::string::size_type pos;
+	std::vector<std::string> result;
+	str += pattern;
+	int size = str.size();
+	for (int i = 0; i < size; i++)
+	{
+		pos = str.find(pattern, i);
+		if (pos < size)
+		{
+			std::string s = str.substr(i, pos - i);
+			result.push_back(s);
+			i = pos + pattern.size() - 1;
+		}
+	}
+	return result;
+}
+
+std::string CommonFunc::GetPlayerTotalName(Player* player, std::string flag, bool fakeplayer, uint8 fake_class, uint8 fake_race, uint8 fake_hr, std::string fake_name, uint32 vip,uint8 gender)
+{
+	//1-Ö°Òµ 2-ÖÖ×å 3-VIP 4-¾üÏÎ 5-Ãû×Ö
+	// 1 | 2 | 3 | 4 | 5
+	
+	std::string totalName = "";
+
+	std::string rcTitle = "";
+	std::string rcIcon = "";
+	std::string gossip = "";
+
+	//»ñÈ¡Ö°Òµ
+	std::string _class = "";
+	std::string classIcon = "";
+	fakeplayer ? GetClass(NULL,_class,classIcon,true,fake_class) : GetClass(player, _class, classIcon);
+
+	//»ñÈ¡ÖÖ×å
+	std::string race = "";
+	std::string raceIcon = "";
+	fakeplayer ? GetRace(NULL, race, raceIcon, true, fake_race, gender) : GetRace(player, race, raceIcon);
+
+	//»ñÈ¡¾üÏÎ
+	std::string hrTitle = "";
+	std::string hrIcon = "";
+	fakeplayer ? GetHRTitle(NULL, hrTitle, hrIcon, true, fake_hr) : GetHRTitle(player, hrTitle, hrIcon);
+
+	std::string vipTitle = "";
+	std::string vipIcon = ""; 
+	fakeplayer ? sVIP->GetVIPTitle(NULL, vipTitle, vipIcon,true,vip) : sVIP->GetVIPTitle(player, vipTitle, vipIcon);
+
+	std::string nameLink = "";
+	std::string nameLinkWithColor = "";
+	fakeplayer ? GetNameLink(NULL, nameLink, nameLinkWithColor,true,fake_class,fake_name) : GetNameLink(player, nameLink, nameLinkWithColor);
+
+	std::vector<std::string> NameTypeVec = sCF->SplitStr(flag, "|");
+	for (size_t i = 0; i < NameTypeVec.size(); i++)
+	{
+		uint32 nameType = (uint32)atoi(NameTypeVec[i].c_str());
+
+		switch (nameType)
+		{
+		case 1:
+			player->realTeam == TEAM_ALLIANCE ? totalName += "|cFF0177EC[ÁªÃË]|r" : totalName += "|cFFFF1717[²¿Âä]|r";
+			break;
+		case 110:
+			totalName += classIcon;
+			break;
+		case 101:
+			totalName += _class;
+			break;
+		case 111:
+			totalName += classIcon;
+			totalName += _class;
+			break;
+		case 210:
+			totalName += raceIcon;
+			break;
+		case 201:
+			totalName += race;
+			break;
+		case 211:
+			totalName += raceIcon;
+			totalName += race;
+			break;
+		case 310:
+			totalName += vipIcon;
+			break;
+		case 301:
+			totalName += vipTitle;
+			break;
+		case 311:
+			totalName += vipIcon;
+			totalName += vipTitle;
+			break;
+		case 410:
+			totalName += hrIcon;
+			break;
+		case 401:
+			totalName += hrTitle;
+			break;
+		case 411:
+			totalName += hrIcon;
+			totalName += hrTitle;
+			break;
+		case 510:
+			break;
+			totalName += rcIcon;
+		case 501:
+			totalName += rcTitle;
+			break;
+		case 511:
+			totalName += rcIcon;
+			totalName += rcTitle;
+			break;
+		case 60:
+			totalName += nameLink;
+			break;
+		case 61:
+			totalName += nameLinkWithColor;
+			break;
+		}
+	}
+
+	return totalName;
+}
+
+uint32 CommonFunc::GetCommercePoints(Player* player)
+{
+	player->tradeSkillCount = 0;
+	if (player->HasSpell(2366)) player->tradeSkillCount++;
+	if (player->HasSpell(2575)) player->tradeSkillCount++;
+	if (player->HasSpell(8613)) player->tradeSkillCount++;
+	if (player->HasSpell(2018)) player->tradeSkillCount++;
+	if (player->HasSpell(3908)) player->tradeSkillCount++;
+	if (player->HasSpell(2108)) player->tradeSkillCount++;
+	if (player->HasSpell(4036)) player->tradeSkillCount++;
+	if (player->HasSpell(2259)) player->tradeSkillCount++;
+	if (player->HasSpell(45357)) player->tradeSkillCount++;
+	if (player->HasSpell(7411)) player->tradeSkillCount++;
+	if (player->HasSpell(25229)) player->tradeSkillCount++;
+
+	return player->tradeSkillCount;
+}
+
+void CommonFunc::SetCommercePoints(Player* player)
+{
+	QueryResult result = CharacterDatabase.PQuery("SELECT extraPrimaryTradeSkills FROM characters where guid = %u", player->GetGUIDLow());
+	if (result)
+		player->maxPrimaryTradeSkills += result->Fetch()[0].GetUInt32();
+	if (player->maxPrimaryTradeSkills >= GetCommercePoints(player))
+		player->SetFreePrimaryProfessions(player->maxPrimaryTradeSkills - GetCommercePoints(player));
+}
+
+
+
+//QQMsg
+#define QQMSG_PORT		5000
+#define QQMSG_GROUP		"´´ÊÀÄ§ÊÞÍæ¼ÒÈº"
+std::queue<std::string> QQMsgQueue;
+
+std::string GetQQMsgTime()
+{
+	time_t t = time(NULL);
+	tm localTime;
+	localtime_r(&t, &localTime);
+	int hour = localTime.tm_hour;
+	int min = localTime.tm_min;
+	int sec = localTime.tm_sec;
+	std::ostringstream oss;
+	oss << hour << ":" << min;
+	return oss.str();
+}
+
+DWORD WINAPI QQMsgThread(LPVOID i)
+{
+	WSADATA wsaData;
+
+	if (WSAStartup(0x202, &wsaData) == SOCKET_ERROR) {
+		WSACleanup();
+		return 0;
+	}
+
+	struct sockaddr_in srv_addr;
+	srv_addr.sin_family = AF_INET;
+	srv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
+	srv_addr.sin_port = ntohs(QQMSG_PORT);
+
+	uint32 count = 0;
+
+	while (true)
+	{
+		if (!QQMsgQueue.empty())
+		{
+			SOCKET cli_sock = socket(PF_INET, SOCK_STREAM, 0);
+			if (cli_sock == INVALID_SOCKET)
+				continue;
+
+			if (connect(cli_sock, (LPSOCKADDR)&srv_addr, sizeof(srv_addr)) == SOCKET_ERROR)
+				continue;
+
+			count++;
+
+			std::ostringstream oss;
+			oss << "¡¾ÓÎÏ·ÏûÏ¢ " << "µÚ" << count << "Ìõ " << GetQQMsgTime() << "¡¿" << QQMsgQueue.front();
+			QQMsgQueue.pop();
+
+			std::string msg = oss.str();
+			url_encode(msg);
+			
+
+			char s[1024];
+			sprintf(s, "GET /openqq/send_group_message?name=%s&content=%s HTTP/1.1\r\nHost: 127.0.0.1:%u\r\n\r\n", QQMSG_GROUP, msg.c_str(), QQMSG_PORT);
+			send(cli_sock, s, sizeof(s), 0);
+			closesocket(cli_sock);
+
+			Sleep(1000);
+		}
+	}
+
+	return 0;
+}
+
+class QQMsgWorldScript : public WorldScript
+{
+public:
+	QQMsgWorldScript() : WorldScript("QQMsgWorldScript") {}
+
+	void OnStartup()
+	{
+		CreateThread(NULL, 0, QQMsgThread, NULL, 0, NULL);
+	}
+};
+
+void AddSC_QQMsg()
+{
+	//new QQMsgWorldScript();
+}
+
+std::string GetDBName(std::string str)
+{
+	std::string pattern = ";";
+
+	std::string::size_type pos;
+	std::vector<std::string> result;
+	str += pattern;
+	int size = str.size();
+	for (int i = 0; i<size; i++)
+	{
+		pos = str.find(pattern, i);
+		if (pos<size)
+		{
+			std::string s = str.substr(i, pos - i);
+			result.push_back(s);
+			i = pos + pattern.size() - 1;
+		}
+	}
+	return result[4];
+}
+void SplitStr(const char* delim, char* args, char** arg1, char** arg2)
+{
+	char* p1 = strtok(args, delim);
+	char* p2 = strtok(NULL, delim);
+
+	if (!p2)
+	{
+		p2 = p1;
+		p1 = NULL;
+	}
+
+	if (arg1)
+		*arg1 = p1;
+
+	if (arg2)
+		*arg2 = p2;
+}
+void EncodeStr(std::string& c)
+{
+	int a[] = { 3, 5, 9, 2, 4, 7, 3 };
+	for (int i = 0, j = 0; c[j]; j++, i = (i + 1) % 7){
+		c[j] += a[i];
+		//if (c[j] > 122) c[j] -= 90;
+	}
+}
+void DecodeStr(std::string& c)
+{
+	int a[] = { 3, 5, 9, 2, 4, 7, 3 };
+	for (int i = 0, j = 0; c[j]; j++, i = (i + 1) % 7){
+		c[j] -= a[i];
+		//if (c[j] < 32) c[j] += 90;
+	}
+}
+char *url_encode(const char *s, int len, int *new_length)
+{
+	unsigned char hexchars[] = "0123456789ABCDEF";
+
+	register int x, y;
+	unsigned char *str;
+
+	str = (unsigned char *)malloc(3 * len + 1);
+	for (x = 0, y = 0; len--; x++, y++)
+	{
+		str[y] = (unsigned char)s[x];
+		if (str[y] == ' ')
+		{
+			str[y] = '+';
+		}
+		else if ((str[y] < '0' && str[y] != '-' && str[y] != '.')
+			|| (str[y] < 'A' && str[y] > '9')
+			|| (str[y] > 'Z' && str[y] < 'a' && str[y] != '_')
+			|| (str[y] > 'z'))
+		{
+			str[y++] = '%';
+			str[y++] = hexchars[(unsigned char)s[x] >> 4];
+			str[y] = hexchars[(unsigned char)s[x] & 15];
+		}
+	}
+	str[y] = '\0';
+	if (new_length) {
+		*new_length = y;
+	}
+
+	return ((char *)str);
+}
+void url_encode(std::string &s)
+{
+	char *buf = url_encode(s.c_str(), s.length(), NULL);
+	if (buf)
+	{
+		s = buf;
+		free(buf);
+	}
+}
+
+void OutString(std::string s)
+{
+	ofstream outfile("data.txt");
+
+	outfile << s << std::endl;
+
+	outfile.close();
+}
+
+void OutPos(uint32 posId)
+{
+	auto itr = PosMap.find(posId);
+	if (itr != PosMap.end())
+	{
+		std::ostringstream oss;
+
+		oss << "PosId " << posId << ":" << itr->second.map << "," << itr->second.x << "," << itr->second.y << "," << itr->second.z << "," << itr->second.o;
+
+		ofstream outfile("data.txt");
+
+		outfile << oss.str() << std::endl;
+
+		outfile.close();
+	}
+	
+}
+
+void PrintStr(std::string s)
+{
+	sWorld->SendServerMessage(SERVER_MSG_STRING, s.c_str());
+}
+
+void CommonFunc::TeleToTarget(Player* player, Player* target)
+{
+	if (!target)
+		return;
+
+	Map* map = target->GetMap();
+
+	if (!map)
+		return;
+
+	if (map->IsBattlegroundOrArena())
+	{
+		if (!player->GetMap()->IsBattlegroundOrArena())
+			player->SetEntryPoint();
+
+		player->SetBattlegroundId(target->GetBattlegroundId(), target->GetBattlegroundTypeId(), PLAYER_MAX_BATTLEGROUND_QUEUES, false, false, TEAM_NEUTRAL);
+	}
+	else if (map->IsDungeon())
+	{
+		// if the GM is bound to another instance, he will not be bound to another one
+		InstancePlayerBind* bind = sInstanceSaveMgr->PlayerGetBoundInstance(player->GetGUIDLow(), target->GetMapId(), target->GetDifficulty(map->IsRaid()));
+		if (!bind)
+			if (InstanceSave* save = sInstanceSaveMgr->GetInstanceSave(target->GetInstanceId()))
+				sInstanceSaveMgr->PlayerBindToInstance(player->GetGUIDLow(), save, !save->CanReset(), player);
+
+		if (map->IsRaid())
+			player->SetRaidDifficulty(target->GetRaidDifficulty());
+		else
+			player->SetDungeonDifficulty(target->GetDungeonDifficulty());
+	}
+
+
+	// stop flight if need
+	if (player->IsInFlight())
+	{
+		player->GetMotionMaster()->MovementExpired();
+		player->CleanupAfterTaxiFlight();
+	}
+	// save only in non-flight case
+	else
+		player->SaveRecallPosition();
+
+	player->TeleportTo(target->GetMapId(), target->GetPositionX(), target->GetPositionY(), target->GetPositionZ() + 0.25f, player->GetOrientation(), TELE_TO_GM_MODE);
+	player->SetPhaseMask(target->GetPhaseMask() | 1, false);
+}
+
+void CommonFunc::TeleToTarget(Player* player, Player* target, float x, float y, float z)
+{
+	if (!target)
+		return;
+
+	Map* map = target->GetMap();
+
+	if (!map)
+		return;
+
+	if (map->IsBattlegroundOrArena())
+	{
+		if (!player->GetMap()->IsBattlegroundOrArena())
+			player->SetEntryPoint();
+
+		player->SetBattlegroundId(target->GetBattlegroundId(), target->GetBattlegroundTypeId(), PLAYER_MAX_BATTLEGROUND_QUEUES, false, false, TEAM_NEUTRAL);
+	}
+	else if (map->IsDungeon())
+	{
+		// if the GM is bound to another instance, he will not be bound to another one
+		InstancePlayerBind* bind = sInstanceSaveMgr->PlayerGetBoundInstance(player->GetGUIDLow(), target->GetMapId(), target->GetDifficulty(map->IsRaid()));
+		if (!bind)
+			if (InstanceSave* save = sInstanceSaveMgr->GetInstanceSave(target->GetInstanceId()))
+				sInstanceSaveMgr->PlayerBindToInstance(player->GetGUIDLow(), save, !save->CanReset(), player);
+
+		if (map->IsRaid())
+			player->SetRaidDifficulty(target->GetRaidDifficulty());
+		else
+			player->SetDungeonDifficulty(target->GetDungeonDifficulty());
+	}
+
+
+	// stop flight if need
+	if (player->IsInFlight())
+	{
+		player->GetMotionMaster()->MovementExpired();
+		player->CleanupAfterTaxiFlight();
+	}
+	// save only in non-flight case
+	else
+		player->SaveRecallPosition();
+
+	player->TeleportTo(target->GetMapId(), x, y, z + 0.25f, player->GetOrientation(), TELE_TO_GM_MODE);
+	player->SetPhaseMask(target->GetPhaseMask() | 1, false);
+}
+
+std::string SecTimeString(uint64 timeInSecs, bool shortText)
+{
+	uint64 secs = timeInSecs % MINUTE;
+	uint64 minutes = timeInSecs % HOUR / MINUTE;
+	uint64 hours = timeInSecs % DAY / HOUR;
+	uint64 days = timeInSecs / DAY;
+
+	std::ostringstream ss;
+	if (days)
+		ss << days << (shortText ? "Ìì" : "Ìì");
+	if (hours)
+		ss << hours << (shortText ? "Ê±" : "Ð¡Ê±");
+	if (minutes)
+		ss << minutes << (shortText ? "·Ö" : "·ÖÖÓ");
+	if (secs || (!days && !hours && !minutes))
+		ss << secs << (shortText ? "Ãë" : "ÃëÖÓ");
+
+	std::string str = ss.str();
+
+	if (!shortText && !str.empty() && str[str.size() - 1] == ' ')
+		str.resize(str.size() - 1);
+
+	return str;
+}
+
+uint32 GetIpCount()
+{
+	std::vector<std::string> IPVec;
+
+	SessionMap::const_iterator itr;
+	for (itr = sWorld->GetAllSessions().begin(); itr != sWorld->GetAllSessions().end(); ++itr)
+	{
+		if (itr->second &&
+			itr->second->GetPlayer() &&
+			itr->second->GetPlayer()->IsInWorld())
+		{
+			std::string ip = itr->second->GetRemoteAddress();
+
+			if (std::find(IPVec.begin(), IPVec.end(), ip) == IPVec.end())
+				IPVec.push_back(ip);
+		}
+	}
+
+	return IPVec.size();
+}
+
+bool IsGCValidString(std::string s, std::string description, WorldSession* session, WorldPacket& recvData)
+{
+	if (s.empty())
+		return true;
+
+	int num = s.size();
+	int i = 0;
+	while (i < num)
+	{
+		int size = 1;
+
+		if (s[i] & 0x80)
+		{
+			char temp = s[i];
+			temp <<= 1;
+			do{
+				temp <<= 1;
+				++size;
+			} while (temp & 0x80);
+		}
+
+		std::string subs;
+		subs = s.substr(i, size);
+
+		switch (size)
+		{
+		case 1:
+			//if (subs[0] < 32 || subs[0] > 126)
+			//{
+			//	if (session)
+			//	{
+			//		sLog->outString("IP:%s AccountId:%u CharGUID:%u Opcode:%s SizeType:%u", session->GetRemoteAddress().c_str(), session->GetAccountId(), session->GetGuidLow(), description, size);
+			//		sLog->outChar("IP:%s AccountId:%u CharGUID:%u Opcode:%s SizeType:%u", session->GetRemoteAddress().c_str(), session->GetAccountId(), session->GetGuidLow(), description, size);
+			//	}
+			//	recvData.rfinish();
+			//	return false;
+			//}
+			break;
+		case 3:
+		{
+			uint32 x = ((subs[0] & 0xFF) << 16) | ((subs[1] & 0xFF) << 8) | (subs[2] & 0xFF);
+
+			bool IsMark = false;
+
+			switch (x)
+			{
+			case 0xE38082://¡£
+			case 0xE38090://¡¾¡¿
+			case 0xE38091:
+			case 0xEFBC8C://£¬
+			case 0xE2809C://¡°¡±
+			case 0xE2809D:
+			case 0xEfBC9B://£»
+			case 0xE38081://¡¢
+			case 0xEFBC9F://£¿
+			case 0xEFBC88://£¨£©
+			case 0xEFBC89:
+			case 0xefbc87://£§
+			case 0xe288b6://¡Ã
+			case 0xefbd9e://¡«
+			case 0xe38085://¡©
+			case 0xefb99f://©|
+			case 0xefbd80://£à
+			case 0xefb9a9://©
+			case 0xe3808e://¡º¡»
+			case 0xe3808f:
+			case 0xe38096://¡¼¡½
+			case 0xe38097:
+			case 0xefbcbb://£Û£Ý
+			case 0xefbcbd:
+			case 0xe3808a://¡¶¡·
+			case 0xe3808b:
+			case 0xefb99b://©x©y
+			case 0xefb99c:
+			case 0xe3808c://¡¸¡¹
+			case 0xe3808d:
+			case 0xe285a0://¢ñ-¢ú
+			case 0xe285a1:
+			case 0xe285a2:
+			case 0xe285a3:
+			case 0xe285a4:
+			case 0xe285a5:
+			case 0xe285a6:
+			case 0xe285a7:
+			case 0xe285a8:
+			case 0xe285a9:
+			case 0xe2978b://¡ð
+			case 0xe29787://¡ó
+			case 0xe296a1://¡õ
+			case 0xe296b3://¡÷
+			case 0xe296bd://¨
+			case 0xe29886://¡î
+			case 0xe2978f://¡ñ
+			case 0xe29786://¡ô
+			case 0xe296b2://¡ø
+			case 0xe296bc://¨
+			case 0xe29980://¡â
+			case 0xe29982://¡á
+			case 0xe2889a://?¡Ì
+			case 0xe2978e://¡ò
+			case 0xe28a99://¡Ñ
+			case 0xe28690://¡û¡ú
+			case 0xe28692://
+				IsMark = true;
+			}
+
+			if (!IsMark && (x < 0xE4B880 || x > 0xE9BEA5))
+			{
+				if (session)
+                    sLog->outString("Possiable String Hack --> IP:%s AccountId:%u CharGUID:%u Opcode:%s SizeType:%u", session->GetRemoteAddress().c_str(), session->GetAccountId(), session->GetGuidLow(), description.c_str(), size);
+				recvData.rfinish();
+				return false;
+			}
+		}
+		break;
+		default:
+			if (session)
+                sLog->outString("Possiable String Hack --> IP:%s AccountId:%u CharGUID:%u Opcode:%s SizeType:%u", session->GetRemoteAddress().c_str(), session->GetAccountId(), session->GetGuidLow(), description.c_str(), size);
+			recvData.rfinish();
+			return false;
+		}
+
+		i += size;
+	}
+
+	return true;
+}
diff --git a/src/server/scripts/Custom/CommonFunc/CommonFunc.h b/src/server/scripts/Custom/CommonFunc/CommonFunc.h
new file mode 100644
index 0000000..3d9e94c
--- /dev/null
+++ b/src/server/scripts/Custom/CommonFunc/CommonFunc.h
@@ -0,0 +1,138 @@
+ï»¿extern bool CampAttackStartFlag;
+
+class CommonFunc
+{
+public:
+	static CommonFunc* instance()
+	{
+		static CommonFunc instance;
+		return &instance;
+	}
+
+	void TeleToTarget(Player* player, Player* target);
+	void TeleToTarget(Player* player, Player* target, float x, float y, float z);
+
+	//æ©ç è®¡ç®
+	bool IsInclude(uint32 mask, uint32 totalMask);
+
+	uint32 GetExtraTalentPoints(Player* player);
+
+	uint32 GetTokenAmount(Player* player);
+	uint32 GetTotalTokenAmount(Player* player);
+	void UpdateTokenAmount(Player* player, uint32 amount, bool ins, std::string action = "");
+	void SetOnlineRewardedCount(Player* player, uint32 count);
+
+	//å¼¹çª
+	void SendAcceptOrCancel(Player* player, uint32 id, std::string text, bool quest = false);
+	bool DoAciotnAfterAccept(Player* player, uint32 id, bool quest = false);
+
+	//å¾æ åç©åé¾æ¥
+	std::string GetItemIcon(uint32 entry, uint32 width, uint32 height, int x, int y);
+	std::string GetItemLink(uint32 entry);
+	std::string GetItemLink(Item* item, WorldSession* session);
+
+
+	//QQæ¶æ¯
+	void SendQQMsg(std::string gnum, std::string content);
+
+	//æ­æ¾å£°é³
+	void PlayCustomSound(Player* player, uint32 soundId);
+
+
+	//è·åæå°±ç¹
+	uint32 GetAchievementPoints(Player* player);
+
+
+	//éä¼å¥å±
+	void GroupReward(Player* player, uint32 rewardTemplateId, uint32 chance);
+
+	//additem ååæ»¡æ¶sendmail
+	void AddOrMailItem(Player* player, uint32 itemId, uint32 count);
+
+
+	//ä¿®æ¹speed
+	void SetSpeed(Player* player, float multi);
+
+	//åææå¨çº¿ç©å®¶åéæ¶æ¯
+	void SendMsGToAll(std::string /*str*/, uint32 /*0:notice 1:warning*/);
+
+	//è·åç©å®¶ä¿¡æ¯
+	std::string GetNameLink(Player* player);
+	void GetNameLink(Player* player, std::string &nameLink, std::string &nameLinkWithColor, bool fakeplayer = false, uint8 fakeclass = 0, std::string fakename = "");
+	void GetRace(Player* player, std::string &race, std::string &raceIcon, bool fakeplayer = false, uint8 fakerace = 0, uint8 gender = 0);
+	void GetClass(Player* player, std::string &_class, std::string &classIcon, bool fakeplayer = false, uint8 fakeclass = 0);
+	void GetHRTitle(Player* player, std::string &hrTitle, std::string &hrIcon, bool fakeplayer = false, uint8 fakehr = 0);
+	std::string GetHRTitle(uint32 rank);
+	//void updateAccountTitle(Player* player);
+	void updateHRTitle(Player* player);
+	uint32 getPlayerHrTitleLevel(Player* player);
+	uint32 getAccountHrTitleLevel(Player* player);
+
+	//æ´æ°ç©å®¶åå­
+	void UpdatePlayerNameWithHR(Player* player);
+	uint32 GetHrTitleId(Player* player);
+
+	void SetLootRate(Player* player);
+
+	void StartCamAttack();
+
+	uint32 GetOnlineIpCount(Player* player);
+	uint32 GetBgIpCount(Player* player, Battleground* bg);
+
+	bool onlineIsAllowed(Player* player);
+	bool joinBgIsAllowed(Player* player, Battleground* bg);
+
+	//è·åå®ç³æ°é
+	uint32 GetGemCountByEntry(Player* player, uint32 itemEntry);
+
+	//å®æä»»å¡
+	void CompleteQuest(Player* player, uint32 questId);
+
+	//reset instance
+	void ResetInstance(Player* player, Difficulty diff, bool isRaid = false, uint32 mapId = 0);
+
+	//åå²å­ç¬¦ä¸²
+	std::vector<std::string> SplitStr(std::string str, std::string pattern);
+
+
+	//è·åå¸¦åç§åç¼çç©å®¶åå­
+	std::string GetPlayerTotalName(Player* player, std::string flag, bool fakeplayer = false, uint8 fake_class = 0, uint8 fake_race = 0, uint8 fake_hr = 0, std::string fake_name = "",uint32 vip = 0,uint8 gender = 0);
+
+
+	uint8 getX(uint32 action) {
+		return (uint8)(action >> 24);
+	}
+
+	uint32 getY(uint32 action) {
+		return (uint32)(action & 0xFFFFFF);//å±è½é«8ä½
+	}
+
+	uint32 joinXY(uint8 x, uint32 y) {
+		return (uint32)((x << 24) | (y & 0xFFFFFF));
+	}
+
+	uint32 GetCommercePoints(Player* player);
+	void SetCommercePoints(Player* player);
+
+
+private:
+	uint32 m_delay = 0;
+};
+
+#define sCF CommonFunc::instance()
+
+extern std::string GetDBName(std::string str);
+extern void SplitStr(const char* delim, char* args, char** arg1, char** arg2);
+extern void EncodeStr(std::string& c);
+extern void DecodeStr(std::string& c);
+extern char *url_encode(const char *s, int len, int *new_length);
+extern void url_encode(std::string &s);
+extern void OutString(std::string s);
+extern void OutPos(uint32 posId);
+extern void PrintStr(std::string s);
+extern std::queue<std::string> QQMsgQueue;
+extern std::string GetQQMsgTime();
+extern void SendQQMsg(std::string gnum, std::string content);
+extern std::string SecTimeString(uint64 timeInSecs, bool shortText);
+extern uint32 GetIpCount();
+extern bool IsGCValidString(std::string s, std::string description, WorldSession* session, WorldPacket& recvData);
diff --git a/src/server/scripts/Custom/CustomEvent/ArenaDuel/ArenaDuel.cpp b/src/server/scripts/Custom/CustomEvent/ArenaDuel/ArenaDuel.cpp
new file mode 100644
index 0000000..5ea4120
--- /dev/null
+++ b/src/server/scripts/Custom/CustomEvent/ArenaDuel/ArenaDuel.cpp
@@ -0,0 +1,756 @@
+#pragma execution_character_set("utf-8")
+#include "ArenaDuel.h"
+#include "../Custom/Reward/Reward.h"
+#include "../Custom/Requirement/Requirement.h"
+#include "../Custom/MainFunc/MainFunc.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
+#include "../Custom/Command/CustomCommand.h"
+#include "Pet.h"
+
+WorldLocation ARENA_DUEL_CIRCLE_LOCATIONS[10] =
+{
+	WorldLocation(0, -13258.1, 257.313, 33.241, 0.376306),
+	WorldLocation(0, -13260.6, 286.052, 33.346, 6.05081),
+	WorldLocation(0, -13254.4, 302.142, 33.6155, 5.78377),
+	WorldLocation(0, -13215.1, 328.655, 33.2434, 5.06514),
+	WorldLocation(0, -13178.9, 321.976, 33.2434, 4.26796),
+	WorldLocation(0, -13152.9, 295.351, 33.3038, 3.46685),
+	WorldLocation(0, -13150.8, 262.599, 33.2429, 3.01524),
+	WorldLocation(0, -13158.4, 241.41, 33.2958, 2.544),
+	WorldLocation(0, -13180.7, 222.091, 33.2439, 2.18664),
+	WorldLocation(0, -13199.7, 217.598, 33.2417, 1.83321),
+};
+
+WorldLocation ARENA_DUEL_MID_LOCATIONS[2] =
+{
+	WorldLocation(0, -13191.5, 303.531, 21.8581, 4.17468),
+	WorldLocation(0, -13220.2, 246.299, 21.8581, 0.87599),
+};
+
+
+WorldLocation ARENA_DUEL_PILLAR_LOCATIONS[4] =
+{
+	WorldLocation(0, -13210.4, 262.851, 18.4, 1.16667),
+	WorldLocation(0, -13197.5, 290.454, 18.4, 4.33035),
+	WorldLocation(0, -13219.8, 284.421, 18.4, 5.82800),
+	WorldLocation(0, -13189.0, 268.273, 18.4, 2.69405),
+};
+
+WorldLocation ARENA_DUEL_EYE_LOCATIONS[4] =
+{
+	WorldLocation(0, -13207.7, 287.798, 21.8574, 4.95382),
+	WorldLocation(0, -13191.5, 279.775, 21.8574, 3.41052),
+	WorldLocation(0, -13199.9, 264.983, 21.8574, 1.94182),
+	WorldLocation(0, -13217.4, 272.533, 21.8574, 0.390663),
+};
+
+std::map<uint32, ArenaDuelTemplate> ArenaDuelMap;
+std::unordered_map<uint64, int64> AreaDuelGambleMap;
+
+void ArenaDuel::Load()
+{
+	ArenaDuelMap.clear();
+	QueryResult result = CharacterDatabase.PQuery("SELECT guid,selected,winnum FROM characters_arena_duel");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 guid = fields[0].GetUInt32();
+			ArenaDuelTemplate temp;
+			temp.selected = fields[1].GetBool();
+			temp.winNum = fields[2].GetUInt32();
+			ArenaDuelMap.insert(std::make_pair(guid, temp));
+		} while (result->NextRow());
+	}
+}
+
+void ArenaDuel::Save(Player* pl)
+{
+	auto itr = ArenaDuelMap.find(pl->GetGUIDLow());
+	if (itr == ArenaDuelMap.end())
+		return;
+
+	PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_ARENA_DUEL);
+	stmt->setUInt32(0, pl->GetGUIDLow());
+	stmt->setBool(1, itr->second.selected);
+	stmt->setUInt32(2, itr->second.winNum);
+	CharacterDatabase.Execute(stmt);
+}
+
+void ArenaDuel::Signup(Player* pl)
+{
+	ArenaDuelTemplate temp;
+	temp.selected = false;
+	temp.winNum = 0;
+	ArenaDuelMap.insert(std::make_pair(pl->GetGUIDLow(), temp));
+
+	Save(pl);
+}
+
+void ArenaDuel::InitPlayer(Player* pl)
+{
+	pl->RemoveAllSpellCooldown();
+
+	if (!pl->IsAlive())
+	{
+		pl->ResurrectPlayer(1.0f);
+		pl->SpawnCorpseBones();
+	}
+
+	pl->RemoveAura(ARENA_DUEL_SEC_DEBUFF);
+	pl->RemoveAura(ARENA_DUEL_FLAG_1);
+	pl->RemoveAura(ARENA_DUEL_FLAG_2);
+}
+
+void ArenaDuel::TelePortAll()
+{
+	//std::random_shuffle(ArenaDuelMap.begin(), ArenaDuelMap.end());
+
+	for (auto itr = ArenaDuelMap.begin(); itr != ArenaDuelMap.end(); itr++)
+		if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+		{
+			InitPlayer(pl);
+			TelePort(pl);
+		}
+}
+
+void ArenaDuel::TelePort(Player* pl)
+{
+	pl->TeleportTo(ARENA_DUEL_CIRCLE_LOCATIONS[urand(0, 9)]);
+}
+
+void ArenaDuel::TeleportDueler()
+{
+	InitPlayer(_DUELER_1);
+	InitPlayer(_DUELER_2);
+	_DUELER_1->TeleportTo(ARENA_DUEL_MID_LOCATIONS[0]);
+	_DUELER_2->TeleportTo(ARENA_DUEL_MID_LOCATIONS[1]);
+}
+
+Player* ArenaDuel::GenerateDueler()
+{
+	for (auto itr = ArenaDuelMap.begin(); itr != ArenaDuelMap.end(); itr++)
+		if (!itr->second.selected)
+			if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+			{
+				itr->second.selected = true;
+				return pl;
+			}
+
+	return NULL;
+}
+
+bool ArenaDuel::HasDueler()
+{
+	for (auto itr = ArenaDuelMap.begin(); itr != ArenaDuelMap.end(); itr++)
+		if (!itr->second.selected && ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+			return true;
+
+	return false;
+}
+
+bool ArenaDuel::IsDueler(Player* pl)
+{
+	if (CheckDueler(_DUELER_1) && _DUELER_1->GetGUID() == pl->GetGUID())
+		return true;
+
+	if (CheckDueler(_DUELER_2) && _DUELER_2->GetGUID() == pl->GetGUID())
+		return true;
+
+	return false;
+}
+
+void ArenaDuel::StartDuel()
+{
+	//CREATE DUEL FLAG OBJECT
+	uint32 gameobject_id = 21680;
+	GameObject* pGameObj = new GameObject();
+
+	Map* map = _DUELER_1->GetMap();
+	if (!pGameObj->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_GAMEOBJECT), gameobject_id,
+		map, _DUELER_1->GetPhaseMask(),
+		ARENA_DUEL_MID_LOCATIONS[0].GetPositionX() + (ARENA_DUEL_MID_LOCATIONS[1].GetPositionX() - ARENA_DUEL_MID_LOCATIONS[0].GetPositionX()) / 2,
+		ARENA_DUEL_MID_LOCATIONS[0].GetPositionY() + (ARENA_DUEL_MID_LOCATIONS[1].GetPositionY() - ARENA_DUEL_MID_LOCATIONS[0].GetPositionY()) / 2,
+		ARENA_DUEL_MID_LOCATIONS[0].GetPositionZ(),
+		ARENA_DUEL_MID_LOCATIONS[0].GetOrientation(), G3D::Quat(), 0, GO_STATE_READY))
+	{
+		delete pGameObj;
+		return;
+	}
+
+	pGameObj->SetUInt32Value(GAMEOBJECT_FACTION, _DUELER_1->getFaction());
+	pGameObj->SetUInt32Value(GAMEOBJECT_LEVEL, _DUELER_1->getLevel() + 1);
+	pGameObj->SetRespawnTime(0);
+	pGameObj->SetSpellId(7266);
+
+
+	_DUELER_1->AddGameObject(pGameObj);
+	map->AddToMap(pGameObj, true);
+	//END
+
+	// create duel-info
+	DuelInfo* duel = new DuelInfo;
+	duel->initiator = _DUELER_1;
+	duel->opponent = _DUELER_2;
+	duel->startTime = 0;
+	duel->startTimer = 0;
+	duel->isMounted = false;
+	_DUELER_1->duel = duel;
+
+	DuelInfo* duel2 = new DuelInfo;
+	duel2->initiator = _DUELER_1;
+	duel2->opponent = _DUELER_1;
+	duel2->startTime = 0;
+	duel2->startTimer = 0;
+	duel2->isMounted = false;
+	_DUELER_2->duel = duel2;
+
+	_DUELER_1->SetUInt64Value(PLAYER_DUEL_ARBITER, pGameObj->GetGUID());
+	_DUELER_2->SetUInt64Value(PLAYER_DUEL_ARBITER, pGameObj->GetGUID());
+}
+
+void ArenaDuel::EndDuel(Player* winner, Player* loser)
+{
+	CloseGamble();
+
+	if (CheckDueler(_DUELER_1) && _DUELER_1->GetGUID() == winner->GetGUID())
+		EndGamble(true);
+	else
+		EndGamble(false);
+
+	InitPlayer(winner);
+	InitPlayer(loser);
+	TelePort(loser);
+
+	if (winner)
+	{
+		winner->UpdateMaxHealth();
+		if (winner->getClass() == CLASS_SHAMAN)
+			winner->UnsummonAllTotems();
+	}
+
+	if (loser)
+	{
+		loser->UpdateMaxHealth();
+		if (loser->getClass() == CLASS_SHAMAN)
+			loser->UnsummonAllTotems();
+	}
+
+
+	auto itr = ArenaDuelMap.find(winner->GetGUIDLow());
+	if (itr != ArenaDuelMap.end())
+		itr->second.winNum++;
+
+	Save(winner);
+
+	sRew->Rew(winner, ARENA_DUEL_WIN_REW_ID);
+	sRew->Rew(loser, ARENA_DUEL_LOS_REW_ID);
+
+	loser->CastSpell(loser, ARENA_DUEL_LOSER_SPELL);
+
+
+	_DUELER_1 = winner;
+	_DUELER_2 = NULL;
+
+
+	std::ostringstream oss;
+	oss << "¾ö¶·½áÊø£¬";
+	oss << sCF->GetNameLink(winner) << "Ê¤Àû£¬";
+	oss << sCF->GetNameLink(loser) << "Ê§°Ü£¡";
+	sWorld->SendScreenMessage(oss.str().c_str());
+
+	if (!HasDueler())
+		SetState(ARENA_DUEL_STATE_END);
+	else
+		SetState(ARENA_DUEL_STATE_WAIT);
+}
+
+void ArenaDuel::SetState(ArenaDuelStates state)
+{
+	_State = state;
+
+	switch (state)
+	{
+	case ARENA_DUEL_STATE_SIGNUP:
+		break;
+	case ARENA_DUEL_STATE_START:
+		_DUELER_1 = NULL;
+		_DUELER_2 = NULL;
+		_PillarTimer = 0;
+		for (size_t i = 0; i < 4; i++)
+			_Pillar[i] = 0;
+		break;
+	case ARENA_DUEL_STATE_SELECT:
+		break;
+	case ARENA_DUEL_STATE_GAMBLE:
+		sWorld->SendScreenMessage("²úÉú¾ö¶·Ë«·½£¡¾ö¶·¼´½«¿ªÊ¼£¡ÏÖÔÚ¿ªÊ¼ÏÂ×¢£¡");
+		_DUELER_1->AddAura(ARENA_DUEL_FLAG_1, _DUELER_1);
+		_DUELER_2->AddAura(ARENA_DUEL_FLAG_2, _DUELER_2);
+		_DUELER_1->AddAura(ARENA_DUEL_FREEZE_DEBUFF, _DUELER_1);
+		_DUELER_2->AddAura(ARENA_DUEL_FREEZE_DEBUFF, _DUELER_2);
+		//µ¯´°ÏÂ×¢
+		PopGamble();
+		break;
+	case ARENA_DUEL_STATE_DUEL:
+		_DuelTimer = 0;
+		_DuelSedcs = 0;
+		_DuelTimer = 0;
+		break;
+	case ARENA_DUEL_STATE_WAIT:
+		_WaitTimer = 0;
+		_WaitSecs = ARENA_DUEL_WAIT_SECS;
+		break;
+	case ARENA_DUEL_STATE_END:
+		_DUELER_1 = NULL;
+		_DUELER_2 = NULL;
+		_RewTimer = 0;
+		_DuelTimer = 0;
+		_DuelSedcs = 0;
+		_WaitTimer = 0;
+		_WaitSecs = ARENA_DUEL_WAIT_SECS;
+		ArenaDuelMap.clear();
+		CharacterDatabase.Execute(CharacterDatabase.GetPreparedStatement(CHAR_DEL_ARENA_DUEL));
+		break;
+	default:
+		break;
+	}
+}
+
+void ArenaDuel::TogglePillar(Map * map)
+{
+	for (size_t i = 0; i < 4; i++)
+	{
+		if (GameObject *go = map->GetGameObject(_Pillar[i]))
+		{
+			if (go->GetGoState() == GO_STATE_READY)
+				go->SetGoState(GO_STATE_ACTIVE);
+			else if (go->GetGoState() == GO_STATE_ACTIVE)
+				go->SetGoState(GO_STATE_READY);
+		}
+	}
+}
+
+void ArenaDuel::Update(Map* map, uint32 diff)
+{
+	if (!map || map->GetId() != ARENA_DUEL_MAP)
+		return;
+
+	//±¨Ãû½×¶Î
+	if (GetState() == ARENA_DUEL_STATE_SIGNUP)
+		return;
+
+	//»î¶¯¿ªÊ¼
+	if (GetState() == ARENA_DUEL_STATE_START)
+	{
+		sGameEventMgr->StopEvent(ARENA_DUEL_SIGNUP_EVENT_ID, false, true);
+
+		if (!HasDueler())
+		{
+			SetState(ARENA_DUEL_STATE_END);
+			return;
+		}
+
+		TelePortAll();
+		SetState(ARENA_DUEL_STATE_WAIT);
+
+		//Öù×Ó
+		for (size_t i = 0; i < 4; i++)
+		{
+			if (GameObject* go = map->SummonGameObject(ARENA_DUEL_PILLAR_ENTRY, ARENA_DUEL_PILLAR_LOCATIONS[i].GetPositionX(), ARENA_DUEL_PILLAR_LOCATIONS[i].GetPositionY(), ARENA_DUEL_PILLAR_LOCATIONS[i].GetPositionZ(), ARENA_DUEL_PILLAR_LOCATIONS[i].GetOrientation(), 0, 0, 0, 0, 0))
+			{
+				go->SetGoState(GO_STATE_READY);
+				_Pillar[i] = go->GetGUID();
+			}
+		}
+	}
+
+	//¾ö¶·µÈ´ý
+	if (GetState() == ARENA_DUEL_STATE_WAIT)
+	{
+		_WaitTimer += diff;
+		if (_WaitTimer > IN_MILLISECONDS)
+		{
+			_WaitTimer = 0;
+			_WaitSecs--;
+
+			if (_WaitSecs > 0)
+			{
+				std::ostringstream oss;
+				oss << "¾àÀë²úÉú¾ö¶·ÕßÊ£ÓàÊ±¼ä£º" << _WaitSecs << "Ãë";
+				sWorld->SendScreenMessage(oss.str().c_str());
+
+				if (_WaitSecs == 8 || _WaitSecs == 5)
+				{
+					if (!CheckDueler(_DUELER_1))
+						_DUELER_1 = GenerateDueler();
+
+					if (CheckDueler(_DUELER_1))
+						_DUELER_1->GetSession()->SendNotification("ÄãÊÇÏÂÒ»Î»¾ö¶·Õß£¬ÇëÌáÇ°×öºÃ×¼±¸£¡");
+
+					if (!CheckDueler(_DUELER_2))
+						_DUELER_2 = GenerateDueler();
+
+					if (CheckDueler(_DUELER_2))
+						_DUELER_2->GetSession()->SendNotification("ÄãÊÇÏÂÒ»Î»¾ö¶·Õß£¬ÇëÌáÇ°×öºÃ×¼±¸£¡");
+				}
+			}
+			else if (_WaitSecs == 0)
+				SetState(ARENA_DUEL_STATE_SELECT);
+		}
+	}
+
+	//²úÉú¾ö¶·Ë«·½
+	if (GetState() == ARENA_DUEL_STATE_SELECT)
+	{
+		if (!CheckDueler(_DUELER_1))
+			_DUELER_1 = GenerateDueler();
+
+		if (!CheckDueler(_DUELER_2))
+			_DUELER_2 = GenerateDueler();
+
+		if (CheckDueler(_DUELER_1) && CheckDueler(_DUELER_2))
+		{
+			if (ARENA_DUEL_GAMBLE_ENABLE)
+				SetState(ARENA_DUEL_STATE_GAMBLE);
+			else
+				SetState(ARENA_DUEL_STATE_DUEL);
+
+			TeleportDueler();
+			StartDuel();
+		}
+		else
+			SetState(ARENA_DUEL_STATE_END);
+
+
+		for (size_t i = 0; i < 4; i++)
+			if (GameObject *go = map->GetGameObject(_Pillar[i]))
+				go->SetGoState(GO_STATE_READY);
+	}
+
+	//Ñ¹×¢½×¶Î
+	if (GetState() == ARENA_DUEL_STATE_GAMBLE)
+	{
+		_GambleTimer += diff;
+
+		if (_GambleTimer > ARENA_DUEL_GAMBLE_TIME)
+		{
+			//ÏÂ×¢½áÊø
+			sWorld->SendScreenMessage("½áÊøÏÂ×¢£¬¾ö¶·ÏÖÔÚÕýÊ½¿ªÊ¼£¡");
+			SetState(ARENA_DUEL_STATE_DUEL);
+			CloseGamble();
+		}
+	}
+
+	//¿ªÊ¼¾ö¶·
+	if (GetState() == ARENA_DUEL_STATE_DUEL)
+	{
+		_DuelTimer += diff;
+
+		if (_DuelTimer > IN_MILLISECONDS)
+		{
+			if (CheckDueler(_DUELER_1))
+				_DUELER_1->AddAura(ARENA_DUEL_SEC_DEBUFF, _DUELER_1);
+
+			if (CheckDueler(_DUELER_2))
+				_DUELER_2->AddAura(ARENA_DUEL_SEC_DEBUFF, _DUELER_2);
+
+			_DuelTimer = 0;
+			_DuelSedcs++;
+
+			switch (_DuelSedcs)
+			{
+			case 0:
+				sWorld->SendScreenMessage("¾àÀëÑÛ¾¦Ë¢ÐÂ»¹ÓÐ10Ãë£¡");
+				break;
+			case 5:
+				TogglePillar(map);
+				break;
+			case 10:
+			{
+				TogglePillar(map);
+				sWorld->SendScreenMessage("ÑÛ¾¦Ë¢ÐÂÁË£¡");
+				uint32 i = urand(0, 3);
+				map->SummonGameObject(ARENA_DUEL_EYE_ENTRY, ARENA_DUEL_EYE_LOCATIONS[i].GetPositionX(), ARENA_DUEL_EYE_LOCATIONS[i].GetPositionY(), ARENA_DUEL_EYE_LOCATIONS[i].GetPositionZ(), ARENA_DUEL_EYE_LOCATIONS[i].GetOrientation(), 0, 0, 0, 0, 10);
+			}
+			break;
+			case 20:
+				TogglePillar(map);
+				_DuelSedcs = 0;
+				break;
+			default:
+				break;
+			}
+		}
+	}
+
+	//»î¶¯½áÊø
+	if (GetState() == ARENA_DUEL_STATE_END)
+	{
+		sWorld->SendScreenMessage("»î¶¯½áÊø£¡");
+
+		if (CheckDueler(_DUELER_1))
+		{
+			_DUELER_1->CastSpell(_DUELER_1, ARENA_DUEL_CHAMPION_SPELL);
+			sRew->Rew(_DUELER_1, ARENA_DUEL_CHAMPION_REW_ID);
+			std::string str = sCF->GetNameLink(_DUELER_1) + "»ñµÃÁË×îÖÕÊ¤Àû£¡";
+			sWorld->SendScreenMessage(str.c_str());
+		}
+
+		if (!map->GetPlayers().isEmpty())
+			for (Map::PlayerList::const_iterator itr = map->GetPlayers().begin(); itr != map->GetPlayers().end(); ++itr)
+				if (Player* pl = itr->GetSource())
+					if (pl->GetAreaId() == ARENA_DUEL_AREA_OUT || pl->GetAreaId() == ARENA_DUEL_AREA_IN)
+						sRew->Rew(pl, ARENA_DUEL_END_REW_ID);
+
+		map->SummonGameObject(ARENA_DUEL_IN_GOB, ARENA_DUEL_MID_LOCATIONS[0].GetPositionX() + (ARENA_DUEL_MID_LOCATIONS[1].GetPositionX() - ARENA_DUEL_MID_LOCATIONS[0].GetPositionX()) / 2,
+			ARENA_DUEL_MID_LOCATIONS[0].GetPositionY() + (ARENA_DUEL_MID_LOCATIONS[1].GetPositionY() - ARENA_DUEL_MID_LOCATIONS[0].GetPositionY()) / 2,
+			ARENA_DUEL_MID_LOCATIONS[0].GetPositionZ(),
+			ARENA_DUEL_MID_LOCATIONS[0].GetOrientation(), 0, 0, 0, 0, 30);
+
+		SetState(ARENA_DUEL_STATE_SIGNUP);
+
+		for (size_t i = 0; i < 4; i++)
+		{
+			if (GameObject *go = map->GetGameObject(_Pillar[i]))
+				go->RemoveFromWorld();
+
+			_Pillar[i] = 0;
+		}
+
+		sGameEventMgr->StopEvent(ARENA_DUEL_START_EVENT_ID, false, true);
+	}
+
+	//»î¶¯½øÐÐ¹ý³ÌÖÐ
+	if (GetState() == ARENA_DUEL_STATE_DUEL || GetState() == ARENA_DUEL_STATE_WAIT)
+	{
+		_RewTimer += diff;
+		if (_RewTimer > ARENA_DUEL_REW_INTERVALS)
+		{
+			_RewTimer = 0;
+
+			sWorld->SendScreenMessage("Î§¹Û½±Àø·¢·Å£¡");
+
+			if (!map->GetPlayers().isEmpty())
+				for (Map::PlayerList::const_iterator itr = map->GetPlayers().begin(); itr != map->GetPlayers().end(); ++itr)
+					if (Player* pl = itr->GetSource())
+						if (pl->GetAreaId() == ARENA_DUEL_AREA_OUT || pl->GetAreaId() == ARENA_DUEL_AREA_IN)
+							sRew->Rew(pl, ARENA_DUEL_PERMIN_REW_ID);
+		}
+	}
+
+	//´«ËÍ²»ÔÚ¾ö¶·ÖÐµÄÍæ¼Ò
+	_AreaCheckTimer += diff;
+	if (_AreaCheckTimer > 1000)
+	{
+		_AreaCheckTimer = 0;
+
+		if (!map->GetPlayers().isEmpty())
+			for (Map::PlayerList::const_iterator itr = map->GetPlayers().begin(); itr != map->GetPlayers().end(); ++itr)
+				if (Player* pl = itr->GetSource())
+					if (pl->GetAreaId() == ARENA_DUEL_AREA_IN && !IsDueler(pl))
+					{
+						TelePort(pl);
+						pl->GetSession()->SendNotification("¾ö¶·¹ý³ÌÖÐ½ûÖ¹ÎÞ¹ØÍæ¼Ò½øÈë¾º¼¼³¡ÇøÓò£¡");
+					}
+
+	}
+}
+
+void ArenaDuel::PopGamble()
+{
+	if (!CheckDueler(_DUELER_1) || !CheckDueler(_DUELER_2))
+		return;
+
+	_GambleTimer = 0;
+	AreaDuelGambleMap.clear();
+
+	SessionMap const& smap = sWorld->GetAllSessions();
+	for (SessionMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+		if (WorldSession* ss = iter->second)
+			if (Player* pl = ss->GetPlayer())
+			{
+				if (pl->GetGUID() == _DUELER_1->GetGUID() || pl->GetGUID() == _DUELER_2->GetGUID())
+					continue;
+
+				if (pl->GetAreaId() != ARENA_DUEL_AREA_IN && pl->GetAreaId() != ARENA_DUEL_AREA_OUT)
+					continue;
+
+				pl->PlayerTalkClass->ClearMenus();
+				pl->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/Icons/INV_BannerPVP_01:30:30:0:0|tÏÂ×¢[ºì¶Ó]»ñÊ¤ --> " + sCF->GetNameLink(_DUELER_1), GOSSIP_SENDER_MAIN, 1, "", 0, true);
+				pl->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/Icons/INV_BannerPVP_02:30:30:0:0|tÏÂ×¢[À¶¶Ó]»ñÊ¤ --> " + sCF->GetNameLink(_DUELER_2), GOSSIP_SENDER_MAIN, 2, "", 0, true);
+				pl->PlayerTalkClass->GetGossipMenu().SetMenuId(ARENA_DUEL_GAMBLE_MENU_ID);
+				pl->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, pl->GetGUID());
+			}
+}
+
+void ArenaDuel::CloseGamble()
+{
+	SessionMap const& smap = sWorld->GetAllSessions();
+	for (SessionMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+		if (WorldSession* ss = iter->second)
+			if (Player* pl = ss->GetPlayer())
+			{
+				if (pl->GetAreaId() != ARENA_DUEL_AREA_OUT && pl->GetAreaId() != ARENA_DUEL_AREA_IN)
+					continue;
+
+				pl->CLOSE_GOSSIP_MENU();
+			}
+}
+
+void ArenaDuel::EndGamble(bool redwin)
+{
+	uint32 red = 0;
+	uint32 blue = 0;
+	uint32 total = 0;
+
+	for (auto itr = AreaDuelGambleMap.begin(); itr != AreaDuelGambleMap.end(); itr++)
+	{
+		if (itr->second > 0)
+			red += itr->second;
+		else
+			blue += abs(itr->second);
+	}
+
+	total = red + blue;
+
+	if (total == 0)
+		return;
+
+	for (auto itr = AreaDuelGambleMap.begin(); itr != AreaDuelGambleMap.end(); itr++)
+	{
+		Player* pl = ObjectAccessor::FindPlayer(itr->first);
+
+		if (!pl)
+			continue;
+
+		if (redwin)
+		{
+			if (itr->second > 0)
+			{
+				if (red > 0)
+				{
+					uint32 x = itr->second * total / red;
+					sCF->UpdateTokenAmount(pl, x, true, "¾º¼¼³¡¾ö¶·¶Ä²©»ñÊ¤");
+					pl->GetSession()->SendAreaTriggerMessage("Ñ¹×¢[ºì¶Ó]³É¹¦£¬»ñµÃ%u[»ý·Ö]", x);
+				}
+			}
+			else
+				pl->GetSession()->SendAreaTriggerMessage("Ñ¹×¢[À¶¶Ó]Ê§°Ü");
+		}
+		else
+		{
+			if (itr->second < 0)
+			{
+				if (blue > 0)
+				{
+					uint32 x = abs(itr->second) * total / blue;
+					sCF->UpdateTokenAmount(pl, x, true, "¾º¼¼³¡¾ö¶·¶Ä²©»ñÊ¤");
+					pl->GetSession()->SendAreaTriggerMessage("Ñ¹×¢[À¶¶Ó]³É¹¦£¬»ñµÃ%u[»ý·Ö]", x);
+				}
+			}
+			else
+				pl->GetSession()->SendAreaTriggerMessage("Ñ¹×¢[ºì¶Ó]Ê§°Ü");
+		}
+	}
+}
+
+class ArenaDuelPlayerScript : PlayerScript
+{
+public:
+	ArenaDuelPlayerScript() : PlayerScript("ArenaDuelPlayerScript") {}
+
+	void OnDuelEnd(Player* winner, Player* loser, DuelCompleteType /*type*/)
+	{
+		if (!sGameEventMgr->IsActiveEvent(ARENA_DUEL_START_EVENT_ID))
+			return;
+
+		if (winner->GetAreaId() != ARENA_DUEL_AREA_IN)
+			return;
+
+		sArenaDuel->EndDuel(winner, loser);
+	}
+
+	void OnGossipSelectCode(Player* pl, uint32 menu_id, uint32 sender, uint32 action, const char* code)
+	{
+		if (menu_id != ARENA_DUEL_GAMBLE_MENU_ID)
+			return;
+
+		pl->CLOSE_GOSSIP_MENU();
+
+		int64 count = abs(atoi(code));
+
+		if (sCF->GetTokenAmount(pl) < count)
+		{
+			pl->GetSession()->SendNotification("[»ý·Ö]²»×ã");
+			return;
+		}
+
+		sCF->UpdateTokenAmount(pl, count, false, "¾º¼¼³¡¾ö¶·¶Ä²©Ñ¹×¢");
+
+		if (action == 1)
+			pl->GetSession()->SendAreaTriggerMessage("ÄãÏÂ×¢%u[»ý·Ö][%s]»ñÊ¤", count, "ºì¶Ó");
+		else if (action == 2)
+		{
+			pl->GetSession()->SendAreaTriggerMessage("ÄãÏÂ×¢%u[»ý·Ö][%s]»ñÊ¤", count, "À¶¶Ó");
+			count = -count;
+		}
+
+		AreaDuelGambleMap.insert(std::make_pair(pl->GetGUID(), count));
+	}
+};
+
+class ArenaDuelCreatureScript : public CreatureScript
+{
+public:
+	ArenaDuelCreatureScript() : CreatureScript("ArenaDuelCreatureScript") { }
+
+
+	bool OnGossipHello(Player* pl, Creature* c) override
+	{
+		pl->PlayerTalkClass->ClearMenus();
+
+		if (sArenaDuel->GetState() == ARENA_DUEL_STATE_SIGNUP)
+		{
+			auto itr = ArenaDuelMap.find(pl->GetGUIDLow());
+			if (itr != ArenaDuelMap.end())
+			{
+				pl->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "ÄãÒÑ¾­±¨¹ýÃûÁË£¡", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 2);
+			}
+			else
+			{
+				if (sMF->Pop(ARENA_DUEL_SIGNUP_REQ_ID))
+					pl->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "ÎÒÒª±¨Ãû", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF, sReq->Notice(pl, ARENA_DUEL_SIGNUP_REQ_ID, "¾º¼¼³¡¾ö¶·±¨Ãû", ""), sReq->Golds(ARENA_DUEL_SIGNUP_REQ_ID), false);
+				else
+					pl->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "ÎÒÒª±¨Ãû", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
+			}
+		}
+		else
+			pl->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "¾º¼¼³¡±¨ÃûÒÑ¾­½áÊø£¬¹ýÈ¥Î§¹Û", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+
+		pl->SEND_GOSSIP_MENU(c->GetEntry(), c->GetGUID());
+
+		return true;
+	}
+
+	bool OnGossipSelect(Player* pl, Creature* creature, uint32 sender, uint32 action) override
+	{
+		if (action == GOSSIP_ACTION_INFO_DEF)
+		{
+			sArenaDuel->Signup(pl);
+			pl->GetSession()->SendAreaTriggerMessage("±¨Ãû³É¹¦£¡");
+		}
+		else if (action == GOSSIP_ACTION_INFO_DEF + 1)
+			sArenaDuel->TelePort(pl);
+
+		pl->CLOSE_GOSSIP_MENU();
+
+		return true;
+	}
+};
+
+void AddSC_ArenaDuel()
+{
+	new ArenaDuelPlayerScript();
+	new ArenaDuelCreatureScript();
+}
diff --git a/src/server/scripts/Custom/CustomEvent/ArenaDuel/ArenaDuel.h b/src/server/scripts/Custom/CustomEvent/ArenaDuel/ArenaDuel.h
new file mode 100644
index 0000000..50c83c1
--- /dev/null
+++ b/src/server/scripts/Custom/CustomEvent/ArenaDuel/ArenaDuel.h
@@ -0,0 +1,116 @@
+ï»¿#define ARENA_DUEL_START_EVENT_ID			101
+#define ARENA_DUEL_SIGNUP_EVENT_ID			100
+#define ARENA_DUEL_PILLAR_ENTRY				194587
+#define ARENA_DUEL_EYE_ENTRY				184663
+#define ARENA_DUEL_MAP						0
+#define ARENA_DUEL_AREA_IN					2177
+#define ARENA_DUEL_AREA_OUT					1741
+#define ARENA_DUEL_WAIT_SECS				10
+#define ARENA_DUEL_REW_INTERVALS			60 * IN_MILLISECONDS
+#define ARENA_DUEL_GAMBLE_TIME				15 * IN_MILLISECONDS
+#define ARENA_DUEL_SIGNUP_REQ_ID			1001		//_req æ¥åéæ±
+#define ARENA_DUEL_PERMIN_REW_ID			1000		//_rew æ¯åéå¥å±
+#define ARENA_DUEL_END_REW_ID				1001		//_rew æ´»å¨ç»ææ¯äººå¥å±
+#define ARENA_DUEL_WIN_REW_ID				1002		//_rew å³æè·èå¥å±
+#define ARENA_DUEL_LOS_REW_ID				1003		//_rew å³æå¤±è´¥å¥å±
+#define ARENA_DUEL_CHAMPION_REW_ID			1004		//_rew å åå¥å±
+#define ARENA_DUEL_LOSER_SPELL				80900		//å¤±è´¥èæè½
+#define ARENA_DUEL_CHAMPION_SPELL			80901		//æç»èå©èæè½
+#define	ARENA_DUEL_IN_GOB					700001		//ç»æä¸­é´å®ç®±
+#define ARENA_DUEL_SEC_DEBUFF				2000021		//æ¯ç§å BUFF
+#define ARENA_DUEL_FLAG_1					2000022		//çº¢é
+#define ARENA_DUEL_FLAG_2					2000023		//èé
+#define ARENA_DUEL_FREEZE_DEBUFF			2000024		//ç©å®¶å»ç»
+#define ARENA_DUEL_GAMBLE_MENU_ID			7779
+
+#define ARENA_DUEL_GAMBLE_ENABLE			false
+
+struct ArenaDuelTemplate
+{
+	bool selected;
+	uint32 winNum;
+};
+
+extern std::map<uint32, ArenaDuelTemplate> ArenaDuelMap;
+
+enum ArenaDuelStates
+{
+	ARENA_DUEL_STATE_SIGNUP,
+	ARENA_DUEL_STATE_START,
+	ARENA_DUEL_STATE_SELECT,
+	ARENA_DUEL_STATE_GAMBLE,
+	ARENA_DUEL_STATE_DUEL,
+	ARENA_DUEL_STATE_WAIT,
+	ARENA_DUEL_STATE_END,
+};
+
+enum ArenaDuelGroupType
+{
+	ARENA_DUEL_GROUP_RED,
+	ARENA_DUEL_GROUP_BLUE,
+};
+
+extern std::unordered_map<uint64, int64> AreaDuelGambleMap;
+
+class ArenaDuel
+{
+public:
+	static ArenaDuel* instance()
+	{
+		static ArenaDuel instance;
+		return &instance;
+	}
+
+	void Load();
+	void Signup(Player* pl);
+	void Save(Player* pl);
+
+	void SetState(ArenaDuelStates state);
+	ArenaDuelStates GetState(){ return _State; }
+
+	void Update(Map* map, uint32 diff);
+
+	void TelePortAll();
+	void TelePort(Player* pl);
+	void TeleportDueler();
+
+	bool HasDueler();
+	bool CheckDueler(Player* dueler)
+	{
+		if (!dueler || !dueler->IsInWorld() || dueler->GetMapId() != ARENA_DUEL_MAP)
+			return false;
+
+		return true;
+	}
+	Player* GenerateDueler();
+	void StartDuel();
+	void EndDuel(Player* winner, Player* loser);
+
+	bool IsDueler(Player* pl);
+
+	void TogglePillar(Map * map);
+
+	void InitPlayer(Player* pl);
+
+	void PopGamble();
+	void CloseGamble();
+	void EndGamble(bool redwin);
+private:
+
+	Player* _DUELER_1;
+	Player* _DUELER_2;
+
+	ArenaDuelStates _State;
+	uint32 _RewTimer;
+	uint32 _DuelTimer;
+	uint32 _DuelSedcs;
+	uint32 _WaitTimer;
+	uint32 _WaitSecs;
+	uint32 _AreaCheckTimer;
+	uint32 _PillarTimer;
+	uint64 _Pillar[4];
+	uint32 _GambleTimer;
+};
+
+#define sArenaDuel ArenaDuel::instance()
+
diff --git a/src/server/scripts/Custom/CustomEvent/BattleIC/BattleIC.cpp b/src/server/scripts/Custom/CustomEvent/BattleIC/BattleIC.cpp
new file mode 100644
index 0000000..3a16d38
--- /dev/null
+++ b/src/server/scripts/Custom/CustomEvent/BattleIC/BattleIC.cpp
@@ -0,0 +1,568 @@
+#pragma execution_character_set("utf-8")
+#include "BattleIC.h"
+#include "../Event.h"
+#include "Transport.h"
+#include "BattlegroundIC.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
+#include "../Custom/Reward/Reward.h"
+
+int BGICSort(const std::pair<uint64, BGICPlayerScore>& x, const std::pair<uint64, BGICPlayerScore>& y)
+{
+	return x.second.kills > y.second.kills;
+}
+
+void BGICSortMapByValue(std::unordered_map<uint64, BGICPlayerScore>& tMap, std::vector<std::pair<uint64, BGICPlayerScore> >& tVector)
+{
+	for (std::unordered_map<uint64, BGICPlayerScore>::iterator curr = tMap.begin(); curr != tMap.end(); curr++)
+		tVector.push_back(std::make_pair(curr->first, curr->second));
+
+	sort(tVector.begin(), tVector.end(), BGICSort);
+}
+
+void BGIC::Stop()
+{
+	std::vector<std::pair<uint64, BGICPlayerScore>> tVector;
+	BGICSortMapByValue(_PlayersMap, tVector);
+
+	std::ostringstream oss;
+	std::ostringstream oss1;
+	uint32 count = 0;
+
+	oss << "³Ô¼¦°ñ\n\n";
+
+	for (auto itr = _PlayersMap.begin(); itr != _PlayersMap.end(); itr++)
+	{
+		if (count > BGIC_DISPLAY_MAX)
+			break;
+
+		if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+		{
+			count++;
+			oss << sCF->GetNameLink(pl) << " - " << itr->second.kills << "\n";
+		}	
+	}
+
+	for (auto itr = _PlayersMap.begin(); itr != _PlayersMap.end(); itr++)
+	{
+		if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+		{
+			if (itr == _PlayersMap.begin())
+			{
+				oss1 << "\n´ó¼ª´óÀû£¬½ñÍí³Ô¼¦£¡\n";
+				oss1 << "\nÄãµÄ¸öÈËÕ½¼¨" << " - " << itr->second.kills << "\n";
+				sRew->Rew(pl, BGIC_SSS_REWARD_ID);
+				sCF->SendAcceptOrCancel(pl, 0, oss.str() + oss1.str());
+			}
+			else
+			{
+				oss1 << "ÄãµÄ¸öÈËÕ½¼¨" << " - " << itr->second.kills;
+				sRew->Rew(pl, BGIC_REWARD_ID, itr->second.kills);
+				sCF->SendAcceptOrCancel(pl, 0, oss.str() + oss1.str());
+			}
+		}
+	}
+
+	Reset();
+}
+
+void BGIC::InitParams(uint32 eventId, Map* map)
+{
+	if (eventId != BGIC_EVENT_ID)
+		return;
+
+	if (!map || map->GetId() != BGIC_EVENT_MAP)
+		return;
+
+	_Map = map;
+
+	for (size_t i = 110; i <= 475; i++)
+		_PosionNpcPosVec.push_back(i);
+
+
+	_DieLootItemMap.insert(std::make_pair(25, 100));
+
+	if (gunshipHorde = sTransportMgr->CreateTransport(GO_HORDE_GUNSHIP))
+		gunshipHorde->EnableMovement(true);
+
+	if (gunshipAlliance = sTransportMgr->CreateTransport(GO_ALLIANCE_GUNSHIP))
+		gunshipAlliance->EnableMovement(true);
+}
+
+void BGIC::Reset()
+{
+	_Timer = 0;
+	_SpawnUpdateTimer = 0;
+	_PosionNpcPosVec.clear();
+	_ChestGobPosVec.clear();
+	_DieLootItemMap.clear();
+	_PlayersMap.clear();
+
+	if (gunshipHorde)
+	{
+		gunshipHorde->CleanupsBeforeDelete();
+		gunshipHorde->AddObjectToRemoveList();
+		gunshipHorde = NULL;
+	}
+
+	if (gunshipAlliance)
+	{
+		gunshipAlliance->CleanupsBeforeDelete();
+		gunshipAlliance->AddObjectToRemoveList();
+		gunshipAlliance = NULL;
+	}
+
+	if (_Map)
+		for (auto itr = _PoisonNpcGUIDVec.begin(); itr != _PoisonNpcGUIDVec.end(); itr++)
+			if (Creature* c = _Map->GetCreature(*itr))
+				c->RemoveFromWorld();
+
+	_Map = NULL;
+}
+
+void BGIC::AddPlayer(Player* pl)
+{
+	BGICPlayerScore Temp;
+	Temp.kills = 0;
+	Temp.killeds = 0;
+	_PlayersMap.insert(std::make_pair(pl->GetGUID(), Temp));
+	InitPlayer(pl);
+	TeleToShip(pl);
+	SetHealth(NULL, pl, BGIC_HEALTH_MAX);
+}
+
+void BGIC::RemovePlayer(Player* pl)
+{
+	auto itr = _PlayersMap.find(pl->GetGUID());
+	if (itr != _PlayersMap.end())
+	{
+		_PlayersMap.erase(itr);
+		ChatHandler(pl->GetSession()).PSendSysMessage("ÄãÒÑ¾­Àë¿ª³Ô¼¦Õ½³¡£¡");
+		ResetPlayer(pl);
+	}	
+}
+
+void BGIC::InitPlayer(Player* pl)
+{
+	//if (!pl->IsAlive())
+	//{
+	//	pl->ResurrectPlayer(1.0f);
+	//	pl->SpawnCorpseBones();
+	//}
+	//
+	//pl->SetHealth(1000);
+	//pl->SetMaxHealth(1000);
+}
+
+void BGIC::ResetPlayer(Player* pl)
+{
+	if (!pl->IsAlive())
+	{
+		pl->ResurrectPlayer(1.0f);
+		pl->SpawnCorpseBones();
+	}
+
+	pl->UpdateMaxHealth();
+}
+
+void BGIC::TeleToShip(Player* pl)
+{
+	uint32 random = urand(TEAM_ALLIANCE, TEAM_HORDE);
+
+	MotionTransport* transport = random == TEAM_ALLIANCE ? gunshipAlliance : gunshipHorde;
+	float x = BG_IC_HangarTrigger[random].GetPositionX();
+	float y = BG_IC_HangarTrigger[random].GetPositionY();
+	float z = BG_IC_HangarTrigger[random].GetPositionZ();
+
+	if (transport)
+	{
+		transport->CalculatePassengerPosition(x, y, z);
+		pl->TeleportTo(pl->GetMapId(), x, y, z + 1.0f, pl->GetOrientation(), TELE_TO_NOT_LEAVE_TRANSPORT);
+		transport->AddPassenger(pl, true);
+	}
+	
+	
+
+	//if (!Valid(pl))
+	//	return;
+	//
+	//pl->SetUnderACKmount();
+	//
+	//MotionTransport* gunship;
+	//float offset_z = 0;
+	//
+	//if (urand(0, 1) == 1)
+	//{
+	//	offset_z = 25.0f;
+	//	gunship = gunshipAlliance;
+	//}	
+	//else
+	//{
+	//	offset_z = 35.0f;
+	//	gunship = gunshipHorde;
+	//}
+	//	
+	//if (gunship)
+	//{
+	//	pl->TeleportTo(BGIC_EVENT_MAP, gunship->RealPosition.GetPositionX(), gunship->RealPosition.GetPositionY(), gunship->RealPosition.GetPositionZ() + offset_z, gunship->RealPosition.GetOrientation() + 3.13f, TELE_TO_NOT_LEAVE_TRANSPORT);
+	//	gunship->AddPassenger(pl, true);
+	//}
+}
+
+void BGIC::UpdateSpawn(uint32 diff)
+{
+	if (!_Map)
+		return;
+
+	_Timer += diff;
+	
+	//for (auto itr = _PlayersMap.begin(); itr != _PlayersMap.end(); itr++)
+	//	if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+	//	{
+	//
+	//		float x = gunshipAlliance->RealPosition.GetPositionX();
+	//		float y = gunshipAlliance->RealPosition.GetPositionY();
+	//		float z = gunshipAlliance->RealPosition.GetPositionZ() + 21.0f;
+	//		pl->SetTelePortDest(BGIC_EVENT_MAP, x, y, z,pl->GetOrientation());
+	//	}
+
+	if (_Timer < IN_MILLISECONDS)
+		return;
+
+	//for(auto itr = _PlayersMap.begin(); itr != _PlayersMap.end(); itr++)
+	//if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+	//{
+	//	float x = gunshipAlliance->RealPosition.GetPositionX();
+	//	float y = gunshipAlliance->RealPosition.GetPositionY();
+	//	float z = gunshipAlliance->RealPosition.GetPositionZ() + 21.0f;
+	//
+	//	if (pl->GetDistance(x, y, z) > 1.0f)
+	//	{
+	//		pl->TeleportTo(BGIC_EVENT_MAP, x, y, z, gunshipAlliance->RealPosition.GetOrientation() + 3.13f, TELE_TO_NOT_LEAVE_TRANSPORT);
+	//		pl->GetSession()->SendNotification("tele");
+	//	}
+	//
+	//}
+	//
+			;//;pl->SetTelePortDest(BGIC_EVENT_MAP, gunshipAlliance->RealPosition.GetPositionX(), gunshipAlliance->RealPosition.GetPositionY(), gunshipAlliance->RealPosition.GetPositionZ() + 20.66, gunshipAlliance->RealPosition.GetOrientation() + 3.13f);
+
+	_Timer = 0;
+
+	_SpawnUpdateTimer += 1;
+
+	if (!_PosionNpcPosVec.empty())
+	{
+		uint32 i = urand(0, _PosionNpcPosVec.size() - 1);
+		uint32 posId = _PosionNpcPosVec[i];
+		auto itr = _PosionNpcPosVec.begin() + i;
+		_PosionNpcPosVec.erase(itr);
+
+		uint32 _map = 0;
+		float x = 0;
+		float y = 0;
+		float z = 0;
+		float o = 0;
+		sEvent->GetTelePos(posId, _map, x, y, z, o);
+
+		if (_map != 0)
+		{
+			Position pos;
+			pos.Relocate(x, y, z, o);
+			if (Creature* c = _Map->SummonCreature(BGIC_NPC_POSION, pos))//, 0, 2 * 60 * IN_MILLISECONDS))
+				_PoisonNpcGUIDVec.push_back(c->GetGUID());
+		}
+	}
+}
+
+bool BGIC::InWar(Player* pl)
+{
+	if (pl->GetMapId() != BGIC_EVENT_MAP)
+		return false;
+
+	if (pl->GetBattleground())
+		return false;
+
+	return true;
+}
+
+void BGIC::OnPVPKill(Player* killer, Player* victim)
+{
+	if (!InWar(killer) || !InWar(victim))
+		return;
+
+	std::string text = "³Ô¼¦Õ½³¡:" + sCF->GetNameLink(killer) + "»÷É±ÁË" + sCF->GetNameLink(victim) + "!";
+
+	if (GameObject* chest = victim->SummonGameObject(BGIC_GOB_KILL_CHEST, victim->GetPositionX(), victim->GetPositionY(), victim->GetPositionZ(), 0, 0, 0, 0, 0, 0))
+	{
+		for (size_t slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+		{
+			Item * item = victim->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+
+			if (!item)
+				continue;
+
+			uint32 entry = item->GetEntry();
+
+			auto itr = _DieLootItemMap.find(entry);
+
+			if (itr == _DieLootItemMap.end())
+				continue;
+
+			if (!roll_chance_f(itr->second))
+				continue;
+
+			victim->DestroyItem(item->GetBagSlot(), item->GetSlot(), true);
+
+			chest->LootExtraItems.insert(std::make_pair(entry, 1));
+		}
+
+		if (!chest->LootExtraItems.empty())
+		{
+			for (auto itr = chest->LootExtraItems.begin(); itr != chest->LootExtraItems.end(); itr++)
+				text += sCF->GetItemLink(itr->first);
+
+			text += "ÒÑµôÂä£¡";
+		}
+			
+	}
+
+	SendScreenMessage(text);
+
+	InitPlayer(victim);
+	TeleToShip(victim);
+
+	for (auto itr = _PlayersMap.begin(); itr != _PlayersMap.end(); itr++)
+	{
+		if (itr->first == victim->GetGUID())
+			itr->second.killeds++;
+		else if (itr->first == killer->GetGUID())
+			itr->second.kills++;
+	}	
+}
+
+void BGIC::OnCreatureKill(Creature* creature, Player* victim)
+{
+	if (!InWar(victim))
+		return;
+
+	std::string text = "³Ô¼¦Õ½³¡:" + sCF->GetNameLink(victim) + "±»¾ç¶¾ÍÌÊÉ!";
+
+	if (GameObject* chest = victim->SummonGameObject(BGIC_GOB_KILL_CHEST, victim->GetPositionX(), victim->GetPositionY(), victim->GetPositionZ(), 0, 0, 0, 0, 0, 0))
+	{
+		for (size_t slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+		{
+			Item * item = victim->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+
+			if (!item)
+				continue;
+
+			uint32 entry = item->GetEntry();
+
+			auto itr = _DieLootItemMap.find(entry);
+
+			if (itr == _DieLootItemMap.end())
+				continue;
+
+			if (!roll_chance_f(itr->second))
+				continue;
+
+			victim->DestroyItem(item->GetBagSlot(), item->GetSlot(), true);
+
+			chest->LootExtraItems.insert(std::make_pair(entry, 1));
+		}
+
+		if (!chest->LootExtraItems.empty())
+		{
+			for (auto itr = chest->LootExtraItems.begin(); itr != chest->LootExtraItems.end(); itr++)
+				text += sCF->GetItemLink(itr->first);
+
+			text += "ÒÑµôÂä£¡";
+		}
+	}
+
+	SendScreenMessage(text);
+
+	InitPlayer(victim);
+	TeleToShip(victim);
+}
+
+void BGIC::SendScreenMessage(std::string text)
+{
+	if (text.empty())
+		return;
+
+	WorldPacket data;
+	ChatHandler::BuildChatPacket(data, CHAT_MSG_RAID_BOSS_EMOTE, LANG_UNIVERSAL,
+		NULL, NULL, text);
+
+	for (auto itr = _PlayersMap.begin(); itr != _PlayersMap.end(); itr++)
+		if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+			if (WorldSession* ss = pl->GetSession())
+				pl->GetSession()->SendPacket(&data);
+}
+
+void BGIC::CheckStop()
+{
+	uint32 max = 0;
+	for (auto itr = _PlayersMap.begin(); itr != _PlayersMap.end(); itr++)
+		if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+			if (itr->second.kills >= max)
+				max = itr->second.kills;
+
+	if (max >= BGIC_STOP_KILLS)
+		Stop();
+}
+
+bool BGIC::Valid(Unit* caster)
+{
+	if (!caster || !_Map || _Map->GetId() != BGIC_EVENT_MAP || caster->GetTypeId() != TYPEID_PLAYER || caster->ToPlayer()->InBattleground() || caster->GetMapId() != BGIC_EVENT_MAP)
+		return false;
+
+	return true;
+}
+
+bool BGIC::IsAllowed(Unit* caster, uint32 spellId)
+{
+	if (!Valid(caster))
+		return false;
+
+	//ÒÔÏÂ¼¼ÄÜÔÊÐíÆ½¾²×´Ì¬ÏÂÊ¹ÓÃ
+	return false;
+}
+
+void BGIC::SetHealth(Player* attacker, Player* victim, int32 val)
+{
+	if (attacker)
+	{
+		if (val <= 0)
+		{
+			OnPVPKill(attacker, victim);
+			CheckStop();
+			val = BGIC_HEALTH_MAX;
+		}
+	}
+	
+	if (val > BGIC_HEALTH_MAX)
+		val = BGIC_HEALTH_MAX;
+
+	victim->SetUInt32Value(UNIT_FIELD_HEALTH, val);
+	victim->SetUInt32Value(UNIT_FIELD_MAXHEALTH, BGIC_HEALTH_MAX);
+}
+
+class BGICPlayerScript : PlayerScript
+{
+public:
+	BGICPlayerScript() : PlayerScript("BGICPlayerScript") {}
+
+	void OnCreatureKill(Player* player, Creature* creature)
+	{
+		
+	}
+
+	void OnUseGameObject(Player* player, GameObject* gob)
+	{
+		
+	}
+
+	void OnPVPKill(Player* killer, Player* killed)
+	{
+		sBGIC->OnPVPKill(killer, killed);
+		sBGIC->CheckStop();
+	}
+
+	void OnPlayerKilledByCreature(Creature* killer, Player* killed)
+	{
+		sBGIC->OnCreatureKill(killer, killed);
+	}
+
+	void OnUpdateZone(Player* player, uint32 newZone, uint32 /*newArea*/)
+	{
+		
+	}
+
+	void OnMapChanged(Player* player)
+	{
+		sBGIC->RemovePlayer(player);
+	}
+};
+
+
+class spell_bgic_shoot : public SpellScriptLoader
+{
+public:
+	spell_bgic_shoot() : SpellScriptLoader("spell_bgic_shoot") { }
+
+	class spell_bgic_shoot_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_bgic_shoot_SpellScript);
+
+		bool Load()
+		{
+			_x = _y = _z = 0.0f;
+			return true;
+		}
+
+		SpellCastResult Cast()
+		{
+			Unit* caster = GetCaster();
+			//float o = Position::NormalizeOrientation(caster->GetOrientation() + frand(0.0f, 2 * M_PI));
+			//float dist = frand(5.0f, 30.0f);
+			//_x = caster->GetPositionX() + dist*cos(o);
+			//_y = caster->GetPositionY() + dist*sin(o);
+			//_z = caster->GetPositionZ() + frand(-10.0f, 15.0f);
+			//GetSpell()->m_targets.SetDst(_x, _y, _z, 0.0f, caster->GetMapId());
+
+
+			float x = GetSpell()->m_targets.GetDstPos()->GetPositionX();
+			float y = GetSpell()->m_targets.GetDstPos()->GetPositionY();
+			float z = GetSpell()->m_targets.GetDstPos()->GetPositionZ();
+
+			Creature* victim = caster->FindNearestCreature(3, 100);
+
+			Position srcPos;
+			srcPos.m_positionX = caster->GetPositionX();
+			srcPos.m_positionY = caster->GetPositionY();
+			srcPos.m_positionZ = caster->GetPositionZ();
+
+			Position victimPos;
+			victimPos.m_positionX = victim->GetPositionX();
+			victimPos.m_positionY = victim->GetPositionY();
+			victimPos.m_positionZ = victim->GetPositionZ();
+
+			if ((&srcPos)->HasInArc(1.0f,(&victimPos)))
+
+
+			//if (caster->isInFrontInMap(victim, caster->GetDistance(x,y,z), 1))
+				ChatHandler(caster->ToPlayer()->GetSession()).PSendSysMessage("2");
+
+
+			return SPELL_CAST_OK;
+		}
+
+		void ChangeDest(SpellEffIndex effIndex)
+		{
+			PreventHitDefaultEffect(effIndex);
+		}
+
+	
+		void Register()
+		{
+			OnCheckCast += SpellCheckCastFn(spell_bgic_shoot_SpellScript::Cast);
+			OnEffectHit += SpellEffectFn(spell_bgic_shoot_SpellScript::ChangeDest, EFFECT_0, SPELL_EFFECT_TRIGGER_MISSILE);		
+		}
+
+	private:
+		float _x, _y, _z;
+	};
+
+	SpellScript* GetSpellScript() const
+	{
+		return new spell_bgic_shoot_SpellScript();
+	}
+};
+
+
+void AddSC_BGICScript()
+{
+	new BGICPlayerScript();
+	new spell_bgic_shoot();
+}
diff --git a/src/server/scripts/Custom/CustomEvent/BattleIC/BattleIC.h b/src/server/scripts/Custom/CustomEvent/BattleIC/BattleIC.h
new file mode 100644
index 0000000..871e9b8
--- /dev/null
+++ b/src/server/scripts/Custom/CustomEvent/BattleIC/BattleIC.h
@@ -0,0 +1,63 @@
+#define BGIC_HEALTH_MAX 100
+
+enum BGICNpcs
+{
+	BGIC_NPC_POSION = 37690,
+};
+
+enum BGICGobs
+{
+	BGIC_GOB_CHEST = 1,
+	BGIC_GOB_KILL_CHEST = 2849,
+};
+
+struct BGICPlayerScore
+{
+	uint32 kills;
+	uint32 killeds;
+};
+
+class BGIC
+{
+public:
+	static BGIC* instance()
+	{
+		static BGIC instance;
+		return &instance;
+	}
+
+public:
+	void Stop();
+	void InitParams(uint32 eventId, Map* map);
+	void Reset();
+	void UpdateSpawn(uint32 diff);
+	void OnPVPKill(Player* killer, Player* victim);
+	bool InWar(Player* pl);
+	void AddPlayer(Player* pl);
+	void RemovePlayer(Player* pl);
+	void InitPlayer(Player* pl);
+	void ResetPlayer(Player* pl);
+	void TeleToShip(Player* pl);
+	void OnCreatureKill(Creature* creature, Player* victim);
+	void SendScreenMessage(std::string text);
+	void CheckStop();
+	bool Valid(Unit* caster);
+	bool IsAllowed(Unit* caster, uint32 spellId);
+	void SetHealth(Player* attacker,Player* victim, int32 val);
+
+private:
+	std::vector<uint32> _PosionNpcPosVec;
+	std::vector<uint64> _PoisonNpcGUIDVec;
+	std::vector<uint32> _ChestGobPosVec;
+	std::unordered_map<uint32,float> _DieLootItemMap;
+	uint32 _SpawnUpdateTimer;
+	uint32 _Timer;
+
+	MotionTransport* gunshipAlliance;
+	MotionTransport* gunshipHorde;
+	Map* _Map;
+	std::unordered_map<uint64, BGICPlayerScore> _PlayersMap;
+
+	Creature* _TeleportTrigger;
+};
+#define sBGIC BGIC::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/CustomEvent/CustomEvent.cpp b/src/server/scripts/Custom/CustomEvent/CustomEvent.cpp
new file mode 100644
index 0000000..9d62b5f
--- /dev/null
+++ b/src/server/scripts/Custom/CustomEvent/CustomEvent.cpp
@@ -0,0 +1,2440 @@
+//#pragma execution_character_set("utf-8")
+//#include "Event.h"
+//#include "GameEventMgr.h"
+//#include "Battleground.h"
+//#include "BattlegroundMgr.h"
+//#include "../CustomEvent/FixedTimeBG/FixedTimeBG.h"
+//#include "../Reward/Reward.h"
+//#include "GroupMgr.h"
+//#include "Group.h"
+//#include "../FakePlayers/FakePlayers.h"
+//#include "ThunderbluffBattle/ThunderbluffBattle.h"
+//#include "../AuthCheck/AuthCheck.h"
+//#include "../CommonFunc/CommonFunc.h"
+//#include "SACity/SA.h"
+//#include "../QuickResponse/QuickResponse.h"
+//#include "../Talisman/Talisman.h"
+//#include "../FunctionCollection/FunctionCollection.h"
+//#include "UnknownBG/UnknownBG.h"
+//#include "../Command/CustomCommand.h"
+//#include "WaypointManager.h"
+//#include "MapManager.h"
+//// load db
+//
+//std::unordered_map<uint32, EventDataTemplate> EventDataMap;
+//std::vector<EventActiveTemplate> EventActiveVec;
+//
+//
+///*»÷É±ÉúÎï*/
+//std::unordered_map<uint32/*creature entry*/, uint32> KillCreatureMap;
+///*´Ý»ÙÎïÌå*/
+//std::unordered_map<uint32/*gob entry*/, uint32> DestroyGobMap;
+///*»÷É±Íæ¼Ò*/
+//std::unordered_map<TeamTypes/*event team*/, uint32> KillPlayerMap;
+///*Íæ¼ÒÐÅÏ¢*/
+//std::unordered_map<uint32/*guid*/, EventPlayerTemplate> PlayerDataMap;
+///*¶ÓÎéÐÅÏ¢*/
+//std::unordered_map<uint32/*guid*/, TeamTypes> GroupDataMap;
+//
+//void CustomEvent::Load()
+//{
+//	EventDataMap.clear();
+//	EventActiveVec.clear();
+//
+//	QueryResult result = WorldDatabase.PQuery("SELECT eventEntry,description,gossipText,noticeText,event_type,group_type,rejoin_type,start_defense_pos,start_offense_pos,defenseName,offenseName,zone_id FROM game_event WHERE eventEntry >= 70");
+//	if (result)
+//	{
+//		do
+//		{
+//			//¼ÓÔØdata
+//			Field* fields = result->Fetch();
+//			uint32 eventId = fields[0].GetUInt32();
+//			EventDataTemplate Temp;
+//			Temp.eventName			= fields[1].GetString();
+//			Temp.gossipText			= fields[2].GetString();
+//			Temp.noticeText			= fields[3].GetString();
+//			Temp.eventType			= EventTypes(fields[4].GetUInt32());
+//			Temp.groupType			= GroupTypes(fields[5].GetUInt32());
+//			Temp.rejoinType			= RejoinTypes(fields[6].GetUInt32());
+//			Temp.startDefensePos	= fields[7].GetUInt32();
+//			Temp.startOffensePos	= fields[8].GetUInt32();
+//			Temp.defenseName		= fields[9].GetString();
+//			Temp.offenseName		= fields[10].GetString();
+//			Temp.zoneId				= fields[11].GetUInt32();
+//
+//			Temp.eventPhaseMap.clear();
+//
+//			Temp.rew_winRewId = 0;
+//			Temp.rew_losRewId = 0;
+//			Temp.rew_killsForRew = 0;
+//			Temp.rew_killedsForRew = 0;
+//			Temp.rew_damageForRew = 0;
+//			Temp.rew_healForRew = 0;
+//			Temp.stop_creature1 = 0;
+//			Temp.stop_creatureCount1 = 0;
+//			Temp.stop_creature2 = 0;
+//			Temp.stop_creatureCount2 = 0;
+//			Temp.stop_creature3 = 0;
+//			Temp.stop_creatureCount3 = 0;
+//			Temp.stop_creature4 = 0;
+//			Temp.stop_creatureCount4 = 0;
+//			Temp.stop_creature5 = 0;
+//			Temp.stop_creatureCount5 = 0;
+//			Temp.stop_gameobject1 = 0;
+//			Temp.stop_gameobjectCount1 = 0;
+//			Temp.stop_gameobject2 = 0;
+//			Temp.stop_gameobjectCount2 = 0;
+//			Temp.stop_gameobject3 = 0;
+//			Temp.stop_gameobjectCount3 = 0;
+//			Temp.stop_gameobject4 = 0;
+//			Temp.stop_gameobjectCount4 = 0;
+//			Temp.stop_gameobject5 = 0;
+//			Temp.stop_gameobjectCount5 = 0;
+//			Temp.stop_defenseKills = 0;
+//			Temp.stop_offenseKills = 0;
+//			Temp.stop_killGaps = 0;
+//			Temp.state_creature1 = 0;
+//			Temp.state_creatureWorldState1 = 0;
+//			Temp.state_creature2 = 0;
+//			Temp.state_creatureWorldState2 = 0;
+//			Temp.state_creature3 = 0;
+//			Temp.state_creatureWorldState3 = 0;
+//			Temp.state_gameobject1 = 0;
+//			Temp.state_gameobjectWorldState1 = 0;
+//			Temp.state_gameobject2 = 0;
+//			Temp.state_gameobjectWorldState2 = 0;
+//			Temp.state_gameobject3 = 0;
+//			Temp.state_gameobjectWorldState3 = 0;
+//			Temp.state_defenseWorldState = 0;
+//			Temp.state_offenseWorldState = 0;
+//			EventDataMap.insert(std::make_pair(eventId, Temp));
+//
+//		} while (result->NextRow());
+//	}
+//
+//	//¼ÓÔØWorldStateVec
+//	result = WorldDatabase.PQuery("SELECT eventId,creature1,creatureWorldState1,creature2,creatureWorldState2,creature3,creatureWorldState3,gameobject1,gameobjectWorldState1,gameobject2,gameobjectWorldState2,gameobject3,gameobjectWorldState3,defenseWorldState,offenseWorldState FROM _game_event_world_state");
+//	if (result)
+//	{
+//		do
+//		{
+//			Field* fields = result->Fetch();
+//			uint32 eventId = fields[0].GetUInt32();
+//
+//			std::unordered_map<uint32, EventDataTemplate>::iterator iter = EventDataMap.find(eventId);
+//		
+//			if (iter != EventDataMap.end())
+//			{
+//				iter->second.state_creature1 = fields[1].GetUInt32();
+//				iter->second.state_creatureWorldState1 = fields[2].GetUInt32();
+//				iter->second.state_creature2 = fields[3].GetUInt32();
+//				iter->second.state_creatureWorldState2 = fields[4].GetUInt32();
+//				iter->second.state_creature3 = fields[5].GetUInt32();
+//				iter->second.state_creatureWorldState3 = fields[6].GetUInt32();
+//				iter->second.state_gameobject1 = fields[7].GetUInt32();
+//				iter->second.state_gameobjectWorldState1 = fields[8].GetUInt32();
+//				iter->second.state_gameobject2 = fields[9].GetUInt32();
+//				iter->second.state_gameobjectWorldState2 = fields[10].GetUInt32();
+//				iter->second.state_gameobject3 = fields[11].GetUInt32();
+//				iter->second.state_gameobjectWorldState3 = fields[12].GetUInt32();
+//				iter->second.state_defenseWorldState = fields[13].GetUInt32();
+//				iter->second.state_offenseWorldState = fields[14].GetUInt32();
+//			}
+//		} while (result->NextRow());
+//	}
+//
+//	//¼ÓÔØRewVec
+//	result = WorldDatabase.PQuery("SELECT eventId,winRewId,losRewId,killsForRew,killedsForRew,damageForRew,healForRew FROM _game_event_rew_setting");
+//	if (result)
+//	{
+//		do
+//		{
+//			Field* fields = result->Fetch();
+//			uint32 eventId = fields[0].GetUInt32();
+//
+//			std::unordered_map<uint32, EventDataTemplate>::iterator iter = EventDataMap.find(eventId);
+//
+//			if (iter != EventDataMap.end())
+//			{
+//				iter->second.rew_winRewId = fields[1].GetUInt32();
+//				iter->second.rew_losRewId = fields[2].GetUInt32();
+//				iter->second.rew_killsForRew = fields[3].GetUInt32();
+//				iter->second.rew_killedsForRew = fields[4].GetUInt32();
+//				iter->second.rew_damageForRew = fields[5].GetFloat();
+//				iter->second.rew_healForRew = fields[6].GetFloat();
+//			}
+//
+//		} while (result->NextRow());
+//	}
+//	
+//
+//	//¼ÓÔØStopConditionVec
+//	result = WorldDatabase.PQuery("SELECT eventId,creature1,creatureCount1,creature2,creatureCount2,creature3,creatureCount3,creature4,creatureCount4,creature5,creatureCount5, gameobject1, gameobjectCount1, gameobject2, gameobjectCount2, gameobject3, gameobjectCount3, gameobject4, gameobjectCount4, gameobject5, gameobjectCount5, defenseKills, offenseKills, killGaps FROM _game_event_stop_condition");
+//	if (result)
+//	{
+//		do
+//		{
+//			Field* fields = result->Fetch();
+//			uint32 eventId = fields[0].GetUInt32();
+//
+//			std::unordered_map<uint32, EventDataTemplate>::iterator iter = EventDataMap.find(eventId);
+//
+//			if (iter != EventDataMap.end())
+//			{
+//				iter->second.stop_creature1 = fields[1].GetUInt32();
+//				iter->second.stop_creatureCount1 = fields[2].GetUInt32();
+//				iter->second.stop_creature2 = fields[3].GetUInt32();
+//				iter->second.stop_creatureCount2 = fields[4].GetUInt32();
+//				iter->second.stop_creature3 = fields[5].GetUInt32();
+//				iter->second.stop_creatureCount3 = fields[6].GetUInt32();
+//				iter->second.stop_creature4 = fields[7].GetUInt32();
+//				iter->second.stop_creatureCount4 = fields[8].GetUInt32();
+//				iter->second.stop_creature5 = fields[9].GetUInt32();
+//				iter->second.stop_creatureCount5 = fields[10].GetUInt32();
+//				iter->second.stop_gameobject1 = fields[11].GetUInt32();
+//				iter->second.stop_gameobjectCount1 = fields[12].GetUInt32();
+//				iter->second.stop_gameobject2 = fields[13].GetUInt32();
+//				iter->second.stop_gameobjectCount2 = fields[14].GetUInt32();
+//				iter->second.stop_gameobject3 = fields[15].GetUInt32();
+//				iter->second.stop_gameobjectCount3 = fields[16].GetUInt32();
+//				iter->second.stop_gameobject4 = fields[17].GetUInt32();
+//				iter->second.stop_gameobjectCount4 = fields[18].GetUInt32();
+//				iter->second.stop_gameobject5 = fields[19].GetUInt32();
+//				iter->second.stop_gameobjectCount5 = fields[20].GetUInt32();
+//				iter->second.stop_defenseKills = fields[21].GetUInt32();
+//				iter->second.stop_offenseKills = fields[22].GetUInt32();
+//				iter->second.stop_killGaps = fields[23].GetUInt32();
+//			}
+//		} while (result->NextRow());
+//	}
+//	
+//
+//
+//	//¼ÓÔØeventPhaseMap
+//
+//	for (auto iter = EventDataMap.begin(); iter != EventDataMap.end(); iter++)
+//	{
+//		result = WorldDatabase.PQuery("SELECT phase,stop_creature_guid,stop_gameobject_guid,stop_player_kills,"
+//			"stop_defense_tele_pos,stop_offense_tele_pos,defense_graveyard_pos,offense_graveyard_pos,stop_defense_notice,stop_offense_notice,"
+//			"defense_graveyard_safe,offense_graveyard_safe,defense_graveyard_healer,offense_graveyard_healer FROM _game_event_phase WHERE eventId = '%u';", iter->first);
+//		if (result)
+//		{
+//			do
+//			{
+//				Field* fields = result->Fetch();
+//				uint32 phase = fields[0].GetUInt32();
+//				EventPhaseTemplate Temp;
+//				Temp.stop_creature			= fields[1].GetUInt32();
+//				Temp.stop_gameobject		= fields[2].GetUInt32();
+//				Temp.stop_kills				= fields[3].GetUInt32();
+//				Temp.stop_defense_tele_pos	= fields[4].GetUInt32();
+//				Temp.stop_offense_tele_pos	= fields[5].GetUInt32();
+//				Temp.defense_graveyard_pos	= fields[6].GetUInt32();
+//				Temp.offense_graveyard_pos	= fields[7].GetUInt32();
+//				Temp.stop_defense_notice	= fields[8].GetString();
+//				Temp.stop_offense_notice	= fields[9].GetString();
+//				Temp.defense_graveyard_safe = fields[10].GetFloat();
+//				Temp.offense_graveyard_safe = fields[11].GetFloat();
+//				Temp.defense_graveyard_healer = fields[12].GetUInt32();
+//				Temp.offense_graveyard_healer = fields[13].GetUInt32();
+//				iter->second.eventPhaseMap.insert(std::make_pair(phase, Temp));
+//
+//			} while (result->NextRow());
+//		}
+//	}
+//
+//	//¼ÓÔØActiveVec
+//	result = WorldDatabase.PQuery("SELECT eventId,activeGuid,activeType,creatureEntry,killCount,gameobjectEntry,destroyCount FROM _game_event_active_condition");
+//	if (result)
+//	{
+//		do
+//		{
+//			Field* fields = result->Fetch();
+//			EventActiveTemplate Temp;
+//			Temp.eventId = fields[0].GetUInt32();
+//			Temp.activeGUID = fields[1].GetUInt32();
+//			Temp.activeType = fields[2].GetUInt32();
+//			Temp.creatureEntry = fields[3].GetUInt32();
+//			Temp.killCount = fields[4].GetUInt32();
+//			Temp.gameobjectEntry = fields[5].GetUInt32();
+//			Temp.destroyCount = fields[6].GetUInt32();
+//			EventActiveVec.push_back(Temp);
+//		} while (result->NextRow());
+//	}
+//}
+//
+//std::unordered_map<uint32, PosTemplate> PosMap;
+//
+//void CustomEvent::LoadPos()
+//{
+//	PosMap.clear();
+//	QueryResult result = WorldDatabase.PQuery("SELECT map,x,y,z,o,posId FROM _position");
+//	if (!result) return;
+//	do
+//	{
+//		Field* fields = result->Fetch();
+//		PosTemplate Temp;
+//		Temp.map = fields[0].GetUInt32();
+//		Temp.x = fields[1].GetFloat();
+//		Temp.y = fields[2].GetFloat();
+//		Temp.z = fields[3].GetFloat();
+//		Temp.o = fields[4].GetFloat();
+//		uint32 ID = fields[5].GetUInt32();
+//		PosMap.insert(std::make_pair(ID, Temp));
+//	} while (result->NextRow());
+//}
+//
+//void CustomEvent::GetTelePos(uint32 eventId, PosTypes type, uint32 &map, float &x, float &y, float &z, float &o)
+//{
+//	uint32 posId = 0;
+//
+//	std::unordered_map<uint32, EventDataTemplate>::iterator iter = EventDataMap.find(eventId);
+//
+//	if (iter != EventDataMap.end())
+//	{
+//		switch (type)
+//		{
+//		case C_PT_START_DEFENSE:
+//			posId = iter->second.startDefensePos;
+//			break;
+//		case C_PT_START_OFFENSE:
+//			posId = iter->second.startOffensePos;
+//			break;
+//		}
+//	}
+//
+//	std::unordered_map<uint32, PosTemplate>::iterator it = PosMap.find(posId);
+//
+//	if (it != PosMap.end())
+//	{
+//		map = it->second.map;
+//		x	= it->second.x;
+//		y	= it->second.y;
+//		z	= it->second.z;
+//		o	= it->second.o;
+//	}
+//
+//}
+//
+//void CustomEvent::GetTelePos(uint32 posId, uint32 &map, float &x, float &y, float &z, float &o)
+//{
+//	std::unordered_map<uint32, PosTemplate>::iterator it = PosMap.find(posId);
+//
+//	if (it != PosMap.end())
+//	{
+//		map = it->second.map;
+//		x = it->second.x;
+//		y = it->second.y;
+//		z = it->second.z;
+//		o = it->second.o;
+//	}
+//}
+//
+//void CustomEvent::SummonSoulHealer()
+//{
+//	if (Map* map = sMapMgr->FindMap(_mapId, 0))
+//	{
+//		auto it = PosMap.find(_graveyard_defense_pos);
+//
+//		if (it != PosMap.end())
+//		{
+//			if (Creature* healer = map->GetCreature(_soulhealer_defense))
+//				healer->RemoveFromWorld();
+//
+//			Position pos;
+//			pos.Relocate(it->second.x, it->second.y, it->second.z, it->second.o);
+//			if (Creature* healer = map->SummonCreature(_defense_graveyard_healer, pos, 0, 60 * 60 * IN_MILLISECONDS))
+//			{
+//				_soulhealer_defense = healer->GetGUID();
+//				healer->setFaction(DEFENSE_FACTION);
+//				healer->setDeathState(DEAD);
+//				healer->SetUInt64Value(UNIT_FIELD_CHANNEL_OBJECT, healer->GetGUID());
+//				healer->SetUInt32Value(UNIT_CHANNEL_SPELL, SPELL_SPIRIT_HEAL_CHANNEL);
+//				healer->SetFloatValue(UNIT_MOD_CAST_SPEED, 1.0f);
+//			}		
+//		}
+//
+//		it = PosMap.find(_graveyard_offense_pos);
+//
+//		if (it != PosMap.end())
+//		{
+//			if (Creature* healer = map->GetCreature(_soulhealer_offense))
+//				healer->RemoveFromWorld();
+//
+//			Position pos;
+//			pos.Relocate(it->second.x, it->second.y, it->second.z, it->second.o);
+//			if (Creature* healer = map->SummonCreature(_offense_graveyard_healer, pos, 0, 60 * 60 * IN_MILLISECONDS))
+//			{
+//				_soulhealer_offense = healer->GetGUID();
+//				healer->setFaction(OFFENSE_FACTION);
+//				healer->setDeathState(DEAD);
+//				healer->SetUInt64Value(UNIT_FIELD_CHANNEL_OBJECT, healer->GetGUID());
+//				healer->SetUInt32Value(UNIT_CHANNEL_SPELL, SPELL_SPIRIT_HEAL_CHANNEL);
+//				healer->SetFloatValue(UNIT_MOD_CAST_SPEED, 1.0f);
+//			}			
+//		}
+//	}
+//}
+//
+//void CustomEvent::InitParams(uint32 eventId)
+//{
+//	std::unordered_map<uint32, EventDataTemplate>::iterator iter = EventDataMap.find(eventId);
+//
+//	if (iter != EventDataMap.end())
+//	{
+//		_eventId = eventId;
+//		_winTeam = C_TEAM_NONE;
+//		_expired = false;
+//		KillCreatureMap.clear();
+//		DestroyGobMap.clear();
+//		KillPlayerMap.clear();
+//		PlayerDataMap.clear();
+//		GroupDataMap.clear();
+//
+//		/*ÊÂ¼þÐÅÏ¢*/
+//		_eventType = iter->second.eventType;
+//		_groupType = iter->second.groupType;
+//		_rejoinType = iter->second.rejoinType;
+//		_eventName = iter->second.eventName;
+//		_gossipText = iter->second.gossipText;
+//		_noticeText = iter->second.noticeText;
+//		_defenseName = iter->second.defenseName;
+//		_offenseName = iter->second.offenseName;
+//		_startDefensePos = iter->second.startDefensePos;
+//		_startOffensePos = iter->second.startOffensePos;
+//
+//		_zoneId = iter->second.zoneId;
+//		_mapId = GetMapIdByZone(_zoneId);
+//		
+//		
+//		_eventPhase = 1;
+//		_stop_creature_flag = false;
+//		_stop_gameobject_flag = false;
+//		_stop_kills_flag = false;
+//
+//		_graveyard_defense_pos = 0;
+//		_graveyard_offense_pos = 0;
+//		_soulhealer_defense = 0;
+//		_soulhealer_offense = 0;
+//		_defense_graveyard_safe = 0;
+//		_offense_graveyard_safe = 0;
+//		_defense_graveyard_healer = 0;
+//		_offense_graveyard_healer = 0;
+//
+//		auto iter = EventDataMap.find(_eventId);
+//
+//		if (iter != EventDataMap.end())
+//		{
+//			auto i = iter->second.eventPhaseMap.find(_eventPhase);
+//
+//			if (i != iter->second.eventPhaseMap.end())
+//			{
+//				_graveyard_defense_pos = i->second.defense_graveyard_pos;
+//				_graveyard_offense_pos = i->second.offense_graveyard_pos;
+//				_defense_graveyard_safe = i->second.defense_graveyard_safe;
+//				_offense_graveyard_safe = i->second.offense_graveyard_safe;
+//				_defense_graveyard_healer = i->second.defense_graveyard_healer;
+//				_offense_graveyard_healer = i->second.offense_graveyard_healer;
+//				SummonSoulHealer();
+//			}
+//		}
+//
+//
+//		_reviveUpdateTimer = REVIVE_INTERVALS;
+//		_safeAreaUpdateTimer = IN_MILLISECONDS;
+//
+//		_rew_winRewId = iter->second.rew_winRewId;
+//		_rew_losRewId = iter->second.rew_losRewId;
+//		_rew_killsForRew = iter->second.rew_killsForRew;
+//		_rew_killedsForRew = iter->second.rew_killedsForRew;
+//		_rew_damageForRew = iter->second.rew_damageForRew;
+//		_rew_healForRew = iter->second.rew_healForRew;
+//
+//		_stop_creature1 = iter->second.stop_creature1;
+//		_stop_creatureCount1 = iter->second.stop_creatureCount1;
+//		_stop_creature2 = iter->second.stop_creature2;
+//		_stop_creatureCount2 = iter->second.stop_creatureCount2;
+//		_stop_creature3 = iter->second.stop_creature3;
+//		_stop_creatureCount3 = iter->second.stop_creatureCount3;
+//		_stop_creature4 = iter->second.stop_creature4;
+//		_stop_creatureCount4 = iter->second.stop_creatureCount4;
+//		_stop_creature5 = iter->second.stop_creature5;
+//		_stop_creatureCount5 = iter->second.stop_creatureCount5;
+//
+//		_stop_gameobject1 = iter->second.stop_gameobject1;
+//		_stop_gameobjectCount1 = iter->second.stop_gameobjectCount1;
+//		_stop_gameobject2 = iter->second.stop_gameobject2;
+//		_stop_gameobjectCount2 = iter->second.stop_gameobjectCount2;
+//		_stop_gameobject3 = iter->second.stop_gameobject3;
+//		_stop_gameobjectCount3 = iter->second.stop_gameobjectCount3;
+//		_stop_gameobject4 = iter->second.stop_gameobject4;
+//		_stop_gameobjectCount4 = iter->second.stop_gameobjectCount4;
+//		_stop_gameobject5 = iter->second.stop_gameobject5;
+//		_stop_gameobjectCount5 = iter->second.stop_gameobjectCount5;
+//
+//		_stop_defenseKills = iter->second.stop_defenseKills;
+//		_stop_offenseKills = iter->second.stop_offenseKills;
+//
+//		_state_creature1 = iter->second.state_creature1;
+//		_state_creatureWorldState1 = iter->second.state_creatureWorldState1;
+//		_state_creature2 = iter->second.state_creature2;
+//		_state_creatureWorldState2 = iter->second.state_creatureWorldState2;
+//		_state_creature3 = iter->second.state_creature3;
+//		_state_creatureWorldState3 = iter->second.state_creatureWorldState3;
+//		_state_gameobject1 = iter->second.state_gameobject1;
+//		_state_gameobjectWorldState1 = iter->second.state_gameobjectWorldState1;
+//		_state_gameobject2 = iter->second.state_gameobject2;
+//		_state_gameobjectWorldState2 = iter->second.state_gameobjectWorldState2;
+//		_state_gameobject3 = iter->second.state_gameobject3;
+//		_state_gameobjectWorldState3 = iter->second.state_gameobjectWorldState3;
+//		_state_defenseWorldState = iter->second.state_defenseWorldState;
+//		_state_offenseWorldState = iter->second.state_offenseWorldState;
+//	}
+//}
+//
+//void CustomEvent::Reset()
+//{
+//	_eventId = 0;
+//	_winTeam = C_TEAM_NONE;
+//	_expired = false;
+//	_AllyAsOffense = true;
+//	KillCreatureMap.clear();
+//	DestroyGobMap.clear();
+//	KillPlayerMap.clear();
+//	PlayerDataMap.clear();
+//	GroupDataMap.clear();
+//
+//	/*ÊÂ¼þÐÅÏ¢*/
+//	_eventType = C_ET_GROUP;
+//	_groupType = C_GT_OFFENSE_PLAYER_RANDOM;
+//	_rejoinType = C_RT_KEEP_GROUP;
+//	_eventName = "";
+//	_gossipText = "";
+//	_noticeText = "";
+//	_defenseName = "";
+//	_offenseName = "";
+//	_startDefensePos = 0;
+//	_startOffensePos = 0;
+//
+//
+//	_eventPhase = 1;
+//	_stop_creature_flag = false;
+//	_stop_gameobject_flag = false;
+//	_stop_kills_flag = false;
+//
+//	_graveyard_defense_pos = 0;
+//	_graveyard_offense_pos = 0;
+//	_soulhealer_defense = 0;
+//	_soulhealer_offense = 0;
+//	_defense_graveyard_safe = 0;
+//	_offense_graveyard_safe = 0;
+//	_defense_graveyard_safe = 0;
+//	_offense_graveyard_safe = 0;
+//
+//	auto iter = EventDataMap.find(_eventId);
+//
+//	if (iter != EventDataMap.end())
+//	{
+//		auto i = iter->second.eventPhaseMap.find(_eventPhase);
+//
+//		if (i != iter->second.eventPhaseMap.end())
+//		{
+//			_graveyard_defense_pos = i->second.defense_graveyard_pos;
+//			_graveyard_offense_pos = i->second.offense_graveyard_pos;
+//			_defense_graveyard_safe = i->second.defense_graveyard_safe;
+//			_offense_graveyard_safe = i->second.offense_graveyard_safe;
+//		}
+//	}
+//
+//	_zoneId = 0;
+//	_mapId = -1;
+//	
+//	_reviveUpdateTimer = REVIVE_INTERVALS;
+//	_safeAreaUpdateTimer = IN_MILLISECONDS;
+//
+//	_rew_winRewId = 0;
+//	_rew_losRewId = 0;
+//	_rew_killsForRew = 0;
+//	_rew_killedsForRew = 0;
+//	_rew_damageForRew = 0;
+//	_rew_healForRew = 0;
+//
+//	_stop_creature1 = 0;
+//	_stop_creatureCount1 = 0;
+//	_stop_creature2 = 0;
+//	_stop_creatureCount2 = 0;
+//	_stop_creature3 = 0;
+//	_stop_creatureCount3 = 0;
+//	_stop_creature4 = 0;
+//	_stop_creatureCount4 = 0;
+//	_stop_creature5 = 0;
+//	_stop_creatureCount5 = 0;
+//	_stop_gameobject1 = 0;
+//	_stop_gameobjectCount1 = 0;
+//	_stop_gameobject2 = 0;
+//	_stop_gameobjectCount2 = 0;
+//	_stop_gameobject3 = 0;
+//	_stop_gameobjectCount3 = 0;
+//	_stop_gameobject4 = 0;
+//	_stop_gameobjectCount4 = 0;
+//	_stop_gameobject5 = 0;
+//	_stop_gameobjectCount5 = 0;
+//	_stop_defenseKills = 0;
+//	_stop_offenseKills = 0;
+//	_stop_killGaps = 0;
+//
+//	_state_creature1 = 0;
+//	_state_creatureWorldState1 = 0;
+//	_state_creature2 = 0;
+//	_state_creatureWorldState2 = 0;
+//	_state_creature3 = 0;
+//	_state_creatureWorldState3 = 0;
+//	_state_gameobject1 = 0;
+//	_state_gameobjectWorldState1 = 0;
+//	_state_gameobject2 = 0;
+//	_state_gameobjectWorldState2 = 0;
+//	_state_gameobject3 = 0;
+//	_state_gameobjectWorldState3 = 0;
+//	_state_defenseWorldState = 0;
+//	_state_offenseWorldState = 0;
+//}
+//
+//void CustomEvent::Start(uint32 eventId)
+//{
+//	if (eventId < 70)
+//		return;
+//
+//	if (eventId == EVENT_ID_QUICK_RESPONSE)
+//	{
+//		sQuickResponse->Anounce();
+//		return;
+//	}
+//
+//	//ÔÚ´Ë×ö¼ÙÈËÉÏÏÂÏß ÇÐ»»ÇøÓòµÈÊÂ¼þ´¦Àí
+//
+//	if (eventId == EVENT_ID_FAKE_PLAYER_LOGIN_OR_LOGOUT)
+//	{
+//		sFakePlayers->LoginOrLogout();
+//		return;
+//	}
+//
+//	if (eventId == EVENT_ID_FAKE_PLAYER_UPDATE_ZONE_ID)
+//	{
+//		sFakePlayers->UpdateZone();
+//		return;
+//	}
+//
+//	if (eventId == EVENT_ID_FAKE_PLAYER_LEVEL_UP)
+//	{
+//		sFakePlayers->LevelUp();
+//		return;
+//	}
+//
+//	
+//	InitParams(eventId);
+//	InitWorldState(eventId);
+//
+//	std::ostringstream oss;
+//	oss << _eventName << "¿ªÊ¼£¡";
+//	sWorld->SendServerMessage(SERVER_MSG_STRING, oss.str().c_str());
+//
+//	if (_noticeText.empty())
+//		return;
+//
+//	SendInvitationToAll(_noticeText);
+//
+//	if (eventId == UKBG_EVENT_ID)
+//	{
+//		sUkBG->Start();
+//		return;
+//	}
+//
+//	if (_eventType != C_ET_GROUP)
+//		return;
+//
+//	oss.str("");
+//	oss << _eventName;
+//
+//	switch (_groupType)
+//	{
+//	case C_GT_OFFENSE_ALL:
+//		oss << "ËùÓÐÍæ¼Ò½«¼ÓÈë" << _offenseName << "£¡";
+//		break;
+//	case C_GT_OFFENSE_ALLY:
+//		oss << "ÁªÃË½«¼ÓÈë" << _offenseName << "£¬²¿Âä½«¼ÓÈë" << _defenseName << "£¡";
+//		break;
+//	case C_GT_OFFENSE_HORDE:
+//		oss << "ÁªÃË½«¼ÓÈë" << _defenseName << "£¬²¿Âä½«¼ÓÈë" << _offenseName << "£¡";
+//		break;
+//	case C_GT_OFFENSE_FACTION_RANDOM:
+//		_AllyAsOffense ? oss << "ÁªÃË½«¼ÓÈë" << _offenseName << "£¬²¿Âä½«¼ÓÈë" << _defenseName << "£¡" : oss << "ÁªÃË½«¼ÓÈë" << _defenseName << "£¬²¿Âä½«¼ÓÈë" << _offenseName << "£¡";
+//		break;
+//	case C_GT_OFFENSE_PLAYER_RANDOM:
+//		oss << "Íæ¼Ò½«Ëæ»ú¼ÓÈë" << _defenseName << "»ò" << _offenseName << "£¡";
+//		break;
+//	}
+//
+//	sWorld->SendServerMessage(SERVER_MSG_STRING, oss.str().c_str());
+//
+//	oss.str("");
+//	oss << _eventName;
+//
+//	switch (_rejoinType)
+//	{
+//	case C_RT_BANED:
+//		oss << "ÖØÐÂ¼ÓÈë»î¶¯½«±»½ûÖ¹£¡";
+//		break;
+//	case C_RT_KEEP_GROUP:
+//		oss << "ÖØÐÂ¼ÓÈë»î¶¯²»»á¸Ä±ä·Ö×é£¡";
+//		break;
+//	case C_RT_REDIS_GROUP:
+//		oss << "ÖØÐÂ¼ÓÈë»î¶¯Ê±£¬ÏµÍ³»áÖØÐÂ·Ö×é£¡";
+//		break;
+//	}
+//
+//	sWorld->SendServerMessage(SERVER_MSG_STRING, oss.str().c_str());
+//}
+//
+//void CustomEvent::Stop(uint32 eventId, bool expired)
+//{
+//	if (eventId < 70)
+//		return;
+//
+//	//ÇÀ´ð
+//	if (eventId == EVENT_ID_QUICK_RESPONSE)
+//	{
+//		sQuickResponse->Reward();
+//		return;
+//	}
+//
+//
+//	//Õ½³¡
+//	if (_eventType == C_ET_WS ||
+//		_eventType == C_ET_AB ||
+//		_eventType == C_ET_EY ||
+//		_eventType == C_ET_SA ||
+//		_eventType == C_ET_AV ||
+//		_eventType == C_ET_IC)
+//	{
+//		Reset();
+//		return;
+//	}
+//
+//
+//
+//	if (_eventType != C_ET_GROUP)
+//		return;
+//
+//	std::ostringstream oss;
+//	oss << _eventName << "½áÊø£¡";
+//
+//	if (expired)
+//		_winTeam = C_TEAM_DEFENSE;
+//	else
+//		_winTeam = C_TEAM_OFFENSE;
+//
+//	//´Ë´¦×öÌØÊâÊâÊÂ¼þÊäÓ®ÅÐ¶Ï
+//	if (eventId == NARROW_EVENT_ID)
+//	{
+//		uint32 defenseKills = GetKillPlayerCount(C_TEAM_DEFENSE);
+//		uint32 offenseKills = GetKillPlayerCount(C_TEAM_OFFENSE);
+//
+//		if (defenseKills == offenseKills)
+//			_winTeam = C_TEAM_NONE;
+//		else if (defenseKills > offenseKills)
+//			_winTeam = C_TEAM_DEFENSE;
+//		else
+//			_winTeam = C_TEAM_OFFENSE;
+//	}
+//
+//	switch (_winTeam)
+//	{
+//	case C_TEAM_NONE:
+//		oss << _offenseName << _defenseName << "¶¼Ã»ÓÐÈ¡µÃ×îºóµÄÊ¤Àû£¡";
+//		break;
+//	case C_TEAM_DEFENSE:
+//		oss << _defenseName << "»ñÊ¤£¡";
+//		break;
+//	case C_TEAM_OFFENSE:
+//		oss << _offenseName << "»ñÊ¤£¡";
+//		break;
+//	}
+//
+//	sWorld->SendScreenMessage(oss.str().c_str());
+//	RewardAllPlayers();
+//	ResetAllPlayers();
+//	Reset();
+//}
+//
+//void CustomEvent::SendInvitationToAll(std::string text)
+//{
+//	uint32 menuId = _eventId + 1000000;
+//
+//	SessionMap const& smap = sWorld->GetAllSessions();
+//	for (SessionMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+//		if (Player* player = iter->second->GetPlayer())
+//		{
+//			if (player->GetSession())
+//			{
+//				player->CLOSE_GOSSIP_MENU();
+//
+//				if (player->IsSpectator())
+//					continue;
+//
+//				if (player->isDead())
+//				{
+//					player->ResurrectPlayer(1.0f);
+//					player->SpawnCorpseBones();
+//				}
+//
+//				WorldPacket data(SMSG_GOSSIP_MESSAGE, 100);
+//				data << uint64(player->GetGUID());
+//				data << uint32(menuId);
+//				data << uint32(1);
+//				data << uint32(1);
+//				data << uint32(1);
+//				data << uint8(1);
+//				data << uint8(0);
+//				data << uint32(0);
+//				data << "";
+//				data << text;
+//				player->GetSession()->SendPacket(&data);
+//			}
+//		}
+//}
+//
+//void CustomEvent::Process(Player* player, Object* obj)
+//{
+//	uint32 entry = obj->GetEntry();
+//	TeamTypes team = GetTeam(player);
+//
+//	std::unordered_map<uint32, EventDataTemplate>::iterator iter = EventDataMap.find(_eventId);
+//
+//	if (iter != EventDataMap.end())
+//	{
+//		bool endFlag = false;
+//		bool announce = false;
+//		std::ostringstream oss;
+//		std::string playerName = sCF->GetNameLink(player);
+//
+//		switch (obj->GetTypeId())
+//		{
+//		case TYPEID_PLAYER:
+//		{
+//			std::unordered_map<TeamTypes/*event team*/, uint32>::iterator i = KillPlayerMap.find(team);
+//
+//			if (i != KillPlayerMap.end())
+//				i->second++;
+//			else
+//				KillPlayerMap.insert(std::make_pair(team, 1));
+//
+//			uint32 defenseKills = GetKillPlayerCount(C_TEAM_DEFENSE);
+//			uint32 offenseKills = GetKillPlayerCount(C_TEAM_OFFENSE);
+//
+//			if (team == C_TEAM_DEFENSE && iter->second.stop_defenseKills > 0)
+//			{
+//				oss << _eventName << _defenseName << "»÷É±Íæ¼Ò" << defenseKills << "/" << iter->second.stop_defenseKills;
+//				announce = true;
+//			}
+//				
+//			if (team == C_TEAM_OFFENSE && iter->second.stop_offenseKills > 0)
+//			{
+//				oss << _eventName << _offenseName << "»÷É±Íæ¼Ò" << offenseKills << "/" << iter->second.stop_offenseKills;
+//				announce = true;
+//			}
+//				
+//			if (iter->second.stop_killGaps > 0)
+//			{
+//				int32 killGaps = defenseKills - offenseKills;
+//
+//				if (killGaps > 0)
+//					oss << "£¬" << _defenseName << "ÁìÏÈ»÷É±" << killGaps << "/" << iter->second.stop_killGaps;
+//				else if (killGaps < 0)
+//					oss << "£¬" << _offenseName << "ÁìÏÈ»÷É±" << abs(killGaps) << "/" << iter->second.stop_killGaps;
+//
+//				announce = true;
+//			}
+//		}
+//		break;
+//		case TYPEID_UNIT:
+//		{
+//			std::unordered_map<uint32/*creature entry*/, uint32>::iterator i = KillCreatureMap.find(entry);
+//
+//			if (i != KillCreatureMap.end())
+//				i->second++;
+//			else
+//				KillCreatureMap.insert(std::make_pair(entry, 1));
+//
+//			uint32 creatureKills = GetKillCreatureCount(entry);
+//
+//			oss << _eventName << playerName << "»÷É±ÁË[" << obj->ToCreature()->GetName() << "]   ";
+//
+//			if (entry == iter->second.stop_creature1 && iter->second.stop_creatureCount1 > 0)
+//			{
+//				if (creatureKills < iter->second.stop_creatureCount1)
+//					oss << creatureKills << "/" << iter->second.stop_creatureCount1;
+//				else
+//					oss << "[Ä¿±ê´ï³É]";
+//				announce = true;
+//			}
+//			else if (entry == iter->second.stop_creature2 && iter->second.stop_creatureCount2 != 0)
+//			{
+//				if (creatureKills < iter->second.stop_creatureCount2)
+//					oss << creatureKills << "/" << iter->second.stop_creatureCount2;
+//				else
+//					oss << "[Ä¿±ê´ï³É]";
+//				announce = true;
+//			}
+//			else if (entry == iter->second.stop_creature3 && iter->second.stop_creatureCount3 != 0)
+//			{
+//				if (creatureKills < iter->second.stop_creatureCount3)
+//					oss << creatureKills << "/" << iter->second.stop_creatureCount3;
+//				else
+//					oss << "[Ä¿±ê´ï³É]";
+//				announce = true;
+//			}
+//			else if (entry == iter->second.stop_creature4 && iter->second.stop_creatureCount4 != 0)
+//			{
+//				if (creatureKills < iter->second.stop_creatureCount4)
+//					oss << creatureKills << "/" << iter->second.stop_creatureCount4;
+//				else
+//					oss << "[Ä¿±ê´ï³É]";
+//				announce = true;
+//			}
+//			else if (entry == iter->second.stop_creature5 && iter->second.stop_creatureCount5 != 0)
+//			{
+//				if (creatureKills < iter->second.stop_creatureCount5)
+//					oss << creatureKills << "/" << iter->second.stop_creatureCount5;
+//				else
+//					oss << "[Ä¿±ê´ï³É]";
+//				announce = true;
+//			}
+//		}
+//		break;
+//		case TYPEID_GAMEOBJECT:
+//		{
+//			std::unordered_map<uint32/*gob entry*/, uint32>::iterator i = DestroyGobMap.find(entry);
+//
+//			if (i != DestroyGobMap.end())
+//				i->second++;
+//			else
+//				DestroyGobMap.insert(std::make_pair(entry, 1));
+//
+//			uint32 count = GetDestroyGobCount(entry);
+//
+//			oss << _eventName << playerName << "´Ý»ÙÁË[" << obj->ToGameObject()->GetName() << "]   ";
+//
+//			if (entry == iter->second.stop_gameobject1 && iter->second.stop_gameobjectCount1 != 0)
+//			{
+//				if (count < iter->second.stop_gameobjectCount1)
+//					oss << count << "/" << iter->second.stop_gameobjectCount1;
+//				else
+//					oss << "[Ä¿±ê´ï³É]";
+//				announce = true;
+//			}
+//			else if (entry == iter->second.stop_gameobject2 && iter->second.stop_gameobjectCount2 != 0)
+//			{
+//				if (count < iter->second.stop_gameobjectCount2)
+//					oss << count << "/" << iter->second.stop_gameobjectCount2;
+//				else
+//					oss << "[Ä¿±ê´ï³É]";
+//				announce = true;
+//			}
+//			else if (entry == iter->second.stop_gameobject3 && iter->second.stop_gameobjectCount3 != 0)
+//			{
+//				if (count < iter->second.stop_gameobjectCount3)
+//					oss << count << "/" << iter->second.stop_gameobjectCount3;
+//				else
+//					oss << "[Ä¿±ê´ï³É]";
+//				announce = true;
+//			}
+//			else if (entry == iter->second.stop_gameobject4 && iter->second.stop_gameobjectCount4 != 0)
+//			{
+//				if (count < iter->second.stop_gameobjectCount4)
+//					oss << count << "/" << iter->second.stop_gameobjectCount4;
+//				else
+//					oss << "[Ä¿±ê´ï³É]";
+//				announce = true;
+//			}
+//			else if (entry == iter->second.stop_gameobject5 && iter->second.stop_gameobjectCount5 != 0)
+//			{
+//				if (count < iter->second.stop_gameobjectCount5)
+//					oss << count << "/" << iter->second.stop_gameobjectCount5;
+//				else
+//					oss << "[Ä¿±ê´ï³É]";
+//				announce = true;
+//			}
+//		}
+//		break;
+//		}
+//
+//		if (announce)
+//			sWorld->SendScreenMessage(oss.str().c_str());
+//
+//		if (
+//			iter->second.stop_creatureCount1 <= GetKillCreatureCount(iter->second.stop_creature1) &&
+//			iter->second.stop_creatureCount2 <= GetKillCreatureCount(iter->second.stop_creature2) &&
+//			iter->second.stop_creatureCount3 <= GetKillCreatureCount(iter->second.stop_creature3) &&
+//			iter->second.stop_creatureCount4 <= GetKillCreatureCount(iter->second.stop_creature4) &&
+//			iter->second.stop_creatureCount5 <= GetKillCreatureCount(iter->second.stop_creature5) &&
+//			iter->second.stop_gameobjectCount1 <= GetDestroyGobCount(iter->second.stop_gameobject1) &&
+//			iter->second.stop_gameobjectCount2 <= GetDestroyGobCount(iter->second.stop_gameobject2) &&
+//			iter->second.stop_gameobjectCount3 <= GetDestroyGobCount(iter->second.stop_gameobject3) &&
+//			iter->second.stop_gameobjectCount4 <= GetDestroyGobCount(iter->second.stop_gameobject4) &&
+//			iter->second.stop_gameobjectCount5 <= GetDestroyGobCount(iter->second.stop_gameobject5) &&
+//			(
+//			iter->second.stop_defenseKills <= GetKillPlayerCount(C_TEAM_DEFENSE) ||
+//			iter->second.stop_offenseKills <= GetKillPlayerCount(C_TEAM_OFFENSE)
+//			)
+//			&&
+//			iter->second.stop_killGaps <= uint32(GetKillPlayerCount(C_TEAM_DEFENSE) - GetKillPlayerCount(C_TEAM_OFFENSE))
+//			)
+//			endFlag = true;
+//
+//		if (endFlag)
+//			sGameEventMgr->StopEvent(_eventId, false, false);
+//	}
+//}
+//
+////WorldState
+//void CustomEvent::_UpdateWorldState(uint32 index, uint32 value)
+//{
+//	if (index == 0)
+//		return;
+//
+//	sWorld->setWorldState(index, value);
+//	SessionMap const& smap = sWorld->GetAllSessions();
+//	for (SessionMap::const_iterator i = smap.begin(); i != smap.end(); ++i)
+//		if (Player* pl = i->second->GetPlayer())
+//			pl->SendUpdateWorldState(index, value);
+//}
+//
+//void CustomEvent::InitWorldState(uint32 eventId)
+//{
+//	std::unordered_map<uint32, EventDataTemplate>::iterator iter = EventDataMap.find(eventId);
+//
+//	if (iter != EventDataMap.end())
+//	{
+//		_UpdateWorldState(iter->second.state_creatureWorldState1, 0);
+//		_UpdateWorldState(iter->second.state_creatureWorldState2, 0);
+//		_UpdateWorldState(iter->second.state_creatureWorldState3, 0);
+//		_UpdateWorldState(iter->second.state_gameobjectWorldState1, 0);
+//		_UpdateWorldState(iter->second.state_gameobjectWorldState2, 0);
+//		_UpdateWorldState(iter->second.state_gameobjectWorldState3, 0);
+//		_UpdateWorldState(iter->second.state_defenseWorldState, iter->second.stop_defenseKills);
+//		_UpdateWorldState(iter->second.state_offenseWorldState, iter->second.stop_offenseKills);
+//	}
+//}
+//
+//void CustomEvent::UpdateWorldState(Object* obj, Player* player)
+//{
+//	uint32 entry = obj->GetEntry();
+//
+//	GameEventMgr::ActiveEvents const& activeEvents = sGameEventMgr->GetActiveEventList();
+//
+//	for (GameEventMgr::ActiveEvents::const_iterator i = activeEvents.begin(); i != activeEvents.end(); ++i)
+//	{
+//		uint32 eventId = *i;	
+//		uint32 worldstateIndex = 0;
+//		bool increase = true;
+//
+//		std::unordered_map<uint32, EventDataTemplate>::iterator iter = EventDataMap.find(eventId);
+//
+//		if (iter != EventDataMap.end())
+//		{
+//			if (obj->GetTypeId() == TYPEID_UNIT)
+//			{
+//				if (entry == iter->second.state_creature1)
+//					worldstateIndex = iter->second.state_creatureWorldState1;
+//				else if (entry == iter->second.state_creature2)
+//					worldstateIndex = iter->second.state_creatureWorldState2;
+//				else if (entry == iter->second.state_creature3)
+//					worldstateIndex = iter->second.state_creatureWorldState3;
+//			}
+//			else if (obj->GetTypeId() == TYPEID_GAMEOBJECT)
+//			{
+//				if (entry == iter->second.state_gameobject1)
+//					worldstateIndex = iter->second.state_gameobjectWorldState1;
+//				else if (entry == iter->second.state_gameobject2)
+//					worldstateIndex = iter->second.state_gameobjectWorldState2;
+//				else if (entry == iter->second.state_gameobject3)
+//					worldstateIndex = iter->second.state_gameobjectWorldState3;
+//			}
+//			else if (obj->GetTypeId() == TYPEID_PLAYER)
+//			{
+//				if (Player* victim = obj->ToPlayer())
+//				{
+//					TeamTypes team = GetTeam(victim);
+//
+//					if (team == C_TEAM_DEFENSE)
+//						worldstateIndex = iter->second.state_offenseWorldState;
+//					else if (team == C_TEAM_OFFENSE)
+//						worldstateIndex = iter->second.state_defenseWorldState;
+//
+//					increase = false;
+//				}
+//			}
+//
+//			if (worldstateIndex == 0)
+//				continue;
+//
+//			if (increase)
+//				sWorld->setWorldState(worldstateIndex, sWorld->getWorldState(worldstateIndex) + 1);
+//			else
+//				sWorld->setWorldState(worldstateIndex, sWorld->getWorldState(worldstateIndex) - 1);
+//
+//			uint32 value = sWorld->getWorldState(worldstateIndex);
+//
+//			SessionMap const& smap = sWorld->GetAllSessions();
+//			for (SessionMap::const_iterator i = smap.begin(); i != smap.end(); ++i)
+//				if (Player* pl = i->second->GetPlayer())
+//					pl->SendUpdateWorldState(worldstateIndex, value);
+//		}
+//	}
+//}
+//
+////¼¤»î
+//void CustomEvent::UpdateActive(Object *obj)
+//{
+//	bool valid = false;
+//	uint32 entry = obj->GetEntry();
+//	TypeID typeId = obj->GetTypeId();
+//
+//	uint32 len = EventActiveVec.size();
+//
+//	for (uint32 i = 0; i < len; i++)
+//	{
+//		if (typeId == TYPEID_UNIT && entry == EventActiveVec[i].creatureEntry)
+//		{
+//			valid = true;
+//			break;
+//		}
+//		else if (typeId == TYPEID_GAMEOBJECT && entry == EventActiveVec[i].gameobjectEntry)
+//		{
+//			valid = true;
+//			break;
+//		}
+//	}
+//
+//	if (!valid)
+//		return;
+//
+//	for (uint32 i = 0; i < len; i++)
+//	{
+//		if (_eventId == EventActiveVec[i].eventId)
+//		{
+//			if (GetKillCreatureCount(EventActiveVec[i].creatureEntry) >= EventActiveVec[i].killCount && GetDestroyGobCount(EventActiveVec[i].gameobjectEntry) >= EventActiveVec[i].destroyCount)
+//			{
+//				uint32 activeGUID = EventActiveVec[i].activeGUID;
+//				uint32 activeType = EventActiveVec[i].activeType;
+//
+//				if (activeType == 0)
+//				{
+//					if (CreatureData const* data = sObjectMgr->GetCreatureData(activeGUID))
+//					{
+//						if (Creature* target = ObjectAccessor::GetObjectInWorld(MAKE_NEW_GUID(activeGUID, data->id, HIGHGUID_UNIT), (Creature*)NULL))
+//						{
+//							if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE) || target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
+//							{
+//								std::ostringstream oss;
+//								target->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
+//								oss << _eventName << "[" << target->GetName() << "]ÏÖÔÚ¿ÉÒÔ¹¥»÷ÁË£¡";
+//								sWorld->SendScreenMessage(oss.str().c_str());
+//							}
+//						}
+//					}
+//				}
+//				else
+//				{
+//					if (GameObjectData const* data = sObjectMgr->GetGOData(activeGUID))
+//					{
+//						if (GameObject* target = ObjectAccessor::GetObjectInWorld(MAKE_NEW_GUID(activeGUID, data->id, HIGHGUID_GAMEOBJECT), (GameObject*)NULL))
+//						{
+//							if (target->HasFlag(GAMEOBJECT_FLAGS, GO_FLAG_NOT_SELECTABLE))
+//							{
+//								std::ostringstream oss;
+//								target->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_NOT_SELECTABLE);
+//								oss << _eventName << "[" << target->GetName() << "]ÒÑ¾­¼¤»î£¡";
+//								sWorld->SendScreenMessage(oss.str().c_str());
+//							}		
+//						}
+//					}
+//				}
+//			}
+//		}
+//	}
+//}
+//
+////Íæ¼Ò
+//bool CustomEvent::AcceptInvitation(Player* player, uint32 menuId)
+//{
+//	if (menuId < 1000000)
+//		return false;
+//
+//	uint32 eventId = menuId - 1000000;
+//
+//	if (!sGameEventMgr->IsActiveEvent(eventId))
+//	{
+//		player->GetSession()->SendNotification("¸ÃÊÂ¼þÒÑ¾­½áÊø£¡");
+//		return true;
+//	}
+//
+//	if (eventId == UKBG_EVENT_ID)
+//	{
+//		sUkBG->AddPlayer(player);
+//		return true;
+//	}
+//
+//	switch (_eventType)
+//	{
+//	case C_ET_NONE:
+//		break;
+//	case C_ET_WS:
+//		player->GetSession()->FixedBGJoin(BATTLEGROUND_WS);
+//		break;
+//	case C_ET_AB:
+//		player->GetSession()->FixedBGJoin(BATTLEGROUND_AB);
+//		break;
+//	case C_ET_EY:
+//		player->GetSession()->FixedBGJoin(BATTLEGROUND_EY);
+//		break;
+//	case C_ET_SA:
+//		player->GetSession()->FixedBGJoin(BATTLEGROUND_SA);
+//		break;
+//	case C_ET_AV:
+//		player->GetSession()->FixedBGJoin(BATTLEGROUND_AV);
+//		break;
+//	case C_ET_IC:
+//		player->GetSession()->FixedBGJoin(BATTLEGROUND_IC);
+//		break;
+//	case C_ET_TELE:
+//	{
+//		uint32 map = 0; float x = 0; float y = 0; float z = 0; float o = 0;
+//		player->GetTeamId() == TEAM_ALLIANCE ? GetTelePos(eventId, C_PT_START_DEFENSE, map, x, y, z, o) : GetTelePos(eventId, C_PT_START_OFFENSE, map, x, y, z, o);
+//
+//		if (map == 0 && x == 0 && y == 0 && z == 0)
+//			return true;
+//
+//		player->TeleportTo(map, x, y, z, o);
+//	}
+//	break;
+//	case C_ET_GROUP:
+//		AddNewToGroup(player);
+//		break;
+//	default:
+//		break;
+//	}
+//
+//	return true;
+//}
+//
+//uint32 CustomEvent::GetTeamMembers(TeamTypes team)
+//{
+//	uint32 count = 0;
+//
+//	std::unordered_map<uint32, EventPlayerTemplate>::iterator iter;
+//	for (iter = PlayerDataMap.begin(); iter != PlayerDataMap.end(); iter++)
+//		if (team == iter->second.team)
+//			count++;
+//
+//	return count;
+//}
+//
+//TeamTypes CustomEvent::GetTeam(Player* player)
+//{
+//	std::unordered_map<uint32, EventPlayerTemplate>::iterator ii = PlayerDataMap.find(player->GetGUIDLow());
+//	if (ii != PlayerDataMap.end())
+//		return ii->second.team;
+//
+//	return C_TEAM_NONE;
+//}
+//
+//TeamTypes CustomEvent::SetTeam(Player* player)
+//{
+//	TeamTypes team = C_TEAM_NONE;
+//
+//	switch (_groupType)
+//	{
+//	case C_GT_OFFENSE_ALL:
+//		team = C_TEAM_OFFENSE;
+//		break;
+//	case C_GT_OFFENSE_ALLY:
+//		if (player->GetTeamId() == TEAM_ALLIANCE)
+//			team = C_TEAM_OFFENSE;
+//		else
+//			team = C_TEAM_DEFENSE;
+//		break;
+//	case C_GT_OFFENSE_HORDE:
+//		if (player->GetTeamId() == TEAM_HORDE)
+//			team = C_TEAM_OFFENSE;
+//		else
+//			team = C_TEAM_DEFENSE;
+//		break;
+//	case C_GT_OFFENSE_FACTION_RANDOM:
+//
+//		if (_AllyAsOffense)
+//		{
+//			if (player->GetTeamId() == TEAM_ALLIANCE)
+//				team = C_TEAM_OFFENSE;
+//			else
+//				team = C_TEAM_DEFENSE;
+//		}
+//		else
+//		{
+//			if (player->GetTeamId() == TEAM_HORDE)
+//				team = C_TEAM_OFFENSE;
+//			else
+//				team = C_TEAM_DEFENSE;
+//		}
+//		break;
+//	case C_GT_OFFENSE_PLAYER_RANDOM:
+//	{
+//		uint32 defenseCount = GetTeamMembers(C_TEAM_DEFENSE);
+//		uint32 offenseCount = GetTeamMembers(C_TEAM_OFFENSE);
+//
+//		if (offenseCount > defenseCount)
+//			team = C_TEAM_DEFENSE;
+//		else if (offenseCount < defenseCount)
+//			team = C_TEAM_OFFENSE;
+//		else
+//		{
+//			if (urand(0, 1) == 0)
+//				team = C_TEAM_OFFENSE;
+//			else
+//				team = C_TEAM_DEFENSE;
+//		}
+//	}
+//	break;
+//	}
+//
+//	std::unordered_map<uint32, EventPlayerTemplate>::iterator ii = PlayerDataMap.find(player->GetGUIDLow());
+//	if (ii != PlayerDataMap.end())
+//		ii->second.team = team;
+//
+//	return team;
+//}
+//
+//void CustomEvent::SetFaction(Player* player, TeamTypes team)
+//{
+//	if (team == C_TEAM_DEFENSE)
+//		player->setFaction(DEFENSE_FACTION);
+//	else if (team == C_TEAM_OFFENSE)
+//		player->setFaction(OFFENSE_FACTION);
+//}
+//
+//void CustomEvent::SetValid(Player* player, bool valid)
+//{
+//	std::unordered_map<uint32, EventPlayerTemplate>::iterator iter = PlayerDataMap.find(player->GetGUIDLow());
+//
+//	if (iter != PlayerDataMap.end())
+//		iter->second.valid = valid;
+//}
+//
+//bool CustomEvent::CheckValid(Player* player)
+//{
+//	std::unordered_map<uint32, EventPlayerTemplate>::iterator iter = PlayerDataMap.find(player->GetGUIDLow());
+//
+//	if (iter != PlayerDataMap.end())
+//		return iter->second.valid;
+//
+//	return false;
+//}
+//
+//TeamTypes CustomEvent::AddPlayer(Player* player)
+//{
+//	TeamTypes team = C_TEAM_NONE;
+//
+//	std::unordered_map<uint32, EventPlayerTemplate>::iterator ii = PlayerDataMap.find(player->GetGUIDLow());
+//
+//	if (ii != PlayerDataMap.end())
+//	{
+//		switch (_rejoinType)
+//		{
+//		case C_RT_BANED:
+//			break;
+//		case C_RT_KEEP_GROUP:
+//			team = GetTeam(player);
+//			SetFaction(player, team);
+//			SetValid(player, true);
+//			break;
+//		case C_RT_REDIS_GROUP:
+//			team = SetTeam(player);
+//			SetFaction(player, team);
+//			SetValid(player, true);
+//			break;
+//		}
+//	}
+//	else
+//	{
+//		team = SetTeam(player);
+//		SetFaction(player, team);
+//
+//		std::unordered_map<uint32, EventPlayerTemplate>::iterator iter = PlayerDataMap.find(player->GetGUIDLow());
+//
+//		if (iter == PlayerDataMap.end())
+//		{
+//			EventPlayerTemplate Temp;
+//			Temp.team = team;
+//			Temp.damage = 0;
+//			Temp.heal = 0;
+//			Temp.kills = 0;
+//			Temp.killeds = 0;
+//			Temp.valid = true;
+//			PlayerDataMap.insert(std::make_pair(player->GetGUIDLow(), Temp));
+//		}
+//	}
+//
+//	return team;
+//}
+//
+//void CustomEvent::AddNewToGroup(Player* player)
+//{
+//	//ÒÑ¾­ÔÚÊÂ¼þÖÐ
+//	if (CheckValid(player))
+//	{
+//		ChatHandler(player->GetSession()).PSendSysMessage("%sÖØÐÂ¼ÓÈëÊÂ¼þÊ§°Ü£¡ÄãÒÑ¾­¼ÓÈëÊÂ¼þ£¡", _eventName.c_str());
+//		return;
+//	}
+//	
+//	//³¬¹ýIPÏÞÖÆ
+//	if (!sCF->joinEventIsAllowed(_eventId, player))
+//		return;
+//
+//	TeamTypes team = AddPlayer(player);
+//
+//	//½ûÖ¹ÖØÐÂ¼ÓÈë
+//	if (team == C_TEAM_NONE)
+//	{
+//		ChatHandler(player->GetSession()).PSendSysMessage("%s¼ÓÈëÊ§°Ü£¡ÎÞ·¨ÖØÐÂ¼ÓÈë£¡", _eventName.c_str());
+//		return;
+//	}
+//
+//	if (team == C_TEAM_DEFENSE)
+//		ChatHandler(player->GetSession()).PSendSysMessage("%sÄã½«Îª%s¶øÕ½£¡", _eventName.c_str(), _defenseName.c_str());
+//	else
+//		ChatHandler(player->GetSession()).PSendSysMessage("%sÄã½«Îª%s¶øÕ½£¡", _eventName.c_str(), _offenseName.c_str());
+//
+//	if (player->isDead())
+//	{
+//		player->ResurrectPlayer(1.0f);
+//		player->SpawnCorpseBones();
+//	}
+//
+//	player->UpdateMaxHealth();
+//	player->UninviteFromGroup();
+//	if (player->GetGroup())
+//		player->RemoveFromGroup();
+//
+//	TelePort(player);
+//
+//	bool groupExist = false;
+//
+//	for (std::unordered_map<uint32, TeamTypes>::iterator ii = GroupDataMap.begin(); ii != GroupDataMap.end(); ii++)
+//	{
+//		if (Group* group = sGroupMgr->GetGroupByGUID(ii->first))
+//			if (!group->IsFull() && ii->second == team)
+//			{
+//				group->AddMember(player);
+//				groupExist = true;
+//				break;
+//			}
+//	}
+//
+//	if (!groupExist)
+//	{
+//		Group* group = new Group;
+//		group->Create(player);
+//		group->ConvertToRaid();
+//		sGroupMgr->AddGroup(group);
+//		GroupDataMap.insert(std::make_pair(group->GetLowGUID(), team));
+//	}
+//}
+//
+//void CustomEvent::TelePort(Player* player)
+//{
+//	uint32 map = 0;
+//	float x = 0;
+//	float y = 0;
+//	float z = 0;
+//	float o = 0;
+//
+//	TeamTypes team = GetTeam(player);
+//
+//	if (team == C_TEAM_DEFENSE)
+//		GetTelePos(_eventId, C_PT_START_DEFENSE, map, x, y, z, o);
+//	else if (team == C_TEAM_OFFENSE)
+//		GetTelePos(_eventId, C_PT_START_OFFENSE, map, x, y, z, o);
+//
+//
+//	if (map == 0 && x == 0 && y == 0 && z == 0)
+//		return;
+//
+//	player->TeleportTo(map, x, y, z, 0);
+//}
+//
+//void CustomEvent::Revive(Player* player)
+//{
+//	player->GetSession()->SendAreaTriggerMessage("%sÄÃ³öÄãµÄÓÂÆø£¬¼ÌÐøÕ½¶·£¡", _eventName.c_str());
+//	player->CastSpell(player, 24171, true);
+//	player->ResurrectPlayer(1.0f);
+//	player->CastSpell(player, 6962, true);
+//	player->CastSpell(player, 44535, true);
+//	player->SpawnCorpseBones();
+//}
+//
+//bool CustomEvent::DiedTele(Player* player)
+//{
+//	if (!CheckValid(player))
+//		return false;
+//
+//	TeamTypes team = GetTeam(player);
+//
+//	if (team == C_TEAM_NONE)
+//		return false;
+//
+//	if (team == C_TEAM_DEFENSE)
+//		Teleport(player, _graveyard_defense_pos);
+//	else if (team == C_TEAM_OFFENSE)
+//		Teleport(player, _graveyard_offense_pos);
+//
+//	return true;
+//}
+//
+//bool CustomEvent::SendAreaSpiritHealerQueryOpcode(Player* player)
+//{
+//	if (!player || player->IsAlive())
+//		return false;
+//
+//	if (_eventId == 0)
+//		return false;
+//
+//	if (_reviveUpdateTimer <= 0)
+//		return false;
+//
+//	TeamTypes team = GetTeam(player);
+//
+//	if (team == C_TEAM_NONE)
+//		return false;
+//
+//	WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
+//
+//	if (team == C_TEAM_DEFENSE)
+//		data << _soulhealer_defense;
+//	else
+//		data << _soulhealer_offense;
+//
+//	data << _reviveUpdateTimer;
+//	player->GetSession()->SendPacket(&data);
+//	return true;
+//}
+//
+//void CustomEvent::RemovePlayer(Player* player)
+//{
+//	if (!CheckValid(player))
+//		return;
+//
+//	std::unordered_map<uint32, EventPlayerTemplate>::iterator ii = PlayerDataMap.find(player->GetGUIDLow());
+//
+//	if (ii != PlayerDataMap.end())
+//		ii->second.valid = false;
+//
+//	ChatHandler(player->GetSession()).PSendSysMessage("ÄãÒÑ¾­Àë¿ª%s", _eventName.c_str());
+//	player->setFactionForRace(player->getRace());
+//	player->UpdateMaxHealth();
+//	player->UninviteFromGroup();
+//	if (player->GetGroup())
+//		player->RemoveFromGroup();
+//	player->TeleportTo(player->m_homebindMapId, player->m_homebindX, player->m_homebindY, player->m_homebindZ, 0);
+//}
+//
+//void CustomEvent::ResetAllPlayers()
+//{
+//	//ÖØÖÃplayer
+//	for (std::unordered_map<uint32, EventPlayerTemplate>::iterator ii = PlayerDataMap.begin(); ii != PlayerDataMap.end(); ii++)
+//		if (Player* player = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(ii->first, 0, HIGHGUID_PLAYER)))
+//		{
+//			if (!ii->second.valid)
+//				continue;
+//
+//			player->setFactionForRace(player->getRace());
+//
+//			if (player->isDead())
+//			{
+//				player->ResurrectPlayer(1.0f);
+//				player->SpawnCorpseBones();
+//			}
+//
+//			player->UpdateMaxHealth();
+//			//Çå³ý¶ÓÎé×´Ì¬
+//			player->UninviteFromGroup();
+//			if (player->GetGroup())
+//				player->RemoveFromGroup();
+//		}
+//}
+//
+//void CustomEvent::RewardAllPlayers()
+//{
+//	for (std::unordered_map<uint32, EventPlayerTemplate>::iterator ii = PlayerDataMap.begin(); ii != PlayerDataMap.end(); ii++)
+//	{
+//		if (Player* player = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(ii->first, 0, HIGHGUID_PLAYER)))
+//		{
+//			ChatHandler(player->GetSession()).PSendSysMessage("%s»îÔ¾¶ÈÍ³¼Æ", _eventName.c_str());
+//			ChatHandler(player->GetSession()).PSendSysMessage("%s»÷É±£º%u/%u", _eventName.c_str(), ii->second.kills, _rew_killsForRew);
+//			ChatHandler(player->GetSession()).PSendSysMessage("%s±»É±£º%u/%u", _eventName.c_str(), ii->second.killeds, _rew_killedsForRew);
+//			ChatHandler(player->GetSession()).PSendSysMessage("%sÉËº¦£º%u/%u", _eventName.c_str(), ii->second.damage, _rew_damageForRew);
+//			ChatHandler(player->GetSession()).PSendSysMessage("%sÖÎÁÆ£º%u/%u", _eventName.c_str(), ii->second.heal, _rew_healForRew);
+//
+//			if (!ii->second.valid)
+//			{
+//				ChatHandler(player->GetSession()).PSendSysMessage("%sÄãÖÐÍ¾Àë¿ª»î¶¯£¬ÎÞ·¨»ñµÃ½±Àø", _eventName.c_str());
+//				continue;
+//			}
+//
+//			if (ii->second.kills < _rew_killsForRew && ii->second.killeds < _rew_killedsForRew && ii->second.damage < _rew_damageForRew && ii->second.heal < _rew_healForRew)
+//			{
+//				ChatHandler(player->GetSession()).PSendSysMessage("%s»îÔ¾¶ÈÎ´´ïµ½ÒªÇó£¬ÎÞ·¨»ñµÃ½±Àø", _eventName.c_str(), ii->second.heal);
+//				continue;
+//			}
+//
+//			if (player && player->IsInWorld())
+//				ii->second.team == _winTeam ? sRew->Rew(player, _rew_winRewId) : sRew->Rew(player, _rew_losRewId);
+//		}	
+//	}
+//}
+//
+//void CustomEvent::IncreaseDamage(Player* player,Unit* target, uint32 damage)
+//{
+//	std::unordered_map<uint32, EventPlayerTemplate>::iterator ii = PlayerDataMap.find(player->GetGUIDLow());
+//
+//	if (ii != PlayerDataMap.end())
+//		if (target->GetTypeId() != TYPEID_PLAYER)
+//			ii->second.damage += damage;
+//}
+//
+//void CustomEvent::IncreaseHeal(Player* player, Unit* target, uint32 heal)
+//{
+//	std::unordered_map<uint32, EventPlayerTemplate>::iterator ii = PlayerDataMap.find(player->GetGUIDLow());
+//
+//	if (ii != PlayerDataMap.end())
+//		if (target->GetTypeId() != TYPEID_PLAYER)
+//			ii->second.heal += heal;
+//}
+//
+//void CustomEvent::IncreaseKills(Player* player)
+//{
+//	std::unordered_map<uint32, EventPlayerTemplate>::iterator ii = PlayerDataMap.find(player->GetGUIDLow());
+//
+//	if (ii != PlayerDataMap.end())
+//			ii->second.kills ++;
+//}
+//
+//void CustomEvent::IncreaseKilleds(Player* player)
+//{
+//	std::unordered_map<uint32, EventPlayerTemplate>::iterator ii = PlayerDataMap.find(player->GetGUIDLow());
+//
+//	if (ii != PlayerDataMap.end())
+//			ii->second.killeds++;
+//}
+//
+//void CustomEvent::Teleport(Player* player, uint32 posId)
+//{
+//	std::unordered_map<uint32, PosTemplate>::iterator it = PosMap.find(posId);
+//
+//	if (it != PosMap.end())
+//		player->TeleportTo(it->second.map, it->second.x, it->second.y, it->second.z, it->second.o);
+//}
+//
+//void CustomEvent::Update(Player* player)
+//{
+//	if (!CheckValid(player))
+//		return;
+//
+//	switch (_eventId)
+//	{
+//	case NARROW_EVENT_ID:			//ÏÁÂ·Ïà·ê
+//	{
+//		uint32 posId = 0;
+//
+//		GetTeam(player) == C_TEAM_OFFENSE ? posId = NARROW_EVENT_OFFENSE_POSID : posId = NARROW_EVENT_DEFENSE_POSID;
+//
+//		if (!player->IsAlive())
+//		{
+//			Teleport(player, posId);
+//			Revive(player);
+//		}
+//
+//		float distance = GetDistance(player, posId);
+//
+//		if (distance < 127.3)
+//			player->RemoveAura(NARROW_EVENT_DEBUFF_ID);
+//		else if (!player->HasAura(NARROW_EVENT_DEBUFF_ID))
+//			player->AddAura(NARROW_EVENT_DEBUFF_ID, player);
+//	}
+//	break;
+//	case PORT_EVENT_ID:
+//
+//	default:
+//		break;
+//	}
+//}
+//
+//void CustomEvent::UpdatePhase(Object* obj)
+//{
+//	uint32 guid = obj->GetGUIDLow();
+//	TypeID typeId = obj->GetTypeId();
+//
+//	auto iter = EventDataMap.find(_eventId);
+//
+//	if (iter != EventDataMap.end())
+//	{
+//		auto i = iter->second.eventPhaseMap.find(_eventPhase);
+//
+//		if (i != iter->second.eventPhaseMap.end())
+//		{
+//			if (i->second.stop_creature == 0)
+//				_stop_creature_flag = true;
+//
+//			if (i->second.stop_gameobject == 0)
+//				_stop_gameobject_flag = true;
+//
+//			if (i->second.stop_kills == 0)
+//				_stop_kills_flag = true;
+//
+//			if (typeId == TYPEID_UNIT && guid == i->second.stop_creature)
+//				_stop_creature_flag = true;
+//
+//			if (typeId == TYPEID_GAMEOBJECT && guid == i->second.stop_gameobject)
+//				_stop_gameobject_flag = true;
+//
+//			if (typeId == TYPEID_PLAYER && (GetKillPlayerCount(C_TEAM_DEFENSE) >= i->second.stop_kills || GetKillPlayerCount(C_TEAM_OFFENSE) >= i->second.stop_kills))
+//				_stop_kills_flag = true;
+//		}
+//	}
+//	else
+//		return;
+//
+//	if (_stop_creature_flag && _stop_gameobject_flag && _stop_kills_flag)
+//	{
+//		_stop_creature_flag = false;
+//		_stop_gameobject_flag = false;
+//		_stop_kills_flag = false;
+//
+//		auto i = iter->second.eventPhaseMap.find(_eventPhase);
+//
+//		if (i != iter->second.eventPhaseMap.end())
+//		{
+//			std::unordered_map<uint32, EventPlayerTemplate>::iterator iter;
+//			for (iter = PlayerDataMap.begin(); iter != PlayerDataMap.end(); iter++)
+//			{
+//				if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(iter->first, 0, HIGHGUID_PLAYER)))
+//				{
+//					if (!iter->second.valid)
+//						continue;
+//
+//					if (!pl->IsInWorld())
+//						continue;
+//
+//					if (!pl->IsAlive())
+//					{
+//						pl->CastSpell(pl, 22012, true);
+//						Revive(pl);
+//					}
+//
+//					if (GetTeam(pl) == C_TEAM_DEFENSE)
+//						Teleport(pl, i->second.stop_defense_tele_pos);
+//					if (GetTeam(pl) == C_TEAM_OFFENSE)
+//						Teleport(pl, i->second.stop_offense_tele_pos);
+//				}
+//			}
+//
+//			if (!i->second.stop_defense_notice.empty())
+//			{
+//				std::string text = _eventName + i->second.stop_defense_notice;
+//				SendScreenMessage(text.c_str(), C_TEAM_DEFENSE);
+//			}
+//				
+//			if (!i->second.stop_offense_notice.empty())
+//			{
+//				std::string text = _eventName + i->second.stop_offense_notice;
+//				SendScreenMessage(text.c_str(), C_TEAM_OFFENSE);
+//			}
+//		}
+//
+//		_eventPhase++;
+//
+//		i = iter->second.eventPhaseMap.find(_eventPhase);
+//
+//		if (i != iter->second.eventPhaseMap.end())
+//		{
+//			_graveyard_defense_pos = i->second.defense_graveyard_pos;
+//			_graveyard_offense_pos = i->second.offense_graveyard_pos;
+//			_defense_graveyard_safe = i->second.defense_graveyard_safe;
+//			_offense_graveyard_safe = i->second.offense_graveyard_safe;
+//			_defense_graveyard_healer = i->second.defense_graveyard_healer;
+//			_offense_graveyard_healer = i->second.offense_graveyard_healer;
+//			SummonSoulHealer();
+//		}
+//	}
+//}
+//
+//void CustomEvent::SendScreenMessage(const char *text, TeamTypes team, bool onlydead)
+//{
+//	WorldPacket data;
+//	ChatHandler::BuildChatPacket(data, CHAT_MSG_RAID_BOSS_EMOTE, LANG_UNIVERSAL,
+//		NULL, NULL, text);
+//
+//	std::unordered_map<uint32, EventPlayerTemplate>::iterator iter;
+//	for (iter = PlayerDataMap.begin(); iter != PlayerDataMap.end(); iter++)
+//	{
+//		if (team == iter->second.team || team == C_TEAM_NONE)
+//		{
+//			if (Player* player = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(iter->first, 0, HIGHGUID_PLAYER)))
+//			{
+//				if (!iter->second.valid)
+//					continue;
+//
+//				if (player->IsAlive() && onlydead)
+//					continue;
+//
+//				if (WorldSession* ss = player->GetSession())
+//					player->GetSession()->SendPacket(&data);
+//			}
+//		}
+//	}	
+//}
+//
+//void CustomEvent::UpdateRevive(uint32 diff)
+//{
+//	if (_graveyard_defense_pos == 0 && _graveyard_offense_pos == 0)
+//		return;
+//
+//	if (_reviveUpdateTimer > 0)
+//		_reviveUpdateTimer -= diff;
+//	else
+//	{
+//		_reviveUpdateTimer = REVIVE_INTERVALS;
+//
+//		std::unordered_map<uint32, EventPlayerTemplate>::iterator iter;
+//		for (iter = PlayerDataMap.begin(); iter != PlayerDataMap.end(); iter++)
+//		{
+//			if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(iter->first, 0, HIGHGUID_PLAYER)))
+//			{
+//				if (!iter->second.valid)
+//					continue;
+//
+//				if (!pl->IsInWorld())
+//					continue;
+//
+//				if (pl->IsAlive())
+//					continue;
+//
+//				if (GetTeam(pl) == C_TEAM_DEFENSE && GetDistance(pl, _graveyard_defense_pos) > 20.0f)
+//					continue;
+//
+//				if (GetTeam(pl) == C_TEAM_OFFENSE && GetDistance(pl, _graveyard_offense_pos) > 20.0f)
+//					continue;
+//
+//				pl->CastSpell(pl, 22012, true);
+//				Revive(pl);
+//			}
+//		}
+//	}
+//}
+//
+//void CustomEvent::UpdateSafeArea(uint32 diff)
+//{
+//	if (_graveyard_defense_pos == 0 && _graveyard_offense_pos == 0)
+//		return;
+//
+//	if (_safeAreaUpdateTimer > 0)
+//		_safeAreaUpdateTimer -= diff;
+//	else
+//	{
+//		_safeAreaUpdateTimer = IN_MILLISECONDS;
+//
+//		std::unordered_map<uint32, EventPlayerTemplate>::iterator iter;
+//		for (iter = PlayerDataMap.begin(); iter != PlayerDataMap.end(); iter++)
+//		{
+//			if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(iter->first, 0, HIGHGUID_PLAYER)))
+//			{
+//				if (!iter->second.valid)
+//					continue;
+//
+//				if (!pl->IsInWorld())
+//					continue;
+//
+//				if (!pl->IsAlive())
+//					continue;
+//				
+//				if (GetTeam(pl) == C_TEAM_OFFENSE && GetDistance(pl, _graveyard_defense_pos) <= _defense_graveyard_safe)
+//				{
+//					std::ostringstream oss;
+//					oss << _eventName << "ÄãÒÑ½øÈëµÐ·½Ä¹µØ±£»¤ÇøÓò" << _defense_graveyard_safe << "£¬Ç¿ÖÆ´«ËÍ";
+//					pl->GetSession()->SendNotification(oss.str().c_str());
+//					Teleport(pl, _graveyard_offense_pos);
+//				}
+//
+//				if (GetTeam(pl) == C_TEAM_DEFENSE && GetDistance(pl, _graveyard_offense_pos) < _offense_graveyard_safe)
+//				{
+//					std::ostringstream oss;
+//					oss << _eventName << "ÄãÒÑ½øÈëµÐ·½Ä¹µØ±£»¤ÇøÓò" << _offense_graveyard_safe << "£¬Ç¿ÖÆ´«ËÍ";
+//					pl->GetSession()->SendNotification(oss.str().c_str());
+//					Teleport(pl, _graveyard_defense_pos);
+//				}		
+//			}
+//		}
+//	}
+//}
+//
+//void CustomEvent::Update(Map* map, uint32 diff)
+//{
+//	if (!map)
+//		return;
+//
+//	if (map->GetId() != _mapId)
+//		return;
+//
+//	UpdateRevive(diff);
+//	UpdateSafeArea(diff);
+//}
+//
+////Õ½³¡
+//bool CustomEvent::IsFixedTimeBgActive(BattlegroundTypeId bgTypeId)
+//{
+//	EventTypes eventType = C_ET_NONE;
+//
+//	switch (bgTypeId)
+//	{
+//	case BATTLEGROUND_AV:
+//		eventType = C_ET_AV;
+//		break;
+//	case BATTLEGROUND_WS:
+//		eventType = C_ET_WS;
+//		break;
+//	case BATTLEGROUND_AB:
+//		eventType = C_ET_AB;
+//		break;
+//	case BATTLEGROUND_EY:
+//		eventType = C_ET_EY;
+//		break;
+//	case BATTLEGROUND_SA:
+//		eventType = C_ET_SA;
+//		break;
+//	case BATTLEGROUND_IC:
+//		eventType = C_ET_IC;
+//		break;
+//	}
+//
+//	if (eventType == _eventType)
+//		return true;
+//
+//	return false;
+//}
+//
+//void CustomEvent::AddBgList(Player* player)
+//{
+//	GameEventMgr::ActiveEvents const& activeEvents = sGameEventMgr->GetActiveEventList();
+//
+//	for (GameEventMgr::ActiveEvents::const_iterator itr = activeEvents.begin(); itr != activeEvents.end(); ++itr)
+//	{
+//		std::unordered_map<uint32, EventDataTemplate>::iterator iter = EventDataMap.find(*itr);
+//
+//		if (iter != EventDataMap.end())
+//		{
+//			if (iter->second.eventType == C_ET_NONE || iter->second.eventType > C_ET_IC)
+//				continue;
+//
+//			const BattlegroundContainer& bgList = sBattlegroundMgr->GetBattlegroundList();
+//			for (BattlegroundContainer::const_iterator ii = bgList.begin(); ii != bgList.end(); ++ii)
+//			{
+//				Battleground* bg = ii->second;
+//				if (!bg)
+//					continue;
+//
+//				if (!iter->second.gossipText.empty())
+//					player->ADD_GOSSIP_ITEM(0, iter->second.gossipText, SENDER_CUSTOM_EVENT, *itr);
+//			}
+//		}
+//	}
+//}
+//
+//void CustomEvent::AddEventList(Player* player, Object* obj, bool isBG)
+//{
+//	player->PlayerTalkClass->ClearMenus();
+//
+//	GameEventMgr::ActiveEvents const& activeEvents = sGameEventMgr->GetActiveEventList();
+//
+//	for (GameEventMgr::ActiveEvents::const_iterator itr = activeEvents.begin(); itr != activeEvents.end(); ++itr)
+//	{
+//		std::unordered_map<uint32, EventDataTemplate>::iterator iter = EventDataMap.find(*itr);
+//
+//		if (iter != EventDataMap.end())
+//		{
+//			if (iter->second.eventType == C_ET_NONE)
+//				continue;
+//
+//			if (!iter->second.gossipText.empty())
+//				player->ADD_GOSSIP_ITEM(0, iter->second.gossipText, SENDER_CUSTOM_EVENT, *itr);
+//		}
+//	}
+//
+//	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+//}
+//
+////Unk1 = 1Ê± ¼ì²âÕóÓªÊÇ·ñÒ»ÖÂ Ò»ÖÂÔòÍ¨¹ý ¿ÉÒÔÊÍ·Å¼¼ÄÜ
+//bool CustomEvent::GobUnk1Check(Unit* target, GameObject *const gob)
+//{
+//	if (!target)
+//		return true;
+//
+//	GameObjectTemplate const* temp = sObjectMgr->GetGameObjectTemplate(gob->GetEntry());
+//
+//	if (std::strcmp(temp->unk1.c_str(), "1") != 0)
+//		return true;
+//
+//	if (temp->faction != target->getFaction())
+//		return false;
+//
+//	return true;
+//}
+//
+//void CustomEvent::PrintPos(Player* player,uint32 posId1, uint32 posId2, uint32 count, bool addPos)
+//{
+//	float x1, x2, y1, y2, z1, z2, o1, o2;
+//	uint32 map1, map2;
+//
+//	bool exsit1 = false;
+//	bool exsit2 = false;
+//
+//	std::unordered_map<uint32, PosTemplate>::iterator it = PosMap.find(posId1);
+//
+//	if (it != PosMap.end())
+//	{
+//		map1 = it->second.map;
+//		x1 = it->second.x;
+//		y1 = it->second.y;
+//		z1 = it->second.z;
+//		o1 = it->second.o;
+//		exsit1 = true;
+//	}
+//
+//	it = PosMap.find(posId2);
+//
+//	if (it != PosMap.end())
+//	{
+//		map2 = it->second.map;
+//		x2 = it->second.x;
+//		y2 = it->second.y;
+//		z2 = it->second.z;
+//		o2 = it->second.o;
+//		exsit2 = true;
+//	}
+//
+//	if (exsit1 && exsit2 && map1 == map2)
+//	{
+//		for (uint8 i = 1; i <= count; i++)
+//		{
+//			uint32 map = map1;
+//
+//			float x = (x1 * i + x2 * (count + 1 - i)) / (count + 1);
+//			float y = (y1 * i + y2 * (count + 1 - i)) / (count + 1);
+//			float z = (z1 * i + z2 * (count + 1 - i)) / (count + 1);
+//			float o = (o1 * i + o2 * (count + 1 - i)) / (count + 1);
+//
+//			ChatHandler(player->GetSession()).PSendSysMessage("%u------x:%f,y:%f,z%f", x, y, z);
+//
+//			if (addPos)
+//			{
+//				std::ostringstream oss;
+//				oss << "posId" << posId1 << "Óë" << posId2 << "Ö®¼ä²É¼¯µã" << uint32(i);
+//
+//				uint32 posId = 1;
+//
+//				if (QueryResult result = WorldDatabase.PQuery("SELECT max(posId) FROM _position"))
+//					posId = result->Fetch()[0].GetUInt32() + 1;
+//
+//				WorldDatabase.DirectPExecute("INSERT INTO _position(comment,posId,map,x,y,z,o) VALUES ('%s','%u','%u','%f','%f','%f','%f')", oss.str().c_str(), posId,map, x, y, z, o);
+//
+//				std::ostringstream oss1;
+//				oss1 << "_positionÐÂÔöID:" << posId << "±¸×¢:" << oss.str().c_str();
+//				ChatHandler(player->GetSession()).PSendSysMessage(oss1.str().c_str());
+//			}
+//		}
+//	}
+//}
+//
+//float CustomEvent::GetDistance(Player* player, uint32 posId)
+//{
+//	std::unordered_map<uint32, PosTemplate>::iterator it = PosMap.find(posId);
+//
+//	if (it != PosMap.end())
+//		if (it->second.map == player->GetMapId())
+//			return player->GetDistance(it->second.x, it->second.y, it->second.z);
+//		
+//	return 1000.0f;
+//}
+//
+//float CustomEvent::GetDistance(uint32 posId1, uint32 posId2)
+//{
+//	float x1, x2, y1, y2, z1, z2;
+//	uint32 map1, map2;
+//
+//	bool exsit1 = false;
+//	bool exsit2 = false;
+//
+//	std::unordered_map<uint32, PosTemplate>::iterator it = PosMap.find(posId1);
+//
+//	if (it != PosMap.end())
+//	{
+//		map1 = it->second.map;
+//		x1 = it->second.x;
+//		y1 = it->second.y;
+//		z1 = it->second.z;
+//		exsit1 = true;
+//	}
+//
+//	it = PosMap.find(posId2);
+//
+//	if (it != PosMap.end())
+//	{
+//		map2 = it->second.map;
+//		x2 = it->second.x;
+//		y2 = it->second.y;
+//		z2 = it->second.z;
+//		exsit2 = true;
+//	}
+//
+//	if (exsit1 && exsit2 && map1 == map2)
+//		return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2));
+//
+//	return 0;
+//}
+//
+//class EventPlayerScript : PlayerScript
+//{
+//public:
+//	EventPlayerScript() : PlayerScript("EventPlayerScript") {}
+//
+//	void OnCreatureKill(Player* player, Creature* creature) override
+//	{
+//		if (!sEvent->IsValid() || !sEvent->CheckValid(player))
+//			return;
+//
+//		sEvent->UpdateWorldState(creature, player);
+//		sEvent->Process(player, creature);
+//		sEvent->UpdateActive(creature);
+//		sEvent->UpdatePhase(creature);
+//	}
+//
+//	void OnUseGameObject(Player* player, GameObject* gob) override
+//	{
+//		if (!sEvent->IsValid() || !sEvent->CheckValid(player))
+//			return;
+//
+//		sEvent->UpdateWorldState(gob, player);
+//		sEvent->Process(player, gob);
+//		sEvent->UpdateActive(gob);
+//		sEvent->UpdatePhase(gob);
+//	}
+//
+//	void OnPVPKill(Player* killer, Player* killed) override
+//	{
+//		if (!sEvent->IsValid() || !sEvent->CheckValid(killer) || !sEvent->CheckValid(killed))
+//			return;
+//
+//		sEvent->UpdateWorldState(killed, killer);
+//		sEvent->Process(killer,killed);
+//		sEvent->UpdatePhase(killed);
+//	}
+//
+//	void OnUpdateZone(Player* player, uint32 newZone, uint32 /*newArea*/) 
+//	{
+//		player->RemoveAura(NARROW_EVENT_DEBUFF_ID);
+//
+//		if (!sEvent->IsValid() || sEvent->GetZoneId() == newZone || !sEvent->CheckValid(player))
+//			return;
+//
+//		sEvent->RemovePlayer(player);
+//	}
+//};
+//
+//
+////Ò°ÍâÌôÕ½½Å±¾
+//class StageTrigger : public CreatureScript
+//{
+//public:
+//	StageTrigger() : CreatureScript("StageTrigger") { }
+//
+//	struct StageTriggerAI : public ScriptedAI
+//	{
+//		StageTriggerAI(Creature* creature) : ScriptedAI(creature), Summons(me)
+//		{
+//			stage = 1;
+//			active = true;
+//		}
+//
+//		SummonList Summons;
+//		uint32 stage;
+//		bool active;
+//
+//		void JustSummoned(Creature* summon) override
+//		{
+//			summon->GetMotionMaster()->MoveRandom(5.0f);
+//			Summons.Summon(summon);
+//		}
+//
+//		void Reset() override
+//		{
+//			stage = 1;
+//			active = true;
+//			Summons.DespawnAll();
+//		}
+//
+//		void MoveInLineOfSight(Unit* who)
+//		{
+//			if (Summons.empty() && active)
+//			{
+//				std::ostringstream oss;
+//				oss << "[Ê¤ÕßÎªÍõ]£ºµÚ" << stage << "¹Ø¿ªÊ¼!";
+//				sWorld->SendScreenMessage(oss.str().c_str());
+//				me->SummonCreatureGroup(stage);
+//			}
+//		}
+//
+//		void SummonedCreatureDies(Creature* summon, Unit* killer)  override
+//		{	
+//			std::ostringstream oss;
+//			oss << "[Ê¤ÕßÎªÍõ]£º[" << killer->GetName() << "]»÷É±[" << summon->GetCreatureTemplate()->Name << "]£¬ÌôÕ½³É¹¦£¡";
+//			sWorld->SendScreenMessage(oss.str().c_str());
+//			Summons.Despawn(summon);
+//
+//			me->SummonGameObject(350005, -13216.9, 232.457, 190.98, 1.29123, 0, 0, 0, 0, 0);
+//
+//			stage++;
+//
+//			if (stage > 10)
+//				active = false;
+//		}
+//	};
+//
+//	CreatureAI* GetAI(Creature* creature) const override
+//	{
+//		return new StageTriggerAI(creature);
+//	}
+//};
+//
+//
+//#define MAX_MOUNT_SPELLS 8
+//
+//uint32 MountSpells[MAX_MOUNT_SPELLS] = { 95001, 95002, 95003, 95004, 95005, 95006, 95007, 95008 };
+//
+////HitSpellClone
+//class HitSpellClone : public CreatureScript
+//{
+//public:
+//	HitSpellClone() : CreatureScript("HitSpellClone") { }
+//
+//	struct HitSpellCloneAI : public ScriptedAI
+//	{
+//		HitSpellCloneAI(Creature* creature) : ScriptedAI(creature), Summons(me)
+//		{
+//			MoveTimer = 0;
+//			SpellTimer = 0;
+//			MoveInterval = 20 * IN_MILLISECONDS;
+//		}
+//
+//		SummonList Summons;
+//		uint32 MoveTimer;
+//		uint32 SpellTimer;
+//		uint32 MoveInterval;
+//		std::unordered_map<uint32, int32>SpellMap;
+//		std::vector<const SpellInfo*> SpellVec;
+//		
+//		void Reset() override
+//		{
+//			if (MAX_MOUNT_SPELLS > 1)
+//			{
+//				for (size_t i = 0; i < MAX_MOUNT_SPELLS; i++)
+//					me->RemoveAura(MountSpells[i]);
+//			
+//				me->AddAura(MountSpells[urand(0, MAX_MOUNT_SPELLS - 1)], me);
+//			}
+//
+//			SpellVec.clear();
+//			MoveSpline(MoveInterval);
+//			Summons.DespawnAll();
+//		}
+//
+//		void SpellHit(Unit* caster, const SpellInfo* spell) override
+//		{
+//			if (!caster)
+//				return;
+//
+//			std::unordered_map<uint32, int32>::iterator iter = SpellMap.find(spell->Id);
+//			if (iter != SpellMap.end())
+//				return;
+//
+//			SpellMap.insert(std::make_pair(spell->Id, 0));
+//
+//			if (std::find(SpellVec.begin(), SpellVec.end(), spell) != SpellVec.end())
+//				return;
+//
+//			SpellVec.push_back(spell);
+//		}
+//
+//		void SpellCooldown()
+//		{
+//			for (std::unordered_map<uint32, int32>::iterator iter = SpellMap.begin(); iter != SpellMap.end(); iter++)
+//				if (iter->second > 0)
+//					iter->second--;
+//		}
+//
+//		void CastSpell(uint32 diff)
+//		{
+//			SpellTimer += diff;
+//
+//			if (SpellTimer > 2 * IN_MILLISECONDS)
+//			{
+//				SpellTimer = 0;
+//
+//				std::vector<uint32/*spellId*/> SpellVec;
+//
+//				for (std::unordered_map<uint32, int32>::iterator iter = SpellMap.begin(); iter != SpellMap.end(); iter++)
+//					if (iter->second <= 0)
+//						SpellVec.push_back(iter->first);
+//
+//				if (SpellVec.empty())
+//					return;
+//
+//				uint32 spellId = SpellVec[urand(0, SpellVec.size() - 1)];
+//
+//				DoCast(spellId);
+//
+//				const SpellInfo* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+//
+//				std::unordered_map<uint32, int32>::iterator iter = SpellMap.find(spellId);
+//
+//				if (iter != SpellMap.end())
+//					iter->second = spellInfo->GetRecoveryTime();
+//			}	
+//		}
+//
+//		void MoveSpline(uint32 diff)
+//		{
+//			if (me->IsInCombat())
+//				return;
+//
+//			MoveTimer += diff;
+//
+//			if (MoveTimer >= MoveInterval)
+//			{
+//				MoveTimer = 0;
+//
+//				if (WaypointPath const* i_path = sWaypointMgr->GetPath(me->GetWaypointPath()))
+//				{
+//					me->StopMoving();
+//
+//					float x = me->GetPositionX();
+//					float y = me->GetPositionY();
+//					float z = me->GetPositionZ();
+//
+//					Movement::PointsArray pathPoints;
+//					pathPoints.push_back(G3D::Vector3(x, y, z));
+//
+//					WaypointData const* node;
+//
+//					uint8 _i = 0;
+//					float _dist = 100000.0f;
+//
+//					for (uint8 i = 0; i < i_path->size(); ++i)
+//					{
+//						node = i_path->at(i);
+//
+//						float dist = sqrt((node->x - x) * (node->x - x) + (node->y - y) * (node->y - y) + (node->z - z) * (node->z - z));
+//
+//						if (dist < _dist)
+//						{
+//							_dist = dist;
+//							_i = i;
+//						}
+//					}
+//
+//					for (uint8 i = _i; i < i_path->size(); ++i)
+//					{
+//						node = i_path->at(i);
+//						pathPoints.push_back(G3D::Vector3(node->x, node->y, node->z));
+//					}
+//
+//					for (uint8 i = 0; i < i_path->size(); ++i)
+//					{
+//						node = i_path->at(i);
+//						pathPoints.push_back(G3D::Vector3(node->x, node->y, node->z));
+//					}
+//
+//					me->GetMotionMaster()->MoveSplinePath(&pathPoints);
+//				}
+//			}
+//		}
+//
+//		bool StopOnCasting()
+//		{
+//			if (me->HasUnitState(UNIT_STATE_CASTING))
+//			{
+//				me->StopMoving();
+//				return true;
+//			}
+//			return false;
+//		}
+//
+//		void UpdateAI(uint32 diff)
+//		{
+//			SpellCooldown();
+//			MoveSpline(diff);
+//
+//			if (!UpdateVictim() || StopOnCasting())
+//				return;
+//
+//			CastSpell(diff);
+//			DoMeleeAttackIfReady();
+//		}
+//
+//		void AttackStart(Unit* who)
+//		{
+//			ScriptedAI::AttackStartCaster(who, 10.0f);
+//			ScriptedAI::AttackStart(who);
+//		}
+//
+//		void EnterCombat(Unit* victim) 
+//		{
+//			
+//		}
+//
+//		void MoveInLineOfSight(Unit* who)
+//		{
+//			if (who->IsHostileTo(me) && who->GetDistance(me) < 10.0f && !me->IsInCombat())
+//				AttackStart(who);
+//		}
+//
+//		void JustSummoned(Creature* summon) override
+//		{
+//			Summons.Summon(summon);
+//		}
+//
+//		void SummonedCreatureDies(Creature* summon, Unit* killer)  override
+//		{
+//			
+//		}
+//	};
+//
+//	CreatureAI* GetAI(Creature* creature) const override
+//	{
+//		return new HitSpellCloneAI(creature);
+//	}
+//};
+//
+//void AddSC_CustomEventScript()
+//{
+//	new EventPlayerScript();
+//	new StageTrigger();
+//	new HitSpellClone();
+//}
diff --git a/src/server/scripts/Custom/CustomEvent/CustomEvent.h b/src/server/scripts/Custom/CustomEvent/CustomEvent.h
new file mode 100644
index 0000000..46227f9
--- /dev/null
+++ b/src/server/scripts/Custom/CustomEvent/CustomEvent.h
@@ -0,0 +1,443 @@
+//#define HS_OFFENSE_ENTRY 59999
+//#define HS_DEFENSE_ENTRY 59998
+//
+//#define REVIVE_INTERVALS  20 * IN_MILLISECONDS
+//
+////ÇÀ´ð
+//#define EVENT_ID_QUICK_RESPONSE					70
+//
+////¼ÙÈË¸üÐÂ
+//#define EVENT_ID_FAKE_PLAYER_UPDATE_ZONE_ID		101
+//#define EVENT_ID_FAKE_PLAYER_LOGIN_OR_LOGOUT	100
+//#define EVENT_ID_FAKE_PLAYER_LEVEL_UP			102
+//
+////´óÌÓÉ±
+//#define UKBG_EVENT_ID	74
+//#define UKBG_LENGTH		18000
+//#define UKBG_H_REWID	32
+//#define UKBG_M_REWID	33
+//#define UKBG_L_REWID	33
+//
+////ÏÁÂ·Ïà·ê
+//#define NARROW_EVENT_ID				72
+//#define NARROW_EVENT_DEFENSE_POSID	2
+//#define NARROW_EVENT_OFFENSE_POSID	3
+//#define NARROW_EVENT_DEBUFF_ID		60001
+//
+////ÏÈ·æ¾ü¸Û¿ÚÕù¶áÕ½
+//#define PORT_EVENT_ID					75
+//#define PORT_EVENT_DEFENSE_GRAVEYARD_1	XX
+//#define PORT_EVENT_DEFENSE_GRAVEYARD_2	XX
+//#define PORT_EVENT_DEFENSE_GRAVEYARD_3	XX
+//
+//#define PORT_EVENT_OFFENSE_GRAVEYARD_1	XX
+//#define PORT_EVENT_OFFENSE_GRAVEYARD_2	XX
+//#define PORT_EVENT_OFFENSE_GRAVEYARD_3	XX
+//
+//
+//
+///*
+//group_type
+//1	lm bl È«ÔÚ½ø¹¥·½
+//2	lm ¹¥ bl ÊØ
+//3	lm ÊØ bl ¹¥
+//4	lm bl ÕóÓª¹¥ÊØËæ»ú
+//5	lm bl Íæ¼Ò¹¥ÊØËæ»ú
+//
+//rejoin_type
+//0 ½ûÖ¹
+//1 µÚÒ»´Î¼ÓÈëÊÂ¼þµÄ¶ÓÎé
+//2 ÖØÐÂ·ÖÅä¶ÓÎé
+//
+//event_type
+//0 ÏµÍ³ÊÂ¼þ
+//1 Õ½¸è
+//2 °¢À­Ï£
+//3 ·ç±©
+//4 Ô¶¹Åº£Ì²
+//5 °ÂÉ½
+//6 Õ÷·þÖ®µº
+//7 Ö»´«ËÍ  lm->defense_start_pos	 bl->offense_start_pos
+//8 ¹¥ÊØ»î¶¯
+//*/
+//
+//#define DEFENSE_FACTION 1
+//#define OFFENSE_FACTION 2
+//
+//enum TeamTypes
+//{
+//	C_TEAM_NONE,
+//	C_TEAM_DEFENSE,
+//	C_TEAM_OFFENSE,
+//};
+//
+//enum GroupTypes
+//{
+//	C_GT_NONE,
+//	C_GT_OFFENSE_ALL,				
+//	C_GT_OFFENSE_ALLY,				
+//	C_GT_OFFENSE_HORDE,				
+//	C_GT_OFFENSE_FACTION_RANDOM,		
+//	C_GT_OFFENSE_PLAYER_RANDOM,		
+//};
+//
+//enum RejoinTypes
+//{
+//	C_RT_BANED,
+//	C_RT_KEEP_GROUP,
+//	C_RT_REDIS_GROUP,
+//};
+//
+//enum EventTypes
+//{
+//	C_ET_NONE,
+//	C_ET_WS,
+//	C_ET_AB,
+//	C_ET_EY,
+//	C_ET_SA,
+//	C_ET_AV,
+//	C_ET_IC,
+//	C_ET_TELE,
+//	C_ET_GROUP,
+//};
+//
+//enum PosTypes
+//{
+//	C_PT_START_DEFENSE,
+//	C_PT_START_OFFENSE,
+//};
+//
+//struct EventPlayerTemplate
+//{
+//	TeamTypes	team;
+//	uint32		kills;
+//	uint32		killeds;
+//	uint32		damage;
+//	uint32		heal;
+//	bool		valid;
+//};
+//
+//struct EventPhaseTemplate
+//{
+//	uint32 stop_creature;
+//	uint32 stop_gameobject;
+//	uint32 stop_kills;
+//	uint32 stop_defense_tele_pos;
+//	uint32 stop_offense_tele_pos;
+//	uint32 defense_graveyard_pos;
+//	uint32 offense_graveyard_pos;
+//	std::string stop_defense_notice;
+//	std::string stop_offense_notice;
+//	float defense_graveyard_safe;
+//	float offense_graveyard_safe;
+//	uint32 defense_graveyard_healer;
+//	uint32 offense_graveyard_healer;
+//};
+//
+//struct EventDataTemplate
+//{
+//	EventTypes		eventType;
+//	GroupTypes		groupType;
+//	RejoinTypes		rejoinType;
+//	std::string		eventName;
+//	std::string		gossipText;
+//	std::string		noticeText;
+//	
+//	std::string		defenseName;
+//	std::string		offenseName;
+//
+//	uint32	startDefensePos;
+//	uint32	startOffensePos;
+//
+//	uint32	zoneId;
+//
+//	std::unordered_map<uint32/*phase*/, EventPhaseTemplate> eventPhaseMap;
+//
+//	uint32	rew_winRewId;
+//	uint32	rew_losRewId;
+//	uint32	rew_killsForRew;
+//	uint32	rew_killedsForRew;
+//	float	rew_damageForRew;
+//	float	rew_healForRew;
+//
+//	uint32 stop_creature1;
+//	uint32 stop_creatureCount1;
+//	uint32 stop_creature2;
+//	uint32 stop_creatureCount2;
+//	uint32 stop_creature3;
+//	uint32 stop_creatureCount3;
+//	uint32 stop_creature4;
+//	uint32 stop_creatureCount4;
+//	uint32 stop_creature5;
+//	uint32 stop_creatureCount5;
+//	uint32 stop_gameobject1;
+//	uint32 stop_gameobjectCount1;
+//	uint32 stop_gameobject2;
+//	uint32 stop_gameobjectCount2;
+//	uint32 stop_gameobject3;
+//	uint32 stop_gameobjectCount3;
+//	uint32 stop_gameobject4;
+//	uint32 stop_gameobjectCount4;
+//	uint32 stop_gameobject5;
+//	uint32 stop_gameobjectCount5;
+//	uint32 stop_defenseKills;
+//	uint32 stop_offenseKills;
+//	uint32 stop_killGaps;
+//
+//	uint32 state_creature1;
+//	uint32 state_creatureWorldState1;
+//	uint32 state_creature2;
+//	uint32 state_creatureWorldState2;
+//	uint32 state_creature3;
+//	uint32 state_creatureWorldState3;
+//	uint32 state_gameobject1;
+//	uint32 state_gameobjectWorldState1;
+//	uint32 state_gameobject2;
+//	uint32 state_gameobjectWorldState2;
+//	uint32 state_gameobject3;
+//	uint32 state_gameobjectWorldState3;
+//	uint32 state_defenseWorldState;
+//	uint32 state_offenseWorldState;
+//};
+//
+//extern std::unordered_map<uint32, EventDataTemplate> EventDataMap;
+//
+//struct EventActiveTemplate
+//{
+//	uint32 eventId;
+//	uint32 activeGUID;
+//	uint32 activeType;
+//	uint32 creatureEntry;
+//	uint32 killCount;
+//	uint32 gameobjectEntry;
+//	uint32 destroyCount;
+//};
+//
+//extern std::vector<EventActiveTemplate> EventActiveVec;
+//
+//
+///*»÷É±ÉúÎï*/
+//extern std::unordered_map<uint32/*creature entry*/, uint32> KillCreatureMap;
+///*´Ý»ÙÎïÌå*/
+//extern std::unordered_map<uint32/*gob entry*/, uint32> DestroyGobMap;
+///*»÷É±Íæ¼Ò*/
+//extern std::unordered_map<TeamTypes/*event team*/, uint32> KillPlayerMap;
+///*Íæ¼ÒÐÅÏ¢*/
+//extern std::unordered_map<uint32/*guid*/, EventPlayerTemplate> PlayerDataMap;
+///*¶ÓÎéÐÅÏ¢*/
+//extern std::unordered_map<uint32/*guid*/, TeamTypes> GroupDataMap;
+//
+//
+//struct PosTemplate
+//{
+//	uint32 map;
+//	float x;
+//	float y;
+//	float z;
+//	float o;
+//};
+//extern std::unordered_map<uint32, PosTemplate> PosMap;
+//
+//class CustomEvent
+//{
+//public:
+//	static CustomEvent* instance()
+//	{
+//		static CustomEvent instance;
+//		return &instance;
+//	}
+//
+//	//¼ÓÔØ×Ô¶¨ÒåÊÂ¼þÐÅÏ¢
+//	void Load();
+//	void LoadPos();
+//
+//	//¼ì²â×Ô¶¨ÒåÊÂ¼þºÏ·¨ ¿ªÊ¼ ½áÊø ¶¯×÷ ³õÊ¼»¯²ÎÊý
+//	void Start(uint32 eventId);
+//	void Stop(uint32 eventId, bool expired = true);
+//	
+//
+//	//WorldStat
+//	void InitWorldState(uint32 eventId);
+//	void _UpdateWorldState(uint32 index, uint32 value);
+//	void UpdateWorldState(Object* obj, Player* player);
+//
+//	//Íæ¼ÒÏà¹Ø ·¢ËÍÑûÇë ½ÓÊÜ ÊÂ¼þÁÐ±í »ñÈ¡Íæ¼ÒÐÅÏ¢ ÐÞ¸ÄÍæ¼ÒÐÅÏ¢µÈµÈ
+//
+//	void SendInvitationToAll(std::string text);
+//	bool AcceptInvitation(Player*, uint32 menuId);
+//	void AddEventList(Player* player, Object* obj, bool isBG = false);
+//	void AddBgList(Player* player);
+//	void Teleport(Player* player, uint32 posId);
+//	void IncreaseDamage(Player* player, Unit* target, uint32 damage);
+//	void IncreaseHeal(Player* player, Unit* target, uint32 heal);
+//	void IncreaseKills(Player* player);
+//	void IncreaseKilleds(Player* player);
+//
+//	//½áÊøÊÂ¼þµÄÌõ¼þ ¼ì²âÌõ¼þÊÇ·ñÂú×ã
+//	void Process(Player* player, Object* obj);
+//	bool DiedTele(Player* player);
+//	bool SendAreaSpiritHealerQueryOpcode(Player* player);
+//	//·Ö·¢½±Àø
+//	void RewardAllPlayers();
+//	void ResetAllPlayers();
+//	void RemovePlayer(Player* player);
+//	//·Ö×é²Ù×÷
+//	uint32 GetTeamMembers(TeamTypes team);
+//	TeamTypes SetTeam(Player* player);
+//	void SetFaction(Player* player,TeamTypes team);
+//	TeamTypes GetTeam(Player* player);
+//	void GetTelePos(uint32 eventId, PosTypes type, uint32 &map, float &x, float &y, float &z, float &o);
+//	void GetTelePos(uint32 posId, uint32 &map, float &x, float &y, float &z, float &o);
+//	void TelePort(Player* player);
+//	TeamTypes AddPlayer(Player* player);
+//	void AddNewToGroup(Player* player);
+//
+//	bool IsFixedTimeBgActive(BattlegroundTypeId bgTypeId);
+//
+//	void UpdateActive(Object *obj);
+//	void UpdatePhase(Object* obj);
+//	void Update(Map* map, uint32 diff);
+//	void SendScreenMessage(const char *text, TeamTypes team = C_TEAM_NONE, bool onlydead = false);
+//	void UpdateRevive(uint32 diff);
+//	void UpdateSafeArea(uint32 diff);
+//	bool GobUnk1Check(Unit* target, GameObject *const gob);
+//	void Revive(Player* player);
+//	void SummonSoulHealer();
+//	float GetDistance(Player* player, uint32 posId);
+//	float GetDistance(uint32 posId1, uint32 posId2);
+//	void PrintPos(Player* player, uint32 posId1, uint32 posId2, uint32 count, bool addPos);
+//	void Update(Player* player);
+//
+//	bool CheckValid(Player* player);
+//	void SetValid(Player* player, bool valid);
+//
+//public:
+//	void InitParams(uint32 eventId);
+//	void Reset();
+//
+//	std::string GetEventName(){ return _eventName; }
+//	uint32 GetZoneId(){ return _zoneId; }
+//	bool IsValid(){ return _eventId >= 70; }
+//
+//
+//	uint32 GetKillPlayerCount(TeamTypes team)
+//	{
+//		std::unordered_map<TeamTypes/*event team*/, uint32>::iterator i = KillPlayerMap.find(team);
+//		if (i != KillPlayerMap.end())
+//			return i->second;
+//
+//		return 0;
+//	}
+//
+//	uint32 GetKillCreatureCount(uint32 entry)
+//	{
+//		std::unordered_map<uint32/*creature entry*/, uint32>::iterator i = KillCreatureMap.find(entry);
+//		if (i != KillCreatureMap.end())
+//			return i->second;
+//
+//		return 0;
+//	}
+//
+//	uint32 GetDestroyGobCount(uint32 entry)
+//	{
+//		std::unordered_map<uint32/*gob entry*/, uint32>::iterator i = DestroyGobMap.find(entry);
+//		if (i != DestroyGobMap.end())
+//			return i->second;
+//
+//		return 0;
+//	}
+//
+//private:
+//	/*»ñÊ¤¶ÓÎé*/
+//	TeamTypes _winTeam;
+//	/*ÊÇ·ñ¹ýÆÚ*/
+//	bool _expired;
+//
+//	bool _AllyAsOffense;
+//
+//
+//	/*»ù±¾ÐÅÏ¢*/
+//	uint32			_eventId;
+//	EventTypes		_eventType;
+//	GroupTypes		_groupType;
+//	RejoinTypes		_rejoinType;
+//	std::string		_eventName;
+//	std::string		_gossipText;
+//	std::string		_noticeText;
+//	std::string		_defenseName;
+//	std::string		_offenseName;
+//	uint32	_startDefensePos;
+//	uint32	_startOffensePos;
+//	uint32 _zoneId;
+//
+//	uint32 _eventPhase;
+//	uint32 _graveyard_defense_pos;
+//	uint32 _graveyard_offense_pos;
+//	uint64 _soulhealer_defense;
+//	uint64 _soulhealer_offense;
+//	bool _stop_creature_flag;
+//	bool _stop_gameobject_flag;
+//	bool _stop_kills_flag;
+//	float _defense_graveyard_safe;
+//	float _offense_graveyard_safe;
+//	uint32 _defense_graveyard_healer;
+//	uint32 _offense_graveyard_healer;
+//
+//	/*½±Àø*/
+//	uint32	_rew_winRewId;
+//	uint32	_rew_losRewId;
+//	uint32	_rew_killsForRew;
+//	uint32	_rew_killedsForRew;
+//	float	_rew_damageForRew;
+//	float	_rew_healForRew;
+//
+//	/*½áÊø*/
+//	uint32 _stop_creature1;
+//	uint32 _stop_creatureCount1;
+//	uint32 _stop_creature2;
+//	uint32 _stop_creatureCount2;
+//	uint32 _stop_creature3;
+//	uint32 _stop_creatureCount3;
+//	uint32 _stop_creature4;
+//	uint32 _stop_creatureCount4;
+//	uint32 _stop_creature5;
+//	uint32 _stop_creatureCount5;
+//	uint32 _stop_gameobject1;
+//	uint32 _stop_gameobjectCount1;
+//	uint32 _stop_gameobject2;
+//	uint32 _stop_gameobjectCount2;
+//	uint32 _stop_gameobject3;
+//	uint32 _stop_gameobjectCount3;
+//	uint32 _stop_gameobject4;
+//	uint32 _stop_gameobjectCount4;
+//	uint32 _stop_gameobject5;
+//	uint32 _stop_gameobjectCount5;
+//	uint32 _stop_defenseKills;
+//	uint32 _stop_offenseKills;
+//	uint32 _stop_killGaps;
+//
+//	/*ÊÀ½ç×´Ì¬*/
+//	uint32 _state_creature1;
+//	uint32 _state_creatureWorldState1;
+//	uint32 _state_creature2;
+//	uint32 _state_creatureWorldState2;
+//	uint32 _state_creature3;
+//	uint32 _state_creatureWorldState3;
+//	uint32 _state_gameobject1;
+//	uint32 _state_gameobjectWorldState1;
+//	uint32 _state_gameobject2;
+//	uint32 _state_gameobjectWorldState2;
+//	uint32 _state_gameobject3;
+//	uint32 _state_gameobjectWorldState3;
+//	uint32 _state_defenseWorldState;
+//	uint32 _state_offenseWorldState;
+//
+//	int32 _mapId;
+//
+//	//¸´»î
+//	int32 _reviveUpdateTimer;
+//
+//	//°²È«Çø
+//	int32 _safeAreaUpdateTimer;
+//};
+//#define sEvent CustomEvent::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/CustomEvent/Event.cpp b/src/server/scripts/Custom/CustomEvent/Event.cpp
new file mode 100644
index 0000000..49b3b3c
--- /dev/null
+++ b/src/server/scripts/Custom/CustomEvent/Event.cpp
@@ -0,0 +1,2195 @@
+#pragma execution_character_set("utf-8")
+#include "Event.h"
+#include "GameEventMgr.h"
+#include "Battleground.h"
+#include "BattlegroundMgr.h"
+#include "../CustomEvent/FixedTimeBG/FixedTimeBG.h"
+#include "../Reward/Reward.h"
+#include "GroupMgr.h"
+#include "Group.h"
+#include "../FakePlayers/FakePlayers.h"
+#include "ThunderbluffBattle/ThunderbluffBattle.h"
+#include "../AuthCheck/AuthCheck.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "SACity/SA.h"
+#include "../QuickResponse/QuickResponse.h"
+#include "../Talisman/Talisman.h"
+#include "../FunctionCollection/FunctionCollection.h"
+#include "UnknownBG/UnknownBG.h"
+#include "../Command/CustomCommand.h"
+#include "WaypointManager.h"
+#include "MapManager.h"
+#include "Guild.h"
+#include "../Switch/Switch.h"
+#include "BattleIC/BattleIC.h"
+#include "ArenaDuel/ArenaDuel.h"
+// load db
+
+void Player::UpdateEventDamage(Unit* target, float damage)
+{ 
+	if (!target || target->GetGUID() == GetGUID() || (target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsCivilian()))
+		return;
+
+	_EventData.Damage += damage; 
+}
+
+void Player::UpdateEventHeal(Unit* target, float heal)
+{ 
+	if (!target || target->GetTypeId() != TYPEID_PLAYER || target->GetGUID() == GetGUID()) 
+		return;
+
+	_EventData.Heal += heal; 
+}
+
+void Player::UpdateEventKills(Unit* target)
+{ 
+	if (!target || target->GetGUID() == GetGUID()) 
+		return;
+
+	_EventData.Kills++; 
+	sEvent->UpdateKillInfo(this, true);
+}
+
+void Player::UpdateEventKilleds(Unit* target)
+{ 
+	if (!target || target->GetGUID() == GetGUID()) 
+		return;
+
+	_EventData.Killeds++;
+	sEvent->UpdateKillInfo(this, false);
+}
+
+void Player::InitEventData(uint32 EventId, EventFactionId FactionId, std::string FactionName)
+{
+	_EventData.EventId = EventId;
+	_EventData.FactionId = FactionId;
+	_EventData.FactionName = FactionName;
+	_EventData.Damage = 0;
+	_EventData.Heal = 0;
+	_EventData.Kills = 0;
+	_EventData.Killeds = 0;
+
+	if (FactionId != 0)
+		setFaction(FactionId);
+}
+
+void Player::EventRest()
+{
+	if (!InEvent())
+		return;
+
+	_EventData = { 0, "", 0, 0, 0, 0, 0 };
+	setFactionForRace(getRace());
+	UpdateMaxHealth();
+	UninviteFromGroup();
+	if (GetGroup())
+		RemoveFromGroup();
+}
+
+class EventPlayerScript : PlayerScript
+{
+public:
+	EventPlayerScript() : PlayerScript("EventPlayerScript") {}
+
+	void OnCreatureKill(Player* player, Creature* creature)
+	{
+		if (!sEvent->Valid())
+			return;
+
+		sEvent->UpdateActive(creature);
+		sEvent->UpdatePhase(creature);
+		sEvent->UpdateWorldState(creature);
+		sEvent->Process(creature);
+	}
+
+	void OnUseGameObject(Player* player, GameObject* gob)
+	{	
+		if (!sEvent->Valid())
+			return;
+
+		sEvent->UpdateActive(gob);
+		sEvent->UpdatePhase(gob);
+		sEvent->UpdateWorldState(gob);
+		sEvent->Process(gob);
+	}
+
+	void OnPVPKill(Player* killer, Player* killed)
+	{
+		if (!sEvent->Valid())
+			return;
+
+		sEvent->UpdateActive(killer, true);
+		sEvent->UpdateActive(killed, false);
+		sEvent->UpdatePhase(killer, true);
+		sEvent->UpdatePhase(killed, false);
+		sEvent->UpdateWorldState(killer, true);
+		sEvent->UpdateWorldState(killed, false);
+		sEvent->Process(killer);
+	}
+
+	void OnPlayerKilledByCreature(Creature* killer, Player* killed) 
+	{ 
+		
+	}
+
+	void OnUpdateZone(Player* player, uint32 newZone, uint32 /*newArea*/) 
+	{
+		if (!player->InEvent())
+			return;
+
+		int32 zone = sEvent->GetZoneId();
+
+		if (zone <= 0)
+			return;
+
+		if (zone == newZone)
+			return;
+		
+		player->EventRest();
+	}
+
+	void OnMapChanged(Player* player)
+	{
+		if (!player->InEvent())
+			return;
+
+		int32 zone = sEvent->GetZoneId();
+		
+		if (zone >= 0)
+			return;
+
+		if (-zone == player->GetMapId())
+			return;
+
+		player->EventRest();
+	}
+};
+
+
+//Ò°ÍâÌôÕ½½Å±¾
+class StageTrigger : public CreatureScript
+{
+public:
+	StageTrigger() : CreatureScript("StageTrigger") { }
+
+	struct StageTriggerAI : public ScriptedAI
+	{
+		StageTriggerAI(Creature* creature) : ScriptedAI(creature), Summons(me)
+		{
+			stage = 1;
+			active = true;
+		}
+
+		SummonList Summons;
+		uint32 stage;
+		bool active;
+
+		void JustSummoned(Creature* summon) override
+		{
+			summon->GetMotionMaster()->MoveRandom(5.0f);
+			Summons.Summon(summon);
+		}
+
+		void Reset() override
+		{
+			stage = 1;
+			active = true;
+			Summons.DespawnAll();
+		}
+
+		void MoveInLineOfSight(Unit* who)
+		{
+			if (Summons.empty() && active)
+			{
+				std::ostringstream oss;
+				oss << "[Ê¤ÕßÎªÍõ]£ºµÚ" << stage << "¹Ø¿ªÊ¼!";
+				sWorld->SendScreenMessage(oss.str().c_str());
+				me->SummonCreatureGroup(stage);
+			}
+		}
+
+		void SummonedCreatureDies(Creature* summon, Unit* killer)  override
+		{	
+			std::ostringstream oss;
+			oss << "[Ê¤ÕßÎªÍõ]£º[" << killer->GetName() << "]»÷É±[" << summon->GetCreatureTemplate()->Name << "]£¬ÌôÕ½³É¹¦£¡";
+			sWorld->SendScreenMessage(oss.str().c_str());
+			Summons.Despawn(summon);
+
+			me->SummonGameObject(350005, -13216.9, 232.457, 190.98, 1.29123, 0, 0, 0, 0, 0);
+
+			stage++;
+
+			if (stage > 10)
+				active = false;
+		}
+	};
+
+	CreatureAI* GetAI(Creature* creature) const override
+	{
+		return new StageTriggerAI(creature);
+	}
+};
+
+
+#define MAX_MOUNT_SPELLS 8
+
+uint32 MountSpells[MAX_MOUNT_SPELLS] = { 95001, 95002, 95003, 95004, 95005, 95006, 95007, 95008 };
+
+//HitSpellClone
+class HitSpellClone : public CreatureScript
+{
+public:
+	HitSpellClone() : CreatureScript("HitSpellClone") { }
+
+	struct HitSpellCloneAI : public ScriptedAI
+	{
+		HitSpellCloneAI(Creature* creature) : ScriptedAI(creature), Summons(me)
+		{
+			MoveTimer = 0;
+			SpellTimer = 0;
+			MoveInterval = 20 * IN_MILLISECONDS;
+		}
+
+		SummonList Summons;
+		uint32 MoveTimer;
+		uint32 SpellTimer;
+		uint32 MoveInterval;
+		std::unordered_map<uint32, int32>SpellMap;
+		std::vector<const SpellInfo*> SpellVec;
+		
+		void Reset() override
+		{
+			if (MAX_MOUNT_SPELLS > 1)
+			{
+				for (size_t i = 0; i < MAX_MOUNT_SPELLS; i++)
+					me->RemoveAura(MountSpells[i]);
+			
+				me->AddAura(MountSpells[urand(0, MAX_MOUNT_SPELLS - 1)], me);
+			}
+
+			SpellVec.clear();
+			MoveSpline(MoveInterval);
+			Summons.DespawnAll();
+		}
+
+		void SpellHit(Unit* caster, const SpellInfo* spell) override
+		{
+			if (!caster)
+				return;
+
+			std::unordered_map<uint32, int32>::iterator iter = SpellMap.find(spell->Id);
+			if (iter != SpellMap.end())
+				return;
+
+			SpellMap.insert(std::make_pair(spell->Id, 0));
+
+			if (std::find(SpellVec.begin(), SpellVec.end(), spell) != SpellVec.end())
+				return;
+
+			SpellVec.push_back(spell);
+		}
+
+		void SpellCooldown()
+		{
+			for (std::unordered_map<uint32, int32>::iterator iter = SpellMap.begin(); iter != SpellMap.end(); iter++)
+				if (iter->second > 0)
+					iter->second--;
+		}
+
+		void CastSpell(uint32 diff)
+		{
+			SpellTimer += diff;
+
+			if (SpellTimer > 2 * IN_MILLISECONDS)
+			{
+				SpellTimer = 0;
+
+				std::vector<uint32/*spellId*/> SpellVec;
+
+				for (std::unordered_map<uint32, int32>::iterator iter = SpellMap.begin(); iter != SpellMap.end(); iter++)
+					if (iter->second <= 0)
+						SpellVec.push_back(iter->first);
+
+				if (SpellVec.empty())
+					return;
+
+				uint32 spellId = SpellVec[urand(0, SpellVec.size() - 1)];
+
+				DoCast(spellId);
+
+				const SpellInfo* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+
+				std::unordered_map<uint32, int32>::iterator iter = SpellMap.find(spellId);
+
+				if (iter != SpellMap.end())
+					iter->second = spellInfo->GetRecoveryTime();
+			}	
+		}
+
+		void MoveSpline(uint32 diff)
+		{
+			if (me->IsInCombat())
+				return;
+
+			MoveTimer += diff;
+
+			if (MoveTimer >= MoveInterval)
+			{
+				MoveTimer = 0;
+
+				if (WaypointPath const* i_path = sWaypointMgr->GetPath(me->GetWaypointPath()))
+				{
+					me->StopMoving();
+
+					float x = me->GetPositionX();
+					float y = me->GetPositionY();
+					float z = me->GetPositionZ();
+
+					Movement::PointsArray pathPoints;
+					pathPoints.push_back(G3D::Vector3(x, y, z));
+
+					WaypointData const* node;
+
+					uint8 _i = 0;
+					float _dist = 100000.0f;
+
+					for (uint8 i = 0; i < i_path->size(); ++i)
+					{
+						node = i_path->at(i);
+
+						float dist = sqrt((node->x - x) * (node->x - x) + (node->y - y) * (node->y - y) + (node->z - z) * (node->z - z));
+
+						if (dist < _dist)
+						{
+							_dist = dist;
+							_i = i;
+						}
+					}
+
+					for (uint8 i = _i; i < i_path->size(); ++i)
+					{
+						node = i_path->at(i);
+						pathPoints.push_back(G3D::Vector3(node->x, node->y, node->z));
+					}
+
+					for (uint8 i = 0; i < i_path->size(); ++i)
+					{
+						node = i_path->at(i);
+						pathPoints.push_back(G3D::Vector3(node->x, node->y, node->z));
+					}
+
+					me->GetMotionMaster()->MoveSplinePath(&pathPoints);
+				}
+			}
+		}
+
+		bool StopOnCasting()
+		{
+			if (me->HasUnitState(UNIT_STATE_CASTING))
+			{
+				me->StopMoving();
+				return true;
+			}
+			return false;
+		}
+
+		void UpdateAI(uint32 diff)
+		{
+			SpellCooldown();
+			MoveSpline(diff);
+
+			if (!UpdateVictim() || StopOnCasting())
+				return;
+
+			CastSpell(diff);
+			DoMeleeAttackIfReady();
+		}
+
+		void AttackStart(Unit* who)
+		{
+			ScriptedAI::AttackStartCaster(who, 10.0f);
+			ScriptedAI::AttackStart(who);
+		}
+
+		void EnterCombat(Unit* victim) 
+		{
+			
+		}
+
+		void MoveInLineOfSight(Unit* who)
+		{
+			if (who->IsHostileTo(me) && who->GetDistance(me) < 10.0f && !me->IsInCombat())
+				AttackStart(who);
+		}
+
+		void JustSummoned(Creature* summon) override
+		{
+			Summons.Summon(summon);
+		}
+
+		void SummonedCreatureDies(Creature* summon, Unit* killer)  override
+		{
+			
+		}
+	};
+
+	CreatureAI* GetAI(Creature* creature) const override
+	{
+		return new HitSpellCloneAI(creature);
+	}
+};
+
+void AddSC_CustomEventScript()
+{
+	new EventPlayerScript();
+	new StageTrigger();
+	new HitSpellClone();
+}
+
+bool Event::CanRew(Player* pl)
+{
+	EventDataTemplate EventData = pl->GetEventData();
+
+	if (EventData.Damage >= _DamageForRew ||
+		EventData.Heal >= _HealForRew ||
+		EventData.Kills >= _KillsForRew ||
+		EventData.Killeds >= _KilledForRew)
+		return true;
+
+	return false;
+}
+
+std::unordered_map<uint32, PosTemplate> PosMap;
+
+void Event::LoadPos()
+{
+	PosMap.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//			0	1	2		3	4		5
+		"SELECT µØÍ¼ID,X×ø±ê,Y×ø±ê,Z×ø±ê,O×ø±ê,×ø±êID FROM _Ä£°å_×ø±ê" :
+		//		0	1 2 3 4	 5
+		"SELECT map,x,y,z,o,posId FROM _position");
+	if (!result) return;
+	do
+	{
+		Field* fields = result->Fetch();
+		PosTemplate Temp;
+		Temp.map = fields[0].GetUInt32();
+		Temp.x = fields[1].GetFloat();
+		Temp.y = fields[2].GetFloat();
+		Temp.z = fields[3].GetFloat();
+		Temp.o = fields[4].GetFloat();
+		uint32 ID = fields[5].GetUInt32();
+		PosMap.insert(std::make_pair(ID, Temp));
+	} while (result->NextRow());
+}
+
+void Event::Reset()
+{
+	for (auto itr = _HealerMap.begin(); itr != _HealerMap.end(); itr++)
+		if (Creature* healer = _Map->GetCreature(itr->second))
+			healer->RemoveFromWorld();
+	_HealerMap.clear();
+
+	_EventId = 0;
+	_EventName = "";
+	_EventType = C_ET_NONE;
+	_GroupType = C_GT_RANDOM_PLAYER;
+	_RejoinType = C_RT_REDIS_GROUP;
+	_NoticeText = "";
+	_GossipText = "";
+	_ZoneId = 0;
+	_Map = NULL;
+	_Phase = 1;
+	_RandomAH = urand(0, 100) > 50 ? false : true;
+	_WinRewId = 0;
+	_LosRewId = 0;
+	_DamageForRew = 0;
+	_HealForRew = 0;
+	_KillsForRew = 0;
+	_KilledForRew = 0;
+	_GroupMap.clear();
+	_FactionVec.clear();
+	_PlayersMap.clear();
+	_KillInfoMap.clear();
+	_FactionNameMap.clear();
+	_StartPosMap.clear();
+	_StopPosMap.clear();
+	_StopVec.clear();
+	_AltVec.clear();
+	_AltFactionVec.clear();
+	_AltedVec.clear();
+	_PhaseFactionVec.clear();
+	_PhaseVec.clear();
+	_UpdateSafeTimer = 0;
+	_UpdateReviveTimer = 0;
+	_SoulVisual = false;
+	_DelayStartCall = false;
+	_DelayStopCall = false;
+	_UpdateDelayNotice = 0;
+	_WinFaction = 0;
+	_WorldStateVec.clear();
+	_WorldStateFactionVec.clear();
+	_SpawnVec.clear();
+	_UpdateSpawnTimer = 0;
+}
+
+void Event::InitParams(uint32 eventId)
+{
+	if (eventId < 100)
+		return;
+
+	QueryResult result;
+
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//		0			1			2			3	4		5			6
+		"SELECT ÊÂ¼þÃû³Æ,µ¯´°ÌáÊ¾ÎÄ±¾,²Ëµ¥ÌáÊ¾ÎÄ±¾,ÇøÓòID,ÊÂ¼þÀàÐÍ,×é¶ÓÀàÐÍ,ÖØÐÂ¼ÓÈëÀàÐÍ,"
+		//		7			8			9					10				11				12
+		"Ê¤Àû½±ÀøÄ£°åID,Ê§°Ü½±ÀøÄ£°åID,»ñµÃ½±Àø×îÐ¡ÉËº¦Öµ,»ñµÃ½±Àø×îÐ¡ÖÎÁÆÖµ,»ñµÃ½±Àø×îÐ¡»÷É±Êý,»ñµÃ½±Àø×îÐ¡±»É±Êý From _ÊÂ¼þ WHERE ÊÂ¼þID = '%u'" :
+		//		0			1			2			3		4		5		6
+		"SELECT EventName,NoticeText,GossipText,ZoneId,EventType,GroupType,RejoinType,"
+		//7			8		9				10		11			12
+		"WinRewId,LosRewId,DamageForRew,HealForRew,KillsForRew,KilledForRew From _event WHERE EventId = '%u'", eventId))
+	{
+		Reset();
+
+		Field* fields = result->Fetch();
+		_EventId = eventId;
+		_EventName = fields[0].GetString();
+		_NoticeText = fields[1].GetString();
+		_GossipText = fields[2].GetString();
+		
+		const char* type = fields[4].GetCString();
+
+		if (type && *type != '\0')
+		{
+			if (strcmp(type, "Õ½³¡ - Õ½¸è") == 0)
+				_EventType = C_ET_WS;
+			else if (strcmp(type, "Õ½³¡ - °¢À­Ï£") == 0)
+				_EventType = C_ET_AB;
+			else if (strcmp(type, "Õ½³¡ - ·ç±©Ö®ÑÛ") == 0)
+				_EventType = C_ET_EY;
+			else if (strcmp(type, "Õ½³¡ - Ô¶¹Åº£Ì²") == 0)
+				_EventType = C_ET_SA;
+			else if (strcmp(type, "Õ½³¡ - °ÂÉ½") == 0)
+				_EventType = C_ET_AV;
+			else if (strcmp(type, "Õ½³¡ - Õ÷·þÖ®µº") == 0)
+				_EventType = C_ET_IC;
+			else if (strcmp(type, "½ö´«ËÍ") == 0)
+				_EventType = C_ET_TELE;
+			else if (strcmp(type, "¶ÔÏß") == 0)
+				_EventType = C_ET_LINE;
+			else if (strcmp(type, "×Ô¶¨ÒåÕóÓª") == 0)
+				_EventType = C_ET_FACTION;
+			else if (strcmp(type, "¹«»á") == 0)
+				_EventType = C_ET_GUILD;
+			else if (strcmp(type, "µ¥ÈË") == 0)
+				_EventType = C_ET_SINGLE;
+		}
+
+		if (_EventType < C_ET_TELE)
+			return;
+
+		_ZoneId = fields[3].GetInt32();
+
+		if (_ZoneId < 0)
+			_Map = sMapMgr->FindMap(abs(_ZoneId), 0);
+		else
+		{
+			int32 map = GetMapIdByZone(_ZoneId);
+			if (map < 0)
+				;
+			else
+				_Map = sMapMgr->FindMap(map, 0);
+		}
+			
+		type = fields[5].GetCString();
+
+		if (type && *type !='\0')
+		{
+			if (strcmp(type, "¶ÔÏß - È«²¿ÕóÓª1") == 0)
+				_GroupType = C_GT_ONE_ALL;
+			else if (strcmp(type, "¶ÔÏß - ÁªÃËÕóÓª1BLÕóÓª2") == 0)
+				_GroupType = C_GT_ONE_A;
+			else if (strcmp(type, "¶ÔÏß - ÁªÃË²¿ÂäËæ»ú") == 0)
+				_GroupType = C_GT_RANDOM_A_H;
+			else if (strcmp(type, "¶ÔÏß - Íæ¼ÒËæ»ú") == 0)
+				_GroupType = C_GT_RANDOM_PLAYER;
+		}
+		
+		type = fields[6].GetCString();
+
+		if (type && *type != '\0')
+		{
+			if (strcmp(type, "ÖØÐÂ¼ÓÈë - ½ûÖ¹") == 0)
+				_RejoinType = C_RT_BANED;
+			else if (strcmp(type, "ÖØÐÂ¼ÓÈë- Ö®Ç°¶ÓÎé") == 0)
+				_RejoinType = C_RT_KEEP_GROUP;
+			else if (strcmp(type, "ÖØÐÂ¼ÓÈë - ÏµÍ³·ÖÅä") == 0)
+				_RejoinType = C_RT_REDIS_GROUP;
+		}
+		
+		_WinRewId		= fields[7].GetUInt32();
+		_LosRewId		= fields[8].GetUInt32();
+		_DamageForRew	= fields[9].GetUInt32();
+		_HealForRew		= fields[10].GetUInt32();
+		_KillsForRew	= fields[11].GetUInt32();
+		_KilledForRew	= fields[12].GetUInt32();
+	}
+	else
+		return;
+
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//		0		1		2					3
+		"SELECT ¶ÓÎéID,¶ÓÎéÃû³Æ,ÊÂ¼þ¿ªÊ¼´«ËÍ×ø±êID,ÊÂ¼þ½áÊø´«ËÍ×ø±êID From _ÊÂ¼þ_¶ÓÎéÅäÖÃ WHERE ÊÂ¼þID = '%u'" :
+		//		0		1		2					3
+		"SELECT TeamId,TeamName,StartTelePosId,StopTelePosId From _event_team WHERE EventId = '%u'", eventId))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			EventFactionId faction		= fields[0].GetUInt32();
+			_FactionVec.push_back(faction);
+			_FactionNameMap[faction]	= fields[1].GetString();
+			_StartPosMap[faction]		= fields[2].GetUInt32();
+			_StopPosMap[faction]		= fields[3].GetUInt32();
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//		0			1	2		3
+		"SELECT ½áÊøÀàÐÍ,¶ÓÎéID, ²ÎÊý,È¨ÖØÖµ From _ÊÂ¼þ_½áÊøÌõ¼þÅäÖÃ WHERE ÊÂ¼þID = '%u'" :
+		//		0			1	 2		3
+		"SELECT StopType,TeamId, Param,Weight From _event_stop WHERE EventId = '%u'", eventId))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			EventStopTemplate Temp;
+
+			const char* type = fields[0].GetCString();
+			if (strcmp(type, "»÷É±ÉúÎï - guid") == 0)
+				Temp.StopType = TYPEID_UNIT;
+			else if (strcmp(type, "´Ý»ÙÎïÌå - guid") == 0)
+				Temp.StopType = TYPEID_GAMEOBJECT;
+			else if (strcmp(type, "»÷É±Íæ¼Ò - ÊýÁ¿") == 0)
+				Temp.StopType = TYPEID_PLAYER;
+
+			Temp.Faction	= fields[1].GetUInt32();
+			Temp.Param		= fields[2].GetUInt32();
+			Temp.Weight		= fields[3].GetUInt32();
+			_StopVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//			0				1				2
+		"SELECT ÉúÎï»òÎïÌåGUID,ÉúÎï»òÎïÌå¼¤»îºóFLAG,¼¤»îÊ±ÌáÊ¾ÎÄ±¾,"
+		//3						4		5					6		7						8	9						10	11						12
+		"Ðè»÷É±ÉúÎï»ò´Ý»ÙÎïÌåID1,ÊýÁ¿1,Ðè»÷É±ÉúÎï»ò´Ý»ÙÎïÌåID2,ÊýÁ¿2,Ðè»÷É±ÉúÎï»ò´Ý»ÙÎïÌåID3,ÊýÁ¿3,Ðè»÷É±ÉúÎï»ò´Ý»ÙÎïÌåID4,ÊýÁ¿4,Ðè»÷É±ÉúÎï»ò´Ý»ÙÎïÌåID5,ÊýÁ¿5 "
+		"From _ÊÂ¼þ_ÉúÎï»òÎïÌå¼¤»îÌõ¼þÅäÖÃ WHERE ÊÂ¼þID = '%u'" :		
+		//		0		1		2
+		"SELECT GUID,ActiveFlag,NoticeText,"
+		//3				4			5			6				7			8			9				10			11			12
+		"TargetEntry1,TargetCount1,TargetEntry2,TargetCount2,TargetEntry3,TargetCount3,TargetEntry4,TargetCount4,TargetEntry5,TargetCount5 "
+		"From _event_active WHERE EventId = '%u'", eventId))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			EventAltTemplate Temp;
+			Temp.GUID		= fields[0].GetInt64();
+			Temp.AltFlag	= fields[1].GetUInt32();
+			Temp.NoticeText = fields[2].GetString();
+			for (size_t i = 0; i < ALT_GUID_MAX; i++)
+			{
+				Temp.TargetEntry[i] = fields[3 + i * 2].GetInt64();
+				Temp.TargetCount[i] = fields[4 + i * 2].GetUInt32();
+				Temp.TargetKillCount[i] = 0;
+			}
+				
+			_AltVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//		0				1		2		3	
+		"SELECT ÉúÎï»òÎïÌåGUID,¶ÓÎéID,»÷É±Íæ¼ÒÊý,Íæ¼Ò±»É±Êý From _ÊÂ¼þ_ÉúÎï»òÎïÌå¼¤»îÌõ¼þ¶ÓÎéÅäÖÃ WHERE ÊÂ¼þID = '%u'" :
+		//		0		1	2		3
+		"SELECT GUID,TeamId,Kills,Killeds From _event_active_team WHERE EventId = '%u'", eventId))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			EventAltFactionTemplate Temp;
+			Temp.GUID			= fields[0].GetInt64();
+			Temp.Faction		= fields[1].GetUInt32();
+			Temp.Kills			= fields[2].GetUInt32();
+			Temp.Killeds		= fields[3].GetUInt32();
+			_AltFactionVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//		0		1									
+		"SELECT ½×¶ÎID,½×¶Î½áÊøÐè»÷É±ÉúÎï»ò´Ý»ÙÎïÌåGUID From _ÊÂ¼þ_½×¶ÎÉúÎï»òÎïÌåÅäÖÃ WHERE ÊÂ¼þID = '%u'" :
+		//		0		1
+		"SELECT Phase,StopGUID From _event_phase WHERE EventId = '%u'", eventId))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			EventPhaseTemplate Temp;
+			Temp.Phase		= fields[0].GetUInt8();
+			Temp.StopGUID	= fields[1].GetInt64();
+			_PhaseVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//			0	1		2			3			4				5					6						7					8					9
+		"SELECT ½×¶ÎID,¶ÓÎéID,Ä¹µØ×ø±êID, Ä¹µØ±£»¤Çø·¶Î§, Ä¹µØÁé»êÒ½ÕßID,½×¶Î½áÊøÐè»÷É±Íæ¼ÒÊý,½×¶Î½áÊøÐèÍæ¼Ò±»É±Êý,½×¶Î½áÊø¼¯Ìå´«ËÍ×ø±êID,½øÈëÄ¹µØ±£»¤ÇøÌáÊ¾ÎÄ±¾,½×¶Î½áÊøÌáÊ¾ÎÄ±¾ "
+		"From _ÊÂ¼þ_½×¶Î¶ÓÎéÅäÖÃ WHERE ÊÂ¼þID = '%u'":
+		//			0	1		2			3				4				5					6			7					8					9
+		"SELECT Phase,TeamId,GraveyardPos, GraveyardSafe, GraveyardHealer,StopPlayerKills,StopPlayerKilleds,StopTelePos,GraveyardSafeNotice,StopNoticeText "
+		"From _event_phase_team WHERE EventId = '%u'", eventId))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			EventPhaseFactionTemplate Temp;
+			Temp.Phase					= fields[0].GetUInt32();
+			Temp.Faction				= fields[1].GetUInt32();
+			Temp.GraveyardPos			= fields[2].GetUInt32();
+			Temp.GraveyardSafe			= fields[3].GetUInt32();
+			Temp.GraveyardHealer		= fields[4].GetUInt32();
+			Temp.StopPlayerKills		= fields[5].GetUInt32();
+			Temp.StopPlayerKilleds		= fields[6].GetUInt32();
+			Temp.StopTelePos			= fields[7].GetUInt32();
+			Temp.GraveyardSafeNotice	= fields[8].GetString();
+			Temp.StopNotice				= fields[9].GetString();
+			_PhaseFactionVec.push_back(Temp);
+		} while (result->NextRow());
+
+		SummonSoulHealer();
+	}
+
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//		0				1			2									3					4									5					6									7					8				9
+		"SELECT ÊÀ½ç×´Ì¬ID,ÊÀ½ç×´Ì¬³õÊ¼Öµ,¸üÐÂÊÀ½ç×´Ì¬ÐèÒª»÷É±ÉúÎï»ò´Ý»ÙÎïÌåID1,¸üÐÂÊÀ½ç×´Ì¬Ôö¼õÖµ1,¸üÐÂÊÀ½ç×´Ì¬ÐèÒª»÷É±ÉúÎï»ò´Ý»ÙÎïÌåID2,¸üÐÂÊÀ½ç×´Ì¬Ôö¼õÖµ2,¸üÐÂÊÀ½ç×´Ì¬ÐèÒª»÷É±ÉúÎï»ò´Ý»ÙÎïÌåID3,¸üÐÂÊÀ½ç×´Ì¬Ôö¼õÖµ3,ÊÀ½ç×´Ì¬´ïµ½¸ÃÖµÊ±ÌáÊ¾,ÌáÊ¾ÎÄ±¾ From _ÊÂ¼þ_ÊÀ½ç×´Ì¬ÅäÖÃ WHERE ÊÂ¼þID = '%u'" :
+		//		0		1		2		3	4		5		6	7		8			9
+		"SELECT ID,StartValue,Entry1,Step1,Entry2,Step2,Entry3,Step3,NoticeValue,NoticeText From _event_worldstate WHERE EventId = '%u'", eventId))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			EventWorldStateTemplate Temp;
+			Temp.ID				= fields[0].GetUInt32();
+			Temp.InitValue		= fields[1].GetInt32();
+			for (size_t i = 0; i < WORLDSTATE_ENTRY_MAX; i++)
+			{
+				Temp.Entry[i]	= fields[2 + i * 2].GetInt32();
+				Temp.Step[i]	= fields[3 + i * 2].GetInt32();
+			}
+			Temp.NoticeValue	= fields[8].GetInt32();
+			Temp.Notice			= fields[9].GetString();
+			_WorldStateVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//		0			1		2			3					4					5
+		"SELECT ÊÀ½ç×´Ì¬ID,¶ÓÎéID,»÷É±»ò±»É±,¸üÐÂÊÀ½ç×´Ì¬Ôö¼õÖµ,ÊÀ½ç×´Ì¬´ïµ½¸ÃÖµÊ±ÌáÊ¾,ÌáÊ¾ÎÄ±¾ From _ÊÂ¼þ_ÊÀ½ç×´Ì¬¶ÓÎéÅäÖÃ WHERE ÊÂ¼þID  = '%u'" :
+		//		0	1		2			3		4			5
+		"SELECT ID,TeamId,KillOrKilled,Step,NoticeValue,NoticeText From _event_worldstate_team WHERE EventId = '%u'", eventId))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			EventWorldStateFactionTemplate Temp;
+			Temp.ID				= fields[0].GetUInt32();
+			Temp.Faction		= fields[1].GetUInt32();
+			Temp.Kill			= fields[2].GetBool();
+			Temp.Step			= fields[3].GetInt32();
+			Temp.NoticeValue	= fields[4].GetInt32();
+			Temp.Notice			= fields[5].GetString();
+			_WorldStateFactionVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//					0		1		2		3			4
+		"SELECT Ë¢ÐÂÉúÎï»òÎïÌåID,½×¶ÎID,Ë¢ÐÂÊ±¼ä,Ë¢ÐÂÎ»ÖÃ×ø±êID,³ÖÐøÊ±¼ä,"
+		//5				6		7		8		9		10
+		"ÌáÊ¾Ê±¼ä1,ÌáÊ¾ÎÄ±¾1,ÌáÊ¾Ê±¼ä2,ÌáÊ¾ÎÄ±¾2,ÌáÊ¾Ê±¼ä3,ÌáÊ¾ÎÄ±¾3 From _ÊÂ¼þ_ÉúÎï»òÎïÌåË¢ÐÂÅäÖÃ WHERE ÊÂ¼þID = '%u'":
+		//		0		1		2		3		4
+		"SELECT Entry,Phase,SpawnTime,PosId,Duration,"
+		//5				6			7			8				9		10
+		"NoticeTime1,SpawnNotice1,NoticeTime2,SpawnNotice2,NoticeTime3,SpawnNotice3 From _event_spawn WHERE EventId = '%u'", eventId))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			EventSpawnTemplate Temp;
+			Temp.Entry		= fields[0].GetInt64();
+			Temp.Phase		= fields[1].GetUInt32();
+			Temp.SpawnTime	= fields[2].GetUInt32();
+			Temp.PosId		= fields[3].GetUInt32();
+			Temp.Duration	= fields[4].GetUInt32();
+
+			for (size_t i = 0; i < MAX_SPAWNNOTICE_COUNT; i++)
+			{
+				Temp.NoticeTime[i] = fields[5 + i * 2].GetInt32();
+				Temp.SpawnNotice[i] = fields[6 + i * 2].GetString();
+			}
+			
+			_SpawnVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+}
+
+bool Event::AcceptInvitation(Player* player, uint32 menuId)
+{
+	if (menuId < 1000000)
+		return false;
+
+	uint32 eventId = menuId - 1000000;
+
+	if (!sGameEventMgr->IsActiveEvent(eventId))
+	{
+		player->GetSession()->SendNotification("¸Ã»î¶¯ÒÑ¾­½áÊø£¡");
+		return true;
+	}
+
+	if (eventId == ARENA_DUEL_SIGNUP_EVENT_ID)
+	{
+		if (sArenaDuel->GetState() == ARENA_DUEL_STATE_SIGNUP)
+		{
+			auto itr = ArenaDuelMap.find(player->GetGUIDLow());
+			if (itr == ArenaDuelMap.end())
+				sArenaDuel->Signup(player);
+			player->GetSession()->SendAreaTriggerMessage("±¨Ãû³É¹¦£¬ÀÞÌ¨Èü¼´½«¿ªÊ¼£¬Çë±£³ÖÔÚÏß£¡");
+		}else
+			player->GetSession()->SendNotification("±¨ÃûÒÑ¾­½ØÖ¹£¡");
+		return true;
+	}
+		
+	if (eventId == UKBG_EVENT_ID)
+	{
+		sUkBG->AddPlayer(player);
+		return true;
+	}
+
+	if (eventId == BGIC_EVENT_ID)
+	{
+		sBGIC->AddPlayer(player);
+		return true;
+	}
+
+	switch (_EventType)
+	{
+	case C_ET_NONE:
+		break;
+	case C_ET_WS:
+		player->GetSession()->FixedBGJoin(BATTLEGROUND_WS);
+		break;
+	case C_ET_AB:
+		player->GetSession()->FixedBGJoin(BATTLEGROUND_AB);
+		break;
+	case C_ET_EY:
+		player->GetSession()->FixedBGJoin(BATTLEGROUND_EY);
+		break;
+	case C_ET_SA:
+		player->GetSession()->FixedBGJoin(BATTLEGROUND_SA);
+		break;
+	case C_ET_AV:
+		player->GetSession()->FixedBGJoin(BATTLEGROUND_AV);
+		break;
+	case C_ET_IC:
+		player->GetSession()->FixedBGJoin(BATTLEGROUND_IC);
+		break;
+	case C_ET_TELE:
+		Tele(player, _StartPosMap[player->GetTeamId()]);
+	break;
+	case C_ET_LINE:
+	case C_ET_FACTION:
+	case C_ET_GUILD:
+		Join(player);
+		break;
+	}
+
+	return true;
+}
+
+void Event::AddEventList(Player* player, Object* obj, bool isBG)
+{
+	player->PlayerTalkClass->ClearMenus();
+
+	GameEventMgr::GameEventDataMap const& events = sGameEventMgr->GetEventMap();
+	GameEventMgr::ActiveEvents const& activeEventsList = sGameEventMgr->GetActiveEventList();
+
+	for (auto itr = events.begin(); itr != events.end(); itr++)
+	{
+		if (itr->eventId <= 70)
+			continue;
+
+		if (sGameEventMgr->IsActiveEvent(itr->eventId))
+		{
+			std::ostringstream oss;
+			oss << itr->description;
+			oss << "\n|cFF33CC00[ÒÑ¼¤»î£¬¾àÀë½áÊø - ";
+			oss << SecTimeString(sGameEventMgr->NextCheck(itr->eventId), true);
+			oss << "]|r";
+			player->ADD_GOSSIP_ITEM(0, oss.str(), SENDER_CUSTOM_EVENT_ACTIVE, itr->eventId);
+		}
+	}
+
+	for (auto itr = events.begin(); itr != events.end(); itr++)
+	{
+		if (itr->eventId <= 70)
+			continue;
+
+		if (!sGameEventMgr->IsActiveEvent(itr->eventId))
+		{
+			std::ostringstream oss;
+			oss << itr->description;
+			oss << "\n|cFF666666[Î´¼¤»î£¬¾àÀë¿ªÊ¼ - ";
+			oss << SecTimeString(sGameEventMgr->NextCheck(itr->eventId), true);
+			oss << "]|r";
+			player->ADD_GOSSIP_ITEM(0, oss.str(), SENDER_CUSTOM_EVENT_DEACTIVE, itr->eventId);
+		}
+	}
+
+	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+}
+void Event::GetTelePos(uint32 posId, uint32 &map, float &x, float &y, float &z, float &o)
+{
+	std::unordered_map<uint32, PosTemplate>::iterator it = PosMap.find(posId);
+
+	if (it != PosMap.end())
+	{
+		map = it->second.map;
+		x = it->second.x;
+		y = it->second.y;
+		z = it->second.z;
+		o = it->second.o;
+	}
+}
+
+//Unk1 = 1Ê± ¼ì²âÕóÓªÊÇ·ñÒ»ÖÂ Ò»ÖÂÔòÍ¨¹ý ¿ÉÒÔÊÍ·Å¼¼ÄÜ
+bool Event::GobUnk1Check(Unit* target, GameObject *const gob)
+{
+	if (!target)
+		return true;
+
+    
+	GameObjectTemplate const* temp = sObjectMgr->GetGameObjectTemplate(gob->GetEntry());
+
+    GameObjectTemplateAddon const* addon = sObjectMgr->GetGameObjectTemplateAddon(gob->GetEntry());
+	if (std::strcmp(temp->unk1.c_str(), "1") != 0)
+		return true;
+
+	if (addon->faction != target->getFaction())
+		return false;
+
+	return true;
+}
+
+bool Event::IpCheck(Player* player)
+{
+	uint32 count = 0;
+
+	for (auto itr = _PlayersMap.begin(); itr != _PlayersMap.end(); itr++)
+		if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+			if (strcmp(pl->GetSession()->GetRemoteAddress().c_str(), player->GetSession()->GetRemoteAddress().c_str()) == 0)
+				count++;
+
+
+	uint32 max = sSwitch->GetValue(ST_EVENT_PLAYERS);
+
+	if (count > max)
+	{
+		std::ostringstream oss;
+		oss << "¼ÓÈë»î¶¯µÄÍæ¼ÒÊýÁ¿ÒÑ´ïµ½ÉÏÏÞ£¬¼ÓÈëÊ§°Ü£¡" << count << "/" << max;
+		player->GetSession()->SendNotification(oss.str().c_str());
+		return false;
+	}
+	else
+		return true;
+}
+
+//Õ½³¡
+bool Event::IsFixedTimeBgActive(BattlegroundTypeId bgTypeId)
+{
+	EventTypes eventType = C_ET_NONE;
+
+	switch (bgTypeId)
+	{
+	case BATTLEGROUND_AV:
+		eventType = C_ET_AV;
+		break;
+	case BATTLEGROUND_WS:
+		eventType = C_ET_WS;
+		break;
+	case BATTLEGROUND_AB:
+		eventType = C_ET_AB;
+		break;
+	case BATTLEGROUND_EY:
+		eventType = C_ET_EY;
+		break;
+	case BATTLEGROUND_SA:
+		eventType = C_ET_SA;
+		break;
+	case BATTLEGROUND_IC:
+		eventType = C_ET_IC;
+		break;
+	}
+
+	if (eventType == _EventType)
+		return true;
+
+	return false;
+}
+
+
+void Event::Start(uint32 eventId)
+{
+	if (eventId == EVENT_ID_QUICK_RESPONSE)
+	{
+		sQuickResponse->Anounce();
+		return;
+	}
+	
+	//ÔÚ´Ë×ö¼ÙÈËÉÏÏÂÏß ÇÐ»»ÇøÓòµÈÊÂ¼þ´¦Àí
+	
+	if (eventId == EVENT_ID_FAKE_PLAYER_LOGIN_OR_LOGOUT)
+	{
+		sFakePlayers->LoginOrLogout();
+		return;
+	}
+	
+	if (eventId == EVENT_ID_FAKE_PLAYER_UPDATE_ZONE_ID)
+	{
+		sFakePlayers->UpdateZone();
+		return;
+	}
+	
+	if (eventId == EVENT_ID_FAKE_PLAYER_LEVEL_UP)
+	{
+		sFakePlayers->LevelUp();
+		return;
+	}
+
+	if (eventId < 100)
+		return;
+
+	InitParams(eventId);
+
+	//³Ô¼¦³õÊ¼»¯
+	sBGIC->InitParams(eventId, _Map);
+
+	if (_EventType == C_ET_NONE)
+		return;
+
+	std::ostringstream oss;
+	oss << _EventName << "¿ªÊ¼£¡";
+	sWorld->SendServerMessage(SERVER_MSG_STRING, oss.str().c_str());
+
+	if (eventId == ARENA_DUEL_START_EVENT_ID)
+	{
+		sArenaDuel->SetState(ARENA_DUEL_STATE_START);
+		return;
+	}
+
+	ReviveAll(true);
+
+	if (_EventType < C_ET_LINE)
+	{
+		StartCall();
+		return;
+	}
+		
+	_DelayStartCall = true;
+
+	if (_EventId == BGIC_EVENT_ID)
+		return;
+
+	InitWorldState();
+
+	oss.str("");
+	oss << _EventName;
+
+	switch (_RejoinType)
+	{
+	case C_RT_BANED:
+		oss << "ÖØÐÂ¼ÓÈë»î¶¯½«±»½ûÖ¹£¡";
+		break;
+	case C_RT_KEEP_GROUP:
+		oss << "ÖØÐÂ¼ÓÈë»î¶¯²»»á¸Ä±ä·Ö×é£¡";
+		break;
+	case C_RT_REDIS_GROUP:
+		oss << "ÖØÐÂ¼ÓÈë»î¶¯Ê±£¬ÏµÍ³»áÖØÐÂ·Ö×é£¡";
+		break;
+	}
+
+	sWorld->SendServerMessage(SERVER_MSG_STRING, oss.str().c_str());
+}
+
+int32 Event::GetWeightLeft(EventFactionId faction)
+{
+	bool exist = false;
+
+	uint32 Weight = 0;
+
+	for (auto itr = _StopVec.begin(); itr != _StopVec.end(); itr++)
+	{
+		if (faction != itr->Faction)
+			continue;
+		
+		exist = true;
+
+		if (itr->StopType == TYPEID_PLAYER)
+			Weight += itr->Param * itr->Weight;
+		else if (itr->Param != 0)
+			Weight += itr->Weight;
+	}
+
+	if (!exist)
+		return 0;
+
+	if (Weight == 0)
+		return -1;
+
+	return Weight;
+}
+
+void Event::Stop(uint32 eventId)
+{
+	//ÇÀ´ð
+	if (eventId == EVENT_ID_QUICK_RESPONSE)
+	{
+		sQuickResponse->Reward();
+		return;
+	}
+
+	if (eventId != 0 && _EventId != eventId)
+		return;
+
+	if (_EventType >= C_ET_WS && _EventType <= C_ET_IC)
+	{
+		Reset();
+		return;
+	}
+
+	if (!Valid())
+		return;
+
+	if (_EventId == BGIC_EVENT_ID)
+	{
+		sBGIC->Stop();
+		return;
+	}
+
+	int32 w = 100000;
+
+	for (auto itr = _FactionVec.begin(); itr != _FactionVec.end(); itr++)
+	{
+		int32 weight = GetWeightLeft(*itr);
+
+		if (weight < w)
+		{
+			w = weight;
+			_WinFaction = *itr;
+		}
+	}
+
+	auto itr = _FactionNameMap.find(_WinFaction);
+	if (itr != _FactionNameMap.end())
+		SendScreenMessage(_EventName + itr->second + "»ñÊ¤£¡");
+
+	ReviveAll(false);
+	_DelayStopCall = true;
+}
+
+void Event::UpdateActive(Object* obj,bool kill)
+{
+	if (_AltVec.empty())
+		return;
+	
+	uint32 targetEntry = obj->GetEntry();
+	TypeID typeId = obj->GetTypeId();
+
+	switch (typeId)
+	{
+	case TYPEID_UNIT:
+		for (auto itr = _AltVec.begin(); itr != _AltVec.end(); itr++)
+			for (size_t i = 0; i < ALT_GUID_MAX; i++)
+				if (targetEntry == itr->TargetEntry[i] && itr->TargetCount[i] != itr->TargetKillCount[i])
+				{
+					itr->TargetKillCount[i]++;
+					SendScreenMessage("»÷É±[" + sObjectMgr->GetCreatureTemplate(obj->GetEntry())->Name + "] " + std::to_string(itr->TargetKillCount[i]) + " / " + std::to_string(itr->TargetCount[i]));
+				}
+					
+		break;
+	case TYPEID_GAMEOBJECT:
+		for (auto itr = _AltVec.begin(); itr != _AltVec.end(); itr++)
+			for (size_t i = 0; i < ALT_GUID_MAX; i++)
+				if (targetEntry == -itr->TargetEntry[i] && itr->TargetCount[i] != itr->TargetKillCount[i])
+				{
+					itr->TargetKillCount[i]++;
+					SendScreenMessage("´Ý»Ù[" + sObjectMgr->GetGameObjectTemplate(obj->GetEntry())->name + "] " + std::to_string(itr->TargetKillCount[i]) + "/" + std::to_string(itr->TargetCount[i]));
+				}
+		break;
+	case TYPEID_PLAYER:
+		for (auto itr = _AltFactionVec.begin(); itr != _AltFactionVec.end(); itr++)
+		{
+			if (itr->Faction == obj->ToPlayer()->GetEventFaction())
+			{
+				if (itr->Kills > 0 && kill)
+					itr->Kills--;
+				if (itr->Killeds > 0 && !kill)
+					itr->Killeds--;
+			}
+		}
+		break;
+	}
+
+	for (auto itr = _AltVec.begin(); itr != _AltVec.end(); itr++)
+	{
+		int64 GUID = itr->GUID;
+
+		if (find(_AltedVec.begin(), _AltedVec.end(), GUID) != _AltedVec.end())
+			continue;
+
+		bool check1 = true;
+
+		for (size_t i = 0; i < ALT_GUID_MAX; i++)
+			if (itr->TargetCount[i] != itr->TargetKillCount[i])
+				check1 = false;
+
+		bool check2 = true;
+
+		if (check1)
+			for (auto i = _AltFactionVec.begin(); i != _AltFactionVec.end(); i++)
+				if (i->GUID == GUID)
+					if (i->Kills != 0 || i->Killeds != 0)
+						check2 = false;
+
+		if (check1 && check2)
+		{
+			_AltedVec.push_back(GUID);
+
+			if (GUID > 0)
+			{
+				if (CreatureData const* data = sObjectMgr->GetCreatureData(GUID))
+					if (Creature* c = ObjectAccessor::GetObjectInWorld(MAKE_NEW_GUID(GUID, data->id, HIGHGUID_UNIT), (Creature*)NULL))
+					{
+						c->SetUInt32Value(UNIT_FIELD_FLAGS, itr->AltFlag);
+						SendScreenMessage(itr->NoticeText);
+					}
+			}
+			else
+			{
+				if (GameObjectData const* data = sObjectMgr->GetGOData(-GUID))
+					if (GameObject* g = ObjectAccessor::GetObjectInWorld(MAKE_NEW_GUID(-GUID, data->id, HIGHGUID_GAMEOBJECT), (GameObject*)NULL))
+					{
+						g->SetUInt32Value(GAMEOBJECT_FLAGS, itr->AltFlag);
+						SendScreenMessage(itr->NoticeText);
+					}			
+			}
+		}
+	}
+}
+
+float Event::GetDistance(Player* player, uint32 pos)
+{
+	std::unordered_map<uint32, PosTemplate>::iterator it = PosMap.find(pos);
+	
+	if (it != PosMap.end())
+		if (it->second.map == player->GetMapId())
+			return player->GetDistance(it->second.x, it->second.y, it->second.z);
+	
+	return 1000.0f;
+}
+
+void Event::Tele(Player* player, uint32 pos)
+{
+	std::unordered_map<uint32, PosTemplate>::iterator it = PosMap.find(pos);
+	
+	if (it != PosMap.end())
+		player->TeleportTo(it->second.map, it->second.x, it->second.y, it->second.z, it->second.o);
+}
+
+void Event::TeleToGraveyard(Player* player)
+{
+	Tele(player, GetPhaseGraveyardPos(player->GetEventFaction()));
+}
+
+typedef std::pair<std::string, uint32> PAIR;
+
+int DoSort(const std::pair<std::string, uint32>& x, const std::pair<std::string, uint32>& y)
+{
+	return x.second > y.second;
+}
+
+void SortMapByValue(std::unordered_map<std::string, uint32>& tMap, std::vector<std::pair<std::string, uint32> >& tVector)
+{
+	for (std::unordered_map<std::string, uint32>::iterator curr = tMap.begin(); curr != tMap.end(); curr++)
+		tVector.push_back(std::make_pair(curr->first, curr->second));
+
+	sort(tVector.begin(), tVector.end(), DoSort);
+}
+
+void Event::RewAndRest()
+{
+	std::unordered_map<std::string, uint32 >KillsMap;
+	std::unordered_map<std::string, uint32 >KilledsMap;
+	std::unordered_map<std::string, uint32 >DamageMap;
+	std::unordered_map<std::string, uint32 >HealMap;
+
+	for (auto itr = _PlayersMap.begin(); itr != _PlayersMap.end(); itr++)
+	{
+		if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+		{
+			if (!pl->InEvent())
+				continue;
+
+			std::string name = sCF->GetNameLink(pl);
+			KillsMap[name] = pl->GetEventData().Kills;
+			KilledsMap[name] = pl->GetEventData().Killeds;
+			DamageMap[name] = pl->GetEventData().Damage;
+			HealMap[name] = pl->GetEventData().Heal;
+		}
+	}
+
+	std::ostringstream oss;
+
+	std::vector<std::pair<std::string, uint32>> tVector;
+	uint32 count;
+
+	oss << "|cffFF0000»÷É±ÅÅÐÐ|r\n";
+	count = 0;
+	tVector.clear();
+	SortMapByValue(KillsMap, tVector);
+
+	for (uint32 i = 0; i < tVector.size(); i++)
+	{
+		if (count > 3)
+			continue;
+		count++;
+		oss << "|cFFF49B00" << tVector[i].first << "|r - " << tVector[i].second << "\n";
+	}
+
+	//oss << "\n\n";
+	//oss << "±»É±ÅÅÐÐ\n";
+	//count = 0;
+	//tVector.clear();
+	//SortMapByValue(KilledsMap, tVector);
+	//
+	//for (uint32 i = 0; i < tVector.size(); i++)
+	//{
+	//	if (count > 3)
+	//		continue;
+	//	count++;
+	//	oss << "|cFFF49B00" << tVector[i].first << "|r - " << tVector[i].second << "\n";
+	//}
+
+	oss << "\n\n";
+	oss << "|cffFF0000ÉËº¦ÅÅÐÐ|r\n";
+	count = 0;
+	tVector.clear();
+	SortMapByValue(DamageMap, tVector);
+
+	for (uint32 i = 0; i < tVector.size(); i++)
+	{
+		if (count > 3)
+			continue;
+		count++;
+		oss << "|cFFF49B00" << tVector[i].first << "|r - " << tVector[i].second << "\n";
+	}
+
+	oss << "\n\n";
+	oss << "|cffFF0000ÖÎÁÆÅÅÐÐ|r\n";
+	count = 0;
+	tVector.clear();
+	SortMapByValue(HealMap, tVector);
+
+	for (uint32 i = 0; i < tVector.size(); i++)
+	{
+		if (count > 3)
+			continue;
+		count++;
+		oss << "|cFFF49B00" << tVector[i].first << "|r - " << tVector[i].second << "\n";
+	}
+
+	oss <<"\n\n";
+	for (auto itr = _PlayersMap.begin(); itr != _PlayersMap.end(); itr++)
+	{
+		if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+		{
+			if (!pl->InEvent())
+				continue;
+
+			std::ostringstream oss1;
+			oss1 << "|cffFF0000ÄãµÄ¸öÈËÕ½¼¨|r" << "\n";
+			oss1 << "|cFFF49B00»÷É±|r - " << pl->GetEventData().Kills << "\n";
+			oss1 << "|cFFF49B00±»É±|r - " << pl->GetEventData().Killeds << "\n";
+			oss1 << "|cFFF49B00ÉËº¦|r - " << pl->GetEventData().Damage << "\n";
+			oss1 << "|cFFF49B00ÖÎÁÆ|r - " << pl->GetEventData().Heal << "\n";
+
+			sCF->SendAcceptOrCancel(pl, 0, oss.str() + oss1.str());
+
+			if (CanRew(pl))
+			{
+				if (pl->GetEventFaction() == _WinFaction)
+					sRew->Rew(pl, _WinRewId);
+				else
+					sRew->Rew(pl, _LosRewId);
+			}
+
+			auto i = _StopPosMap.find(pl->GetEventFaction());
+
+			if (i != _StopPosMap.end())
+				Tele(pl, i->second);
+
+			pl->EventRest();
+		}
+	}
+
+	Reset();
+}
+
+void Event::Update(Map* map, uint32 diff)
+{
+	if (_EventType < C_ET_LINE && !map || !_Map || map->GetId() != _Map->GetId())
+		return;
+
+	if (_EventId == BGIC_EVENT_ID)
+		sBGIC->UpdateSpawn(diff);
+
+	//ÑÓ³ÙÕÙ»½
+	if (_DelayStartCall)
+	{
+		_UpdateDelayNotice += diff;
+
+		if (_UpdateDelayNotice > 500)
+		{
+			_UpdateDelayNotice = 0;
+			_DelayStartCall = false;
+			StartCall();
+		}
+	}
+
+	if (_EventId == BGIC_EVENT_ID)
+		return;
+
+	//ÑÓ³Ù½±Àø²¢ÖØÖÃ
+	if (_DelayStopCall)
+	{
+		_UpdateDelayNotice += diff;
+
+		if (_UpdateDelayNotice > 500)
+		{
+			_UpdateDelayNotice = 0;
+			_DelayStopCall = false;
+			RewAndRest();
+		}
+	}
+
+	UpdateRevive(diff);
+	UpdateSafe(diff);
+	UpdateSpawn(diff);
+}
+
+void Event::UpdateSpawn(uint32 diff)
+{
+	_UpdateSpawnTimer += diff;
+
+	if (_UpdateSpawnTimer < IN_MILLISECONDS)
+		return;
+
+	_UpdateSpawnTimer = 0;
+
+	for (auto itr = _SpawnVec.begin(); itr != _SpawnVec.end(); itr++)
+	{
+		if (itr->SpawnTime == 0 || (itr->Phase != 0 && itr->Phase != _Phase))
+			continue;
+
+		itr->SpawnTime -= 1;
+
+		for (size_t i = 0; i < MAX_SPAWNNOTICE_COUNT; i++)
+			if (itr->SpawnTime == itr->NoticeTime[i])
+				SendScreenMessage(itr->SpawnNotice[i]);
+
+		if (itr->SpawnTime == 0)
+		{
+			uint32 map = 0;
+			float x = 0;
+			float y = 0;
+			float z = 0;
+			float o = 0;
+
+			GetTelePos(itr->PosId, map, x, y, z, o);
+
+			Position pos;
+			pos.Relocate(x, y, z, o);
+
+			if (itr->Entry > 0)
+				_Map->SummonCreature(itr->Entry, pos, 0, itr->Duration * IN_MILLISECONDS);
+			else
+				_Map->SummonGameObject(-itr->Entry, x, y, z, o, 0, 0, 0, 0, itr->Duration);
+		}
+	}
+}
+
+void Event::UpdateRevive(uint32 diff)
+{
+	_UpdateReviveTimer += diff;
+
+	/*if (_UpdateReviveTimer > 29500 && !_SoulVisual)
+	{
+		for (auto itr = _PlayersMap.begin(); itr != _PlayersMap.end(); itr++)
+		{
+			if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+			{
+				if (!pl->InEvent())
+					continue;
+
+				if (pl->IsAlive())
+					continue;
+
+				//if (GetDistance(pl, GetPhaseGraveyardPos(pl->GetEventFaction())) < 20.0f)
+					//pl->CastSpell(pl, 24171, true);
+				auto itr = _HealerMap.find(pl->GetEventFaction());
+
+				if (itr != _HealerMap.end())
+				{
+					if (Creature* healer = _Map->GetCreature(itr->second))
+					{
+						if (healer->GetDistance(pl) < 20.0f)
+							healer->CastSpell(pl, 24171, true);
+					}
+				}
+			}
+		}
+
+		_SoulVisual = true;
+
+	}else */if (_UpdateReviveTimer > 30000)
+	{
+		_UpdateReviveTimer = 0;
+		_SoulVisual = false;
+
+		for (auto itr = _PlayersMap.begin(); itr != _PlayersMap.end(); itr++)
+		{
+			if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+			{
+				if (!pl->InEvent())
+					continue;
+
+				if (pl->IsAlive())
+					continue;
+
+				if (GetDistance(pl, GetPhaseGraveyardPos(pl->GetEventFaction())) < 20.0f)
+				{
+					pl->GetSession()->SendAreaTriggerMessage("%sÄÃ³öÄãµÄÓÂÆø£¬¼ÌÐøÕ½¶·£¡", _EventName.c_str());
+					pl->CastSpell(pl, 24171, true);
+					pl->ResurrectPlayer(1.0f);
+					pl->CastSpell(pl, 6962, true);
+					pl->CastSpell(pl, SPELL_SPIRIT_HEAL_MANA, true);
+					sObjectAccessor->ConvertCorpseForPlayer(pl->GetGUID());
+				}
+			}
+		}
+	}
+}
+
+void Event::UpdateSafe(uint32 diff)
+{
+	_UpdateSafeTimer += diff;
+
+	if (_UpdateSafeTimer > 1000)
+	{
+		_UpdateSafeTimer = 0;
+
+		for (auto itr = _PlayersMap.begin(); itr != _PlayersMap.end(); itr++)
+		{
+			if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+			{
+				if (pl->InEvent() && pl->IsAlive())
+				{
+					for (auto i = _PhaseFactionVec.begin(); i != _PhaseFactionVec.end(); i++)
+					{
+						if (i->Phase == _Phase)
+						{
+							if (i->Faction != pl->GetEventFaction() && GetDistance(pl, i->GraveyardPos) < i->GraveyardSafe)
+							{
+								TeleToGraveyard(pl);
+								pl->GetSession()->SendNotification(i->GraveyardSafeNotice.c_str());
+								break;
+							}
+						}
+					}
+				}	
+			}
+		}
+	}
+}
+
+uint32 Event::GetFactionMembers(EventFactionId faction)
+{
+	uint32 count = 0;
+
+	for (auto iter = _PlayersMap.begin(); iter != _PlayersMap.end(); iter++)
+		if (faction == iter->second)
+			count++;
+
+	return count;
+}
+
+void Event::ReviveAll(bool start)
+{
+	SessionMap const& smap = sWorld->GetAllSessions();
+	for (SessionMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+		if (Player* player = iter->second->GetPlayer())
+		{
+			if (player->IsAlive())
+				continue;
+
+			if (start || !start && player->InEvent())
+			{
+				player->ResurrectPlayer(1.0f);
+				player->SpawnCorpseBones();
+			}		
+		}
+}
+
+void Event::StartCall()
+{
+	if (_NoticeText.empty())
+		return;
+
+	uint32 menuId = _EventId + 1000000;
+
+	SessionMap const& smap = sWorld->GetAllSessions();
+	for (SessionMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+		if (Player* player = iter->second->GetPlayer())
+		{
+			WorldPacket data(SMSG_GOSSIP_MESSAGE, 100);
+			data << uint64(player->GetGUID());
+			data << uint32(menuId);
+			data << uint32(1);
+			data << uint32(1);
+			data << uint32(1);
+			data << uint8(1);
+			data << uint8(0);
+			data << uint32(0);
+			data << "";
+			data << _NoticeText;
+			player->GetSession()->SendPacket(&data);
+		}
+}
+
+void Event::Join(Player* pl)
+{
+	if (!Valid())
+	{
+		ChatHandler(pl->GetSession()).PSendSysMessage("¼ÓÈëÊ§°Ü£¡»î¶¯ÒÑ¾­½áÊø£¡");
+		return;
+	}
+
+	//³¬¹ýIPÏÞÖÆ
+	if (!IpCheck(pl))
+		return;
+
+	//ÒÑ¾­ÔÚÊÂ¼þÖÐ
+
+	if (pl->InEvent())
+	{
+		ChatHandler(pl->GetSession()).PSendSysMessage("%s¼ÓÈëÊ§°Ü£¡ÄãÒÑ¾­¼ÓÈë»î¶¯£¡", _EventName.c_str());
+		return;
+	}
+#pragma region ·Ö×é
+
+	EventFactionId faction = Subgroup(pl);
+
+	if (faction == 0)
+	{
+		ChatHandler(pl->GetSession()).PSendSysMessage("%s¼ÓÈëÊ§°Ü£¡ÎÞ·¨ÖØÐÂ¼ÓÈë£¡", _EventName.c_str());
+		return;
+	}
+
+	if (pl->isDead())
+	{
+		pl->ResurrectPlayer(1.0f);
+		pl->SpawnCorpseBones();
+	}
+
+	pl->UpdateMaxHealth();
+	pl->UninviteFromGroup();
+	if (pl->GetGroup())
+		pl->RemoveFromGroup();
+
+	pl->InitEventData(_EventId, faction, _FactionNameMap[faction]);
+	_PlayersMap[pl->GetGUIDLow()] = faction;
+
+	bool groupExist = false;
+
+	for (auto iter = _GroupMap.begin(); iter != _GroupMap.end(); iter++)
+	{
+		if (Group* group = sGroupMgr->GetGroupByGUID(iter->first))
+		{
+			if (!group->IsFull() && iter->second == faction)
+			{
+				group->AddMember(pl);
+				groupExist = true;
+				break;
+			}
+		}
+	}
+
+	if (!groupExist)
+	{
+		Group* group = new Group;
+		group->Create(pl);
+		group->ConvertToRaid();
+		sGroupMgr->AddGroup(group);
+		_GroupMap[group->GetLowGUID()] = faction;
+	}
+
+#pragma endregion
+
+	auto itr = _StartPosMap.find(faction);
+
+	if (itr != _StartPosMap.end())
+		Tele(pl, itr->second);
+}
+
+EventFactionId Event::Subgroup(Player* pl)
+{
+	auto iter = _PlayersMap.find(pl->GetGUIDLow());
+
+	if (iter != _PlayersMap.end())
+	{
+		if (_RejoinType == C_RT_BANED)
+			return 0;
+		else if (_RejoinType == C_RT_KEEP_GROUP)
+			return iter->second;
+	}
+
+	if (_EventType == C_ET_LINE)
+	{
+		switch (_GroupType)
+		{
+		case C_GT_ONE_ALL:
+			return 1;
+		case C_GT_ONE_A:
+			if (pl->GetTeamId() == TEAM_ALLIANCE)
+				return 1;
+			else
+				return 2;
+		case C_GT_ONE_H:
+			if (pl->GetTeamId() == TEAM_ALLIANCE)
+				return 2;
+			else
+				return 1;
+		case C_GT_RANDOM_A_H:
+			if (_RandomAH)
+			{
+				if (pl->GetTeamId() == TEAM_ALLIANCE)
+					return 1;
+				else
+					return 2;
+			}
+			else
+			{
+				if (pl->GetTeamId() == TEAM_ALLIANCE)
+					return 2;
+				else
+					return 1;
+			}
+			break;
+		case C_GT_RANDOM_PLAYER:
+		{
+			if (GetFactionMembers(1) > GetFactionMembers(2))
+				return 2;
+			else
+				return 1;
+		}
+			break;
+		default:
+			break;
+		}
+	}
+	else if (_EventType == C_ET_FACTION)
+		return pl->faction;
+	else if (_EventType == C_ET_GUILD)
+		return pl->GetGuildId();
+
+	return 0;
+}
+
+void Event::UpdatePhase(Object* obj, bool kill)
+{
+	bool nextphaseexsit = false;
+
+	for (auto itr = _PhaseFactionVec.begin(); itr != _PhaseFactionVec.end(); itr++)
+	{
+		if (itr->Phase == (_Phase + 1))
+		{
+			nextphaseexsit = true;
+			break;
+		}	
+	}
+	
+	if (!nextphaseexsit)
+		return;
+
+
+	uint32 guid = obj->GetGUIDLow();
+	TypeID typeId = obj->GetTypeId();
+
+
+	switch (typeId)
+	{
+	case TYPEID_UNIT:
+	{
+		for (auto itr = _PhaseVec.begin(); itr != _PhaseVec.end(); itr++)
+		{
+			if (itr->Phase == _Phase)
+			{
+				if (itr->StopGUID == guid && itr->StopGUID > 0)
+					itr->StopGUID = 0;
+			}
+		}
+	}
+		break;
+	case TYPEID_PLAYER:
+	{
+		for (auto itr = _PhaseFactionVec.begin(); itr != _PhaseFactionVec.end(); itr++)
+		{
+			if (itr->Phase == _Phase && obj->ToPlayer()->GetEventFaction() == itr->Faction)
+			{
+				if (itr->StopPlayerKills > 0 && kill)
+					itr->StopPlayerKills--;
+
+				if (itr->StopPlayerKilleds > 0 && !kill)
+					itr->StopPlayerKilleds--;
+			}
+		}
+	}
+		break;
+	case TYPEID_GAMEOBJECT:
+	{
+		for (auto itr = _PhaseVec.begin(); itr != _PhaseVec.end(); itr++)
+		{
+			if (itr->Phase == _Phase)
+			{
+				if (-itr->StopGUID == guid && itr->StopGUID < 0)
+					itr->StopGUID = 0;
+			}
+		}
+	}
+		break;
+	}
+
+	for (auto itr = _PhaseVec.begin(); itr != _PhaseVec.end(); itr++)
+		if (itr->Phase == _Phase)
+			if (itr->StopGUID != 0)
+				return;
+
+	for (auto itr = _PhaseFactionVec.begin(); itr != _PhaseFactionVec.end(); itr++)
+		if (itr->Phase == _Phase && itr->StopPlayerKilleds == 0 && itr->StopPlayerKills == 0)
+		{
+			for (auto itr = _PlayersMap.begin(); itr != _PlayersMap.end(); itr++)
+			{
+				if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+				{
+					if (!pl->InEvent())
+						continue;
+
+					for (auto i = _PhaseFactionVec.begin(); i != _PhaseFactionVec.end(); i++)
+						if (_Phase == i->Phase && pl->GetEventFaction() == i->Faction)
+						{
+							if (!i->StopNotice.empty())
+							{
+								WorldPacket data;
+								ChatHandler::BuildChatPacket(data, CHAT_MSG_RAID_BOSS_EMOTE, LANG_UNIVERSAL,
+									NULL, NULL, i->StopNotice);
+
+								if (WorldSession* ss = pl->GetSession())
+									ss->SendPacket(&data);
+							}
+							Tele(pl, i->StopTelePos);
+						}
+				}		
+			}
+
+			_Phase++;
+			SummonSoulHealer();
+			return;
+		}
+
+
+	//if (typeId == TYPEID_PLAYER)
+	//	for (auto itr = _PhaseFactionVec.begin(); itr != _PhaseFactionVec.end(); itr++)
+	//		if (itr->Phase == _Phase && obj->ToPlayer()->GetEventFaction() == itr->Faction)
+	//			if (itr->StopPlayerKilleds != 0 || itr->StopPlayerKills != 0)
+	//				return;
+	//
+	//for (auto itr = _PlayersMap.begin(); itr != _PlayersMap.end(); itr++)
+	//{
+	//	if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+	//	{
+	//		if (!pl->InEvent())
+	//			continue;
+	//
+	//		for (auto i = _PhaseFactionVec.begin(); i != _PhaseFactionVec.end(); i++)
+	//			if (_Phase == i->Phase && pl->GetEventFaction() == i->Faction && !i->StopNotice.empty())
+	//				pl->GetSession()->SendNotification(i->StopNotice.c_str()); 
+	//	}
+	//}
+	//
+	//_Phase++;
+	//
+	//SummonSoulHealer();
+}
+
+void Event::UpdateWorldState(uint32 ID, uint32 value)
+{
+	for (auto itr = _PlayersMap.begin(); itr != _PlayersMap.end(); itr++)
+		if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+			pl->SendUpdateWorldState(ID, value);
+}
+
+
+void Event::InitWorldState()
+{
+	for (auto itr = _WorldStateVec.begin(); itr != _WorldStateVec.end(); itr++)
+	{
+		sWorld->setWorldState(itr->ID, itr->InitValue);
+
+		SessionMap const& smap = sWorld->GetAllSessions();
+		for (SessionMap::const_iterator i = smap.begin(); i != smap.end(); ++i)
+			if (Player* pl = i->second->GetPlayer())
+				pl->SendUpdateWorldState(itr->ID, itr->InitValue);
+	}
+}
+
+void Event::UpdateWorldState(Object* obj, bool kill)
+{
+	int64 entry = obj->GetEntry();
+	TypeID typeId = obj->GetTypeId();
+
+	switch (typeId)
+	{
+	case TYPEID_UNIT:
+	{
+		for (auto itr = _WorldStateVec.begin(); itr != _WorldStateVec.end(); itr++)
+		{
+			for (size_t i = 0; i < WORLDSTATE_ENTRY_MAX; i++)
+			{
+				if (entry == itr->Entry[i])
+				{
+					if (itr->Step == 0)
+						continue;
+
+					uint64 value = sWorld->getWorldState(itr->ID);
+					value += itr->Step[i];
+					sWorld->setWorldState(itr->ID, value);
+					UpdateWorldState(itr->ID, value);
+					if (value == itr->NoticeValue || itr->NoticeValue == 0)
+						SendScreenMessage(itr->Notice);
+				}
+			}
+		}
+	}
+		break;
+	case TYPEID_GAMEOBJECT:
+	{
+		entry = -entry;
+
+		for (auto itr = _WorldStateVec.begin(); itr != _WorldStateVec.end(); itr++)
+		{
+			for (size_t i = 0; i < WORLDSTATE_ENTRY_MAX; i++)
+			{
+				if (entry == itr->Entry[i])
+				{
+					if (itr->Step == 0)
+						continue;
+
+					uint64 value = sWorld->getWorldState(itr->ID);
+					value += itr->Step[i];
+					sWorld->setWorldState(itr->ID, value);
+					UpdateWorldState(itr->ID, value);
+					if (value == itr->NoticeValue || itr->NoticeValue == 0)
+						SendScreenMessage(itr->Notice);
+				}
+			}
+		}
+	}
+		break;
+	case TYPEID_PLAYER:
+	{
+		for (auto itr = _WorldStateFactionVec.begin(); itr != _WorldStateFactionVec.end(); itr++)
+		{
+			if (itr->Faction == obj->ToPlayer()->GetEventFaction() && kill == itr->Kill)
+			{
+				if (itr->Step == 0)
+					continue;
+
+				uint64 value = sWorld->getWorldState(itr->ID);
+				value += itr->Step;
+				sWorld->setWorldState(itr->ID, value);
+				UpdateWorldState(itr->ID, value);
+				if (value == itr->NoticeValue || itr->NoticeValue == 0)
+					SendScreenMessage(itr->Notice);
+			}
+		}
+	}
+		break;
+	}
+}
+
+void Event::Process(Object* obj)
+{
+	uint32 guid = obj->GetGUIDLow();
+
+	switch (obj->GetTypeId())
+	{
+	case TYPEID_UNIT:
+		for (auto itr = _StopVec.begin(); itr != _StopVec.end(); itr++)
+			if (guid == itr->Param && itr->StopType == TYPEID_UNIT)
+				itr->Param = 0;
+		break;
+	case TYPEID_GAMEOBJECT:
+		for (auto itr = _StopVec.begin(); itr != _StopVec.end(); itr++)
+			if (guid == itr->Param && itr->StopType == TYPEID_GAMEOBJECT)
+				itr->Param = 0;
+	break;
+	case TYPEID_PLAYER:
+		for (auto itr = _StopVec.begin(); itr != _StopVec.end(); itr++)
+			if (itr->StopType == TYPEID_PLAYER && itr->Faction == obj->ToPlayer()->GetEventFaction())
+				if (itr->Param > 0)
+					itr->Param--;
+	break;
+	}
+
+	
+
+	for (auto itr = _StopVec.begin(); itr != _StopVec.end(); itr++)
+	{
+		EventFactionId faction = itr->Faction;
+
+		bool stop = true;
+
+		for (auto i = _StopVec.begin(); i != _StopVec.end(); i++)
+			if (faction == i->Faction)
+				if (itr->Param != 0)
+					stop = false;
+
+		if (stop)
+		{
+			sGameEventMgr->StopEvent(_EventId, false, true);
+			return;
+		}
+	}
+}
+
+bool Event::DiedTele(Player* player)
+{
+	if (player->InEvent())
+	{
+		Tele(player, GetPhaseGraveyardPos(player->GetEventFaction()));
+		return true;
+	}
+
+	return false;
+}
+
+bool Event::SendAreaSpiritHealerQueryOpcode(Player* player)
+{
+	if (!player || !player->InEvent() || player->IsAlive())
+		return false;
+
+	auto itr = _HealerMap.find(player->GetEventFaction());
+
+	if (itr != _HealerMap.end())
+	{
+		WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
+
+		data << itr->second;
+		data << 30000 - _UpdateReviveTimer;
+		player->GetSession()->SendPacket(&data);
+		return true;
+	}
+	
+	return false;
+}
+
+void Event::SummonSoulHealer()
+{
+	if (!_Map)
+		return;
+
+	for (auto itr = _HealerMap.begin(); itr != _HealerMap.end(); itr++)
+		if (Creature* healer = _Map->GetCreature(itr->second))
+			healer->RemoveFromWorld();
+
+	_HealerMap.clear();
+
+	for (auto itr = _PhaseFactionVec.begin(); itr != _PhaseFactionVec.end(); itr++)
+	{
+		if (itr->Phase != _Phase)
+			continue;
+
+		uint32 map = 0;
+		float x = 0;
+		float y = 0;
+		float z = 0;
+		float o = 0;
+
+		GetTelePos(itr->GraveyardPos, map, x, y, z, o);
+
+		Position pos;
+		pos.Relocate(x, y, z, o);
+
+		if (Creature* healer = _Map->SummonCreature(itr->GraveyardHealer, pos, 0, 60 * 60 * IN_MILLISECONDS))
+		{
+			_HealerMap[itr->Faction] = healer->GetGUID();
+			healer->setFaction(itr->Faction);
+			healer->setDeathState(DEAD);
+			healer->SetUInt64Value(UNIT_FIELD_CHANNEL_OBJECT, healer->GetGUID());
+			healer->SetUInt32Value(UNIT_CHANNEL_SPELL, SPELL_SPIRIT_HEAL_CHANNEL);
+			healer->SetFloatValue(UNIT_MOD_CAST_SPEED, 1.0f);
+		}
+	}
+}
+
+void Event::SendScreenMessage(std::string text, EventFactionId faction, bool onlydead)
+{
+	if (text.empty())
+		return;
+
+	WorldPacket data;
+	ChatHandler::BuildChatPacket(data, CHAT_MSG_RAID_BOSS_EMOTE, LANG_UNIVERSAL,
+		NULL, NULL, text);
+
+	for (auto itr = _PlayersMap.begin(); itr != _PlayersMap.end(); itr++)
+	{
+		if (Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(itr->first, 0, HIGHGUID_PLAYER)))
+		{
+			if (!pl->InEvent())
+				continue;
+
+			if (faction == 0 || faction == pl->GetEventFaction())
+			{
+				if (pl->IsAlive() && onlydead)
+					continue;
+
+				if (WorldSession* ss = pl->GetSession())
+					pl->GetSession()->SendPacket(&data);
+			}
+		}
+	}
+}
diff --git a/src/server/scripts/Custom/CustomEvent/Event.h b/src/server/scripts/Custom/CustomEvent/Event.h
new file mode 100644
index 0000000..f6a7b81
--- /dev/null
+++ b/src/server/scripts/Custom/CustomEvent/Event.h
@@ -0,0 +1,314 @@
+//æ¢ç­
+#define EVENT_ID_QUICK_RESPONSE					70
+
+//åäººæ´æ°
+#define EVENT_ID_FAKE_PLAYER_UPDATE_ZONE_ID		71
+#define EVENT_ID_FAKE_PLAYER_LOGIN_OR_LOGOUT	72
+#define EVENT_ID_FAKE_PLAYER_LEVEL_UP			73
+
+//å¤§éæ
+#define UKBG_EVENT_ID	0
+#define UKBG_LENGTH		18000
+#define UKBG_H_REWID	32
+#define UKBG_M_REWID	33
+#define UKBG_L_REWID	33
+
+//ç­è·¯ç¸é¢
+#define NARROW_EVENT_ID				0
+#define NARROW_EVENT_DEFENSE_POSID	2
+#define NARROW_EVENT_OFFENSE_POSID	3
+#define NARROW_EVENT_DEBUFF_ID		60001
+
+#define BGIC_EVENT_ID		0
+#define BGIC_EVENT_MAP		628
+#define BGIC_SSS_REWARD_ID	1
+#define BGIC_REWARD_ID		2
+#define BGIC_DISPLAY_MAX	10
+#define BGIC_STOP_KILLS		50
+
+
+struct PosTemplate
+{
+	uint32 map;
+	float x;
+	float y;
+	float z;
+	float o;
+};
+extern std::unordered_map<uint32, PosTemplate> PosMap;
+
+enum GroupTypes
+{
+	C_GT_ONE_ALL,				
+	C_GT_ONE_A,				
+	C_GT_ONE_H,				
+	C_GT_RANDOM_A_H,		
+	C_GT_RANDOM_PLAYER,
+};
+
+enum RejoinTypes
+{
+	C_RT_BANED,
+	C_RT_KEEP_GROUP,
+	C_RT_REDIS_GROUP,
+};
+
+enum EventTypes
+{
+	C_ET_NONE,
+	C_ET_WS,
+	C_ET_AB,
+	C_ET_EY,
+	C_ET_SA,
+	C_ET_AV,
+	C_ET_IC,
+	C_ET_TELE,
+	C_ET_LINE,
+	C_ET_FACTION,
+	C_ET_GUILD,
+	C_ET_SINGLE,
+};
+
+struct EventPhaseFactionTemplate
+{
+	uint8 Phase;
+	uint32 Faction;
+	uint32 GraveyardPos;
+	uint32 GraveyardSafe;
+	uint32 GraveyardHealer;
+	uint32 StopTelePos;
+	uint32 StopPlayerKills;
+	uint32 StopPlayerKilleds;
+	std::string GraveyardSafeNotice;
+	std::string StopNotice;
+};
+
+struct EventPhaseTemplate
+{
+	uint8 Phase;
+	int64 StopGUID;
+};
+
+#define ALT_GUID_MAX 5
+
+struct EventAltTemplate
+{
+	int64 GUID;
+	uint32 AltFlag;
+	std::string NoticeText;
+	int64 TargetEntry[ALT_GUID_MAX];
+	uint32 TargetCount[ALT_GUID_MAX];
+	uint32 TargetKillCount[ALT_GUID_MAX];
+};
+
+struct EventAltFactionTemplate
+{
+	int64 GUID;
+	EventFactionId Faction;
+	uint32 Kills;
+	uint32 Killeds;
+};
+
+struct EventStopTemplate
+{
+	EventFactionId Faction;
+	TypeID StopType;
+	uint32 Param;
+	uint32 Weight;
+};
+
+struct EventKillInfoTemplate
+{
+	uint32 Kills;
+	uint32 Killeds;
+};
+
+#define WORLDSTATE_ENTRY_MAX 3
+
+struct EventWorldStateTemplate
+{
+	uint32 ID;
+	int32 InitValue;
+	int64 Entry[WORLDSTATE_ENTRY_MAX];
+	int32 Step[WORLDSTATE_ENTRY_MAX];
+	int32 NoticeValue;
+	std::string Notice;
+};
+
+struct EventWorldStateFactionTemplate
+{
+	uint32 ID;
+	uint32 Faction;
+	bool Kill;
+	int32 Step;
+	int32 NoticeValue;
+	std::string Notice;
+};
+
+#define MAX_SPAWNNOTICE_COUNT 3
+
+struct EventSpawnTemplate
+{
+	int64 Entry;
+	uint32 Phase;
+	uint32 SpawnTime;
+	uint32 PosId;
+	uint32 Duration;
+	uint32 NoticeTime[MAX_SPAWNNOTICE_COUNT];
+	std::string SpawnNotice[MAX_SPAWNNOTICE_COUNT];
+};
+
+struct EventListTemplate
+{
+	std::string EventName;
+	std::string StartTime;
+	std::string Occurence;
+	std::string Length;
+	EventTypes EventType;
+};
+
+extern std::unordered_map<uint32, EventListTemplate> EventListMap;
+
+class Event
+{
+public:
+	static Event* instance()
+	{
+		static Event instance;
+		return &instance;
+	}
+
+public:
+	void Reset();
+	void InitParams(uint32 eventId);
+	void LoadPos();
+	void Start(uint32 eventId);
+	void Stop(uint32 eventId);
+	bool AcceptInvitation(Player* player, uint32 menuId);
+	bool CanRew(Player* pl);
+	void Update(Map* map, uint32 diff);
+	void UpdateRevive(uint32 diff);
+	void UpdateSafe(uint32 diff);
+	int32 GetWeightLeft(EventFactionId faction);
+	float GetDistance(Player* player, uint32 pos);
+	void Tele(Player* player, uint32 pos);
+	void TeleToGraveyard(Player* player);
+	void ReviveAll(bool start);
+	void StartCall();
+	void RewAndRest();
+	void Join(Player* pl);
+	EventFactionId Subgroup(Player* pl);
+	void Leave(Player* pl);
+	void DieTele(Player* pl);
+	void SafeTele(Player* pl);
+	void UpdateActive(Object* obj, bool kill = false);
+	void UpdatePhase(Object* obj, bool kill = false);
+	void UpdateWorldState(uint32 ID, uint32 value);
+	void InitWorldState();
+	void UpdateWorldState(Object* obj, bool kill = false);
+	void UpdateSpawn(uint32 diff);
+	void Process(Object* obj);
+	uint32 GetFactionMembers(EventFactionId faction);
+	bool DiedTele(Player* player);
+	bool SendAreaSpiritHealerQueryOpcode(Player* player);
+	void AddEventList(Player* player, Object* obj, bool isBG = false);
+	void GetTelePos(uint32 posId, uint32 &map, float &x, float &y, float &z, float &o);
+	bool GobUnk1Check(Unit* target, GameObject *const gob);
+	bool IpCheck(Player* player); 
+	bool IsFixedTimeBgActive(BattlegroundTypeId bgTypeId);
+	int32 GetZoneId(){ return _ZoneId; }
+	void SummonSoulHealer();
+	void SendScreenMessage(std::string text, EventFactionId faction = 0, bool onlydead = false);
+	bool Valid(){ if (_EventId == 0 || _EventType < C_ET_LINE || _EventId == BGIC_EVENT_ID) return false; return true; }
+private:
+	/*_game_event*/
+	uint32 _EventId;
+	std::string _EventName;
+	EventTypes _EventType;
+	GroupTypes _GroupType;
+	RejoinTypes _RejoinType;
+	std::string _NoticeText;
+	std::string _GossipText;
+	int32 _ZoneId;
+	Map* _Map;
+	uint8 _Phase;
+	bool _RandomAH;
+	uint32 _WinRewId;
+	uint32 _LosRewId;
+	uint32 _DamageForRew;
+	uint32 _HealForRew;
+	uint32 _KillsForRew;
+	uint32 _KilledForRew;
+
+	//Start
+	std::unordered_map<EventFactionId, std::string> _FactionNameMap;
+	std::unordered_map<EventFactionId, uint32> _StartPosMap;
+	std::unordered_map<EventFactionId, uint32> _StopPosMap;
+	std::unordered_map<uint32, EventFactionId>_GroupMap;
+	std::vector<EventFactionId> _FactionVec;
+	std::unordered_map<uint32, EventFactionId>_PlayersMap;
+	std::unordered_map<EventFactionId, EventKillInfoTemplate> _KillInfoMap;
+	
+	//Stop
+	std::vector<EventStopTemplate>_StopVec;
+
+	//Alt
+	std::vector<EventAltTemplate>_AltVec;
+	std::vector<EventAltFactionTemplate>_AltFactionVec;
+	std::vector<int64>_AltedVec;
+	
+	//Phase
+	std::vector<EventPhaseFactionTemplate> _PhaseFactionVec;
+	std::vector<EventPhaseTemplate> _PhaseVec;
+	//Healer
+	std::unordered_map<EventFactionId, uint64> _HealerMap;
+
+	//WorldState
+	std::vector<EventWorldStateTemplate> _WorldStateVec;
+	std::vector<EventWorldStateFactionTemplate> _WorldStateFactionVec;
+
+	//Spawn
+	std::vector<EventSpawnTemplate> _SpawnVec;
+	uint32 _UpdateSpawnTimer;
+
+	uint32 _UpdateSafeTimer;
+	uint32 _UpdateReviveTimer;
+	bool _SoulVisual;
+
+	bool _DelayStartCall;
+	bool _DelayStopCall;
+	uint32 _UpdateDelayNotice;
+	EventFactionId _WinFaction;
+public:
+	uint32 GetPhaseGraveyardPos(EventFactionId faction)
+	{
+		for (auto itr = _PhaseFactionVec.begin(); itr != _PhaseFactionVec.end(); itr++)
+			if (itr->Faction == faction && itr->Phase == _Phase)
+				return itr->GraveyardPos;
+
+		return 0;
+	}
+
+	void GetKillInfo(EventFactionId faction, uint32 &Kills, uint32 &Killeds)
+	{
+		auto itr = _KillInfoMap.find(faction);
+		if (itr != _KillInfoMap.end())
+		{
+			Kills = itr->second.Kills;
+			Killeds = itr->second.Killeds;
+		}
+	}
+
+	void UpdateKillInfo(Player* player, bool kill)
+	{
+		auto itr = _KillInfoMap.find(player->GetEventFaction());
+		if (itr != _KillInfoMap.end())
+		{
+			if (kill)
+				itr->second.Kills++;
+			else
+				itr->second.Killeds++;
+		}
+	}
+};
+#define sEvent Event::instance()
diff --git a/src/server/scripts/Custom/CustomEvent/FixedTimeBG/FixedTimeBG.cpp b/src/server/scripts/Custom/CustomEvent/FixedTimeBG/FixedTimeBG.cpp
new file mode 100644
index 0000000..ebe780a
--- /dev/null
+++ b/src/server/scripts/Custom/CustomEvent/FixedTimeBG/FixedTimeBG.cpp
@@ -0,0 +1,230 @@
+#pragma execution_character_set("utf-8")
+#include "FixedTimeBG.h"
+#include "BattlegroundMgr.h"
+#include "Battleground.h"
+#include "../../CommonFunc/CommonFunc.h"
+#include "../Event.h"
+#include "../../DataLoader/DataLoader.h"
+#include "../../Reward/Reward.h"
+#include "../../Requirement/Requirement.h"
+
+std::unordered_map<BattlegroundTypeId, FixedTimeBGTemplate> FixedTimeBGMap;
+
+void FixedTimeBG::Load()
+{
+	FixedTimeBGMap.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//			0		1			2				3			4					5				6					7				8			9		10
+		"SELECT Õ½³¡ÀàÐÍ,Ê¤Àû½±ÀøÄ£°åID, Ê§°Ü½±ÀøÄ£°åID,½áÊø»÷É±ÈËÊý,»ñµÃ½±Àø×îÐ¡»÷É±Êý,»ñµÃ½±Àø×îÐ¡±»É±Êý,»ñµÃ½±Àø×îÐ¡ÉËº¦Öµ,»ñµÃ½±Àø×îÐ¡ÖÎÁÆÖµ,×ÊÔ´»òÆìÖÄ,ÊÇ·ñ¿çÕóÓª,×îµÍÑªÁ¿,"
+		//11				12			13			14			15			16		17
+		"Ëæ»ú¹â»·¼ä¸ôÊ±¼ä, Ëæ»ú¹â»·ID1,Ëæ»ú¹â»·ID2,Ëæ»ú¹â»·ID3,Ëæ»ú¹â»·ID4,Ëæ»ú¹â»·ID5,Õ½³¡Ãû³Æ FROM __Õ½³¡" :
+		//			0		1			2		3		4		5			6		7		8	9	10
+		"SELECT bgTypeId,winRewId, losRewId,endKills,RewKills,RewdKilleds,RewDmg,RewHeal,maxRes,cf,limitHP,"
+		//11					12			13			14			15			16			17
+		"RandomBuffInterval, RandomBuff1,RandomBuff2,RandomBuff3,RandomBuff4,RandomBuff5,bgName FROM _battleground");
+	if (!result)
+	{
+		return;
+	}
+	do
+	{
+		Field* fields = result->Fetch();
+
+		BattlegroundTypeId bgTypeId = BattlegroundTypeId(fields[0].GetUInt32());
+
+		FixedTimeBGTemplate FixedTimeBGTemp;
+		FixedTimeBGTemp.winRewardTemplateId		= fields[1].GetUInt32();
+		FixedTimeBGTemp.loseRewardTemplateId	= fields[2].GetUInt32();
+		FixedTimeBGTemp.killsForEnd				= fields[3].GetUInt32();
+		FixedTimeBGTemp.killsForReward			= fields[4].GetUInt32();
+		FixedTimeBGTemp.killedsForReward		= fields[5].GetUInt32();
+		FixedTimeBGTemp.damageForReward			= fields[6].GetUInt32();
+		FixedTimeBGTemp.healForReward			= fields[7].GetUInt32();
+		FixedTimeBGTemp.resourcesMax			= fields[8].GetUInt32();
+		FixedTimeBGTemp.crossFaction			= fields[9].GetBool();
+		FixedTimeBGTemp.limitHP					= fields[10].GetUInt32();
+		FixedTimeBGTemp.RandomBuffInterval		= fields[11].GetUInt32();
+
+		for (size_t i = 0; i < 5; i++)
+			FixedTimeBGTemp.randomBuffs[i]		= fields[12 + i].GetUInt32();
+
+		FixedTimeBGTemp.bgName					= fields[17].GetString();
+
+		FixedTimeBGMap.insert(std::make_pair(bgTypeId, FixedTimeBGTemp));
+	} while (result->NextRow());
+}
+
+
+uint32 FixedTimeBG::GetLimitHP(BattlegroundTypeId bgTypeId)
+{
+	std::unordered_map<BattlegroundTypeId, FixedTimeBGTemplate>::iterator iter = FixedTimeBGMap.find(bgTypeId);
+
+	if (iter != FixedTimeBGMap.end())
+		return iter->second.limitHP;
+
+	return 0;
+}
+
+uint32 FixedTimeBG::GetMaxRes(BattlegroundTypeId bgTypeId)
+{
+	std::unordered_map<BattlegroundTypeId, FixedTimeBGTemplate>::iterator iter = FixedTimeBGMap.find(bgTypeId);
+
+	if (iter != FixedTimeBGMap.end())
+		return iter->second.resourcesMax;
+
+	return 0;
+}
+bool FixedTimeBG::GetCFFlag(BattlegroundTypeId bgTypeId)
+{
+	std::unordered_map<BattlegroundTypeId, FixedTimeBGTemplate>::iterator iter = FixedTimeBGMap.find(bgTypeId);
+
+	if (iter != FixedTimeBGMap.end())
+		return iter->second.crossFaction;
+
+	return false;
+}
+
+uint32 FixedTimeBG::GetWinRewId(BattlegroundTypeId bgTypeId)
+{
+	std::unordered_map<BattlegroundTypeId, FixedTimeBGTemplate>::iterator iter = FixedTimeBGMap.find(bgTypeId);
+
+	if (iter != FixedTimeBGMap.end())
+		return iter->second.winRewardTemplateId;
+
+	return 0;
+}
+uint32 FixedTimeBG::GetLosRewId(BattlegroundTypeId bgTypeId)
+{
+	std::unordered_map<BattlegroundTypeId, FixedTimeBGTemplate>::iterator iter = FixedTimeBGMap.find(bgTypeId);
+
+	if (iter != FixedTimeBGMap.end())
+		return iter->second.loseRewardTemplateId;
+
+	return 0;
+}
+uint32 FixedTimeBG::GetEndKilss(BattlegroundTypeId bgTypeId)
+{
+	std::unordered_map<BattlegroundTypeId, FixedTimeBGTemplate>::iterator iter = FixedTimeBGMap.find(bgTypeId);
+
+	if (iter != FixedTimeBGMap.end())
+		return iter->second.killsForEnd;
+
+	return 0;
+}
+uint32 FixedTimeBG::GetRewHeal(BattlegroundTypeId bgTypeId)
+{
+	std::unordered_map<BattlegroundTypeId, FixedTimeBGTemplate>::iterator iter = FixedTimeBGMap.find(bgTypeId);
+
+	if (iter != FixedTimeBGMap.end())
+		return iter->second.healForReward;
+
+	return 0;
+}
+uint32 FixedTimeBG::GetRewDmg(BattlegroundTypeId bgTypeId)
+{
+	std::unordered_map<BattlegroundTypeId, FixedTimeBGTemplate>::iterator iter = FixedTimeBGMap.find(bgTypeId);
+
+	if (iter != FixedTimeBGMap.end())
+		return iter->second.damageForReward;
+
+	return 0;
+}
+uint32 FixedTimeBG::GetRewKills(BattlegroundTypeId bgTypeId)
+{
+	std::unordered_map<BattlegroundTypeId, FixedTimeBGTemplate>::iterator iter = FixedTimeBGMap.find(bgTypeId);
+
+	if (iter != FixedTimeBGMap.end())
+		return iter->second.killsForReward;
+
+	return 0;
+}
+uint32 FixedTimeBG::GetRewKilleds(BattlegroundTypeId bgTypeId)
+{
+	std::unordered_map<BattlegroundTypeId, FixedTimeBGTemplate>::iterator iter = FixedTimeBGMap.find(bgTypeId);
+
+	if (iter != FixedTimeBGMap.end())
+		return iter->second.killedsForReward;
+
+	return 0;
+}
+
+void FixedTimeBG::RewardPlayer(Player* player, BattlegroundTypeId bgTypeId, bool win)
+{
+	if (win)
+		sRew->Rew(player, GetWinRewId(bgTypeId));
+	else
+		sRew->Rew(player, GetLosRewId(bgTypeId));
+}
+
+uint32 FixedTimeBG::GetRandomBuffInterval(BattlegroundTypeId bgTypeId)
+{
+	std::unordered_map<BattlegroundTypeId, FixedTimeBGTemplate>::iterator iter = FixedTimeBGMap.find(bgTypeId);
+
+	if (iter != FixedTimeBGMap.end())
+		return iter->second.RandomBuffInterval * IN_MILLISECONDS;
+
+	return 0;
+}
+
+void FixedTimeBG::RemoveRandomBuff(Battleground* bg, Player* player)
+{
+	BattlegroundTypeId bgTypeId = bg->GetBgTypeID();
+
+	std::unordered_map<BattlegroundTypeId, FixedTimeBGTemplate>::iterator iter = FixedTimeBGMap.find(bgTypeId);
+
+	if (iter != FixedTimeBGMap.end())
+		for (size_t i = 0; i < 5; i++)
+			player->RemoveAura(iter->second.randomBuffs[i]);
+}
+
+void FixedTimeBG::AddRandomBuff(Battleground* bg, uint32 diff)
+{
+	bg->RandomBuffInterval -= diff;
+
+	if (bg->RandomBuffInterval <= 0)
+	{
+		BattlegroundTypeId bgTypeId = bg->GetBgTypeID();
+
+		bg->RandomBuffInterval = GetRandomBuffInterval(bgTypeId);
+
+		if (bg->RandomBuffInterval == 0)
+			return;
+
+		std::unordered_map<BattlegroundTypeId, FixedTimeBGTemplate>::iterator iter = FixedTimeBGMap.find(bgTypeId);
+
+		if (iter != FixedTimeBGMap.end())
+		{
+			std::vector<uint32> buffVec;
+
+			for (size_t i = 0; i < 5; i++)
+				if (const SpellInfo* spell = sSpellMgr->GetSpellInfo(iter->second.randomBuffs[i]))
+					buffVec.push_back(iter->second.randomBuffs[i]);
+
+			if (buffVec.empty())
+				return;
+
+			uint32 spellId = buffVec[urand(0, buffVec.size() - 1)];
+
+			std::ostringstream oss;
+
+			if (const SpellInfo* spell = sSpellMgr->GetSpellInfo(spellId))
+				oss << iter->second.bgName << " ËùÓÐÍæ¼Ò»ñµÃËæ»úÐ§¹û " << spell->SpellName[4];
+
+			Battleground::BattlegroundPlayerMap const& pl = bg->GetPlayers();
+			for (Battleground::BattlegroundPlayerMap::const_iterator itr = pl.begin(); itr != pl.end(); ++itr)
+			{
+				Player* player = itr->second;
+
+				if (!player || !player->IsInWorld())
+					continue;
+
+				for (size_t i = 0; i < buffVec.size(); i++)
+					player->RemoveAura(buffVec[i]);
+
+				player->AddAura(spellId, player);
+
+				player->GetSession()->SendNotification(oss.str().c_str());
+			}
+		}
+	}
+}
diff --git a/src/server/scripts/Custom/CustomEvent/FixedTimeBG/FixedTimeBG.h b/src/server/scripts/Custom/CustomEvent/FixedTimeBG/FixedTimeBG.h
new file mode 100644
index 0000000..882691c
--- /dev/null
+++ b/src/server/scripts/Custom/CustomEvent/FixedTimeBG/FixedTimeBG.h
@@ -0,0 +1,49 @@
+////å®æ¶æåº////
+
+#define MAX_BG_RANDOM_BUFFS 5
+
+struct FixedTimeBGTemplate
+{
+	uint32 winRewardTemplateId;
+	uint32 loseRewardTemplateId;
+	uint32 killsForEnd;
+	uint32 healForReward;
+	uint32 damageForReward;
+	uint32 killsForReward;
+	uint32 killedsForReward;
+	uint32 resourcesMax;
+	bool crossFaction;
+	uint32 limitHP;
+	uint32 RandomBuffInterval;
+	uint32 randomBuffs[MAX_BG_RANDOM_BUFFS];
+	std::string bgName;
+};
+extern std::unordered_map<BattlegroundTypeId,FixedTimeBGTemplate> FixedTimeBGMap;
+
+class FixedTimeBG
+{
+public:
+	static FixedTimeBG* instance()
+	{
+		static FixedTimeBG instance;
+		return &instance;
+	}
+	void Load();
+
+	uint32 GetLimitHP(BattlegroundTypeId bgTypeId);
+	uint32 GetMaxRes(BattlegroundTypeId bgTypeId);
+	bool GetCFFlag(BattlegroundTypeId bgTypeId);
+	uint32 GetWinRewId(BattlegroundTypeId bgTypeId);
+	uint32 GetLosRewId(BattlegroundTypeId bgTypeId);
+	uint32 GetEndKilss(BattlegroundTypeId bgTypeId);
+	uint32 GetRewHeal(BattlegroundTypeId bgTypeId);
+	uint32 GetRewDmg(BattlegroundTypeId bgTypeId);
+	uint32 GetRewKills(BattlegroundTypeId bgTypeId);
+	uint32 GetRewKilleds(BattlegroundTypeId bgTypeId);
+	void RewardPlayer(Player* player, BattlegroundTypeId bgTypeId, bool win);
+
+	uint32 GetRandomBuffInterval(BattlegroundTypeId bgTypeId);
+	void AddRandomBuff(Battleground* bg, uint32 diff);
+	void RemoveRandomBuff(Battleground* bg, Player* player);
+};
+#define sFTB FixedTimeBG::instance()
diff --git a/src/server/scripts/Custom/CustomEvent/GurubashiChest/GurubashiChest.cpp b/src/server/scripts/Custom/CustomEvent/GurubashiChest/GurubashiChest.cpp
new file mode 100644
index 0000000..c2ae12e
--- /dev/null
+++ b/src/server/scripts/Custom/CustomEvent/GurubashiChest/GurubashiChest.cpp
@@ -0,0 +1,84 @@
+//eventid 112
+//creature guid 213732
+
+
+#define CHEST_ID 1000000
+
+enum GurubashiEvents
+{
+	EVENT_Gurubashi_NPC_MOVE = 1,
+	EVENT_Gurubashi_NPC_SUMMON_GAMEOBJECT = 2,
+	EVENT_Gurubashi_NPC_MOVE_BACK = 3,
+	EVENT_Gurubashi_DONE = 4,
+};
+
+Position const POS_Gurubashi_NPC[2] =
+{
+	{ -13219.6f, 221.663f, 33.243f, 1.54758f },//³õÊ¼Î»ÖÃ
+	{ -13207.1f, 280.8f, 21.9f, 4.2f },//±¦ÏäË¢ÐÂÎ»ÖÃ
+};
+
+class npc_gurubashi_chest : public CreatureScript
+{
+public:
+	npc_gurubashi_chest() : CreatureScript("npc_gurubashi_chest") { }
+
+	struct npc_gurubashi_chestAI : public ScriptedAI
+	{
+		npc_gurubashi_chestAI(Creature* creature) : ScriptedAI(creature){}
+
+		void Reset() override{}
+		
+		void InitializeAI()
+		{
+			events.ScheduleEvent(EVENT_Gurubashi_NPC_MOVE, 10);
+			events.ScheduleEvent(EVENT_Gurubashi_NPC_SUMMON_GAMEOBJECT, 40000);
+			events.ScheduleEvent(EVENT_Gurubashi_NPC_MOVE_BACK, 45000);
+		}
+
+		void UpdateAI(uint32 diff) override
+		{
+			events.Update(diff);
+	
+			while (uint32 eventId = events.ExecuteEvent())
+			{
+				switch (eventId)
+				{
+				case EVENT_Gurubashi_NPC_MOVE:
+					me->SetWalk(true);
+					me->GetMotionMaster()->MovePoint(1, POS_Gurubashi_NPC[1]);
+					break;
+				case EVENT_Gurubashi_NPC_SUMMON_GAMEOBJECT:
+				{
+					me->CastSpell(me, 37665);
+					uint32 gobCount = urand(50, 50);
+					for (uint32 i = 0; i < gobCount; i++)
+					{
+						if (GameObject* chest = me->SummonGameObject(CHEST_ID, me->GetPositionX() + frand(-20, 20), me->GetPositionY() + frand(-20, 20), me->GetPositionZ(), 0, 0, 0, 0, 0, 10 * 60 * 1000))
+						{
+							chest->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_NOT_SELECTABLE);
+						}
+					}
+
+				}
+				break;
+				case EVENT_Gurubashi_NPC_MOVE_BACK:
+					me->GetMotionMaster()->MovePoint(2, POS_Gurubashi_NPC[0]);
+					break;
+				}
+			}
+		}
+	private:
+		EventMap events;
+	};
+
+	CreatureAI* GetAI(Creature* creature) const
+	{
+		return new npc_gurubashi_chestAI(creature);
+	}
+};
+
+void AddSC_Gurubashi()
+{
+	new npc_gurubashi_chest();
+}
diff --git a/src/server/scripts/Custom/CustomEvent/SACity/SA.h b/src/server/scripts/Custom/CustomEvent/SACity/SA.h
new file mode 100644
index 0000000..f8e1ae8
--- /dev/null
+++ b/src/server/scripts/Custom/CustomEvent/SACity/SA.h
@@ -0,0 +1,17 @@
+ï»¿#define EVENT_ID_SA 80
+
+#define CorpseCreature_ENTRY 50008
+
+class SACity
+{
+public:
+	static SACity* instance()
+	{
+		static SACity instance;
+		return &instance;
+	}
+
+private:
+
+};
+#define sSACity SACity::instance()
diff --git a/src/server/scripts/Custom/CustomEvent/SACity/SAScripts.cpp b/src/server/scripts/Custom/CustomEvent/SACity/SAScripts.cpp
new file mode 100644
index 0000000..4c8c4d7
--- /dev/null
+++ b/src/server/scripts/Custom/CustomEvent/SACity/SAScripts.cpp
@@ -0,0 +1,226 @@
+#pragma execution_character_set("utf-8")
+#include "BattlegroundSA.h"
+#include "SA.h"
+#include "../Event.h"
+
+#define GATE_1_R	450011
+#define GATE_1_L	450013
+#define GATE_2_R	450012
+#define GATE_2_L	450014
+#define GATE_3		450015
+#define MAIN_GATE   192549
+
+const Position SummonPos1 = { 1509.24f, -35.67f, 4.51f, 3.25f };
+const Position SummonPos2 = { 1297.13f, -63.91f, 34.05f, 3.25f };
+const Position SummonPos3 = { 1210.07f, -70.68f, 70.09f, 3.25f };
+
+enum EventsSummon
+{
+	EVENT_SUMMON = 1,
+	EVENT_NOTICE,
+};
+
+class SATrigger : public CreatureScript
+{
+public:
+	SATrigger() : CreatureScript("SATrigger") { }
+	struct SATriggerAI : public CreatureAI
+	{
+		SummonList Summons;
+		EventMap events;
+
+		SATriggerAI(Creature* creature) : CreatureAI(creature), Summons(me)
+		{
+		}
+
+		void Reset() override
+		{
+			Summons.DespawnAll();
+			events.Reset();
+
+			for (uint8 i = 0; i < BG_SA_BOAT_ONE; i++)
+			{
+				if (BG_SA_ObjEntries[i] == 190722)
+					me->SummonGameObject(450011, BG_SA_ObjSpawnlocs[i][0], BG_SA_ObjSpawnlocs[i][1], BG_SA_ObjSpawnlocs[i][2], BG_SA_ObjSpawnlocs[i][3], 0, 0, 0, 0, 0);
+				else if (BG_SA_ObjEntries[i] == 190723)
+					me->SummonGameObject(450012, BG_SA_ObjSpawnlocs[i][0], BG_SA_ObjSpawnlocs[i][1], BG_SA_ObjSpawnlocs[i][2], BG_SA_ObjSpawnlocs[i][3], 0, 0, 0, 0, 0);
+				else if (BG_SA_ObjEntries[i] == 190724)
+					me->SummonGameObject(450013, BG_SA_ObjSpawnlocs[i][0], BG_SA_ObjSpawnlocs[i][1], BG_SA_ObjSpawnlocs[i][2], BG_SA_ObjSpawnlocs[i][3], 0, 0, 0, 0, 0);
+				else if (BG_SA_ObjEntries[i] == 190726)
+					me->SummonGameObject(450014, BG_SA_ObjSpawnlocs[i][0], BG_SA_ObjSpawnlocs[i][1], BG_SA_ObjSpawnlocs[i][2], BG_SA_ObjSpawnlocs[i][3], 0, 0, 0, 0, 0);
+				else if (BG_SA_ObjEntries[i] == 190727)
+					me->SummonGameObject(450015, BG_SA_ObjSpawnlocs[i][0], BG_SA_ObjSpawnlocs[i][1], BG_SA_ObjSpawnlocs[i][2], BG_SA_ObjSpawnlocs[i][3], 0, 0, 0, 0, 0);
+				else
+					me->SummonGameObject(BG_SA_ObjEntries[i], BG_SA_ObjSpawnlocs[i][0], BG_SA_ObjSpawnlocs[i][1], BG_SA_ObjSpawnlocs[i][2], BG_SA_ObjSpawnlocs[i][3], 0, 0, 0, 0, 0);
+
+
+			}
+			for (uint8 i = BG_SA_PORTAL_DEFFENDER_BLUE; i < BG_SA_BOMB; i++)
+				me->SummonGameObject(BG_SA_ObjEntries[i], BG_SA_ObjSpawnlocs[i][0], BG_SA_ObjSpawnlocs[i][1], BG_SA_ObjSpawnlocs[i][2], BG_SA_ObjSpawnlocs[i][3], 0, 0, 0, 0, 0);
+			for (uint8 i = 0; i < BG_SA_DEMOLISHER_5; i++)
+				me->SummonCreature(BG_SA_NpcEntries[i], BG_SA_NpcSpawnlocs[i][0], BG_SA_NpcSpawnlocs[i][1], BG_SA_NpcSpawnlocs[i][2], BG_SA_NpcSpawnlocs[i][3], TEMPSUMMON_TIMED_DESPAWN, 30 * MINUTE * IN_MILLISECONDS);
+
+			events.ScheduleEvent(EVENT_SUMMON, 150 * IN_MILLISECONDS);
+			events.ScheduleEvent(EVENT_NOTICE, 30 * IN_MILLISECONDS);
+		}
+
+		void SummonCorpseCreature()
+		{
+			GameObject* gate_1_r = me->FindNearestGameObject(GATE_1_R, 1000.0f);
+			GameObject* gate_1_l = me->FindNearestGameObject(GATE_1_L, 1000.0f);
+			GameObject* gate_2_r = me->FindNearestGameObject(GATE_2_R, 1000.0f);
+			GameObject* gate_2_l = me->FindNearestGameObject(GATE_2_L, 1000.0f);
+			GameObject* gate_3 = me->FindNearestGameObject(GATE_3, 1000.0f);
+
+			if (!gate_1_r || !gate_1_l || !gate_2_r || !gate_2_l || !gate_3)
+				return;
+	
+
+			if (gate_1_r->GetDestructibleState() != GO_DESTRUCTIBLE_DESTROYED || gate_1_l->GetDestructibleState() != GO_DESTRUCTIBLE_DESTROYED)
+			{
+				if (Creature* summon = me->SummonCreature(CorpseCreature_ENTRY, SummonPos1, TEMPSUMMON_TIMED_DESPAWN, 10 * MINUTE * IN_MILLISECONDS))
+					summon->AI()->DoAction(1);
+			}
+				
+			else if (gate_2_r->GetDestructibleState() != GO_DESTRUCTIBLE_DESTROYED || gate_2_l->GetDestructibleState() != GO_DESTRUCTIBLE_DESTROYED)
+			{
+				if (Creature* summon = me->SummonCreature(CorpseCreature_ENTRY, SummonPos2, TEMPSUMMON_TIMED_DESPAWN, 10 * MINUTE * IN_MILLISECONDS))
+					summon->AI()->DoAction(2);
+			}
+			else if (gate_3->GetDestructibleState() != GO_DESTRUCTIBLE_DESTROYED)
+			{
+				if (Creature* summon = me->SummonCreature(CorpseCreature_ENTRY, SummonPos3, TEMPSUMMON_TIMED_DESPAWN, 10 * MINUTE * IN_MILLISECONDS))
+					summon->AI()->DoAction(3);
+			}
+		}
+
+		void JustSummoned(Creature* summon) override
+		{
+			summon->SetReactState(REACT_PASSIVE);
+			Summons.Summon(summon);
+		}
+
+		void SummonedCreatureDies(Creature* summon, Unit*) override
+		{
+			Summons.Despawn(summon);
+		}
+
+		void UpdateAI(uint32 diff) override
+		{
+			events.Update(diff);
+			switch (events.ExecuteEvent())
+			{
+			case EVENT_SUMMON:
+				if (Creature* corpse = me->FindNearestCreature(CorpseCreature_ENTRY, 5.0f))
+				{
+					Summons.DespawnAll();
+					sGameEventMgr->StopEvent(EVENT_ID_SA,false,false);
+					break;
+				}
+				if (sGameEventMgr->IsActiveEvent(EVENT_ID_SA))
+					SummonCorpseCreature();
+				events.ScheduleEvent(EVENT_SUMMON, 1000);
+				break;
+			case EVENT_NOTICE:
+			{
+				std::ostringstream oss;
+				oss <<  "[½©Ê¬Î§³Ç]½©Ê¬Á½·ÖÖÓºó³öÏÖ£¬Çë×öºÃ×¼±¸£¡";
+				sWorld->SendScreenMessage(oss.str().c_str());
+			}
+			break;
+			default:
+				break;
+			}
+		}
+	};
+
+	CreatureAI* GetAI(Creature* creature) const override
+	{
+		return new SATriggerAI(creature);
+	}
+};
+
+
+enum EventsCorpseCreature
+{
+	EVENT_CHECK_DISTANCE = 1,
+};
+
+class CorpseCreature : public CreatureScript
+{
+public:
+	CorpseCreature() : CreatureScript("CorpseCreature") { }
+	struct CorpseCreatureAI : public CreatureAI
+	{
+		SummonList Summons;
+		EventMap events;
+		CorpseCreatureAI(Creature* creature) : CreatureAI(creature), Summons(me)
+		{
+		}
+
+		void Reset() override
+		{
+			events.Reset();
+			events.ScheduleEvent(EVENT_CHECK_DISTANCE, 0);
+		}
+		
+		void LoadPath(uint32 path_id)
+		{
+			me->LoadPath(path_id);
+			me->SetDefaultMovementType(WAYPOINT_MOTION_TYPE);
+			me->GetMotionMaster()->Initialize();
+		}
+
+		void DoAction(int32 param) override
+		{
+			switch (param)
+			{
+			case 1:
+				LoadPath(urand(1, 6));
+				break;
+			case 2:
+				LoadPath(urand(7, 8));
+				break;
+			case 3:
+				LoadPath(9);
+				break;
+			default:
+				break;
+			}
+		}
+
+		void UpdateAI(uint32 diff) override
+		{
+			events.Update(diff);
+			switch (events.ExecuteEvent())
+			{
+			case EVENT_CHECK_DISTANCE:
+				if (GameObject* gate = me->FindNearestGameObjectOfType(GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING, 5.0f))
+				{
+					if (gate->GetDestructibleState() != GO_DESTRUCTIBLE_DESTROYED)
+					{
+						me->CastSpell(gate, 5555,true);
+						DoCast(64228);
+						me->setDeathState(JUST_DIED, true);
+					}			
+				}
+				events.ScheduleEvent(EVENT_CHECK_DISTANCE, 1000);
+				break;
+			default:
+				break;
+			}
+		}
+	};
+
+	CreatureAI* GetAI(Creature* creature) const override
+	{
+		return new CorpseCreatureAI(creature);
+	}
+};
+
+
+void AddSC_SATrigger()
+{
+	new SATrigger();
+	new CorpseCreature();
+}
diff --git a/src/server/scripts/Custom/CustomEvent/ThunderbluffBattle/ThunderbluffBattle.cpp b/src/server/scripts/Custom/CustomEvent/ThunderbluffBattle/ThunderbluffBattle.cpp
new file mode 100644
index 0000000..674eafd
--- /dev/null
+++ b/src/server/scripts/Custom/CustomEvent/ThunderbluffBattle/ThunderbluffBattle.cpp
@@ -0,0 +1,339 @@
+//#pragma execution_character_set("utf-8")
+//#include "ThunderbluffBattle.h"
+//#include "../CustomEvent/Event.h"
+//#include "../Reward/Reward.h"
+//
+//MotionTransport* gunship	= NULL;
+//
+//bool isGeneral_1_Alive		= true;
+//bool isGeneral_2_Alive		= true;
+//bool isGeneral_3_Alive		= true;
+//bool isBaine_Alive			= true;
+//std::list<GameObject*> ThunderbluffGobList;
+//std::list<Creature*> ThunderbluffCreatureList;
+//int32 gunshipHP = 0;
+//
+//
+//void ThunderbluffBattle::Init(Creature* controller)
+//{
+//	DelAllCreatures();
+//	DelAllGameObjects();
+//
+//	SetPhase(PHASE_ZERO);
+//
+//	gunshipHP = GunShipHP;
+//
+//	isGeneral_1_Alive		= true;
+//	isGeneral_2_Alive		= true;
+//	isGeneral_3_Alive		= true;
+//	isBaine_Alive			= true;
+//
+//	////////////controller å¬å¤////////////
+//	//é£è
+//	gunship = sTransportMgr->CreateTransport(GO_GUNSHIP, 0, controller->GetMap());
+//	if (gunship)
+//		ThunderbluffGobList.push_back(gunship);
+//	//ä¼ éå¨
+//	for (size_t i = 0; i < 4; i++)
+//	{
+//		if (GameObject* portal = controller->SummonGameObject(GO_PORTAL_HIGHLAND, HighLandPortalPos[i].GetPositionX(), HighLandPortalPos[i].GetPositionY(), HighLandPortalPos[i].GetPositionZ(), HighLandPortalPos[i].GetOrientation(), 0, 0, 0, 0, 0))
+//			ThunderbluffGobList.push_back(portal);
+//	}
+//
+//	//é±¼åç®å°åè§¦åå¨
+//	for (size_t i = 0; i < 15; i++)
+//	{
+//		if (GameObject* harppon = controller->SummonGameObject(GO_HARPOON, HarpoonPos[i].GetPositionX(), HarpoonPos[i].GetPositionY(), HarpoonPos[i].GetPositionZ(), HarpoonPos[i].GetOrientation(), 0, 0, 0, 0, 0))
+//			ThunderbluffGobList.push_back(harppon);
+//
+//		controller->SummonCreature(NPC_HAROON_TRIGGER, HarpoonPos[i]);
+//	}
+//
+//	//å¢å°
+//	for (size_t i = 0; i < 4; i++)
+//	{
+//		if (Creature* defenseHealer = controller->SummonCreature(NPC_SPIRITHEALER, DefenseHealerPos[i]))
+//			defenseHealer->setFaction(DEFENSE_FACTION);
+//	}
+//	//ä¼ éè§¦åå¨
+//	for (size_t i = 0; i < 10; i++)
+//		controller->SummonCreature(NPC_TELE_TRIGGER, TeleTriggerPos[i]);
+//	//çå¤´äººå°å
+//	controller->SummonCreature(NPC_GENERAL_1, GeneralPos[0]);
+//	controller->SummonCreature(NPC_GENERAL_2, GeneralPos[1]);
+//	controller->SummonCreature(NPC_GENERAL_3, GeneralPos[2]);
+//	controller->SummonCreature(NPC_BAINE, BainePos);
+//
+//
+//
+//	////////////é£è å¬å¤////////////
+//	//å¢å°
+//	if (Creature* offenseHealer = AddCreatureToShip(NPC_SPIRITHEALER, OffenseHealerPos.GetPositionX(), OffenseHealerPos.GetPositionY(), OffenseHealerPos.GetPositionZ(), OffenseHealerPos.GetOrientation(), gunship))
+//		offenseHealer->setFaction(OFFENSE_FACTION);
+//	//ä¼ éå¨
+//	AddGameObjectToShip(GO_PORTAL_SHIP, GunShipPortalPos.GetPositionX(), GunShipPortalPos.GetPositionY(), GunShipPortalPos.GetPositionZ(), GunShipPortalPos.GetOrientation(), gunship);
+//		
+//	//é£è¹å¤å£³
+//	if (Creature* gunshipShell = AddCreatureToShip(NPC_GUNSHIP_SHELL, OffenseHealerPos.GetPositionX(), OffenseHealerPos.GetPositionY(), OffenseHealerPos.GetPositionZ(), OffenseHealerPos.GetOrientation(), gunship))
+//		gunshipShell->setFaction(OFFENSE_FACTION);
+//
+//	//é£æº
+//	for (size_t i = 0; i < 7; i++)
+//	{
+//		AddCreatureToShip(NPC_VEHICLE_AIR, GunshipAirVehicle[i].GetPositionX(), GunshipAirVehicle[i].GetPositionY(), GunshipAirVehicle[i].GetPositionZ(), GunshipAirVehicle[i].GetOrientation(), gunship);
+//	}
+//}
+//
+//void ThunderbluffBattle::Stop()
+//{
+//	DelAllCreatures();
+//	DelAllGameObjects();
+//
+//	//å¥å±ç©å®¶
+//
+//	if (isBaine_Alive)
+//		sThunderbluffBattle->RewardByCreature(NPC_BAINE, false);
+//}
+//
+//
+//void ThunderbluffBattle::RewardByCreature(uint32 entry, bool kill)
+//{
+//	uint32 ThunderbluffBattleRewSettingId = 0;
+//
+//	switch (entry)
+//	{
+//	case NPC_GENERAL_1:
+//		ThunderbluffBattleRewSettingId = RewSettingId_General_1;
+//		break;
+//	case NPC_GENERAL_2:
+//		ThunderbluffBattleRewSettingId = RewSettingId_General_2;
+//		break;
+//	case NPC_GENERAL_3:
+//		ThunderbluffBattleRewSettingId = RewSettingId_General_3;
+//		break;
+//	case NPC_BAINE:
+//		ThunderbluffBattleRewSettingId = RewSettingId_Baine;
+//		break;
+//	default:
+//		break;
+//	}
+//
+//	if (ThunderbluffBattleRewSettingId == 0)
+//		return;
+//
+//	uint32 killsForRew = 0;
+//	uint32 killedsForRew = 0;
+//	float damageForRew = 0;
+//	float healForRew = 0;
+//	uint32 winRewId = 0;
+//	uint32 losRewId = 0;
+//
+//	for (std::vector<EventRewTemplate>::iterator itr = EventRewVec.begin(); itr != EventRewVec.end(); ++itr)
+//	{
+//		if (itr->eventId == ThunderbluffBattleRewSettingId)
+//		{
+//			killsForRew = itr->killsForRew;
+//			killedsForRew = itr->killedsForRew;
+//			damageForRew = itr->damageForRew;
+//			healForRew = itr->healForRew;
+//			winRewId = itr->winRewId;
+//			losRewId = itr->losRewId;
+//			break;
+//		}
+//	}
+//
+//	SessionMap const& smap = sWorld->GetAllSessions();
+//	for (SessionMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+//		if (Player* pl = iter->second->GetPlayer())
+//		{
+//			if (pl->event_team == EVENT_TEAM_NONE)
+//				continue;
+//
+//			if (pl->event_kills >= killsForRew || pl->event_killeds >= killedsForRew
+//				|| pl->event_damage >= damageForRew || pl->event_heal >= healForRew)
+//			{
+//				if (kill)
+//					pl->event_team == EVENT_TEAM_OFFENSE ? sRew->Rew(pl, winRewId) : sRew->Rew(pl, losRewId);
+//				else
+//					pl->event_team == EVENT_TEAM_DEFENSE ? sRew->Rew(pl, winRewId) : sRew->Rew(pl, losRewId);
+//
+//				pl->event_kills		= 0;
+//				pl->event_killeds	= 0;
+//				pl->event_damage	= 0;
+//				pl->event_heal		= 0;
+//			}
+//		}
+//
+//}
+//
+//
+//Creature* ThunderbluffBattle::AddCreatureToShip(uint32 entry, float x, float y, float z, float o, MotionTransport* transport)
+//{
+//	Map* map = transport->GetMap();
+//	if (!map)
+//		return NULL;
+//
+//	if (transport)
+//	{
+//		transport->CalculatePassengerPosition(x, y, z, &o);
+//		if (Creature* creature = transport->SummonCreature(entry, x, y, z, o, TEMPSUMMON_MANUAL_DESPAWN))
+//		{
+//			ThunderbluffCreatureList.push_back(creature);
+//			transport->AddPassenger(creature, true);
+//			return creature;
+//		}	
+//	}
+//
+//	return NULL;
+//}
+//
+//GameObject* ThunderbluffBattle::AddGameObjectToShip(uint32 entry, float x, float y, float z, float o, MotionTransport* transport)
+//{
+//	Map* map = transport->GetMap();
+//	if (!map)
+//		return NULL;
+//
+//	if (transport)
+//	{
+//		transport->CalculatePassengerPosition(x, y, z, &o);
+//		if (GameObject* gob = transport->SummonGameObject(entry, x, y, z, o, 0, 0, 0, 0, 0))
+//		{
+//			ThunderbluffGobList.push_back(gob);
+//			transport->AddPassenger(gob, true);
+//			return gob;
+//		}
+//	}
+//
+//	return NULL;
+//}
+//
+//void ThunderbluffBattle::TeleAllPlayers()
+//{
+//	SessionMap const& smap = sWorld->GetAllSessions();
+//	for (SessionMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+//		if (Player* pl = iter->second->GetPlayer())
+//			if (pl->event_team == EVENT_TEAM_OFFENSE)
+//				TelePlayerToShip(pl, gunship);
+//			else if (pl->event_team == EVENT_TEAM_DEFENSE)
+//				TelePlayerToHighLand(pl);
+//}
+//
+//
+//void ThunderbluffBattle::TelePlayerToShip(Player* player, MotionTransport* transport)
+//{
+//	if (!transport)
+//		return;
+//
+//	float x = GunShipPortalPos.GetPositionX();
+//	float y = GunShipPortalPos.GetPositionY();
+//	float z = GunShipPortalPos.GetPositionZ();
+//	float o = GunShipPortalPos.GetOrientation();
+//
+//	transport->CalculatePassengerPosition(x, y, z);
+//	player->TeleportTo(transport->GetMapId(), x, y, z, o, TELE_TO_NOT_LEAVE_TRANSPORT);
+//}
+//
+//void ThunderbluffBattle::TelePlayerToHighLand(Player* player)
+//{	
+//	switch (GetPhase())
+//	{
+//	case PHASE_ZERO:
+//	case PHASE_ONE:
+//		player->TeleportTo(1, HighLandPortalPos[0].GetPositionX(), HighLandPortalPos[0].GetPositionY(), HighLandPortalPos[0].GetPositionZ(), HighLandPortalPos[0].GetOrientation());
+//		break;
+//	case PHASE_TWO:
+//		player->TeleportTo(1, HighLandPortalPos[1].GetPositionX(), HighLandPortalPos[1].GetPositionY(), HighLandPortalPos[1].GetPositionZ(), HighLandPortalPos[1].GetOrientation());
+//		break;
+//	case PHASE_THREE:
+//		player->TeleportTo(1, HighLandPortalPos[2].GetPositionX(), HighLandPortalPos[2].GetPositionY(), HighLandPortalPos[2].GetPositionZ(), HighLandPortalPos[2].GetOrientation());
+//		break;
+//	case PHASE_FINAL:
+//		player->TeleportTo(1, HighLandPortalPos[3].GetPositionX(), HighLandPortalPos[3].GetPositionY(), HighLandPortalPos[3].GetPositionZ(), HighLandPortalPos[3].GetOrientation());
+//		break;
+//	default:
+//		break;
+//	}
+//}
+//
+//void ThunderbluffBattle::TelePlayerToShipHS(Player* player, MotionTransport* transport)
+//{
+//	if (!transport)
+//		return;
+//
+//	float x = OffenseHealerPos.GetPositionX();
+//	float y = OffenseHealerPos.GetPositionY();
+//	float z = OffenseHealerPos.GetPositionZ();
+//	float o = OffenseHealerPos.GetOrientation();
+//
+//	transport->CalculatePassengerPosition(x, y, z);
+//	player->TeleportTo(transport->GetMapId(), x, y, z, o, TELE_TO_NOT_LEAVE_TRANSPORT);
+//}
+//
+//void ThunderbluffBattle::TelePlayerToHighLandHS(Player* player)
+//{
+//	switch (GetPhase())
+//	{
+//	case PHASE_ZERO:
+//	case PHASE_ONE:
+//		player->TeleportTo(1, DefenseHealerPos[0].GetPositionX(), DefenseHealerPos[0].GetPositionY(), DefenseHealerPos[0].GetPositionZ(), DefenseHealerPos[0].GetOrientation());
+//		break;
+//	case PHASE_TWO:
+//		player->TeleportTo(1, DefenseHealerPos[1].GetPositionX(), DefenseHealerPos[1].GetPositionY(), DefenseHealerPos[1].GetPositionZ(), DefenseHealerPos[1].GetOrientation());
+//		break;
+//	case PHASE_THREE:
+//		player->TeleportTo(1, DefenseHealerPos[2].GetPositionX(), DefenseHealerPos[2].GetPositionY(), DefenseHealerPos[2].GetPositionZ(), DefenseHealerPos[2].GetOrientation());
+//		break;
+//	case PHASE_FINAL:
+//		player->TeleportTo(1, DefenseHealerPos[3].GetPositionX(), DefenseHealerPos[3].GetPositionY(), DefenseHealerPos[3].GetPositionZ(), DefenseHealerPos[3].GetOrientation());
+//		break;
+//	default:
+//		break;
+//	}
+//}
+//
+//bool ThunderbluffBattle::DiedTele(Player* player)
+//{
+//	if (player->event_team == EVENT_TEAM_NONE)
+//		return false;
+//
+//	if (player->IsInCombat())
+//		return false;
+//
+//	player->event_team == EVENT_TEAM_OFFENSE ? TelePlayerToShipHS(player, gunship) : TelePlayerToHighLandHS(player);
+//	return true;
+//}
+//
+//void ThunderbluffBattle::JoinTele(Player* player)
+//{
+//	player->event_team == EVENT_TEAM_OFFENSE ? TelePlayerToShipHS(player, gunship) : TelePlayerToHighLand(player);
+//}
+//
+//void ThunderbluffBattle::DelAllGameObjects()
+//{
+//	for (std::list<GameObject*>::const_iterator itr = ThunderbluffGobList.begin(); itr != ThunderbluffGobList.end(); ++itr)
+//		if ((*itr) && (*itr)->IsInWorld())
+//		{
+//			(*itr)->CleanupsBeforeDelete();
+//			(*itr)->Delete();
+//		}
+//			
+//	ThunderbluffGobList.clear();
+//	gunship = NULL;
+//}
+//
+//void ThunderbluffBattle::DelAllCreatures()
+//{
+//	for (std::list<Creature*>::const_iterator itr = ThunderbluffCreatureList.begin(); itr != ThunderbluffCreatureList.end(); ++itr)
+//		if ((*itr) && (*itr)->IsInWorld())
+//			(*itr)->RemoveFromWorld();
+//
+//	ThunderbluffCreatureList.clear();
+//}
+//
+//void ThunderbluffBattle::SetWorldState(WorldStatesGeneral type, uint32 value)
+//{
+//	SessionMap const& smap = sWorld->GetAllSessions();
+//	for (SessionMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+//		if (Player* pl = iter->second->GetPlayer())
+//				pl->SendUpdateWorldState(type, value);
+//}
diff --git a/src/server/scripts/Custom/CustomEvent/ThunderbluffBattle/ThunderbluffBattle.h b/src/server/scripts/Custom/CustomEvent/ThunderbluffBattle/ThunderbluffBattle.h
new file mode 100644
index 0000000..defe23f
--- /dev/null
+++ b/src/server/scripts/Custom/CustomEvent/ThunderbluffBattle/ThunderbluffBattle.h
@@ -0,0 +1,199 @@
+#include "Transport.h"
+#include "TransportMgr.h"
+
+#define EVENT_THUDERBLUFF_BATTLE_ID  101
+
+const uint32 GunShipHP = 10000;
+const uint32 DmgPerThrow = 1000;
+
+//½×¶ÎÑÓ³ÙÊ±¼ä
+const uint32 TIME_PHASE_ONE_DELAY = 260 * IN_MILLISECONDS; //3·ÖµÈÈË Í¾ÖÐ2·Ö
+const uint32 TIME_PHASE_TWO_DELAY = 610 * IN_MILLISECONDS;//
+const uint32 TIME_PHASE_THREE_DELAY = 1000 * IN_MILLISECONDS;
+const uint32 TIME_PHASE_FINAL_DELAY =  1400 * IN_MILLISECONDS;
+
+//RewSettingId
+const uint32 RewSettingId_General_1 = 10001;
+const uint32 RewSettingId_General_2 = 10002;
+const uint32 RewSettingId_General_3 = 10003;
+const uint32 RewSettingId_Baine = 10004;
+
+extern MotionTransport* gunship;
+extern bool isGeneral_1_Alive;
+extern bool isGeneral_2_Alive;
+extern bool isGeneral_3_Alive;
+extern bool isBaine_Alive;
+extern std::list<GameObject*> ThunderbluffGobList;
+extern std::list<Creature*> ThunderbluffCreatureList;
+
+extern int32 gunshipHP;
+
+enum PhaseIds
+{
+	PHASE_ZERO,
+	PHASE_ONE,
+	PHASE_TWO,
+	PHASE_THREE,
+	PHASE_FINAL,
+};
+
+enum ThuderbluffBattleEvents
+{
+	EVENT_PHASE_ONE = 1,
+	EVENT_PHASE_TWO,
+	EVENT_PHASE_THREE,
+	EVENT_PHASE_FINAL,
+	EVENT_TIMER,
+};
+
+
+enum GameObjectIds
+{
+	GO_GUNSHIP				= 450000,
+	GO_PORTAL_SHIP			= 450001,
+	GO_PORTAL_HIGHLAND		= 450002,
+
+	GO_HARPOON				= 192177,
+};
+enum NPCIds
+{
+	NPC_CONTROLLER		= 60035,
+	NPC_SPIRITHEALER	= 60036,
+	NPC_TELE_TRIGGER	= 60037,
+	NPC_BAINE			= 60038,
+	NPC_GENERAL_1		= 60039,
+	NPC_GENERAL_2		= 60040,
+	NPC_GENERAL_3		= 60041,
+
+	NPC_VEHICLE_AIR		= 60042,
+	NPC_GUNSHIP_SHELL	= 60043,
+
+	NPC_HAROON_TRIGGER	= 60044,
+};
+
+
+enum WorldStatesGeneral
+{
+	WORLD_STATE_GENERAL_1 = 10001,
+	WORLD_STATE_GENERAL_2 = 10002,
+	WORLD_STATE_GENERAL_3 = 10003,
+};
+
+const Position GunshipAirVehicle[7] =
+{
+	{ 36.8f, -4.51f, 40.0f, 3.0f },
+	{ 50.3f, -4.51f, 40.0f, 3.0f },
+	{ 36.8f, 4.510f, 40.0f, 3.0f },
+	{ 50.3f, 4.510f, 40.0f, 3.0f },
+	{ 40.0f, -40.0f, 25.0f, 3.0f},
+	{ 40.0f, 40.00f, 25.0f, 3.0f },
+	{ 57.0f, 0.000f, 0.00f, 3.0f },
+};
+
+//·ÉÍ§´«ËÍÆ÷×ø±ê
+const Position GunShipPortalPos = { 0.00f, 0.00f, 23.00f, 3.00f };
+
+//¸ßµØ´«ËÍ×ø±ê
+const Position HighLandPortalPos[4] =
+{
+	{ -1452.05f, -36.7138f, 157.544f, 2.35053f },
+	{ -985.234f, 324.765f, 135.224f, 2.15026f },
+	{ -1045.02f, -323.711f, 159.03f, 5.6335f },
+	{ -1204.1f, -5.01502f, 165.478f, 4.63998f },
+};
+
+//½ø¹¥·½Ä¹µØ×ø±ê
+const Position OffenseHealerPos = { -43.86f, 0.00f, 20.54f, 7.22f };
+
+//·ÀÊØ·½Ä¹×ø±ê
+const Position DefenseHealerPos[4] =
+{
+	{ -1404.47f, -142.373f, 159.254f, 1.42121f },
+	{ -972.524f, 213.953f, 136.038f, 2.17912f },
+	{ -1088.48f, -226.345f, 159.312f, 0.706521f },
+	{ -1201.31f, 7.16812f, 165.2f, 4.37433f },
+};
+
+//Å£Í·ÈË½«¾ü×ø±ê
+const Position GeneralPos[3] =
+{
+	{ -1405.0f, -77.5565f, 158.935f, 5.12808f },
+	{ -1008.41f, 236.936f, 135.337f, 4.18792f },
+	{ -1058.64f, -233.276f, 159.03f, 1.72963f },
+};
+
+const Position BainePos = { -1209.63f, -100.15f, 162.667f, 1.50761f };
+
+//´«ËÍ´¥·¢Æ÷×ø±ê ·ÀÖ¹½ø¹¥·½Íµboss
+const Position TeleTriggerPos[10] =
+{
+	{-1073.95f	,155.010f	,139.461f	,4.151f	},
+	{-1070.80f	,-121.341f	,151.762f	,0.495f	},
+	{-1353.51f	,-8.665f	,141.483f	,0.904f	},
+	{-1341.23f	,-128.383f	,159.822f	,6.032f	},
+	{-1111.61f	,-161.215f	,162.052f	,0.444f	},
+	{-1126.04f	,195.709f	,120.951f	,0.456f	},
+	{-1307.92f	,179.078f	,129.994f	,5.047f	},
+	{-1285.01f	,184.123f	,129.994f	,4.587f	},
+	{-1033.77f	,-25.413f	,140.694f	,2.910f	},
+	{-1042.93f	,-47.504f	,140.694f	,2.286f	},
+};
+
+const Position HarpoonPos[15] =
+{
+	{ -1095.32f, -263.754f, 159.416f, 2.584f },
+	{ -1081.52f, -328.406f, 159.955f, 3.637f },
+	{ -1019.38f, -322.878f, 159.267f, 5.066f },
+	{ -1004.02f, -267.671f, 159.283f, 0.032f },
+	{ -1036.11f, -204.550f, 160.116f, 0.813f },
+	{ -975.746f, 192.4350f, 136.380f, 4.964f },
+	{ -935.655f, 247.7420f, 135.746f, 5.686f },
+	{ -954.889f, 295.9860f, 135.592f, 0.762f },
+	{ -1030.06f, 294.4780f, 135.745f, 2.309f },
+	{ -1042.90f, 234.7220f, 134.700f, 2.949f },
+	{ -1485.66f, -107.560f, 158.935f, 3.966f },
+	{ -1438.70f, -33.1325f, 157.327f, 1.794f },
+	{ -1405.68f, -160.389f, 158.935f, 4.260f },
+	{ -1375.76f, -114.850f, 158.935f, 5.709f },
+	{ -1374.20f, -58.6768f, 158.898f, 0.671f },
+};
+
+class ThunderbluffBattle
+{
+public:
+	static ThunderbluffBattle* instance()
+	{
+		static ThunderbluffBattle instance;
+		return &instance;
+	}
+
+	void Init(Creature* controller);
+	void Stop();
+
+
+	Creature* AddCreatureToShip(uint32 entry, float x, float y, float z, float o, MotionTransport* transport);
+	GameObject* AddGameObjectToShip(uint32 entry, float x, float y, float z, float o, MotionTransport* transport);
+
+	void DelAllCreatures();
+	void DelAllGameObjects();
+
+	void RewardByCreature(uint32 entry, bool kill);
+
+	void TeleAllPlayers();
+	void TelePlayerToShip(Player* player, MotionTransport* transport);
+	void TelePlayerToShipHS(Player* player, MotionTransport* transport);
+	void TelePlayerToHighLand(Player* player);
+	void TelePlayerToHighLandHS(Player* player);
+
+	void JoinTele(Player* player);
+	bool DiedTele(Player* player);
+
+	void SetPhase(PhaseIds phase){ m_curPahse = phase; }
+	PhaseIds GetPhase(){ return m_curPahse; }
+
+	void SetWorldState(WorldStatesGeneral type, uint32 value);
+
+private:
+	PhaseIds m_curPahse;
+};
+#define sThunderbluffBattle ThunderbluffBattle::instance()
diff --git a/src/server/scripts/Custom/CustomEvent/ThunderbluffBattle/ThunderbluffBattleScripts.cpp b/src/server/scripts/Custom/CustomEvent/ThunderbluffBattle/ThunderbluffBattleScripts.cpp
new file mode 100644
index 0000000..7e1f5c6
--- /dev/null
+++ b/src/server/scripts/Custom/CustomEvent/ThunderbluffBattle/ThunderbluffBattleScripts.cpp
@@ -0,0 +1,626 @@
+//#pragma execution_character_set("utf-8")
+//#include "ThunderbluffBattle.h"
+//#include "../CustomEvent/Event.h"
+//#include "Vehicle.h"
+//
+//enum SpellIds
+//{
+//	SPELL_TELE_DEBUFF = 54643,
+//
+//	//Å£Í·ÊØÎÀ
+//	SPELL_THROW_FIRE = 250000,
+//	SPELL_THROW_WIND = 250001,
+//
+//	SPELL_dianran = 250002,
+//	SPELL_CHARGE = 40497,
+//	SPELL_huimiedaji = 250003,
+//	SPELL_HEAL = 250004,
+//};
+//
+//
+//
+//class ThunderbluffController : public CreatureScript
+//{
+//public:
+//	ThunderbluffController() : CreatureScript("ThunderbluffController") { }
+//	struct ThunderbluffControllerAI : public ScriptedAI
+//	{
+//		ThunderbluffControllerAI(Creature* creature) : ScriptedAI(creature), Summons(me){}
+//		SummonList Summons;
+//		uint32 TimerMinuteCount;
+//
+//		void InitializeAI() override
+//		{ 
+//			events.Reset();
+//			TimerMinuteCount = 0;
+//			events.ScheduleEvent(EVENT_TIMER, IN_MILLISECONDS);
+//			events.ScheduleEvent(EVENT_PHASE_ONE, TIME_PHASE_ONE_DELAY);
+//			events.ScheduleEvent(EVENT_PHASE_TWO, TIME_PHASE_TWO_DELAY);
+//			events.ScheduleEvent(EVENT_PHASE_THREE, TIME_PHASE_THREE_DELAY);
+//			events.ScheduleEvent(EVENT_PHASE_FINAL, TIME_PHASE_FINAL_DELAY);
+//			sThunderbluffBattle->Init(me);
+//		}
+//
+//		void JustSummoned(Creature* summoned) override
+//		{
+//			ThunderbluffCreatureList.push_back(summoned);
+//		}
+//
+//		void SummonedCreatureDies(Creature* summoned, Unit* /*killer*/) override
+//		{
+//			sThunderbluffBattle->RewardByCreature(summoned->GetEntry(), true);
+//
+//			switch (summoned->GetEntry())
+//			{
+//			case NPC_GENERAL_1:
+//				isGeneral_1_Alive = false;
+//				sThunderbluffBattle->SetWorldState(WORLD_STATE_GENERAL_1, 1);
+//				break;
+//			case NPC_GENERAL_2:
+//				isGeneral_2_Alive = false;
+//				sThunderbluffBattle->SetWorldState(WORLD_STATE_GENERAL_2, 1);
+//				break;
+//			case NPC_GENERAL_3:
+//				isGeneral_3_Alive = false;
+//				sThunderbluffBattle->SetWorldState(WORLD_STATE_GENERAL_3, 1);
+//				break;
+//			case NPC_BAINE:
+//				isBaine_Alive = false;
+//				sGameEventMgr->StopEvent(EVENT_THUDERBLUFF_BATTLE_ID,false,false);
+//				break;
+//			default:
+//				break;
+//			}
+//		}
+//
+//		void UpdateAI(uint32 diff)
+//		{
+//			events.Update(diff);
+//			while (uint32 eventId = events.ExecuteEvent())
+//			{
+//				switch (eventId)
+//				{
+//				case EVENT_TIMER:
+//				{
+//					//TimerMinuteCount++;
+//					//std::ostringstream oss;
+//					//oss << "Ê±¼ä£º" << TimerMinuteCount << "Ãë";
+//					//sWorld->SendServerMessage(SERVER_MSG_STRING, oss.str().c_str());
+//				}	
+//				events.ScheduleEvent(EVENT_TIMER, IN_MILLISECONDS);
+//					break;
+//				case EVENT_PHASE_ONE:
+//					Announce(PHASE_ONE);
+//					sThunderbluffBattle->SetPhase(PHASE_ONE);
+//					sThunderbluffBattle->SetWorldState(WORLD_STATE_GENERAL_1, 0);
+//					sThunderbluffBattle->SetWorldState(WORLD_STATE_GENERAL_2, 0);
+//					sThunderbluffBattle->SetWorldState(WORLD_STATE_GENERAL_3, 0);
+//					break;
+//				case EVENT_PHASE_TWO:
+//					Announce(PHASE_TWO);
+//					sThunderbluffBattle->SetPhase(PHASE_TWO);
+//					sThunderbluffBattle->TeleAllPlayers();
+//					if (isGeneral_1_Alive)
+//						sThunderbluffBattle->RewardByCreature(NPC_GENERAL_1, false);
+//					break;
+//				case EVENT_PHASE_THREE:
+//					Announce(PHASE_THREE);
+//					sThunderbluffBattle->SetPhase(PHASE_THREE);
+//					sThunderbluffBattle->TeleAllPlayers();
+//					if (isGeneral_2_Alive)
+//						sThunderbluffBattle->RewardByCreature(NPC_GENERAL_2, false);
+//					break;
+//				case EVENT_PHASE_FINAL:
+//					Announce(PHASE_FINAL);
+//					sThunderbluffBattle->SetPhase(PHASE_FINAL);
+//					sThunderbluffBattle->TeleAllPlayers();
+//					if (isGeneral_3_Alive)
+//						sThunderbluffBattle->RewardByCreature(NPC_GENERAL_3, false);
+//					break;
+//				default:
+//					break;
+//				}
+//			}
+//		}
+//		
+//
+//		void Announce(PhaseIds phase)
+//		{
+//			std::ostringstream oss;
+//			oss << event_name << "µÚ" << phase << "½×¶Î¼¤»î£¡";
+//
+//			SessionMap const& smap = sWorld->GetAllSessions();
+//			for (SessionMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+//				if (Player* pl = iter->second->GetPlayer())
+//					if (pl->event_team != EVENT_TEAM_NONE)
+//					{
+//						pl->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+//						ChatHandler(pl->GetSession()).PSendSysMessage(oss.str().c_str());
+//					}				
+//		}
+//
+//
+//	private:
+//		EventMap events;
+//	};
+//
+//
+//
+//	CreatureAI* GetAI(Creature* creature) const override
+//	{
+//		return new ThunderbluffControllerAI(creature);
+//	}
+//};
+//
+//
+//class ThunderbluffTeleTrigger : public CreatureScript
+//{
+//public:
+//	ThunderbluffTeleTrigger() : CreatureScript("ThunderbluffTeleTrigger") { }
+//	struct ThunderbluffTeleTriggerAI : public ScriptedAI
+//	{
+//		ThunderbluffTeleTriggerAI(Creature* creature) : ScriptedAI(creature), Summons(me){}
+//		SummonList Summons;
+//
+//		void MoveInLineOfSight(Unit* who) override
+//		{
+//			if (!gunship)
+//				return;
+//
+//			if (who->GetTypeId() != TYPEID_PLAYER)
+//				return;
+//
+//			if (!me->IsWithinDistInMap(who, 10.0f))
+//				return;
+//
+//			Player* player = who->ToPlayer();
+//
+//			if (player->event_team == EVENT_TEAM_OFFENSE)
+//				sThunderbluffBattle->TelePlayerToShip(player, gunship);
+//			else
+//				sThunderbluffBattle->TelePlayerToHighLand(player);
+//		}	
+//	};
+//
+//	CreatureAI* GetAI(Creature* creature) const override
+//	{
+//		return new ThunderbluffTeleTriggerAI(creature);
+//	}
+//};
+//
+//
+//class ThunderbluffBattlePortal : public GameObjectScript
+//{
+//public:
+//	ThunderbluffBattlePortal() : GameObjectScript("ThunderbluffBattlePortal") { }
+//
+//	bool OnGossipHello(Player* player, GameObject* go)
+//	{
+//		if (!gunship)
+//			return false;
+//
+//		if (sThunderbluffBattle->GetPhase() == PHASE_ZERO)
+//		{
+//			player->GetSession()->SendNotification("µÈ´ý´«ËÍÆ÷¼¤»î!");
+//			return false;
+//		}
+//
+//		if (!player->HasAura(SPELL_TELE_DEBUFF))
+//		{
+//			player->AddAura(SPELL_TELE_DEBUFF, player);
+//			switch (go->GetEntry())
+//			{
+//			case GO_PORTAL_HIGHLAND:
+//				sThunderbluffBattle->TelePlayerToShip(player, gunship);
+//				break;
+//			case GO_PORTAL_SHIP:
+//				sThunderbluffBattle->TelePlayerToHighLand(player);
+//				break;
+//			default:
+//				break;
+//			}
+//		}
+//		return true;
+//	}
+//};
+//
+//
+//class ThunderbluffBattleSpiritHealer : public CreatureScript
+//{
+//public:
+//	ThunderbluffBattleSpiritHealer() : CreatureScript("ThunderbluffBattleSpiritHealer") { }
+//	struct ThunderbluffBattleSpiritHealerAI : public CreatureAI
+//	{
+//		SummonList Summons;
+//		EventMap events;
+//		uint32 Timer;
+//		bool announce_30;
+//		bool announce_20;
+//		bool announce_10;
+//		bool revive;
+//
+//		ThunderbluffBattleSpiritHealerAI(Creature* creature) : CreatureAI(creature), Summons(me){}
+//
+//		void Reset() override
+//		{
+//			Timer = 0;
+//			announce_30 = false;
+//			announce_20 = false;
+//			announce_10 = false;
+//			revive = false;
+//		}
+//
+//		void UpdateAI(uint32 diff) override
+//		{
+//			Timer += diff;
+//
+//			if (!announce_30 && Timer > 10000)
+//			{
+//				announce_30 = true;
+//				Announce(30);
+//			}
+//
+//			if (!announce_20 && Timer > 20000)
+//			{
+//				announce_20 = true;
+//				Announce(20);
+//			}
+//
+//			if (!announce_10 && Timer > 30000)
+//			{
+//				announce_10 = true;
+//				Announce(10);
+//			}
+//
+//			if (!revive && Timer > 40000)
+//			{
+//				Revive();
+//				Reset();
+//			}
+//		}
+//
+//		void Announce(uint32 seconds)
+//		{
+//			std::ostringstream oss;
+//			oss << event_name << seconds << "Ãëºó¼¯Ìå¸´»î£¬Çë¿¿½üÁé»êÒ½Õß...";
+//
+//			std::list<Player*> playersNearby;
+//			me->GetPlayerListInGrid(playersNearby, 30, false);
+//			if (!playersNearby.empty())
+//				for (std::list<Player*>::iterator itr = playersNearby.begin(); itr != playersNearby.end(); ++itr)
+//				{
+//					Player* pl = *itr;
+//
+//					if (!pl->IsInWorld())
+//						continue;
+//
+//					if (pl->event_team == EVENT_TEAM_NONE || pl->getFaction() != me->getFaction())
+//						continue;
+//
+//					if (pl->IsAlive())
+//						continue;
+//
+//					pl->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+//				}
+//		}
+//
+//		void Revive()
+//		{
+//			std::ostringstream oss;
+//
+//			oss << event_name << "ÄÃ³öÄãµÄÓÂÆø£¬¼ÌÐøÕ½¶·£¡";
+//
+//			std::list<Player*> playersNearby;
+//			me->GetPlayerListInGrid(playersNearby, 30, false);
+//
+//			if (!playersNearby.empty())
+//			{
+//				for (std::list<Player*>::iterator itr = playersNearby.begin(); itr != playersNearby.end(); ++itr)
+//				{
+//					Player* pl = *itr;
+//
+//					if (!pl->IsInWorld())
+//						continue;
+//
+//					if (pl->event_team == EVENT_TEAM_NONE)
+//						continue;
+//
+//			
+//					if (pl->IsAlive())
+//						continue;
+//
+//					pl->GetSession()->SendNotification(oss.str().c_str());
+//					me->CastSpell(me, 22012, true);
+//					pl->CastSpell(*itr, 24171, true);
+//					pl->ResurrectPlayer(1.0f);
+//					pl->CastSpell(*itr, 6962, true);
+//					pl->CastSpell(*itr, 44535, true);
+//					pl->SpawnCorpseBones();
+//				}
+//			}
+//		}
+//	};
+//
+//	CreatureAI* GetAI(Creature* creature) const override
+//	{
+//		return new ThunderbluffBattleSpiritHealerAI(creature);
+//	}
+//};
+//
+//
+//class ThunderbluffAirVehicle : public CreatureScript
+//{
+//public:
+//	ThunderbluffAirVehicle() : CreatureScript("ThunderbluffAirVehicle") { }
+//
+//	struct ThunderbluffAirVehicleAI : public VehicleAI
+//	{
+//		ThunderbluffAirVehicleAI(Creature *pCreature) : VehicleAI(pCreature){}
+//
+//		Unit* thrower;
+//		uint32 Timer = 0;
+//		bool countdown = false;
+//		
+//		float x = 0;
+//		float y = 0;
+//		float z = 0;
+//
+//		void SpellHit(Unit* caster, SpellInfo const* spell) override
+//		{
+//			if (spell->Id == 49756)
+//			{
+//				thrower = caster;
+//
+//				me->CastSpell(caster, 43789);
+//
+//				Unit* ps = me->GetVehicleKit()->GetPassenger(0);
+//				me->MonsterWhisper("¸ÃËÀ£¬±»ÄÇ¸öÅ£Í·ÈË»÷ÖÐÁË£¬¿ì¸ÉµôËü...·ñÔòÎÒÃÇ¾Í×¹»ÙÁË£¡", ps->ToPlayer());
+//				countdown = true;
+//			}
+//		}
+//
+//
+//		void UpdateAI(uint32 diff)
+//		{
+//			if (countdown)
+//			{
+//				Timer += diff;
+//
+//				if (Timer > 5 * IN_MILLISECONDS)
+//				{
+//					countdown = false;
+//					Timer = 0;			
+//					
+//					me->RemoveAura(43789);
+//					
+//					if (thrower->IsAlive())
+//					{
+//						thrower->RemoveAura(43789);
+//						me->SetReactState(REACT_PASSIVE);
+//						me->setDeathState(JUST_DIED);
+//						me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+//					}	
+//				}
+//			}
+//
+//			VehicleAI::UpdateAI(diff);
+//		}
+//		void PassengerBoarded(Unit* who, int8 seatid, bool add)
+//		{
+//			me->SetDisableGravity(false);
+//			me->SendMovementFlagUpdate();
+//			me->SetCanFly(true);
+//			for (uint32 i = 0; i < 9;i++)
+//				me->SetSpeed(UnitMoveType(i), 2.0f, true);
+//		}
+//
+//		void JustDied(Unit* killer)
+//		{
+//			
+//		}
+//
+//		void SpellHitTarget(Unit* target, SpellInfo const* spell)
+//		{
+//			if (target->GetEntry() == NPC_BAINE)
+//				target->ModifyHealth(-10000);
+//		}
+//
+//	};
+//
+//	CreatureAI* GetAI(Creature* pCreature) const
+//	{
+//		return new ThunderbluffAirVehicleAI(pCreature);
+//	}
+//};
+//
+//enum THRWOER_EVENTS
+//{
+//	EVENT_THROW = 1,
+//	EVENT_CAST_SPELL_dianran,
+//	EVENT_CAST_SPELL_CHARGE,
+//	EVENT_CAST_SPELL_huimiedaji,
+//	
+//	EVENT_CHECK_HP,
+//	EVENT_CAST_SPELL_HEAL,
+//};
+//
+//class ThunderbluffThower : public CreatureScript
+//{
+//public:
+//	ThunderbluffThower() : CreatureScript("ThunderbluffThower") { }
+//
+//	struct ThunderbluffThowerAI : public ScriptedAI
+//	{
+//		ThunderbluffThowerAI(Creature* creature) : ScriptedAI(creature), Summons(me){}
+//
+//		SummonList Summons;
+//
+//		uint32 throwTimer;
+//		void InitializeAI() override
+//		{
+//			throwTimer = urand(1000, 3000);
+//			events.ScheduleEvent(EVENT_THROW, throwTimer);
+//		}
+//
+//		void Reset() override
+//		{
+//			events.Reset();
+//			throwTimer = urand(1000, 3000);
+//			events.ScheduleEvent(EVENT_THROW, throwTimer);
+//		}
+//
+//		void EnterCombat(Unit* victim) override
+//		{
+//			events.ScheduleEvent(EVENT_CHECK_HP, 0);
+//			events.ScheduleEvent(EVENT_CAST_SPELL_CHARGE, 1000);
+//			events.ScheduleEvent(EVENT_CAST_SPELL_dianran, 3000);
+//			events.ScheduleEvent(EVENT_CAST_SPELL_huimiedaji, 6000);
+//		}
+//
+//		void UpdateAI(uint32 diff) override
+//		{
+//			events.Update(diff);
+//
+//			if (me->HasUnitState(UNIT_STATE_CASTING))
+//				return;
+//
+//			while (uint32 eventId = events.ExecuteEvent())
+//			{
+//				switch (eventId)
+//				{
+//				case EVENT_THROW:
+//					if (urand(0, 1) == 0)
+//					{
+//						if (gunshipHP > 0)
+//						{
+//							if (Creature* target = me->FindNearestCreature(NPC_GUNSHIP_SHELL, 500.0f))
+//							{
+//								me->SetFacingToObject(target);
+//								me->CastSpell(target, SPELL_THROW_FIRE);
+//								gunshipHP -= DmgPerThrow;
+//								if (gunshipHP < 0)
+//									gunshipHP = 0;
+//							}
+//						}
+//					}			
+//					events.ScheduleEvent(EVENT_THROW, throwTimer);
+//					break;
+//				case EVENT_CHECK_HP:
+//					if (me->HealthBelowPct(50))
+//					{
+//						events.ScheduleEvent(EVENT_CAST_SPELL_HEAL, 0);
+//						break;
+//					}		
+//					events.ScheduleEvent(EVENT_CHECK_HP, 1000);
+//					break;
+//				case EVENT_CAST_SPELL_HEAL:
+//					DoCast(SPELL_HEAL);
+//					events.ScheduleEvent(EVENT_CAST_SPELL_HEAL, urand(3000, 5000));
+//					break;
+//				case EVENT_CAST_SPELL_dianran:
+//					DoCast(SPELL_dianran);
+//					events.ScheduleEvent(EVENT_CAST_SPELL_dianran, urand(10000, 15000));
+//					break;
+//				case EVENT_CAST_SPELL_CHARGE:
+//					DoCast(SPELL_CHARGE);
+//					events.ScheduleEvent(EVENT_CAST_SPELL_CHARGE, urand(6000, 10000));
+//					break;
+//				case EVENT_CAST_SPELL_huimiedaji:
+//					DoCast(SPELL_huimiedaji);
+//					events.ScheduleEvent(EVENT_CAST_SPELL_huimiedaji, urand(5000, 8000));
+//					break;
+//				default:
+//					break;
+//				}
+//			}
+//
+//			DoMeleeAttackIfReady();
+//		}
+//
+//	private:
+//		EventMap events;
+//	};
+//
+//	CreatureAI* GetAI(Creature* creature) const
+//	{
+//		return new ThunderbluffThowerAI(creature);
+//	}
+//};
+//
+//
+//class ThunderbluffHarpoonTrigger : public CreatureScript
+//{
+//public:
+//	ThunderbluffHarpoonTrigger() : CreatureScript("ThunderbluffHarpoonTrigger") { }
+//
+//	struct ThunderbluffHarpoonTriggerAI : public ScriptedAI
+//	{
+//		ThunderbluffHarpoonTriggerAI(Creature* creature) : ScriptedAI(creature), Summons(me){}
+//
+//		SummonList Summons;
+//
+//		void InitializeAI() override
+//		{
+//			events.ScheduleEvent(EVENT_THROW, urand(1000, 15000));
+//		}
+//
+//		void Reset() override
+//		{
+//			events.Reset();
+//			events.ScheduleEvent(EVENT_THROW, urand(1000, 15000));
+//		}
+//
+//		void UpdateAI(uint32 diff) override
+//		{
+//			events.Update(diff);
+//
+//			while (uint32 eventId = events.ExecuteEvent())
+//			{
+//				if (eventId == EVENT_THROW)
+//				{
+//					Map::PlayerList const &players = me->GetMap()->GetPlayers();
+//					for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
+//					{
+//						if (Player* player = itr->GetSource())
+//						{
+//							if (me->GetDistance2d(player) > 250.0f)
+//								continue;
+//
+//							if (Vehicle* v = player->GetVehicle())
+//								if (Unit* mount = v->GetBase())
+//								{
+//									me->SetFacingToObject(mount);
+//									me->CastSpell(mount, 49727);
+//									break;
+//								}
+//						}
+//
+//						
+//					}
+//					events.ScheduleEvent(EVENT_THROW, urand(1000, 2000));
+//				}				
+//			}
+//		}
+//
+//	private:
+//		EventMap events;
+//	};
+//
+//	CreatureAI* GetAI(Creature* creature) const
+//	{
+//		return new ThunderbluffHarpoonTriggerAI(creature);
+//	}
+//};
+//
+//
+//
+//void AddSC_Thunderbluff_Scripts()
+//{
+//	new ThunderbluffController();
+//	new ThunderbluffTeleTrigger();
+//	new ThunderbluffBattlePortal();
+//	new ThunderbluffBattleSpiritHealer();
+//	new ThunderbluffAirVehicle();
+//	new ThunderbluffThower();
+//	//new ThunderbluffHarpoonTrigger();
+//}
diff --git a/src/server/scripts/Custom/CustomEvent/UnknownBG/UnknownBG.cpp b/src/server/scripts/Custom/CustomEvent/UnknownBG/UnknownBG.cpp
new file mode 100644
index 0000000..b3fa95d
--- /dev/null
+++ b/src/server/scripts/Custom/CustomEvent/UnknownBG/UnknownBG.cpp
@@ -0,0 +1,399 @@
+#pragma execution_character_set("utf-8")
+#include "UnknownBG.h"
+#include "../Event.h"
+#include "../../CommonFunc/CommonFunc.h"
+#include "../../Reward/Reward.h"
+
+std::vector<UkBGTemplate> UkBGVec;
+uint32 UKBG_KILLEDSEQUENCE;
+float UKBG_R;
+
+void UkBG::Start()
+{
+	UKBG_KILLEDSEQUENCE = 0;
+	UkBGVec.clear();
+	Active = true;
+}
+
+void UkBG::Stop()
+{
+	UKBG_KILLEDSEQUENCE = 0;
+	UkBGVec.clear();
+}
+
+void UkBG::RandPos(float &x1, float& y1, float x, float y, float r)
+{
+	uint32 i = urand(0, 100);
+	float R = frand(0, r);
+	x1 = x + R * cos(2 * M_PI * i / 100);
+	y1 = y + R * sin(2 * M_PI * i / 100);
+}
+
+void UkBG::AddPlayer(Player* player)
+{
+	if (!sUkBG->Active)
+	{
+		player->GetSession()->SendNotification("[ËÀÍöÑ°±¦]ÒÑ¾­½áÊø£¡");
+		return;
+	}
+
+	if (InUkBG(player))
+	{
+		player->GetSession()->SendNotification("²»ÄÜÖØ¸´²ÎÓë[ËÀÍöÑ°±¦]£¡");
+		return;
+	}
+
+	UkBGTemplate Temp;
+	Temp.guid = player->GetGUID();
+	Temp.killCount = 0;
+	Temp.killedSequence = 0;
+
+	UkBGVec.push_back(Temp);
+
+	float x1;float y1;
+	RandPos(x1, y1, _x, _y, 300);
+	player->TeleportTo(_map, x1, y1, 50, 0);
+	player->CastSpell(player, 79404);
+}
+
+void UkBG::RemovePlayer(Player* player)
+{
+	uint32 totalCount = UkBGVec.size();
+
+	for (std::vector<UkBGTemplate>::iterator itr = UkBGVec.begin(); itr != UkBGVec.end(); itr++)
+		if (player->GetGUID() == itr->guid)
+		{
+			if (itr->killedSequence > 0)
+				break;
+
+			UKBG_KILLEDSEQUENCE++;
+			itr->killedSequence = UKBG_KILLEDSEQUENCE;
+
+			std::ostringstream oss;
+			oss << "|cFFFF1717[ËÀÍöÑ°±¦]|r" << sCF->GetNameLink(player) << "±»|cFFFF1717[ËÀÍöÖ®Ï¢]|r" << "ÍÌÊÉ£¡" << UKBG_KILLEDSEQUENCE << " / " << totalCount;
+
+			sWorld->SendScreenMessage(oss.str().c_str());
+
+			CheckDone();
+
+			break;
+		}
+}
+
+bool UkBG::InUkBG(Player* player)
+{
+	for (std::vector<UkBGTemplate>::iterator itr = UkBGVec.begin(); itr != UkBGVec.end(); itr++)
+		if (player->GetGUID() == itr->guid)
+			return true;
+
+	return false;
+}
+
+void UkBG::SetKilledSequence(Unit* killer, Player* killed)
+{
+	uint32 totalCount = UkBGVec.size();
+
+	for (std::vector<UkBGTemplate>::iterator itr = UkBGVec.begin(); itr != UkBGVec.end(); itr++)
+		if (killed->GetGUID() == itr->guid)
+		{
+			if (itr->killedSequence > 0)
+			{
+				killed->GetSession()->SendNotification("ÄãÒÑÔÚ|cFFFF1717[ËÀÍöÑ°±¦]|rÖÐ±»É±ËÀ£¡");
+				killed->TeleportTo(killed->m_homebindMapId, killed->m_homebindX, killed->m_homebindY, killed->m_homebindZ, 0);
+				break;
+			}
+				
+			UKBG_KILLEDSEQUENCE++;
+			itr->killedSequence = UKBG_KILLEDSEQUENCE;
+
+			std::ostringstream oss;
+
+			if (killer->GetTypeId() == TYPEID_PLAYER)
+				oss << "|cFFFF1717[ËÀÍöÑ°±¦]|r" << sCF->GetNameLink(killed) << "±»" << sCF->GetNameLink(killer->ToPlayer()) << "»÷É±£¡" << UKBG_KILLEDSEQUENCE << "/" << totalCount;
+			else if (killer->GetTypeId() == TYPEID_UNIT)
+				oss << "|cFFFF1717[ËÀÍöÑ°±¦]|r" << sCF->GetNameLink(killed) << "±»|cFFFF1717[" + killer->GetName() + "]|r" << "ÍÌÊÉ£¡" << UKBG_KILLEDSEQUENCE << " / " << totalCount;
+
+			sWorld->SendScreenMessage(oss.str().c_str());
+
+			Unit::Kill(killer, killed->ToUnit());
+
+			CheckDone();
+
+			break;
+		}
+}
+
+void UkBG::SetKillCount(Player* player)
+{
+	for (std::vector<UkBGTemplate>::iterator itr = UkBGVec.begin(); itr != UkBGVec.end(); itr++)
+		if (player->GetGUID() == itr->guid)
+		{
+			itr->killCount++;
+			break;
+		}
+}
+
+void UkBG::CheckDone()
+{
+	//¼ì²âËÀÍöÑ°±¦ÊÇ·ñÍê³É Ö»Ê£ÏÂÒ»ÈËÇÒ×ÜÈËÊý´óÓÚXX
+	uint32 totalCount = UkBGVec.size();
+
+	if (/*deathcount > 3 && */totalCount - UKBG_KILLEDSEQUENCE == 1 && totalCount > 1)
+	{
+		sWorld->SendScreenMessage("ËÀÍöÑ°±¦ÒÑ¾­½áÊø£¡");
+		Active = false;
+
+		//½±Àø
+		for (std::vector<UkBGTemplate>::iterator itr = UkBGVec.begin(); itr != UkBGVec.end(); itr++)
+		{
+			if (Player* player = ObjectAccessor::FindPlayerInOrOutOfWorld(itr->guid))
+			{
+				uint32 rewId = 0;
+				std::ostringstream oss;
+
+				if (itr->killedSequence == 0)
+				{
+					if (itr->killCount > 0)
+					{
+						rewId = UKBG_H_REWID;
+						oss << "|cFFFF1717[ËÀÍöÑ°±¦]|r" << sCF->GetNameLink(player) << "ÍçÇ¿µØÉú´æÏÂÀ´²¢Íê³ÉÁË»÷É±Ä¿±ê£¬»ñµÃ|cFFFF1717[ÖÁ¸ß]|r½±Àø£¡";
+						sWorld->SendScreenMessage(oss.str().c_str());
+					}	
+					else
+					{
+						rewId = UKBG_L_REWID;
+						oss << "|cFFFF1717[ËÀÍöÑ°±¦]|r" << sCF->GetNameLink(player) << "»úÖÇµØÉú´æÏÂÀ´µ«Î´Íê³É»÷É±Ä¿±ê£¬»ñµÃ|cFFFF1717[»ù´¡]|r½±Àø£¡";
+						sWorld->SendScreenMessage(oss.str().c_str());
+					}				
+				}
+				//else if (itr->killedSequence <= 5)
+				//{
+				//	if (itr->killCount > 0)
+				//	{
+				//		rewId = UKBG_M_REWID;
+				//		oss << "|cFFFF1717[ËÀÍöÑ°±¦]|r" << sCF->GetNameLink(player) << "ÍçÇ¿Æ´²«£¬ËäËÀÓÌÈÙ£¬»ñµÃ|cFFFF1717[ÖÐµÈ]|r½±Àø£¡";
+				//		sWorld->SendServerMessage(SERVER_MSG_STRING, oss.str().c_str());
+				//	}	
+				//	else
+				//	{
+				//		rewId = UKBG_L_REWID;
+				//		oss << "|cFFFF1717[ËÀÍöÑ°±¦]|r" << sCF->GetNameLink(player) << "¹¶ÇÒÍµÉú£¬ËÀ²»×ãÏ§£¬»ñµÃ|cFFFF1717[»ù´¡]|r½±Àø£¡";
+				//		sWorld->SendServerMessage(SERVER_MSG_STRING, oss.str().c_str());
+				//	}			
+				//}
+				else
+				{
+					if (itr->killCount > 0)
+					{
+						rewId = UKBG_L_REWID;
+						ChatHandler(player->GetSession()).PSendSysMessage("|cFFFF1717[ËÀÍöÑ°±¦]|rÄãÔÚËÀÍöÑ°±¦ÖÐ±íÏÖÆ½Æ½£¬»ñµÃ|cFFFF1717[»ù´¡]|r½±Àø£¡");
+					}	
+				}
+
+				sRew->Rew(player, rewId);
+			}
+		}
+	}
+}
+
+class UkBGPlayer : PlayerScript
+{
+public:
+	UkBGPlayer() : PlayerScript("UkBGPlayer") {}
+	void OnPVPKill(Player* killer, Player* killed) 
+	{ 
+		if (!sUkBG->InUkBG(killer) || !sUkBG->InUkBG(killed))
+			return;
+
+		sUkBG->SetKillCount(killer);
+		sUkBG->SetKilledSequence(killer, killed);	
+	}
+
+	void OnPlayerKilledByCreature(Creature* killer, Player* killed)
+	{
+		if (!sUkBG->InUkBG(killed))
+			return;
+
+		sUkBG->SetKilledSequence(killer, killed);
+	}
+
+	void OnLogout(Player* player) 
+	{ 
+		if (!sUkBG->InUkBG(player))
+			return;
+
+		sUkBG->RemovePlayer(player);
+	}
+
+	void OnUpdateZone(Player* player, uint32 newZone, uint32 /*newArea*/) 
+	{ 
+		if (newZone !=400 && sUkBG->InUkBG(player))
+			sUkBG->RemovePlayer(player);
+	}
+};
+
+class UkBGTrigger : public CreatureScript
+{
+public:
+	UkBGTrigger() : CreatureScript("UkBGTrigger") { }
+	struct UkBGTriggerAI : public ScriptedAI
+	{
+		SummonList Summons;
+		uint8 i_max = 250;
+		uint32 interval = UKBG_LENGTH * 1000 / i_max;
+		uint32 PlayerTimer = 0;
+		uint32 SummonTimer = 0;
+		uint32 SpawnTimer = 0;
+
+		uint32 map = me->GetMapId();
+		float x = me->GetPositionX();
+		float y = me->GetPositionY();
+		float z = me->GetPositionZ() + 2.0f;
+
+		UkBGTriggerAI(Creature* creature) : ScriptedAI(creature), Summons(me)
+		{
+			me->m_SightDistance = 1000.0f;
+			me->GetMap()->SetVisibilityRange(420.0f);
+			UKBG_R = 1.5 * i_max;
+		}
+
+		void Summon()
+		{
+			UKBG_R = 1.5 * i_max;
+
+			for (uint8 i = 0; i < i_max; i++)
+			{
+				float x1 = x + UKBG_R * cos(2 * M_PI * i / i_max);
+				float y1 = y + UKBG_R * sin(2 * M_PI * i / i_max);
+				float z1 = -59.93f;
+				//me->SummonCreature(28253, x1, y1, z1 - 7, 0, TEMPSUMMON_TIMED_DESPAWN, interval);
+
+				//¶òÔËÖ®´¸Ä§·¨äöÎÐ 179506
+
+				//¶¾Îí
+				//me->SummonGameObject(19587, x1, y1, z1, 0, 0, 0, 0, 0, ceil(interval / 1000));
+
+				//ÉñÊ¥ÉÁµç(´¹Ö±)
+				//me->SummonGameObject(191302, x1, y1, z1, 0, 0, 0, 0, 0, 2 * ceil(interval / 1000));
+				//
+				////Î×ÑýÍõÖ®ÑÛäöÎÐ±¦ÖéÔÆ
+				me->SummonGameObject(192862, x1, y1, z1, 0, 0, 0, 0, 0, ceil(interval / 1000));
+				//
+				////ÑÌÔÆ
+				//me->SummonGameObject(189330, x1, y1, z1, 0, 0, 0, 0, 0, ceil(interval / 1000));
+				//
+				////²¡Ä¾ÁÖÅ¨ÑÌ
+				//me->SummonGameObject(177671, x1, y1, z1, 0, 0, 0, 0, 0, ceil(interval / 1000));
+				//
+				////WotLK¹âÁÁ¹â»·
+				me->SummonGameObject(190745, x1, y1, z1 - 5, 0, 0, 0, 0, 0, ceil(interval / 1000));
+			}
+
+			i_max = i_max - 1;
+
+
+			sWorld->SendZoneText(me->GetZoneId(), "ËÀÍöÖ®Ï¢ÔÚ±Æ½ü..");
+		}
+
+		void PlayerPosCheck()
+		{
+			std::list<Player*> playersNearby;
+			me->GetPlayerListInGrid(playersNearby, 1000, true);
+
+			if (!playersNearby.empty())
+				for (std::list<Player*>::iterator itr = playersNearby.begin(); itr != playersNearby.end(); ++itr)
+				{
+					if (sUkBG->InUkBG(*itr))
+					{
+						if (UKBG_R < (*itr)->GetExactDist2d(me))
+							sUkBG->SetKilledSequence(me, (*itr));
+					}else
+					{
+						(*itr)->GetSession()->SendNotification("ÄãÎ´¼ÓÈë|cFFFF1717[ËÀÍöÑ°±¦]|r£¡");
+						(*itr)->TeleportTo((*itr)->m_homebindMapId, (*itr)->m_homebindX, (*itr)->m_homebindY, (*itr)->m_homebindZ, 0);
+					}
+				}
+		}
+
+		void Spawn()
+		{
+			uint32 count = i_max / 10;
+
+			for (size_t i = 0; i < count; i++)
+			{
+				float x1; float y1;
+				sUkBG->RandPos(x1, y1, x, y, UKBG_R);
+
+
+				uint32 rand = urand(0, 4);
+
+				if (rand == 0)
+				{
+					me->SummonGameObject(350000, x1, y1, z, frand(0,2), 0, 0, 0, 0, 180);
+					me->SummonCreature(60010, x1, y1, z + 3.0f, frand(0, 2), TEMPSUMMON_TIMED_DESPAWN, 180000);
+				}
+				else if (rand == 1)
+					me->SummonGameObject(350002, x1, y1, z, 0, 0, 0, 0, 0, 180);
+				else
+					me->SummonGameObject(350001, x1, y1, z, 0, 0, 0, 0, 0, 180);
+			}
+		}
+
+		void Reset()
+		{
+			i_max = 250;
+			UKBG_R = 1.5 * i_max;
+			SummonTimer = 0;
+			PlayerTimer = 0;
+			SpawnTimer = 0;
+			Summon();
+			Spawn();
+		}
+
+		void UpdateAI(uint32 diff) override
+		{
+			if (!sUkBG->Active)
+				return;
+
+			//Íæ¼ÒÎ»ÖÃ¼ì²â
+			PlayerTimer += diff;
+
+			if (PlayerTimer > 500)
+			{
+				PlayerTimer = 0;
+				PlayerPosCheck();
+			}
+
+			//ÕÙ»½ºÚÎí
+			SummonTimer += diff;
+
+			if (SummonTimer > interval)
+			{
+				SummonTimer = 0;
+
+				if (i_max > 5)
+					Summon();
+			}
+
+			//Ë¢ÐÂÎïÌå¡¢ÉúÎï
+			SpawnTimer += diff;
+
+			if (SpawnTimer > 180000)
+			{
+				SpawnTimer = 0;
+				Spawn();
+			}
+		}
+	};
+
+	CreatureAI* GetAI(Creature* creature) const override
+	{
+		return new UkBGTriggerAI(creature);
+	}
+};
+
+void AddSC_UkBG()
+{
+	new UkBGTrigger();
+	new UkBGPlayer();
+}
diff --git a/src/server/scripts/Custom/CustomEvent/UnknownBG/UnknownBG.h b/src/server/scripts/Custom/CustomEvent/UnknownBG/UnknownBG.h
new file mode 100644
index 0000000..de954b8
--- /dev/null
+++ b/src/server/scripts/Custom/CustomEvent/UnknownBG/UnknownBG.h
@@ -0,0 +1,38 @@
+struct UkBGTemplate
+{
+	uint64 guid;
+	uint32 killCount;
+	uint32 killedSequence;
+};
+
+extern std::vector<UkBGTemplate> UkBGVec;
+
+class UkBG
+{
+public:
+	static UkBG* instance()
+	{
+		static UkBG instance;
+		return &instance;
+	}
+
+	void Start();
+	void Stop();
+	bool Active;
+
+	void SetKilledSequence(Unit* killer, Player* killed);
+	void SetKillCount(Player* player);
+
+	void AddPlayer(Player* player);
+	void RemovePlayer(Player* player);
+	bool InUkBG(Player* player);
+
+	void CheckDone();
+
+	void RandPos(float &x1, float& y1, float x, float y, float r);
+private:
+	uint32 _map = 1;
+	float _x = -6116.08f;
+	float _y = -3900.58f;
+};
+#define sUkBG UkBG::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/DBCCreate/CSVparser.cpp b/src/server/scripts/Custom/DBCCreate/CSVparser.cpp
new file mode 100644
index 0000000..b65894c
--- /dev/null
+++ b/src/server/scripts/Custom/DBCCreate/CSVparser.cpp
@@ -0,0 +1,271 @@
+
+#include <fstream>
+#include <sstream>
+#include <iomanip>
+#include "CSVparser.hpp"
+
+namespace csv {
+
+  Parser::Parser(const std::string &data, const DataType &type, char sep)
+    : _type(type), _sep(sep)
+  {
+      std::string line;
+      if (type == eFILE)
+      {
+        _file = data;
+        std::ifstream ifile(_file.c_str());
+        if (ifile.is_open())
+        {
+            while (ifile.good())
+            {
+                getline(ifile, line);
+                if (line != "")
+                    _originalFile.push_back(line);
+            }
+            ifile.close();
+
+            if (_originalFile.size() == 0)
+              throw Error(std::string("No Data in ").append(_file));
+            
+            parseHeader();
+            parseContent();
+        }
+        else
+            throw Error(std::string("Failed to open ").append(_file));
+      }
+      else
+      {
+        std::istringstream stream(data);
+        while (std::getline(stream, line))
+          if (line != "")
+            _originalFile.push_back(line);
+        if (_originalFile.size() == 0)
+          throw Error(std::string("No Data in pure content"));
+
+        parseHeader();
+        parseContent();
+      }
+  }
+
+  Parser::~Parser(void)
+  {
+	  return;
+     std::vector<Row *>::iterator it;
+
+     for (it = _content.begin(); it != _content.end(); it++)
+          delete *it;
+  }
+
+  void Parser::parseHeader(void)
+  {
+      std::stringstream ss(_originalFile[0]);
+      std::string item;
+
+      while (std::getline(ss, item, _sep))
+          _header.push_back(item);
+  }
+
+  void Parser::parseContent(void)
+  {
+     std::vector<std::string>::iterator it;
+     
+     it = _originalFile.begin();
+     it++; // skip header
+
+     for (; it != _originalFile.end(); it++)
+     {
+         bool quoted = false;
+         int tokenStart = 0;
+         unsigned int i = 0;
+
+         Row *row = new Row(_header);
+
+         for (; i != it->length(); i++)
+         {
+              if (it->at(i) == '"')
+                  quoted = ((quoted) ? (false) : (true));
+              else if (it->at(i) == ',' && !quoted)
+              {
+                  row->push(it->substr(tokenStart, i - tokenStart));
+                  tokenStart = i + 1;
+              }
+         }
+
+         //end
+         row->push(it->substr(tokenStart, it->length() - tokenStart));
+
+         // if value(s) missing
+         if (row->size() != _header.size())
+          throw Error("corrupted data !");
+         _content.push_back(row);
+     }
+  }
+
+  Row &Parser::getRow(unsigned int rowPosition) const
+  {
+      if (rowPosition < _content.size())
+          return *(_content[rowPosition]);
+      throw Error("can't return this row (doesn't exist)");
+  }
+
+  Row &Parser::operator[](unsigned int rowPosition) const
+  {
+      return Parser::getRow(rowPosition);
+  }
+
+  unsigned int Parser::rowCount(void) const
+  {
+      return _content.size();
+  }
+
+  unsigned int Parser::columnCount(void) const
+  {
+      return _header.size();
+  }
+
+  std::vector<std::string> Parser::getHeader(void) const
+  {
+      return _header;
+  }
+
+  const std::string Parser::getHeaderElement(unsigned int pos) const
+  {
+      if (pos >= _header.size())
+        throw Error("can't return this header (doesn't exist)");
+      return _header[pos];
+  }
+
+  bool Parser::deleteRow(unsigned int pos)
+  {
+    if (pos < _content.size())
+    {
+      delete *(_content.begin() + pos);
+      _content.erase(_content.begin() + pos);
+      return true;
+    }
+    return false;
+  }
+
+  bool Parser::addRow(unsigned int pos, const std::vector<std::string> &r)
+  {
+    Row *row = new Row(_header);
+
+    for (auto it = r.begin(); it != r.end(); it++)
+      row->push(*it);
+    
+    if (pos <= _content.size())
+    {
+      _content.insert(_content.begin() + pos, row);
+      return true;
+    }
+    return false;
+  }
+
+  void Parser::sync(void) const
+  {
+    if (_type == DataType::eFILE)
+    {
+      std::ofstream f;
+      f.open(_file, std::ios::out | std::ios::trunc);
+
+      // header
+      unsigned int i = 0;
+      for (auto it = _header.begin(); it != _header.end(); it++)
+      {
+        f << *it;
+        if (i < _header.size() - 1)
+          f << ",";
+        else
+          f << std::endl;
+        i++;
+      }
+     
+      for (auto it = _content.begin(); it != _content.end(); it++)
+        f << **it << std::endl;
+      f.close();
+    }
+  }
+
+  const std::string &Parser::getFileName(void) const
+  {
+      return _file;    
+  }
+  
+  /*
+  ** ROW
+  */
+
+  Row::Row(const std::vector<std::string> &header)
+      : _header(header) {}
+
+  Row::~Row(void) {}
+
+  unsigned int Row::size(void) const
+  {
+    return _values.size();
+  }
+
+  void Row::push(const std::string &value)
+  {
+    _values.push_back(value);
+  }
+
+  bool Row::set(const std::string &key, const std::string &value) 
+  {
+    std::vector<std::string>::const_iterator it;
+    int pos = 0;
+
+    for (it = _header.begin(); it != _header.end(); it++)
+    {
+        if (key == *it)
+        {
+          _values[pos] = value;
+          return true;
+        }
+        pos++;
+    }
+    return false;
+  }
+
+  const std::string Row::operator[](unsigned int valuePosition) const
+  {
+       if (valuePosition < _values.size())
+           return _values[valuePosition];
+       throw Error("can't return this value (doesn't exist)");
+  }
+
+  const std::string Row::operator[](const std::string &key) const
+  {
+      std::vector<std::string>::const_iterator it;
+      int pos = 0;
+
+      for (it = _header.begin(); it != _header.end(); it++)
+      {
+          if (key == *it)
+              return _values[pos];
+          pos++;
+      }
+      
+      throw Error("can't return this value (doesn't exist)");
+  }
+
+  std::ostream &operator<<(std::ostream &os, const Row &row)
+  {
+      for (unsigned int i = 0; i != row._values.size(); i++)
+          os << row._values[i] << " | ";
+
+      return os;
+  }
+
+  std::ofstream &operator<<(std::ofstream &os, const Row &row)
+  {
+    for (unsigned int i = 0; i != row._values.size(); i++)
+    {
+        os << row._values[i];
+        if (i < row._values.size() - 1)
+          os << ",";
+    }
+    return os;
+  }
+}
+
diff --git a/src/server/scripts/Custom/DBCCreate/CSVparser.hpp b/src/server/scripts/Custom/DBCCreate/CSVparser.hpp
new file mode 100644
index 0000000..abfbb70
--- /dev/null
+++ b/src/server/scripts/Custom/DBCCreate/CSVparser.hpp
@@ -0,0 +1,99 @@
+#ifndef     _CSVPARSER_HPP_
+#define    _CSVPARSER_HPP_
+
+#include <stdexcept>
+#include <string>
+#include <vector>
+#include <list>
+#include <sstream>
+
+namespace csv
+{
+    class Error : public std::runtime_error
+    {
+      public:
+        Error(const std::string &msg):
+          std::runtime_error(std::string("CSVparser : ").append(msg))
+        {
+        }
+    };
+
+    class Row
+    {
+    	public:
+    	    Row(const std::vector<std::string> &);
+    	    ~Row(void);
+
+    	public:
+            unsigned int size(void) const;
+            void push(const std::string &);
+            bool set(const std::string &, const std::string &); 
+
+    	private:
+    		const std::vector<std::string> _header;
+    		std::vector<std::string> _values;
+
+        public:
+
+            template<typename T>
+            const T getValue(unsigned int pos) const
+            {
+                if (pos < _values.size())
+                {
+                    T res;
+                    std::stringstream ss;
+                    ss << _values[pos];
+                    ss >> res;
+                    return res;
+                }
+                throw Error("can't return this value (doesn't exist)");
+            }
+            const std::string operator[](unsigned int) const;
+            const std::string operator[](const std::string &valueName) const;
+            friend std::ostream& operator<<(std::ostream& os, const Row &row);
+            friend std::ofstream& operator<<(std::ofstream& os, const Row &row);
+    };
+
+    enum DataType {
+        eFILE = 0,
+        ePURE = 1
+    };
+
+    class Parser
+    {
+
+    public:
+        Parser(const std::string &, const DataType &type = eFILE, char sep = ',');
+        ~Parser(void);
+
+    public:
+        Row &getRow(unsigned int row) const;
+        unsigned int rowCount(void) const;
+        unsigned int columnCount(void) const;
+        std::vector<std::string> getHeader(void) const;
+        const std::string getHeaderElement(unsigned int pos) const;
+        const std::string &getFileName(void) const;
+
+    public:
+        bool deleteRow(unsigned int row);
+        bool addRow(unsigned int pos, const std::vector<std::string> &);
+        void sync(void) const;
+
+    protected:
+    	void parseHeader(void);
+    	void parseContent(void);
+
+    private:
+        std::string _file;
+        const DataType _type;
+        const char _sep;
+        std::vector<std::string> _originalFile;
+        std::vector<std::string> _header;
+        std::vector<Row *> _content;
+
+    public:
+        Row &operator[](unsigned int row) const;
+    };
+}
+
+#endif /*!_CSVPARSER_HPP_*/
diff --git a/src/server/scripts/Custom/DBCCreate/DBCCreate.cpp b/src/server/scripts/Custom/DBCCreate/DBCCreate.cpp
new file mode 100644
index 0000000..fcba82a
--- /dev/null
+++ b/src/server/scripts/Custom/DBCCreate/DBCCreate.cpp
@@ -0,0 +1,1092 @@
+ï»¿#pragma execution_character_set("utf-8")
+#include "DBCCreate.h"
+#include <fstream>
+#include <Windows.h>
+#include "shellapi.h"
+#include "../Switch/Switch.h"
+#include "../ItemMod/NoPatchItem.h"
+#include "../CommonFunc/CommonFunc.h"
+
+void DBCCreate::RepStr(std::string &s1, const std::string &s2, const std::string &s3)
+{
+	std::string::size_type pos = 0;
+	std::string::size_type a = s2.size();
+	std::string::size_type b = s3.size();
+	while ((pos = s1.find(s2, pos)) != std::string::npos)
+	{
+		s1.replace(pos, a, s3);
+		pos += b;
+	}
+}
+
+void DBCCreate::RepStr(std::string &s)
+{
+	RepStr(s, "\r", "\\r");
+	RepStr(s, "\n", "\\n");
+	RepStr(s, "\"", "\"\"");
+}
+
+char DBCCreate::GetFieldType(std::string fmt, uint32 index)
+{
+	switch (fmt.at(index))
+	{
+	case 's':
+		return 's';
+	case 'f':
+		return 'f';
+	case 'i':
+	case 'u':
+	case 'n':
+	case 'x':
+	default:
+		return 'i';
+	}
+}
+
+void DBCCreate::OutDBC(std::string file, std::vector<std::vector<std::string>> dbcData, std::string fmt, uint8 type)
+{
+	sLog->outString(">>%s - æ­£å¨åå¥æ°æ®...", file.c_str());
+
+	std::unordered_map<std::string, uint32> stringMap;
+
+	std::vector<char> stringBytes;
+	stringBytes.push_back('\0');
+
+	uint32 wdbc = 0x43424457;
+	uint32 recordCount = dbcData.size();
+	uint32 fieldCount = dbcData.at(0).size();
+	uint32 recordSize = fieldCount * 4;
+
+	ofstream f(file.c_str(), ios::binary);
+
+	f.write((char*)&wdbc, sizeof(uint32));
+	f.write((char*)&recordCount, sizeof(uint32));
+	f.write((char*)&fieldCount, sizeof(uint32));
+	f.write((char*)&recordSize, sizeof(uint32));
+
+
+	for (uint32 i = 0; i < recordCount; i++)
+	{
+		std::vector<std::string> dataList = dbcData.at(i);
+
+		for (uint32 j = 0; j < fieldCount; j++)
+		{
+			switch (GetFieldType(fmt, j))
+			{
+			case 's':
+			{
+				if (dataList[j].empty())
+					continue;
+
+				auto itr = stringMap.find(dataList[j]);
+
+				if (itr == stringMap.end())
+				{
+					stringMap.insert(std::make_pair(dataList[j], stringBytes.size()));
+
+					for (size_t k = 0; k < dataList[j].size(); k++)
+						stringBytes.push_back(dataList[j][k]);
+
+					stringBytes.push_back('\0');
+				}
+			}
+			break;
+			default:
+				break;
+			}
+		}
+	}
+
+
+	uint32 size = stringBytes.size();
+	f.write((char*)&size, sizeof(uint32));
+
+	for (uint32 i = 0; i < recordCount; i++)
+	{
+		std::vector<std::string> dataList = dbcData.at(i);
+
+		for (uint32 j = 0; j < fieldCount; j++)
+		{
+			switch (GetFieldType(fmt, j))
+			{
+			case 'i':
+			{
+				__int64 value = atoll(dataList[j].c_str());
+				f.write((char*)&value, sizeof(uint32));
+			}
+			break;
+			case 'f':
+			{
+				float value = atof(dataList[j].c_str());
+				f.write((char*)&value, sizeof(uint32));
+			}
+			break;
+			case 's':
+			{
+				uint32 value = 0;
+
+				if (!dataList[j].empty())
+				{
+					auto itr = stringMap.find(dataList[j]);
+					value = itr->second;
+				}
+				f.write((char*)&value, sizeof(uint32));
+			}
+			break;
+			default:
+			{
+				uint32 value = atoi(dataList[j].c_str());
+				f.write((char*)&value, sizeof(uint32));
+			}
+			break;
+			}
+		}
+
+		uint32 x = (i + 1) * 100 / recordCount;
+		uint32 y = (i + 2) * 100 / recordCount;
+
+		if (x != 0 && (x != y || x == 100))
+			sLog->outString(">>%s - write data %d%% ", file.c_str(), x);
+	}
+
+	for (uint32 i = 0; i < stringBytes.size(); i++)
+		f.write((char*)&stringBytes[0 + i], sizeof(char));
+
+	f.close();
+
+	std::string serverPath = sSwitch->GetFlagByIndex(ST_DBC_PATH, 1) + file;
+	std::string clientPath = sSwitch->GetFlagByIndex(ST_DBC_PATH, 2) + file;
+
+	switch (type)
+	{
+	case 0:
+		CopyFile(file.c_str(), serverPath.c_str(), FALSE);
+		CopyFile(file.c_str(), clientPath.c_str(), FALSE);
+		sLog->outString(">>%s - æå¡ç«¯è·¯å¾[%s]", file.c_str(), serverPath.c_str());
+		sLog->outString(">>%s - å®¢æ·ç«¯è·¯å¾[%s]", file.c_str(), clientPath.c_str());
+		break;
+	case 1:
+		CopyFile(file.c_str(), serverPath.c_str(), FALSE);
+		sLog->outString(">>%s - æå¡ç«¯è·¯å¾[%s]", file.c_str(), serverPath.c_str());
+		break;
+	case 2:
+		CopyFile(file.c_str(), clientPath.c_str(), FALSE);
+		sLog->outString(">>%s - å®¢æ·ç«¯è·¯å¾[%s]", file.c_str(), clientPath.c_str());
+		break;
+	default:
+		break;
+	}
+
+	remove(file.c_str());
+
+	//Encrypt(file, recordCount, fieldCount);
+}
+
+void DBCCreate::Encrypt(std::string file, uint32 recordCount, uint32 fieldCount)
+{
+	std::string serverPath = sSwitch->GetFlagByIndex(ST_DBC_PATH, 1) + file;
+	std::string clientPath = sSwitch->GetFlagByIndex(ST_DBC_PATH, 2) + file;
+
+	if (strcmp(serverPath.c_str(), clientPath.c_str()) == 0)
+	{
+		sLog->outString(">>%s - æå¡ç«¯ä¸å®¢æ·ç«¯è·¯å¾ç¸åï¼å°æ æ³ä½¿ç¨å®¢æ·ç«¯DBCå å¯åè½...", file.c_str());
+		return;
+	}
+
+	bool encrypt = true;
+
+	std::vector<uint32> fields;
+
+	if (strcmp(file.c_str(), "Spell.dbc") == 0)
+	{
+		//mydbceditor åå·
+		fields.push_back(72);
+		fields.push_back(73);
+		fields.push_back(74);
+		//fields.push_back(96);
+		//fields.push_back(97);
+		//fields.push_back(98);
+	}
+	else
+		encrypt = false;
+
+	if (!encrypt || fields.empty())
+		return;
+
+	FILE *fp;
+	fp = fopen(clientPath.c_str(), "rb+");
+
+	if (NULL != fp)
+	{
+		for (uint32 i = 0; i < recordCount; i++)
+		{
+			for (uint32 j = 0; j < fieldCount; j++)
+			{
+				uint32 offset = 5 * sizeof(uint32) + (i * 234 + j) * sizeof(uint32);
+
+				if (std::find(fields.begin(), fields.end(), j + 1) != fields.end())
+				{
+					uint32 zero = 0;
+
+					if (fseek(fp, offset, SEEK_SET) == 0)
+						fwrite(&zero, sizeof(uint32), 1, fp);
+				}
+			}
+
+			uint32 x = (i + 1) * 100 / recordCount;
+			uint32 y = (i + 2) * 100 / recordCount;
+
+			if (x != 0 && (x != y || x == 100))
+				sLog->outString(">>%s - encrypt client dbc %d%% ", file.c_str(), x);
+		}
+
+		fclose(fp);
+
+		sLog->outString(">>%s - å®¢æ·ç«¯é¨åå å¯å®æ...", file.c_str());
+	}
+	else
+	{
+		sLog->outString(">>%s - æ æ³æå¼[%s]...", file.c_str(), clientPath.c_str());
+		sLog->outString(">>%s - å®¢æ·ç«¯é¨åå å¯å¤±è´¥...", file.c_str());
+	}
+}
+
+void DBCCreate::GenerateTalentSql()
+{
+	//WorldDatabase.DirectPExecute("TRUNCATE TABLE _dbc_talent;");
+	//
+	//for (uint32 id = 0; id < sTalentStore.GetNumRows(); id++)
+	//{
+	//
+	//	TalentEntry const* info = sTalentStore.LookupEntry(id);
+	//
+	//	if (!info)
+	//		continue;
+	//
+	//	WorldDatabase.DirectPExecute("INSERT INTO _dbc_talent("
+	//		"TalentID, TalentTab,"
+	//		"Row, Col, RankID1, RankID2, RankID3, RankID4, RankID5, "
+	//		"DependsOn, DependsOnRank, addToSpellBook ,petMask, petMask1)"
+	//		"VALUES ('%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d');",
+	//		info->TalentID, info->TalentTab, info->Row,info->Col,
+	//		info->RankID[0], info->RankID[1], info->RankID[2], info->RankID[3], info->RankID[4],
+	//		info->DependsOn, info->DependsOnRank, info->addToSpellBook, info->petMask, info->petMask1);
+	//}
+	//
+	//sLog->outString("_dbc_talentæ´æ°å®æ...");
+}
+
+void DBCCreate::GenerateSpellItemEnchantmentSql()
+{
+	WorldDatabase.DirectPExecute("TRUNCATE TABLE _dbc_spellitemenchantment;");
+
+	for (uint32 id = 0; id < sSpellItemEnchantmentStore.GetNumRows(); id++)
+	{
+
+		SpellItemEnchantmentEntry const* info = sSpellItemEnchantmentStore.LookupEntry(id);
+
+		if (!info)
+			continue;
+
+		WorldDatabase.DirectPExecute("INSERT INTO _dbc_spellitemenchantment("
+			"ID, charges,"
+			"type1, type2, type3, amount1, amount2, amount3, spellid1, spellid2, spellid3, "
+			"description, aura_id, slot ,GemID, EnchantmentCondition, requiredSkill, requiredSkillValue, requiredLevel)"
+			"VALUES ('%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%s','%d','%d','%d','%d','%d','%d','%d');",
+			info->ID, info->charges,
+			info->type[0], info->type[1], info->type[2], info->amount[0], info->amount[1], info->amount[2], info->spellid[0], info->spellid[1], info->spellid[2],
+			info->description[4], info->aura_id, info->slot, info->GemID, info->EnchantmentCondition, info->requiredSkill, info->requiredSkillValue, info->requiredLevel);
+	}
+
+	sLog->outString("_dbc_spellitemenchantmentæ´æ°å®æ...");
+}
+
+void DBCCreate::GenerateCharStartOutfitSql()
+{
+	WorldDatabase.DirectPExecute("TRUNCATE TABLE _dbc_charstartoutfit;");
+
+	for (uint32 id = 0; id < sCharStartOutfitStore.GetNumRows(); id++)
+	{
+
+		CharStartOutfitEntry const* info = sCharStartOutfitStore.LookupEntry(id);
+
+		if (!info)
+			continue;
+
+		WorldDatabase.DirectPExecute("INSERT INTO _dbc_charstartoutfit("
+			"Race, Class, Gender,"
+			"Item1, Item2, Item3, Item4, Item5, Item6, Item7, Item8, Item9,Item10, Item11, Item12, Item13, Item14, Item15, Item16, Item17, Item18, Item19,Item20, Item21, Item22, Item23, Item24)"
+			"VALUES ('%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d');",
+			info->Race, info->Class, info->Gender, 
+			info->ItemId[0], info->ItemId[1], info->ItemId[2], info->ItemId[3], info->ItemId[4], info->ItemId[5], info->ItemId[6], info->ItemId[7], info->ItemId[8], info->ItemId[9],
+			info->ItemId[10], info->ItemId[11], info->ItemId[12], info->ItemId[13], info->ItemId[14], info->ItemId[15], info->ItemId[16], info->ItemId[17], info->ItemId[18], info->ItemId[19],
+			info->ItemId[20], info->ItemId[21], info->ItemId[22], info->ItemId[23]);
+	}
+
+	sLog->outString("_dbc_charstartoutfitæ´æ°å®æ...");
+}
+
+void DBCCreate::GenerateItemDisplayInfoSql()
+{
+	WorldDatabase.DirectPExecute("TRUNCATE TABLE _dbc_itemdisplayinfo;");
+
+	for (uint32 id = 0; id < sItemDisplayInfoStore.GetNumRows(); id++)
+	{
+
+		ItemDisplayInfoEntry const* info = sItemDisplayInfoStore.LookupEntry(id);
+
+		if (!info)
+			continue;
+
+		WorldDatabase.DirectPExecute("INSERT INTO _dbc_itemdisplayinfo(ID, LeftModel, RightModel, LeftModelTexture, RightModelTexture, Icon, Field7, Field8, Field9, Field10, Field11, Field12, groupSoundIndex, Field14, Field15, Field16, Field17, Field18, Field19, Field20, Field21, Field22, Field23, Field24, Field25) "
+			"VALUES ('%u','%s','%s','%s','%s','%s','%s','%u','%u','%u','%u','%u','%u','%u','%u','%s','%s','%s','%s','%s','%s','%s','%s','%u','%u');",
+			info->ID, info->Field2, info->Field3, info->Field4, info->Field5, info->inventoryIcon, info->Field7, info->Field8, info->Field9, info->Field10,
+			info->Field11, info->Field12, info->Field13, info->Field14, info->Field15, info->Field16, info->Field17, info->Field18, info->Field19, info->Field20,
+			info->Field21, info->Field22, info->Field23, info->Field24, info->Field25);
+	}
+
+	sLog->outString("_dbc_itemdisplayinfoæ´æ°å®æ...");
+}
+
+void DBCCreate::GenerateSpellIconSql()
+{
+	WorldDatabase.DirectPExecute("TRUNCATE TABLE _dbc_spellicon;");
+
+	for (uint32 id = 0; id < sSpellIconStore.GetNumRows(); id++)
+	{
+
+		SpellIconEntry const* info = sSpellIconStore.LookupEntry(id);
+
+		if (!info)
+			continue;
+
+		PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_INS_SPELL_ICON_DBC);
+		stmt->setUInt32(0, info->ID);
+		stmt->setString(1, info->Icon);
+		WorldDatabase.Execute(stmt);
+	}
+
+	sLog->outString("_dbc_spelliconæ´æ°å®æ...");
+}
+
+void DBCCreate::GenerateItemExtendCostSql()
+{
+	WorldDatabase.DirectPExecute("TRUNCATE TABLE _dbc_itemextendedcost;");
+
+	for (uint32 id = 0; id < sItemExtendedCostStore.GetNumRows(); id++)
+	{
+
+		ItemExtendedCostEntry const* info = sItemExtendedCostStore.LookupEntry(id);
+
+		if (!info)
+			continue;
+
+		WorldDatabase.DirectPExecute("INSERT INTO _dbc_itemextendedcost(ID,honorpoints,arenapoints,arenaslot,item1,item2,item3,item4,item5,reqitemcount1,reqitemcount2,reqitemcount3,reqitemcount4,reqitemcount5,arenarating,uk)"
+			"VALUES ('%u','%u','%u','%u','%u','%u','%u','%u','%u','%u','%u','%u','%u','%u','%u','%u');",
+			info->ID, info->reqhonorpoints, info->reqarenapoints, info->reqarenaslot, info->reqitem[0], info->reqitem[1], info->reqitem[2], info->reqitem[3], info->reqitem[4],
+			info->reqitemcount[0], info->reqitemcount[1], info->reqitemcount[2], info->reqitemcount[3], info->reqitemcount[4], info->reqpersonalarenarating, 0);
+	}
+
+	sLog->outString("_dbc_itemextendedcostæ´æ°å®æ...");
+}
+
+void DBCCreate::GenerateSpellSql()
+{
+	WorldDatabase.DirectPExecute("TRUNCATE TABLE _dbc_spell;");
+
+	for (uint32 id = 0; id < _sSpellStore.GetNumRows(); id++)
+	{
+
+		_SpellEntry const* info = _sSpellStore.LookupEntry(id);
+
+		if (!info)
+			continue;
+
+		PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_INS_SPELL_DBC);
+		uint8 i = 0;
+		stmt->setUInt32(i++, info->Id);
+		stmt->setUInt32(i++, info->Category);
+		stmt->setUInt32(i++, info->Dispel);
+		stmt->setUInt32(i++, info->Mechanic);
+		stmt->setUInt64(i++, info->Attributes);
+		stmt->setUInt64(i++, info->AttributesEx);
+		stmt->setUInt64(i++, info->AttributesEx2);
+		stmt->setUInt64(i++, info->AttributesEx3);
+		stmt->setUInt64(i++, info->AttributesEx4);
+		stmt->setUInt64(i++, info->AttributesEx5);
+		stmt->setUInt64(i++, info->AttributesEx6);
+		stmt->setUInt64(i++, info->AttributesEx7);
+		stmt->setUInt32(i++, info->Stances);
+		stmt->setUInt32(i++, info->unk_320_2);
+		stmt->setUInt32(i++, info->StancesNot);
+		stmt->setUInt32(i++, info->unk_320_3);
+		stmt->setUInt32(i++, info->Targets);
+		stmt->setUInt32(i++, info->TargetCreatureType);
+		stmt->setUInt32(i++, info->RequiresSpellFocus);
+		stmt->setUInt32(i++, info->FacingCasterFlags);
+		stmt->setUInt32(i++, info->CasterAuraState);
+		stmt->setUInt32(i++, info->TargetAuraState);
+		stmt->setUInt32(i++, info->CasterAuraStateNot);
+		stmt->setUInt32(i++, info->TargetAuraStateNot);
+		stmt->setUInt32(i++, info->casterAuraSpell);
+		stmt->setUInt32(i++, info->targetAuraSpell);
+		stmt->setUInt32(i++, info->excludeCasterAuraSpell);
+		stmt->setUInt32(i++, info->excludeTargetAuraSpell);
+		stmt->setUInt32(i++, info->CastingTimeIndex);
+		stmt->setUInt32(i++, info->RecoveryTime);
+		stmt->setUInt32(i++, info->CategoryRecoveryTime);
+		stmt->setUInt32(i++, info->InterruptFlags);
+		stmt->setUInt32(i++, info->AuraInterruptFlags);
+		stmt->setUInt32(i++, info->ChannelInterruptFlags);
+		stmt->setUInt32(i++, info->procFlags);
+		stmt->setUInt32(i++, info->procChance);
+		stmt->setUInt32(i++, info->procCharges);
+		stmt->setUInt32(i++, info->maxLevel);
+		stmt->setUInt32(i++, info->baseLevel);
+		stmt->setUInt32(i++, info->spellLevel);
+		stmt->setUInt32(i++, info->DurationIndex);
+		if (info->powerType > 127)
+			stmt->setInt32(i++, -2);
+		else
+			stmt->setInt32(i++, info->powerType);
+		stmt->setUInt32(i++, info->manaCost);
+		stmt->setUInt32(i++, info->manaCostPerlevel);
+		stmt->setUInt32(i++, info->manaPerSecond);
+		stmt->setUInt32(i++, info->manaPerSecondPerLevel);
+		stmt->setUInt32(i++, info->rangeIndex);
+		stmt->setFloat(i++, info->speed);
+		stmt->setUInt32(i++, info->modalNextSpell);
+		stmt->setUInt32(i++, info->StackAmount);
+		stmt->setUInt32(i++, info->Totem[0]);
+		stmt->setUInt32(i++, info->Totem[1]);
+		stmt->setInt32(i++, info->Reagent[0]);
+		stmt->setInt32(i++, info->Reagent[1]);
+		stmt->setInt32(i++, info->Reagent[2]);
+		stmt->setInt32(i++, info->Reagent[3]);
+		stmt->setInt32(i++, info->Reagent[4]);
+		stmt->setInt32(i++, info->Reagent[5]);
+		stmt->setInt32(i++, info->Reagent[6]);
+		stmt->setInt32(i++, info->Reagent[7]);
+		stmt->setInt32(i++, info->ReagentCount[0]);
+		stmt->setInt32(i++, info->ReagentCount[1]);
+		stmt->setInt32(i++, info->ReagentCount[2]);
+		stmt->setInt32(i++, info->ReagentCount[3]);
+		stmt->setInt32(i++, info->ReagentCount[4]);
+		stmt->setInt32(i++, info->ReagentCount[5]);
+		stmt->setInt32(i++, info->ReagentCount[6]);
+		stmt->setInt32(i++, info->ReagentCount[7]);
+		stmt->setInt32(i++, info->EquippedItemClass);
+		stmt->setInt32(i++, info->EquippedItemSubClassMask);
+		stmt->setInt32(i++, info->EquippedItemInventoryTypeMask);
+		stmt->setUInt32(i++, info->Effect[0]);
+		stmt->setUInt32(i++, info->Effect[1]);
+		stmt->setUInt32(i++, info->Effect[2]);
+		stmt->setInt32(i++, info->EffectDieSides[0]);
+		stmt->setInt32(i++, info->EffectDieSides[1]);
+		stmt->setInt32(i++, info->EffectDieSides[2]);
+		stmt->setFloat(i++, info->EffectRealPointsPerLevel[0]);
+		stmt->setFloat(i++, info->EffectRealPointsPerLevel[1]);
+		stmt->setFloat(i++, info->EffectRealPointsPerLevel[2]);
+		stmt->setInt32(i++, info->EffectBasePoints[0]);
+		stmt->setInt32(i++, info->EffectBasePoints[1]);
+		stmt->setInt32(i++, info->EffectBasePoints[2]);
+		stmt->setUInt32(i++, info->EffectMechanic[0]);
+		stmt->setUInt32(i++, info->EffectMechanic[1]);
+		stmt->setUInt32(i++, info->EffectMechanic[2]);
+		stmt->setUInt32(i++, info->EffectImplicitTargetA[0]);
+		stmt->setUInt32(i++, info->EffectImplicitTargetA[1]);
+		stmt->setUInt32(i++, info->EffectImplicitTargetA[2]);
+		stmt->setUInt32(i++, info->EffectImplicitTargetB[0]);
+		stmt->setUInt32(i++, info->EffectImplicitTargetB[1]);
+		stmt->setUInt32(i++, info->EffectImplicitTargetB[2]);
+		stmt->setUInt32(i++, info->EffectRadiusIndex[0]);
+		stmt->setUInt32(i++, info->EffectRadiusIndex[1]);
+		stmt->setUInt32(i++, info->EffectRadiusIndex[2]);
+		stmt->setUInt32(i++, info->EffectApplyAuraName[0]);
+		stmt->setUInt32(i++, info->EffectApplyAuraName[1]);
+		stmt->setUInt32(i++, info->EffectApplyAuraName[2]);
+		stmt->setUInt32(i++, info->EffectAmplitude[0]);
+		stmt->setUInt32(i++, info->EffectAmplitude[1]);
+		stmt->setUInt32(i++, info->EffectAmplitude[2]);
+		stmt->setFloat(i++, info->EffectValueMultiplier[0]);
+		stmt->setFloat(i++, info->EffectValueMultiplier[1]);
+		stmt->setFloat(i++, info->EffectValueMultiplier[2]);
+		stmt->setUInt32(i++, info->EffectChainTarget[0]);
+		stmt->setUInt32(i++, info->EffectChainTarget[1]);
+		stmt->setUInt32(i++, info->EffectChainTarget[2]);
+		stmt->setUInt32(i++, info->EffectItemType[0]);
+		stmt->setUInt32(i++, info->EffectItemType[1]);
+		stmt->setUInt32(i++, info->EffectItemType[2]);
+		stmt->setInt32(i++, info->EffectMiscValue[0]);
+		stmt->setInt32(i++, info->EffectMiscValue[1]);
+		stmt->setInt32(i++, info->EffectMiscValue[2]);
+		stmt->setInt32(i++, info->EffectMiscValueB[0]);
+		stmt->setInt32(i++, info->EffectMiscValueB[1]);
+		stmt->setInt32(i++, info->EffectMiscValueB[2]);
+		stmt->setInt32(i++, info->EffectTriggerSpell[0]);
+		stmt->setInt32(i++, info->EffectTriggerSpell[1]);
+		stmt->setInt32(i++, info->EffectTriggerSpell[2]);
+		stmt->setFloat(i++, info->EffectPointsPerComboPoint[0]);
+		stmt->setFloat(i++, info->EffectPointsPerComboPoint[1]);
+		stmt->setFloat(i++, info->EffectPointsPerComboPoint[2]);
+		stmt->setUInt64(i++, info->EffectSpellClassMask[0][0]);
+		stmt->setUInt64(i++, info->EffectSpellClassMask[0][1]);
+		stmt->setUInt64(i++, info->EffectSpellClassMask[0][2]);
+		stmt->setUInt64(i++, info->EffectSpellClassMask[1][0]);
+		stmt->setUInt64(i++, info->EffectSpellClassMask[1][1]);
+		stmt->setUInt64(i++, info->EffectSpellClassMask[1][2]);
+		stmt->setUInt64(i++, info->EffectSpellClassMask[2][0]);
+		stmt->setUInt64(i++, info->EffectSpellClassMask[2][1]);
+		stmt->setUInt64(i++, info->EffectSpellClassMask[2][2]);
+		stmt->setUInt32(i++, info->SpellVisual[0]);
+		stmt->setUInt32(i++, info->SpellVisual[1]);
+		stmt->setUInt32(i++, info->SpellIconID);
+		stmt->setUInt32(i++, info->activeIconID);
+		stmt->setUInt32(i++, info->spellPriority);
+		stmt->setString(i++, info->SpellName[4]);
+		stmt->setUInt32(i++, info->SpellNameFlag);
+		stmt->setString(i++, info->Rank[4]);
+		stmt->setUInt32(i++, info->RankFlags);
+		stmt->setString(i++, info->Description[4]);
+		stmt->setUInt32(i++, info->DescriptionFlags);
+		stmt->setString(i++, info->ToolTip[4]);
+		stmt->setUInt32(i++, info->ToolTipFlags);
+		stmt->setUInt32(i++, info->ManaCostPercentage);
+		stmt->setUInt32(i++, info->StartRecoveryCategory);
+		stmt->setUInt32(i++, info->StartRecoveryTime);
+		stmt->setUInt32(i++, info->MaxTargetLevel);
+		stmt->setUInt32(i++, info->SpellFamilyName);
+		stmt->setUInt64(i++, info->SpellFamilyFlags[0]);
+		stmt->setUInt64(i++, info->SpellFamilyFlags[1]);
+		stmt->setUInt64(i++, info->SpellFamilyFlags[2]);
+		stmt->setUInt32(i++, info->MaxAffectedTargets);
+		stmt->setUInt32(i++, info->DmgClass);
+		stmt->setUInt32(i++, info->PreventionType);
+		stmt->setInt32(i++, info->StanceBarOrder);
+		stmt->setFloat(i++, info->EffectDamageMultiplier[0]);
+		stmt->setFloat(i++, info->EffectDamageMultiplier[1]);
+		stmt->setFloat(i++, info->EffectDamageMultiplier[2]);
+		stmt->setUInt32(i++, info->MinFactionId);
+		stmt->setUInt32(i++, info->MinReputation);
+		stmt->setUInt32(i++, info->RequiredAuraVision);
+		stmt->setUInt32(i++, info->TotemCategory[0]);
+		stmt->setUInt32(i++, info->TotemCategory[1]);
+		stmt->setInt32(i++, info->AreaGroupId);
+		stmt->setUInt32(i++, info->SchoolMask);
+		stmt->setUInt32(i++, info->runeCostID);
+		stmt->setUInt32(i++, info->spellMissileID);
+		stmt->setInt32(i++, info->PowerDisplayId);
+		stmt->setFloat(i++, info->EffectBonusMultiplier[0]);
+		stmt->setFloat(i++, info->EffectBonusMultiplier[1]);
+		stmt->setFloat(i++, info->EffectBonusMultiplier[2]);
+		stmt->setInt32(i++, info->spellDescriptionVariableID);
+		stmt->setUInt32(i++, info->SpellDifficultyId);
+		WorldDatabase.Execute(stmt);
+	}
+
+	sLog->outString("_dbc_spellæ´æ°å®æ...");
+}
+
+void DBCCreate::GenerateItemDBC()
+{
+	std::vector<std::vector<std::string>> dbcData;
+	std::string file = "Item.dbc";
+	std::string fmt = "niiiiiii";
+	uint32 index = 0;
+	std::vector<uint32> EntryVec;
+
+	if (QueryResult result = WorldDatabase.PQuery("SELECT entry,class,subclass,SoundOverrideSubclass,Material,displayid,InventoryType,sheath FROM item_template ORDER BY entry ASC"))
+	{
+		do
+		{
+			std::vector<std::string> v;
+			Field* fields = result->Fetch();
+
+			EntryVec.push_back(fields[0].GetUInt32());
+
+			for (uint8 i = 0; i < 8; i++)
+				v.push_back(fields[i].GetString());
+
+			dbcData.push_back(v);
+
+			index++;
+
+			if (index % 100 == 0)
+				sLog->outString(">>%s - packet data %d...", file.c_str(), index);
+
+		} while (result->NextRow());
+	}
+
+	for (uint32 id = 0; id < sItemStore.GetNumRows(); id++)
+	{
+		ItemEntry const* info = sItemStore.LookupEntry(id);
+
+		if (!info || info->ID > 56806)
+			continue;
+
+		if (std::find(EntryVec.begin(), EntryVec.end(), info->ID) != EntryVec.end())
+			continue;
+
+		std::vector<std::string> v;
+		v.push_back(std::to_string(info->ID));
+		v.push_back(std::to_string(info->Class));
+		v.push_back(std::to_string(info->SubClass));
+		v.push_back(std::to_string(info->SoundOverrideSubclass));
+		v.push_back(std::to_string(info->Material));
+		v.push_back(std::to_string(info->DisplayId));
+		v.push_back(std::to_string(info->InventoryType));
+		v.push_back(std::to_string(info->Sheath));
+		dbcData.push_back(v);
+
+		index++;
+
+		if (index % 100 == 0)
+			sLog->outString(">>%s - packet data %d...", file.c_str(), index);
+	}
+
+	OutDBC(file, dbcData, fmt);
+}
+
+void DBCCreate::GenerateItemDisplayInfoDBC()
+{
+	std::vector<std::vector<std::string>> dbcData;
+	std::string file = "ItemDisplayInfo.dbc";
+	std::string fmt = "nssssssiiiiiiiissssssssii";
+	uint32 index = 0;
+	//1		//2			//3			//4				//5				//6			//7	//8		//9			//10	//11	//12		//13			//14	//15	//16	//17	//18		//19	//20	//21	//22		//23	//24	//25
+	if (QueryResult result = WorldDatabase.PQuery("SELECT ID, LeftModel, RightModel, LeftModelTexture, RightModelTexture, Icon, Field7, Field8, Field9, Field10, Field11, Field12, groupSoundIndex, Field14, Field15, Field16, Field17, Field18, Field19, Field20, Field21, Field22, Field23, Field24, Field25 FROM _dbc_itemdisplayinfo  ORDER BY ID ASC"))
+	{
+		do
+		{
+			std::vector<std::string> v;
+			Field* fields = result->Fetch();
+			for (uint8 i = 0; i < 25; i++)
+				v.push_back(fields[i].GetString());
+		
+			dbcData.push_back(v);
+
+			index++;
+			sLog->outString(">>%s - packet data %d...", file.c_str(), index);
+
+		} while (result->NextRow());
+	}
+
+	OutDBC(file, dbcData, fmt);
+}
+
+void DBCCreate::GenerateItemExtendCostDBC()
+{
+	std::vector<std::vector<std::string>> dbcData;
+	std::string file = "ItemExtendedCost.dbc";
+	std::string fmt = "niiiiiiiiiiiiiix";
+	uint32 index = 0;									//1		//2			//3			//4		//5		//6	//7		//8	//9		//10		//11			//12		//13			//14		/15			//16
+	if (QueryResult result = WorldDatabase.PQuery("SELECT ID,honorpoints,arenapoints,arenaslot,item1,item2,item3,item4,item5,reqitemcount1,reqitemcount2,reqitemcount3,reqitemcount4,reqitemcount5,arenarating,uk FROM _dbc_itemextendedcost ORDER BY ID ASC"))
+	{
+		do
+		{
+			std::vector<std::string> v;
+			Field* fields = result->Fetch();
+
+			for (size_t i = 0; i < 16; i++)
+				v.push_back(fields[i].GetString());
+
+			dbcData.push_back(v);
+
+			index++;
+
+			if (index % 200 == 0)
+				sLog->outString(">>%s - packet data %d...", file.c_str(), index);
+
+		} while (result->NextRow());
+	}
+
+	OutDBC(file, dbcData, fmt);
+}
+
+void DBCCreate::GenerateSpellDBC()
+{
+	std::vector<std::vector<std::string>> dbcData;
+	std::string file = "Spell.dbc";
+	std::string fmt = "niiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiifiiiiiiiiiiiiiiiiiiiiiiiiiiiiifffiiiiiiiiiiiiiiiiiiiiifffiiiiiiiiiiiiiiifffiiiiiiiiiiiiiissssssssssssssssissssssssssssssssissssssssssssssssissssssssssssssssiiiiiiiiiiiiifffiiiiiiiiiifffii";
+	uint32 index = 0;
+	if (QueryResult result = WorldDatabase.PQuery(
+				//1	//2			//3		//4		//5			//6				//7				//8			//9				//10			//11			//12
+		"SELECT Id, Category, Dispel, Mechanic, Attributes, AttributesEx, AttributesEx2, AttributesEx3, AttributesEx4, AttributesEx5, AttributesEx6, AttributesEx7, "
+		//13		//14		//15		//16		//17		//18			//19				//20				//21
+		"Stances, unk_320_2, StancesNot, unk_320_3, Targets, TargetCreatureType, RequiresSpellFocus, FacingCasterFlags, CasterAuraState, "
+		//22				//23				//24				//25			//26				//27					//28
+		"TargetAuraState, CasterAuraStateNot, TargetAuraStateNot, casterAuraSpell, targetAuraSpell, excludeCasterAuraSpell, excludeTargetAuraSpell, "
+		//29				//30			//31					//32			//33				//34				//35
+		"CastingTimeIndex, RecoveryTime, CategoryRecoveryTime, InterruptFlags, AuraInterruptFlags, ChannelInterruptFlags, ProcFlags, "
+		//36			//37		//38		//39		//40		//41		//42		//43		//44			//45			//46
+		"ProcChance, ProcCharges, MaxLevel, BaseLevel, SpellLevel, DurationIndex, powerType, manaCost, manaCostPerlevel, manaPerSecond, manaPerSecondPerLevel, "
+		//47			//48		//49		//50		//51	//52	//53	//54		//55	//56		//57		//58	//59	//60
+		"rangeIndex, speed, modalNextSpell, StackAmount, Totem1, Totem2, Reagent1, Reagent2, Reagent3, Reagent4, Reagent5, Reagent6, Reagent7, Reagent8, "
+		//61				//62		//63			//64			//65			//66		//67			//68
+		"ReagentCount1, ReagentCount2, ReagentCount3, ReagentCount4, ReagentCount5, ReagentCount6, ReagentCount7, ReagentCount8, "
+		//69					//70					//71							//72	//73	//74		/75				//76			//77
+		"EquippedItemClass, EquippedItemSubClassMask, EquippedItemInventoryTypeMask, Effect1, Effect2, Effect3, EffectDieSides1, EffectDieSides2, EffectDieSides3, "
+		//78							//79					//80						//81				//82				//83
+		"EffectRealPointsPerLevel1, EffectRealPointsPerLevel2, EffectRealPointsPerLevel3, EffectBasePoints1, EffectBasePoints2, EffectBasePoints3, "
+		//84				//85			//86				//87					//88					//89
+		"EffectMechanic1, EffectMechanic2, EffectMechanic3, EffectImplicitTargetA1, EffectImplicitTargetA2, EffectImplicitTargetA3, "
+		//90						//91					//92					//93				//94				//95
+		"EffectImplicitTargetB1, EffectImplicitTargetB2, EffectImplicitTargetB3, EffectRadiusIndex1, EffectRadiusIndex2, EffectRadiusIndex3, "
+		//96						//97				//98				//99				//100			//101
+		"EffectApplyAuraName1, EffectApplyAuraName2, EffectApplyAuraName3, EffectAmplitude1, EffectAmplitude2, EffectAmplitude3, "
+		//102						//103					//104					//105				//106				//107
+		"EffectValueMultiplier1, EffectValueMultiplier2, EffectValueMultiplier3, EffectChainTarget1, EffectChainTarget2, EffectChainTarget3, "
+		//108				//109			//110				//111			//112				//113
+		"EffectItemType1, EffectItemType2, EffectItemType3, EffectMiscValueA1, EffectMiscValueA2, EffectMiscValueA3, "
+		//114					//115			//116				//117				//118					//119
+		"EffectMiscValueB1, EffectMiscValueB2, EffectMiscValueB3, EffectTriggerSpell1, EffectTriggerSpell2, EffectTriggerSpell3, "
+		//120							//121						//122
+		"EffectPointsPerComboPoint1, EffectPointsPerComboPoint2, EffectPointsPerComboPoint3, "
+		//123						//124					//125					//126					//127					//128					//129					//130					//131
+		"EffectSpellClassMaskA1, EffectSpellClassMaskA2, EffectSpellClassMaskA3, EffectSpellClassMaskB1, EffectSpellClassMaskB2, EffectSpellClassMaskB3, EffectSpellClassMaskC1, EffectSpellClassMaskC2, EffectSpellClassMaskC3, "
+		//132				//133		//134		//135			//136		//137		//138		//139	//140		//141		//142				//143		//144	
+		"SpellVisual1, SpellVisual2, SpellIconID, activeIconID, spellPriority, SpellName, SpellNameFlag, Rank, RankFlags, Description, DescriptionFlags, ToolTip, ToolTipFlags, "
+		//145					//146				//147				//148				//149			//150			//151				//152
+		"ManaCostPercentage, StartRecoveryCategory, StartRecoveryTime, MaxTargetLevel, SpellFamilyName, SpellFamilyFlags1, SpellFamilyFlags2, SpellFamilyFlags3, "
+		//153					//154		//155		//156			//157						//158					//159
+		"MaxAffectedTargets, DmgClass, PreventionType, StanceBarOrder, EffectDamageMultiplier1, EffectDamageMultiplier2, EffectDamageMultiplier3, "
+		//160			//161			//162				//163			//164			//165		//166		//167			//168		//169
+		"MinFactionId, MinReputation, RequiredAuraVision, TotemCategory1, TotemCategory2, AreaGroupId, SchoolMask, runeCostID, spellMissileID, PowerDisplayId, "
+		//170						//171					//172					//173						//174		
+		"EffectBonusMultiplier1, EffectBonusMultiplier2, EffectBonusMultiplier3, spellDescriptionVariableID, SpellDifficultyId FROM _dbc_spell  ORDER BY Id ASC"))
+	{
+		do
+		{
+			std::vector<std::string> v;
+			Field* fields = result->Fetch();
+
+			for (size_t i = 0; i < 136; i++)
+				v.push_back(fields[i].GetString());
+			
+			std::string SpellName			= fields[136].GetString();
+			std::string SpellNameFlag		= fields[137].GetString();
+			std::string Rank				= fields[138].GetString();
+			std::string RankFlags			= fields[139].GetString();
+			std::string Description			= fields[140].GetString();
+			std::string DescriptionFlags	= fields[141].GetString();
+			std::string ToolTip				= fields[142].GetString();
+			std::string ToolTipFlags		= fields[143].GetString();
+
+			//SpellName
+			for (size_t i = 0; i < 16; i++)
+			{
+				if (i == 4)
+					v.push_back(fields[136].GetString());
+				else
+					v.push_back("");
+			}
+			//SpellNameFlag
+			v.push_back(fields[137].GetString());
+			//Rank
+			for (size_t i = 0; i < 16; i++)
+			{
+				if (i == 4)
+					v.push_back(fields[138].GetString());
+				else
+					v.push_back("");
+			}
+			//RankFlags
+			v.push_back(fields[139].GetString());
+			//Description
+			for (size_t i = 0; i < 16; i++)
+			{
+				if (i == 4)
+					v.push_back(fields[140].GetString());
+				else
+					v.push_back("");
+			}
+			//DescriptionFlags
+			v.push_back(fields[141].GetString());
+			//ToolTip
+			for (size_t i = 0; i < 16; i++)
+			{
+				if (i == 4)
+					v.push_back(fields[142].GetString());
+				else
+					v.push_back("");
+			}
+			//ToolTipFlags
+			v.push_back(fields[143].GetString());
+
+			for (size_t i = 144; i < 174; i++)
+				v.push_back(fields[i].GetString());
+
+			dbcData.push_back(v);
+
+			index++;
+
+			if (index % 200 == 0)
+				sLog->outString(">>%s - packet data %d...", file.c_str(), index);
+
+		} while (result->NextRow());
+	}
+
+
+	//OutDBC(file, dbcData, fmt);
+
+	std::string serverPath = sSwitch->GetFlagByIndex(ST_DBC_PATH, 1) + file;
+	std::string clientPath = sSwitch->GetFlagByIndex(ST_DBC_PATH, 2) + file;
+
+	if (strcmp(serverPath.c_str(), clientPath.c_str()) == 0)
+	{
+		OutDBC(file, dbcData, fmt);
+		sLog->outString(">>%s - æå¡ç«¯ä¸å®¢æ·ç«¯è·¯å¾ç¸åï¼å°æ æ³ä½¿ç¨å®¢æ·ç«¯DBCå å¯åè½...", file.c_str());
+		return;
+	}
+
+	OutDBC(file, dbcData, fmt, 1);
+
+	for (size_t i = 0; i < dbcData.size(); i++)
+	{
+		if (atoi(dbcData[i][0].c_str()) <= 90000)
+			continue;
+
+		bool flag = false;
+
+		for (size_t j = 0; j < dbcData[i].size(); j++)
+		{
+			uint32 col = j + 1;
+
+			if (col == 117 || col == 118 || col == 119 || col == 230 || col == 231 || col == 232)
+			{
+				dbcData[i][j] = "0";
+				flag = true;
+			}
+				
+			if (col == 72 || col == 73 || col == 74)
+			{
+				if (strcmp(dbcData[i][j].c_str(), "6") == 0)// && strcmp(dbcData[i][13].c_str(), "1") != 0)
+				{
+					dbcData[i][j + 24] = "0";
+					flag = true;
+				}			
+			}			
+		}
+
+		if (flag)
+			sLog->outString(">>Spell.dbc - Encrypt data %s...", dbcData[i][0].c_str());
+
+	}
+
+	OutDBC(file, dbcData, fmt, 2);
+}
+
+void DBCCreate::GenerateCharStartOutfitDBC()
+{
+	sLog->outString("_dbc_charstartoutfitæªå®æå¼å");
+	return;
+	std::vector<std::vector<std::string>> dbcData;
+	std::string file = "CharStartOutfit.dbc";
+	std::string fmt = "dbbbXiiiiiiiiiiiiiiiiiiiiiiiixxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
+	uint32 index = 0;
+	if (QueryResult result = WorldDatabase.PQuery("SELECT "
+		//1		//2		//3
+		"Race, Class, Gender, "
+		//4	- 28
+		"Item1, Item2, Item3, Item4, Item5, Item6, Item7, Item8, Item9,Item10, Item11, Item12, Item13, Item14, Item15, Item16, Item17, Item18, Item19,Item20, Item21, Item22, Item23, Item24 "
+		"FROM _dbc_charstartoutfit ORDER BY Race ASC"))
+	{
+		do
+		{
+			std::vector<std::string> v;
+			Field* fields = result->Fetch();
+			v.push_back(std::to_string(index + 1));	//ID
+			v.push_back(fields[0].GetString());		//race
+			v.push_back(fields[1].GetString());		//class
+			v.push_back(fields[2].GetString());		//gender
+			v.push_back("0");						//unused
+
+			//itemid
+			for (size_t i = 0; i < 24; i++)
+				v.push_back(fields[3 + i].GetString());
+
+			//displayid
+			for (size_t i = 0; i < 24; i++)
+			{
+				uint32 entry = fields[3 + i].GetUInt32();
+				const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+
+				if (!temp)
+					v.push_back("-1");
+				else
+					v.push_back(std::to_string(temp->DisplayInfoID));
+			}
+
+			//inventory
+			for (size_t i = 0; i < 24; i++)
+			{
+				uint32 entry = fields[3 + i].GetUInt32();
+				const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+
+				if (!temp)
+					v.push_back("-1");
+				else
+					v.push_back(std::to_string(temp->InventoryType));
+			}
+
+			dbcData.push_back(v);
+
+			index++;
+
+			if (index % 200 == 0)
+				sLog->outString(">>%s - packet data %d...", file.c_str(), index);
+
+
+		} while (result->NextRow());
+	}
+
+	OutDBC(file, dbcData, fmt);
+}
+
+void DBCCreate::GenerateSpellItemEnchantmentDBC()
+{
+	std::vector<std::vector<std::string>> dbcData;
+	std::string file = "SpellItemEnchantment.dbc";
+	std::string fmt = "niiiiiiixxxiiissssssssssssssssxiiiiiii";
+	uint32 index = 0;									
+	if (QueryResult result = WorldDatabase.PQuery(
+				//1	//2			//3		//4	//5		//6		//7			//8		//9		//10		//11
+		"SELECT ID, charges, type1, type2, type3, amount1, amount2, amount3, spellid1, spellid2, spellid3, "
+			//12		//13	//14	//15	//16				//17			//18				//19
+		"description, aura_id, slot ,GemID, EnchantmentCondition, requiredSkill, requiredSkillValue, requiredLevel FROM _dbc_spellitemenchantment ORDER BY ID ASC"))
+	{
+		do
+		{
+			std::vector<std::string> v;
+			Field* fields = result->Fetch();
+
+			v.push_back(fields[0].GetString());
+			v.push_back(fields[1].GetString());
+			v.push_back(fields[2].GetString());
+			v.push_back(fields[3].GetString());
+			v.push_back(fields[4].GetString());
+			v.push_back(fields[5].GetString());
+			v.push_back(fields[6].GetString());
+			v.push_back(fields[7].GetString());
+			v.push_back("0");
+			v.push_back("0");
+			v.push_back("0");
+			v.push_back(fields[8].GetString());
+			v.push_back(fields[9].GetString());
+			v.push_back(fields[10].GetString());
+
+			for (size_t i = 0; i < 16; i++)
+			{
+				if (i != 4)
+					v.push_back("");
+				else
+					v.push_back(fields[11].GetString());
+			}
+
+			v.push_back("16712190");
+			v.push_back(fields[12].GetString());
+			v.push_back(fields[13].GetString());
+			v.push_back(fields[14].GetString());
+			v.push_back(fields[15].GetString());
+			v.push_back(fields[16].GetString());
+			v.push_back(fields[17].GetString());
+			v.push_back(fields[18].GetString());
+
+			dbcData.push_back(v);
+
+			index++;
+			
+			if (index % 200 == 0)
+				sLog->outString(">>%s - packet data %d...", file.c_str(), index);
+
+		} while (result->NextRow());
+	}
+
+	OutDBC(file, dbcData, fmt);
+}
+
+void DBCCreate::GenerateTalentDBC()
+{
+	std::vector<std::vector<std::string>> dbcData;
+	std::string file = "Talent.dbc";
+	std::string fmt = "niiiiiiiixxxxixxixxixxx";
+	uint32 index = 0;
+	if (QueryResult result = WorldDatabase.PQuery(
+		//1			//2		//3		//4
+		"SELECT TalentID, TalentTab, Row, Col, "
+		//5			//6		//7		//8			//9
+		"RankID1, RankID2, RankID3, RankID4, RankID5, "
+		//10			//11		//12			//13		//14
+		"DependsOn, DependsOnRank, addToSpellBook ,petMask, petMask1 FROM _dbc_talent ORDER BY TalentID ASC"))
+	{
+		do
+		{
+			std::vector<std::string> v;
+			Field* fields = result->Fetch();
+
+			v.push_back(fields[0].GetString());	//0
+			v.push_back(fields[1].GetString());	//1
+			v.push_back(fields[2].GetString());	//2
+			v.push_back(fields[3].GetString());	//3
+			v.push_back(fields[4].GetString());	//4
+			v.push_back(fields[5].GetString());	//5
+			v.push_back(fields[6].GetString());	//6
+			v.push_back(fields[7].GetString());	//7
+			v.push_back(fields[8].GetString());	//8
+			v.push_back("0");					//9
+			v.push_back("0");					//10
+			v.push_back("0");					//11
+			v.push_back("0");					//12
+			v.push_back(fields[9].GetString());	//13
+			v.push_back("0");					//14
+			v.push_back("0");					//15
+			v.push_back(fields[10].GetString());//16
+			v.push_back("0");					//17
+			v.push_back("0");					//18
+			v.push_back(fields[11].GetString());//19
+			v.push_back("0");					//20
+			v.push_back(fields[12].GetString());//21
+			v.push_back(fields[13].GetString());//22
+
+			dbcData.push_back(v);
+
+			index++;
+
+			if (index % 200 == 0)
+				sLog->outString(">>%s - packet data %d...", file.c_str(), index);
+
+		} while (result->NextRow());
+	}
+
+	OutDBC(file, dbcData, fmt);
+}
+
+void DBCCreate::GenerateSpellIconDBC()
+{
+	std::vector<std::vector<std::string>> dbcData;
+	std::string file = "SpellIcon.dbc";
+	std::string fmt = "ns";
+	uint32 index = 0;
+	if (QueryResult result = WorldDatabase.PQuery("SELECT ID, Icon FROM _dbc_spellicon  ORDER BY ID ASC"))
+	{
+		do
+		{
+			std::vector<std::string> v;
+			Field* fields = result->Fetch();
+
+			v.push_back(fields[0].GetString());
+			v.push_back(fields[1].GetString());
+			
+			dbcData.push_back(v);
+
+			index++;
+
+			if (index % 200 == 0)
+				sLog->outString(">>%s - packet data %d...", file.c_str(), index);
+
+
+		} while (result->NextRow());
+	}
+
+	OutDBC(file, dbcData, fmt);
+}
diff --git a/src/server/scripts/Custom/DBCCreate/DBCCreate.h b/src/server/scripts/Custom/DBCCreate/DBCCreate.h
new file mode 100644
index 0000000..e44a081
--- /dev/null
+++ b/src/server/scripts/Custom/DBCCreate/DBCCreate.h
@@ -0,0 +1,42 @@
+class DBCCreate
+{
+public:
+	static DBCCreate* instance()
+	{
+		static DBCCreate instance;
+		return &instance;
+	}
+
+	void RepStr(std::string &s1, const std::string &s2, const std::string &s3);
+	void RepStr(std::string &s);
+
+	char GetFieldType(std::string fmt, uint32 index);
+	void OutDBC(std::string file, std::vector<std::vector<std::string>> dbcData, std::string fmt, uint8 type = 0);
+	void Encrypt(std::string file, uint32 recordCount, uint32 fieldCount);
+
+	void GenerateItemDisplayInfoSql();	
+	void GenerateItemDBC();
+	void GenerateItemDisplayInfoDBC();
+
+	void GenerateItemExtendCostSql();
+	void GenerateItemExtendCostDBC();
+
+	void GenerateSpellSql();
+	void GenerateSpellDBC();
+
+	void GenerateCharStartOutfitSql();
+	void GenerateCharStartOutfitDBC();
+
+	void GenerateSpellItemEnchantmentSql();
+	void GenerateSpellItemEnchantmentDBC();
+
+	void GenerateTalentSql();
+	void GenerateTalentDBC();
+
+	void GenerateSpellIconSql();
+	void GenerateSpellIconDBC();
+
+private:
+
+};
+#define sDBCCreate DBCCreate::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/DataLoader/DataLoader.cpp b/src/server/scripts/Custom/DataLoader/DataLoader.cpp
new file mode 100644
index 0000000..a8c45a3
--- /dev/null
+++ b/src/server/scripts/Custom/DataLoader/DataLoader.cpp
@@ -0,0 +1,384 @@
+ï»¿#pragma execution_character_set("utf-8")
+#include "LFGMgr.h"
+#include "../Requirement/Requirement.h"
+#include "../Reward/Reward.h"
+#include "../DataLoader/DataLoader.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../HonorRank/HonorRank.h"
+#include "../Recruit/Recruit.h"
+#include "../SellReward/SellReward.h"
+#include "../FunctionCollection/FunctionCollection.h"
+#include "../ItemMod/ItemMod.h"
+#include "../Quest/QuestMod.h"
+#include "../MapMod/MapMod.h"
+#include "../AntiCheat/AntiCheat.h"
+#include "../UnitMod/CreatureMod/CreatureMod.h"
+#include "../UnitMod/CharMod/CharMod.h"
+#include "../Challenge/challenge.h"
+#include "../Challenge/stage.h"
+#include "../VIP/VIP.h"
+#include "../Switch/Switch.h"
+#include "../Lottery/Lottery.h"
+#include "../MountVendor/MountVendor.h"
+#include "../ExtraEquipment/ExtraEquipment.h"
+#include "../StatPoints/StatPoints.h"
+#include "../String/myString.h"
+#include "../ResetInstance/ResetInstance.h"
+#include "../CustomEvent/FixedTimeBG/FixedTimeBG.h"
+#include "../ServerAnnounce/ServerAnnounce.h"
+#include "../CustomEvent/Event.h"
+#include "../scripts/CustomScripts.h"
+#include "../FakePlayers/FakePlayers.h"
+#include "../SpellMod/SpellMod.h"
+#include "../Deadline/Deadline.h"
+#include "../LeaderReward/LeaderReward.h"
+#include "../Trigger/Trigger.h"
+#include "../QuickResponse/QuickResponse.h"
+#include "../Command/CustomCommand.h"
+#include "../Instance/InstanceDieTele.h"
+#include "../GateWay/GateWay.h"
+#include "../GCAddon/GCAddon.h"
+#include "../Armory/Armory.h"
+#include "../Gift/Gift.h"
+#include "../SignIn/SignIn.h"
+#include "../ItemSet/ItemSet.h"
+#include "../Talisman/Talisman.h"
+#include "../Skill/Skill.h"
+#include "../Rank/Rank.h"
+#include "../Faction/Faction.h"
+#include "../Morph/Morph.h"
+#include "../LuckDraw/LuckDraw.h"
+#include "../Recovery/Recovery.h"
+#include "../PvP/PvP.h"
+#include "../PetMod/PetMod.h"
+#include "../AntiFarm/AntiFarm.h"
+#include "../Faker/Faker.h"
+#include "../RandomEnchant/RandomEnchant.h"
+#include "../ItemMod/NoPatchItem.h"
+#include "../NPC/NPC.h"
+#include "../Reincarnation/Reincarnation.h"
+#include "../TalentReq/TalentReq.h"
+#include "../EquipmentManager/EquipmentManager.h"
+#include "../ZoneAura/ZoneAura.h"
+#include "../PlayerLoot/PlayerLoot.h"
+#include "../UI/Rune/Rune.h"
+#include "../MainFunc/MainFunc.h"
+#include "../GS/GS.h"
+#include "../AuthCheck/AuthCheck.h"
+#include "../CustomEvent/ArenaDuel/ArenaDuel.h"
+#include "../CDK/CDK.h"
+#include "../CharPvpTop/CharPvpTop.h"
+#include "../GvgSys/GvgSys.h"
+/*-----------------------------------------------------------*/
+/*-----------------------------------------------------------*/
+/*-------------------æ°æ®å è½½åº--------------------------------*/
+/*-----------------------------------------------------------*/
+/*-----------------------------------------------------------*/
+
+std::unordered_map<uint32, float> PlayerDropRateMap;
+std::unordered_map<uint32, KillerStreakTemplate> KillerStreakMap;
+std::unordered_map<uint32, MountAllowedTemplate> MountAllowedMap;
+std::unordered_map<uint32, uint32> BuyTransItemMap;
+std::vector<std::string> AddonBanVec;
+std::unordered_map<uint32, float> AreaVisibilityDistMap;
+std::vector<std::string> DirtyWordVector;
+
+void DataLoader::AddLootPl(Player* target, uint32 mod)
+{
+    std::unordered_map<uint32, float>::iterator iter = PlayerDropRateMap.find(target->GetGUIDLow());
+    if (iter != PlayerDropRateMap.end())
+    {
+        iter->second = mod;
+        WorldDatabase.DirectPExecute("UPDATE `_å±æ§è°æ´_ç©å®¶æçä¿®æ¹` SET `æè½åç`='%u' WHERE (`ç©å®¶GUID`='%u')", mod, target->GetGUIDLow());
+    }
+    else
+    {
+        PlayerDropRateMap.insert(std::make_pair(target->GetGUIDLow(), mod));
+        WorldDatabase.DirectPExecute("INSERT INTO `_å±æ§è°æ´_ç©å®¶æçä¿®æ¹` (`ç©å®¶GUID`, `æè½åç`) VALUES ('%u', '%u')", target->GetGUIDLow(), mod);
+    }
+
+}
+
+
+void DataLoader::Load()
+{
+	QueryResult result;
+
+	MountAllowedMap.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//		0			1				2					3
+		"SELECT åéªæè½ID,æ¯å¦åè®¸å®¤åä½¿ç¨,æ¯å¦åè®¸å¯æ¬ä½¿ç¨,æ¯å¦åè®¸æåºä½¿ç¨,"
+		//4				5			6			7		8				9		10			11			12			13
+		"ç¦ç¨å°å¾ID1,ç¦ç¨å°å¾ID2,ç¦ç¨å°å¾ID3,ç¦ç¨å°å¾ID4,ç¦ç¨å°å¾ID5,ç¦ç¨å°å¾ID6,ç¦ç¨å°å¾ID7,ç¦ç¨å°å¾ID8,ç¦ç¨å°å¾ID9,ç¦ç¨å°å¾ID10 FROM _åéª_ä½¿ç¨åºå" :	
+		//		0			 1			2			3
+		"SELECT mountSpellId,indoor,instance,battleground,"
+		//4			5		6		7		8		9		10		11		12		13
+		"banMap1,banMap2,banMap3,banMap4,banMap5,banMap6,banMap7,banMap8,banMap9,banMap10 FROM _mount_allowed"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 mountSpellId = fields[0].GetUInt32();
+			MountAllowedTemplate Temp;
+			Temp.indoor = fields[1].GetBool();
+			Temp.instance = fields[2].GetBool();
+			Temp.battleground = fields[3].GetBool();
+
+			for (size_t i = 0; i < BAN_MAP_MAX; i++)
+				Temp.BanMap[i] = fields[4 + i].GetInt32();
+
+			MountAllowedMap.insert(std::make_pair(mountSpellId, Temp));
+		} while (result->NextRow());
+	}
+
+	KillerStreakMap.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//		0		1				2			3		4			5
+		"SELECT è¿ææ°é, è¿æå¥å±æ¨¡æ¿ID,ç»ç»å¥å±æ¨¡æ¿ID,æç¤ºç±»å,è¿æå¥å±ç±»å,ç»ç»å¥å±ç±»å FROM __è¿æ" :
+		//		0		1		2		3			4		5
+		"SELECT count, rewId,endRewId,announceFlag,rewFlag,endRewFlag FROM _killerstreak"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			KillerStreakTemplate Temp;
+			uint32 num = fields[0].GetUInt32();
+			Temp.rewId = fields[1].GetUInt32();
+			Temp.endRewId = fields[2].GetUInt32();
+			Temp.announceFlag = fields[3].GetUInt32();
+			Temp.rewFlag = fields[4].GetUInt32();
+			Temp.endRewFlag = fields[5].GetUInt32();
+			KillerStreakMap.insert(std::make_pair(num, Temp));
+		} while (result->NextRow());
+	}
+	
+	BuyTransItemMap.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ç©åID, éæ±æ¨¡æ¿ID FROM _ç©å_è´­ä¹°å¹»å" :
+		"SELECT entry, reqId FROM _itemmod_buy_trans"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			BuyTransItemMap.insert(std::make_pair(fields[0].GetUInt32(), fields[1].GetUInt32()));
+		} while (result->NextRow());
+	}
+	
+	PlayerDropRateMap.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ç©å®¶GUID,æè½åç FROM _å±æ§è°æ´_ç©å®¶æçä¿®æ¹" :
+		"SELECT guid,rate FROM _rate_charaters"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			PlayerDropRateMap.insert(std::make_pair(fields[0].GetUInt32(), fields[1].GetFloat()));
+		} while (result->NextRow());
+	}
+
+	AreaVisibilityDistMap.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT å°åID,å¯è§è·ç¦» FROM _å±æ§è°æ´_å°åå¯è§è·ç¦»" :
+		"SELECT Area,Distance FROM _area_visibility"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			AreaVisibilityDistMap.insert(std::make_pair(fields[0].GetUInt32(), fields[1].GetFloat()));
+		} while (result->NextRow());
+	}
+
+	DirtyWordVector.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+		"SELECT å±è½è¯ FROM __èå¤©å±è½è¯åè¡¨" :
+		"SELECT DirtyWord FROM _dirtyword"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			DirtyWordVector.push_back(fields[0].GetString());
+		} while (result->NextRow());
+	}
+}
+
+void DataLoader::LoadAll()
+{
+	sFixtimeBG->Load();
+	sSpellMod->Load();
+	sRandomEnchant->Load();
+	sSwitch->Load();
+	sItemMod->Load();
+	sRew->Load();
+	sRew->LoadDamCreToSend();
+	sReq->Load();
+	//sFC->Load();
+	sMF->Load();
+	sHR->Load();
+	sRecruit->Load();
+	sQuestMod->Load();
+	sMapMod->Load();
+	sCreatureMod->Load();
+	sCharMod->Load();
+	sChallengeMod->Load();
+	sVIP->Load();
+	sLottery->Load();
+	sMountVendor->Load();
+	sStage->Load();
+	sExtraEquipment->Load();
+	sStatPoints->Load();
+	sString->Load();
+	sResetIns->Load();
+	sFTB->Load();
+	sServerAnnounce->Load();
+	sCustomScript->LoadGobScripts();
+	sCustomScript->LoadCreautreScripts();
+	sCustomScript->LoadCircleData();
+	sDeadline->Load();
+	sLeaderReward->Load();
+	sTrigger->Load();
+	sQuickResponse->Load();
+	sCustomCommand->Load();
+	sInstanceDieTele->Load();
+	sGateWay->Load();
+	sGCAddon->Load();
+	sArmory->Load();
+	sGift->Load();
+	sSignIn->Load();
+	sTalisman->Load();
+	sCustomSkill->Load();
+	sRank->Load();
+	sFaction->Load();
+	sEvent->LoadPos();
+	//sMorph->Load();
+	sLuckDraw->Load();
+	sRecovery->Load();
+	sPvP->Load();
+	sPetMod->Load();
+	sAntiFarm->SetParams();
+	Load();
+	//sObjectMgr->LoadVendors();
+	sNoPatchItem->Load();
+	sStory->Load();
+	sReincarnation->Load();
+	sTalentReq->Load();
+	sEM->Load();
+	sZoneAura->Load();
+	sPlayerLoot->Load();
+	sRune->Load();
+	sGS->Load();
+	sItemMod->InitUIItemEntryData();
+	sLFGMgr->LoadRewards();
+	sCDK->Load();
+	sCharPvpTop->LoadTopSys();
+	sGvgSys->LoadgvgSys();
+}
+
+class DataLoaderWorldScript : public WorldScript
+{
+public:
+	DataLoaderWorldScript() : WorldScript("DataLoaderWorldScript") {}
+
+	void OnAfterConfigLoad(bool)
+	{
+		sDataLoader->LoadAll();
+		sFaker->Load();
+		sArenaDuel->Load();
+        sLog->outString("å è½½èªå®ä¹æ°æ®åºå®æ");
+	}
+};
+
+class DataReloaderCommand : public CommandScript
+{
+public:
+	DataReloaderCommand() : CommandScript("DataReloaderCommand") { }
+
+    std::vector<ChatCommand> GetCommands() const
+	{
+		static std::vector<ChatCommand> reloaderCommandTable =
+		{
+			{ "all", SEC_CONSOLE, true, &HandleRlALLCommand, "" },
+			{ "item", SEC_CONSOLE, true, &HandleRlItemCommand, "" },
+			{ "spell", SEC_CONSOLE, true, &HandleRlSpellCommand, "" }
+		};
+
+		static std::vector<ChatCommand> commandTable =
+		{
+			{ "rl", SEC_CONSOLE, true, NULL, "", reloaderCommandTable }
+		};
+
+		return commandTable;
+	}
+
+	static bool HandleRlALLCommand(ChatHandler* handler, const char* /*args*/)
+	{
+		sDataLoader->LoadAll();
+
+		if (!handler->GetSession())
+		{
+			sLog->outString(">> [æ°æ®åº]éè½½å®æ¯...\n");
+			return true;
+		}
+
+		if (handler->GetSession()->GetPlayer())
+			handler->SendSysMessage("[æ°æ®åº]éè½½å®æ¯...");
+
+		return true;
+	}
+
+	static bool HandleRlItemCommand(ChatHandler* handler, const char* /*args*/)
+	{
+		sObjectMgr->LoadItemTemplates();
+
+		if (!handler->GetSession())
+		{
+			sLog->outString(">> [è£å¤ä¿®æ¹æ°æ®è¡¨]éè½½å®æ¯...\n");
+			return true;
+		}
+
+		if (handler->GetSession()->GetPlayer())
+			handler->SendSysMessage(">> [è£å¤ä¿®æ¹æ°æ®è¡¨]éè½½å®æ¯...");
+
+		return true;
+	}
+
+	static bool HandleRlSpellCommand(ChatHandler* handler, const char* /*args*/)
+	{
+		sSpellMgr->LoadDbcDataCorrections();
+
+		if (!handler->GetSession())
+		{
+			sLog->outString(">> [SpellModæ°æ®è¡¨]éè½½å®æ¯...\n");
+			return true;
+		}
+
+		if (handler->GetSession()->GetPlayer())
+			handler->SendSysMessage("[SpellModæ°æ®è¡¨]éè½½å®æ¯...");
+
+		return true;
+	}
+};
+
+class LoaderDataOnLogin : PlayerScript
+{
+public:
+	LoaderDataOnLogin() : PlayerScript("LoaderDataOnLogin") {}
+	void OnLogin(Player* player) override
+	{
+		//åå§åonlineRewardedCount		
+		QueryResult result = CharacterDatabase.PQuery("SELECT onlineRewardedCount FROM characters WHERE guid = '%u'", player->GetGUIDLow());
+		if (!result)
+			player->onlineRewardedCount = 10000;
+		else
+		{
+			Field* fields = result->Fetch();
+			player->onlineRewardedCount = fields[0].GetInt32();
+		}
+	}
+};
+
+void AddSC_Data_Loader()
+{
+	new DataLoaderWorldScript();
+	new DataReloaderCommand();
+	new LoaderDataOnLogin();
+}
diff --git a/src/server/scripts/Custom/DataLoader/DataLoader.h b/src/server/scripts/Custom/DataLoader/DataLoader.h
new file mode 100644
index 0000000..da906e7
--- /dev/null
+++ b/src/server/scripts/Custom/DataLoader/DataLoader.h
@@ -0,0 +1,53 @@
+ï»¿//æç
+extern std::unordered_map<uint32, float> PlayerDropRateMap;
+
+////è¿æ////
+struct KillerStreakTemplate
+{
+	uint32 rewId;
+	uint32 rewFlag;
+	uint32 endRewId;
+	uint32 endRewFlag;
+	uint32 announceFlag;
+};
+extern std::unordered_map<uint32, KillerStreakTemplate> KillerStreakMap;
+
+//åéª
+#define BAN_MAP_MAX 10
+
+struct MountAllowedTemplate
+{
+	bool indoor;
+	bool instance;
+	bool battleground;
+	int BanMap[BAN_MAP_MAX];
+};
+
+extern std::unordered_map<uint32, MountAllowedTemplate> MountAllowedMap;
+
+//å¹»åè´­ä¹°
+extern std::unordered_map<uint32, uint32> BuyTransItemMap;
+
+extern std::unordered_map<uint32, float> AreaVisibilityDistMap;
+
+//è¿æ»¤èå¤©å­ç¬¦
+extern std::vector<std::string> DirtyWordVector;
+
+/*----------------æ°æ®å è½½-------------*/
+class DataLoader
+{
+public:
+	static DataLoader* instance()
+	{
+		static DataLoader instance;
+		return &instance;
+	}
+
+    void AddLootPl(Player* target, uint32 mod);
+	void Load();
+	void LoadAll();
+	
+private:
+	ACE_Thread_Mutex _lock;
+};
+#define sDataLoader DataLoader::instance()
diff --git a/src/server/scripts/Custom/Deadline/Deadline.cpp b/src/server/scripts/Custom/Deadline/Deadline.cpp
new file mode 100644
index 0000000..8b63815
--- /dev/null
+++ b/src/server/scripts/Custom/Deadline/Deadline.cpp
@@ -0,0 +1,169 @@
+#pragma execution_character_set("utf-8")
+#include "Deadline.h"
+#include "Group.h"
+#include "../Reward/Reward.h"
+#include "../String/myString.h"
+#include "../Switch/Switch.h"
+
+std::vector<DeadlineTemplate> DeadlineVec;
+
+void Deadline::Load()
+{
+	DeadlineVec.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT µØÍ¼ID,Ê±¼ä,Í¨¹Ø½±ÀøÄ£°åID,Í¨¹ØÐè»÷É±ÉúÎïID,¸±±¾ÌôÕ½µÈ¼¶,ÊÂ¼þ×´Ì¬ID,Í¨¹ØÕÙ»½ÎïÌåID,¸±±¾ÄÑ¶È FROM _¸±±¾_ÏÞÊ±Ä£Ê½" :
+		"SELECT mapId,countDown,rewId,killedEntry,challengeLv,worldStat,gobEntry,diff FROM _deadline");
+
+	if (!result) return;
+	do
+	{
+		Field* fields = result->Fetch();
+		DeadlineTemplate Temp;
+		Temp.mapId			= fields[0].GetUInt32();
+		Temp.countDown		= fields[1].GetUInt32()  * MINUTE * IN_MILLISECONDS;
+		Temp.rewId			= fields[2].GetUInt32();
+		Temp.killedEntry	= fields[3].GetUInt32();
+		Temp.challengeLv	= fields[4].GetInt32();
+		Temp.worldStat		= fields[5].GetUInt32();
+		Temp.gobEntry		= fields[6].GetUInt32();
+		Temp.diff			= fields[7].GetUInt8();
+		DeadlineVec.push_back(Temp);
+	} while (result->NextRow());
+}
+
+void Deadline::SetActive(Map* map)
+{
+	//if (map->GetDifficulty() != DUNGEON_DIFFICULTY_HEROIC)
+		//return;
+
+	//ÒÑ¼¤»î »ò ÒÑÊ§°Ü
+	if (map->deadlineActive || map->deadlineFailed)
+		return;
+
+	for (std::vector<DeadlineTemplate>::iterator iter = DeadlineVec.begin(); iter != DeadlineVec.end(); ++iter)
+		if (iter->mapId == map->GetId() && iter->challengeLv == map->challengeLv && map->GetDifficulty() == iter->diff)
+		{
+			map->countDown = iter->countDown;
+			map->deadlineActive = true;
+			Announce(map, sString->GetText(CORE_STR_TYPES(STR_DEADLINE_START)));
+			SetWorldState(map, map->countDown / (MINUTE * IN_MILLISECONDS));
+			break;
+		}
+}
+
+void Deadline::Announce(Map* map, const char* text)
+{
+	Map::PlayerList const &players = map->GetPlayers();
+	for (Map::PlayerList::const_iterator i = players.begin(); i != players.end(); ++i)
+	{
+		Player* player = i->GetSource();
+		if (!player)
+			continue;
+
+		ChatHandler(player->GetSession()).PSendSysMessage(text);
+	}
+}
+
+void Deadline::Reward(Player* killer)
+{
+	uint32 rewId = 0;
+	uint32 mapId = killer->GetMapId();
+	Map* map = killer->GetMap();
+
+	if (!map)
+		return;
+
+	for (std::vector<DeadlineTemplate>::iterator iter = DeadlineVec.begin(); iter != DeadlineVec.end(); ++iter)
+		if (iter->mapId == mapId && killer->GetMap()->challengeLv == iter->challengeLv && map->GetDifficulty() == iter->diff)
+		{
+			rewId = iter->rewId;
+			break;
+		}
+
+	if (rewId == 0)
+		return;
+
+	Group* group = killer->GetGroup();
+	if (group)
+	{
+		for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+			if (Player* member = itr->GetSource())
+				if (member->IsInWorld())
+					sRew->Rew(member, rewId);
+	}
+	else
+		sRew->Rew(killer, rewId);
+}
+
+void Deadline::SetWorldState(Map* map, uint32 value)
+{
+	uint32 worldStatType = 0;
+
+	for (std::vector<DeadlineTemplate>::iterator iter = DeadlineVec.begin(); iter != DeadlineVec.end(); ++iter)
+		if (iter->mapId == map->GetId() && map->challengeLv == iter->challengeLv && map->GetDifficulty() == iter->diff)
+		{
+			worldStatType = iter->worldStat;
+			break;
+		}
+
+	if (worldStatType == 0)
+		return;
+
+	Map::PlayerList const &players = map->GetPlayers();
+	for (Map::PlayerList::const_iterator i = players.begin(); i != players.end(); ++i)
+	{
+		Player* player = i->GetSource();
+		if (!player)
+			continue;
+
+		player->SendUpdateWorldState(worldStatType, value);
+	}
+}
+
+class DeadlineKill : PlayerScript
+{
+public:
+	DeadlineKill() : PlayerScript("DeadlineKill") {}
+
+	void OnCreatureKill(Player* killer, Creature* killed) override
+	{
+		if (killer->GetMap()->deadlineFailed)
+			return;
+
+		for (std::vector<DeadlineTemplate>::iterator iter = DeadlineVec.begin(); iter != DeadlineVec.end(); ++iter)
+			if (killed->GetEntry() == iter->killedEntry && killer->GetMap()->challengeLv == iter->challengeLv)
+			{
+				sDeadline->Reward(killer);
+				killer->SummonGameObject(iter->gobEntry, killed->GetPositionX(), killed->GetPositionY(), killed->GetPositionZ(), killed->GetOrientation(), 0, 0, 0, 0, 0);
+				sDeadline->Announce(killer->GetMap(), sString->GetText(CORE_STR_TYPES(STR_DEADLINE_SUCCESS)));
+				break;
+			}
+	}
+
+	void OnMapChanged(Player* player) 
+	{
+		Map* map = player->GetMap();
+
+		if (!map || map->countDown == 0)
+			return;
+
+		if (map->countDown < 0)
+		{
+			sDeadline->Announce(map, sString->GetText(CORE_STR_TYPES(STR_DEADLINE_FAILED)));
+			sDeadline->SetWorldState(map, 0);
+		}
+		else
+		{
+			uint32 leftTime = map->countDown / (60 * IN_MILLISECONDS) + 1;
+			sDeadline->SetWorldState(map, leftTime);
+
+			if (sSwitch->GetOnOff(ST_DEADLINE_TIME_NOTICE))
+				sDeadline->Announce(map, sString->Format(sString->GetText(CORE_STR_TYPES(STR_DEADLINE_TIME_LEFT)), leftTime));
+		}	
+	}
+};
+
+void AddSC_DeadLine()
+{
+	new DeadlineKill();
+}
diff --git a/src/server/scripts/Custom/Deadline/Deadline.h b/src/server/scripts/Custom/Deadline/Deadline.h
new file mode 100644
index 0000000..3c35a3c
--- /dev/null
+++ b/src/server/scripts/Custom/Deadline/Deadline.h
@@ -0,0 +1,31 @@
+struct DeadlineTemplate
+{
+	uint32 mapId;
+	uint32 countDown;
+	uint32 rewId;
+	uint32 killedEntry;
+	uint32 challengeLv;
+	uint32 worldStat;
+	uint32 gobEntry;
+	uint8 diff;
+};
+extern std::vector<DeadlineTemplate> DeadlineVec;
+
+class Deadline
+{
+public:
+	static Deadline* instance()
+	{
+		static Deadline instance;
+		return &instance;
+	}
+
+	void Load();
+	void SetActive(Map* map);
+	void Reward(Player* killer);
+	void Announce(Map* map, const char* text);
+	void SetWorldState(Map* map,uint32 value);
+private:
+
+};
+#define sDeadline Deadline::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/EquipmentManager/EquipmentManager.cpp b/src/server/scripts/Custom/EquipmentManager/EquipmentManager.cpp
new file mode 100644
index 0000000..aaf8e9c
--- /dev/null
+++ b/src/server/scripts/Custom/EquipmentManager/EquipmentManager.cpp
@@ -0,0 +1,318 @@
+#pragma execution_character_set("utf-8")
+#include "EquipmentManager.h"
+#include "Item.h"
+#include "../Custom/ItemMod/NoPatchItem.h"
+#include "..\..\server\scripts\Custom\CommonFunc\CommonFunc.h"
+std::vector<EquipmentTemplate> EquipmentVec;
+
+void Player::InitMapTempItems(uint32 Map)
+{
+    ApplyMapTempItems(false);
+
+    for (uint32 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
+        if (_MapTempItems[i])
+        {
+            delete _MapTempItems[i];
+            _MapTempItems[i] = NULL;
+        }
+
+    CanSawpOnMapTempItems = true;
+
+    for (auto itr = EquipmentVec.begin(); itr != EquipmentVec.end(); itr++)
+    {
+        if (getClass() != itr->_class)
+            continue;
+
+        if (itr->MapOrArea < 0)
+            continue;
+
+        if (itr->MapOrArea != Map)
+            continue;
+
+        for (uint32 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
+            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itr->items[i]))
+            {
+                _MapTempItems[i] = Item::CreateItem(itr->items[i], 1, this);
+                ChatHandler(GetSession()).PSendSysMessage("¼ÓÔØµØÍ¼×°±¸%s..", sCF->GetItemLink(itr->items[i]).c_str());
+            }
+
+        CanSawpOnMapTempItems = false;
+        break;
+    }
+
+    ApplyMapTempItems(true);
+}
+
+bool Player::HasMapTempItems()
+{
+    bool ok = false;
+    for (auto itr = EquipmentVec.begin(); itr != EquipmentVec.end(); itr++)
+    {
+        if (GetMapId() == itr->MapOrArea)
+        {
+            ok = true;
+            return ok;
+            break;
+        }
+    }
+    return ok;
+}
+void Player::InitAreaTempItems(uint32 Area)
+{
+    ApplyAreaTempItems(false);
+
+    for (uint32 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
+        if (_AreaTempItems[i])
+        {
+            delete _AreaTempItems[i];
+            _AreaTempItems[i] = NULL;
+        }
+
+    CanSawpOnAreaTempItems = true;
+
+    for (auto itr = EquipmentVec.begin(); itr != EquipmentVec.end(); itr++)
+    {
+        if (getClass() != itr->_class)
+            continue;
+
+        if (itr->MapOrArea > 0)
+            continue;
+
+        if ((-itr->MapOrArea) != Area)
+            continue;
+
+        for (uint32 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
+            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itr->items[i]))
+            {
+                _AreaTempItems[i] = Item::CreateItem(itr->items[i], 1, this);
+                ChatHandler(GetSession()).PSendSysMessage("¼ÓÔØµØÓò×°±¸%s..", sCF->GetItemLink(itr->items[i]).c_str());
+            }
+
+        CanSawpOnAreaTempItems = false;
+        break;
+    }
+
+    ApplyAreaTempItems(true);
+}
+
+void Player::ApplyMapTempItems(bool apply)
+{
+    if (apply)
+    {
+        for (uint32 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
+        {
+            if (_MapTempItems[i])
+            {
+                SetVisibleItemSlot(i, _MapTempItems[i]);
+
+                if (Item* dscItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                    _ApplyItemMods(dscItem, i, false);
+
+                _ApplyItemMods(_MapTempItems[i], i, true);
+                ChatHandler(GetSession()).PSendSysMessage("¼ÓÔØÇøÓò×°±¸%s..", sCF->GetItemLink(_MapTempItems[i]->GetEntry()).c_str());
+            }
+        }
+    }
+    else
+    {
+        for (uint32 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
+        {
+            if (_MapTempItems[i])
+            {
+                SetVisibleItemSlot(i, NULL);
+                _ApplyItemMods(_MapTempItems[i], i, false);
+                ChatHandler(GetSession()).PSendSysMessage("Ð¶ÔØÇøÓò×°±¸%s..", sCF->GetItemLink(_MapTempItems[i]->GetEntry()).c_str());
+
+                if (Item* dscItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                {
+                    _ApplyItemMods(dscItem, i, true);
+                    SetVisibleItemSlot(i, dscItem);
+                }
+            }
+        }
+    }
+}
+
+void Player::ApplyAreaTempItems(bool apply)
+{
+    if (apply)
+    {
+        for (uint32 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
+        {
+            if (_AreaTempItems[i])
+            {
+                SetVisibleItemSlot(i, _AreaTempItems[i]);
+
+                if (Item* dscItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                    _ApplyItemMods(dscItem, i, false);
+
+                _ApplyItemMods(_AreaTempItems[i], i, true);
+                ChatHandler(GetSession()).PSendSysMessage("¼ÓÔØÇøÓò×°±¸%s..", sCF->GetItemLink(_AreaTempItems[i]->GetEntry()).c_str());
+            }
+        }
+    }
+    else
+    {
+        for (uint32 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
+        {
+            if (_AreaTempItems[i])
+            {
+                SetVisibleItemSlot(i, NULL);
+                _ApplyItemMods(_AreaTempItems[i], i, false);
+                ChatHandler(GetSession()).PSendSysMessage("Ð¶ÔØÇøÓò×°±¸%s..", sCF->GetItemLink(_AreaTempItems[i]->GetEntry()).c_str());
+
+                if (Item* dscItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                {
+                    _ApplyItemMods(dscItem, i, true);
+                    SetVisibleItemSlot(i, dscItem);
+                }
+            }
+        }
+    }
+}
+
+
+void EquipmentManager::Load()
+{
+	EquipmentVec.clear();
+	
+	//QueryResult result = WorldDatabase.PQuery("SELECT class, map, zone, area,"
+	//	"HEAD,NECK,SHOULDERS,BODY,CHEST,WAIST,LEGS,FEET,WRISTS,HANDS,FINGER1,FINGER2,TRINKET1,TRINKET2,BACK,MAINHAND,OFFHAND,RANGED,TABARD "
+	//	"From _equipment");
+	//if (result)
+	//{
+	//	do
+	//	{
+	//		Field* fields = result->Fetch();
+	//		EquipmentTemplate Temp;
+	//		Temp._class = fields[0].GetUInt8();
+	//		Temp.map	= fields[1].GetUInt32();
+	//		Temp.zone	= fields[2].GetUInt32();
+	//		Temp.area	= fields[3].GetUInt32();
+	//
+	//		for (size_t i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
+	//			Temp.slots[i] = fields[i + 4].GetInt32();
+	//
+	//		EquipmentVec.push_back(Temp);
+	//	} while (result->NextRow());
+	//}
+}
+
+bool EquipmentManager::SlotIsFreeze(Player* pl, uint8 slot)
+{
+    /*
+	for (auto itr = EquipmentVec.begin(); itr != EquipmentVec.end(); itr++)
+	{
+		if (itr->_class != pl->getClass())
+			continue;
+
+		uint32 map = pl->GetMapId();
+		uint32 zone = pl->GetZoneId();
+		uint32 area = pl->GetAreaId();
+
+		if (itr->map != map)
+			continue;
+		
+		if (itr->zone == 0 && itr->area == 0 ||
+			itr->zone == zone && itr->area == 0 ||
+			itr->zone == zone && itr->area == area)
+		{
+			for (size_t i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
+			{
+				if (slot != i)
+					continue;
+
+				if (itr->slots[i] != 0)
+					return true;
+			}
+		}
+	}
+    */
+	return false;
+}
+
+void EquipmentManager::Update(Player* pl, uint8 update)
+{
+	if (update != 0)
+		return;
+    /**
+	for (size_t i = KEYRING_SLOT_EM_START; i < KEYRING_SLOT_END; i++)
+		if (Item* item = pl->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+			pl->SwapItem(INVENTORY_SLOT_BAG_0 << 8 | i, INVENTORY_SLOT_BAG_0 << 8 | EQUIPMENT_SLOT_START + i - KEYRING_SLOT_EM_START);
+
+	for (auto itr = EquipmentVec.begin(); itr != EquipmentVec.end(); itr++)
+	{
+		if (itr->_class != pl->getClass())
+			continue;
+
+		uint32 map = pl->GetMapId();
+		uint32 zone = pl->GetZoneId();
+		uint32 area = pl->GetAreaId();
+
+		if (map != itr->map)
+			continue;
+
+		//if (update == 0 && itr->zone == 0 && itr->area == 0 ||
+		//	update == 1 && itr->zone == zone && itr->area == 0 ||
+		//	update == 2 && itr->zone == zone && itr->area == area)
+		{
+			for (size_t slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+			{
+				int32 entry = itr->slots[slot];
+
+				uint16 src = (INVENTORY_SLOT_BAG_0 << 8) | slot;
+				uint16 dst = (INVENTORY_SLOT_BAG_0 << 8) | (KEYRING_SLOT_EM_START + slot);
+
+				if (entry < 0)
+					pl->SwapItem(src, dst);
+				else if (const ItemTemplate* proto = sObjectMgr->GetItemTemplate(entry))
+				{
+					uint32 enchants[MAX_ENCHANTMENT_SLOT];
+					for (uint8 j = 0; j < MAX_ENCHANTMENT_SLOT; ++j)
+						enchants[j] = 0;
+
+					if (Item* srcItem = pl->GetItemByPos(src))
+						for (uint8 j = 0; j < MAX_ENCHANTMENT_SLOT; ++j)
+						{
+							if (j >= SOCK_ENCHANTMENT_SLOT && j <= BONUS_ENCHANTMENT_SLOT)
+								continue;
+
+							enchants[j] = srcItem->GetEnchantmentId(EnchantmentSlot(j));
+						}
+							
+					
+					pl->SwapItem(src, dst);
+
+					if (!pl->GetItemByPos(src))
+					{
+						pl->EquipNewItem(src, entry, true);
+
+						if (Item* srcItem = pl->GetItemByPos(src))
+							for (uint8 j = 0; j < MAX_ENCHANTMENT_SLOT; ++j)
+							{
+								if (j >= SOCK_ENCHANTMENT_SLOT && j <= BONUS_ENCHANTMENT_SLOT)
+									continue;
+
+								pl->ApplyEnchantment(srcItem, EnchantmentSlot(j), false);
+								srcItem->SetEnchantment(EnchantmentSlot(j), enchants[j], 0, 0);
+								pl->ApplyEnchantment(srcItem, EnchantmentSlot(j), true);
+							}
+					}
+						
+				}
+			}
+		}
+	}*/
+}
+
+bool EquipmentManager::InKeyings(Item* item)
+{
+	if (item)
+		return item->GetBagSlot() == INVENTORY_SLOT_BAG_0 && item->GetSlot() >= KEYRING_SLOT_EM_START && item->GetSlot() < KEYRING_SLOT_END;
+	return false;
+}
+
+bool EquipmentManager::InKeyings(uint8 bag, uint8 slot)
+{
+	return bag == INVENTORY_SLOT_BAG_0 && slot >= KEYRING_SLOT_EM_START && slot < KEYRING_SLOT_END;
+}
diff --git a/src/server/scripts/Custom/EquipmentManager/EquipmentManager.h b/src/server/scripts/Custom/EquipmentManager/EquipmentManager.h
new file mode 100644
index 0000000..b420f3b
--- /dev/null
+++ b/src/server/scripts/Custom/EquipmentManager/EquipmentManager.h
@@ -0,0 +1,26 @@
+ï»¿struct EquipmentTemplate
+{
+    uint8 _class;
+    int32 MapOrArea;
+    uint32 items[EQUIPMENT_SLOT_END];
+};
+
+extern std::vector<EquipmentTemplate> EquipmentVec;
+
+class EquipmentManager
+{
+public:
+	static EquipmentManager* instance()
+	{
+		static EquipmentManager instance;
+		return &instance;
+	}
+	void Load();
+	bool SlotIsFreeze(Player* pl, uint8 slot);
+	bool InKeyings(Item* item);
+	bool InKeyings(uint8 bag, uint8 slot);
+	void Update(Player* pl, uint8 update);
+private:
+
+};
+#define sEM EquipmentManager::instance()
diff --git a/src/server/scripts/Custom/ExtraEquipment/ExtraEquipment.cpp b/src/server/scripts/Custom/ExtraEquipment/ExtraEquipment.cpp
new file mode 100644
index 0000000..b979e45
--- /dev/null
+++ b/src/server/scripts/Custom/ExtraEquipment/ExtraEquipment.cpp
@@ -0,0 +1,985 @@
+#pragma execution_character_set("utf-8")
+#include "ExtraEquipment.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
+#include "../Custom/ItemMod/ItemMod.h"
+
+float extra_stat_muil;
+float extra_enchant_stat_muil;
+bool extra_origin_item_back;
+
+std::vector<uint32 /*entry*/> ExtraEuipMentEntryVec;
+
+void ExtraEquipment::Load()
+{
+	extra_stat_muil = 1.0f;
+	extra_enchant_stat_muil = 1.0f;
+	extra_origin_item_back	= false;
+
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÊôÐÔ±¶ÂÊ, ¸½Ä§ÊôÐÔ±¶ÂÊ, ÊÇ·ñ¿ÉÒÔÈ¡»Ø from _ÎïÆ·_Ë«¼×" :
+		"SELECT stat_muil, enchant_muil, originItemEnable from _itemmod_extra_equipments");
+	if (result)
+	{
+		Field* fields = result->Fetch();
+
+		extra_stat_muil = fields[0].GetFloat();
+		extra_enchant_stat_muil = fields[1].GetFloat();
+		extra_origin_item_back	= fields[2].GetBool();
+	}
+
+	ExtraEuipMentEntryVec.clear();
+	QueryResult result1 = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÎïÆ·ID from _ÎïÆ·_Ë«¼×ÁÐ±í" :
+		"SELECT entry from _itemmod_extra_equipments_enable");
+	if (result1)
+	{
+		do
+		{
+			Field* fields = result1->Fetch();
+			ExtraEuipMentEntryVec.push_back(fields[0].GetUInt32());
+		} while (result1->NextRow());
+	}
+
+}
+
+std::string ExtraEquipment::GetItemName(uint32 entry, uint32 width, uint32 height, int x, int y)
+{
+	std::ostringstream ss;
+	ss << "|TInterface";
+	const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+	const ItemDisplayInfoEntry* dispInfo = NULL;
+	if (temp)
+	{
+		dispInfo = sItemDisplayInfoStore.LookupEntry(temp->DisplayInfoID);
+		if (dispInfo)
+			ss << "/ICONS/" << dispInfo->inventoryIcon;
+	}
+	if (!temp && !dispInfo)
+		ss << "/InventoryItems/WoWUnknownItem01";
+	ss << ":" << width << ":" << height << ":" << x << ":" << y << "|t";
+	ss << temp->Name1;
+	return ss.str();
+}
+
+std::string ExtraEquipment::GetSlotDefaultText(EquipmentSlots slot, uint32 width, uint32 height, int x, int y)
+{
+	std::ostringstream ss;
+	ss << "|TInterface/PaperDoll/";
+	switch (slot)
+	{
+	case EQUIPMENT_SLOT_HEAD: ss << "UI-PaperDoll-Slot-Head"; break;
+	case EQUIPMENT_SLOT_SHOULDERS: ss << "UI-PaperDoll-Slot-Shoulder"; break;
+	case EQUIPMENT_SLOT_NECK: ss << "UI-PaperDoll-Slot-Neck"; break;
+	case EQUIPMENT_SLOT_BODY: ss << "UI-PaperDoll-Slot-Shirt"; break;
+	case EQUIPMENT_SLOT_CHEST: ss << "UI-PaperDoll-Slot-Chest"; break;
+	case EQUIPMENT_SLOT_WAIST: ss << "UI-PaperDoll-Slot-Waist"; break;
+	case EQUIPMENT_SLOT_LEGS: ss << "UI-PaperDoll-Slot-Legs"; break;
+	case EQUIPMENT_SLOT_FEET: ss << "UI-PaperDoll-Slot-Feet"; break;
+	case EQUIPMENT_SLOT_WRISTS: ss << "UI-PaperDoll-Slot-Wrists"; break;
+	case EQUIPMENT_SLOT_HANDS: ss << "UI-PaperDoll-Slot-Hands"; break;
+	case EQUIPMENT_SLOT_FINGER1: ss << "UI-PaperDoll-Slot-Finger"; break;
+	case EQUIPMENT_SLOT_FINGER2: ss << "UI-PaperDoll-Slot-Finger"; break;
+	case EQUIPMENT_SLOT_TRINKET1: ss << "UI-PaperDoll-Slot-Trinket"; break;
+	case EQUIPMENT_SLOT_TRINKET2: ss << "UI-PaperDoll-Slot-Trinket"; break;
+	case EQUIPMENT_SLOT_BACK: ss << "UI-PaperDoll-Slot-Chest"; break;
+	case EQUIPMENT_SLOT_MAINHAND: ss << "UI-PaperDoll-Slot-MainHand"; break;
+	case EQUIPMENT_SLOT_OFFHAND: ss << "UI-PaperDoll-Slot-SecondaryHand"; break;
+	case EQUIPMENT_SLOT_RANGED: ss << "UI-PaperDoll-Slot-Ranged"; break;
+	case EQUIPMENT_SLOT_TABARD: ss << "UI-PaperDoll-Slot-Tabard"; break;
+	default: ss << "UI-Backpack-EmptySlot";
+	}
+	ss << ":" << width << ":" << height << ":" << x << ":" << y << "|t";
+
+	ss << "Î´×°±¸";
+
+	return ss.str();
+}
+
+std::string ExtraEquipment::GetSlotText(Player* player, EquipmentSlots slot)
+{
+	uint32 len = player->ExtraEquimentVec.size();
+	for (size_t i = 0; i < len; i++)
+		if (slot == player->ExtraEquimentVec[i].slot)
+			return GetItemName(player->ExtraEquimentVec[i].itemEntry, 30, 30, 0, 0) + GetDes(player,slot);
+
+	return GetSlotDefaultText(slot, 30, 30, 0, 0);
+}
+
+std::string ExtraEquipment::GetStatDes(uint32 entry)
+{
+	const ItemTemplate* proto = sObjectMgr->GetItemTemplate(entry);
+
+	if (!proto)
+		return "";
+
+	std::ostringstream oss;
+
+	//×°±¸ÊôÐÔ
+	for (uint8 k = 0; k < MAX_ITEM_PROTO_STATS; ++k)
+	{
+		if (k >= proto->StatsCount)
+			break;
+
+		uint32 statType = proto->ItemStat[k].ItemStatType;
+		int32  val = proto->ItemStat[k].ItemStatValue *extra_stat_muil;
+
+		if (val == 0)
+			continue;
+
+		switch (statType)
+		{
+		case ITEM_MOD_MANA:
+			oss << "\n              +" << val << "·¨Á¦Öµ";
+			break;
+		case ITEM_MOD_HEALTH:                           // modify HP
+			oss << "\n              +" << val << "ÉúÃüÖµ";
+			break;
+		case ITEM_MOD_AGILITY:                          // modify agility
+			oss << "\n              +" << val << "Ãô½Ý";
+			break;
+		case ITEM_MOD_STRENGTH:                         //modify strength
+			oss << "\n              +" << val << "Á¦Á¿";
+			break;
+		case ITEM_MOD_INTELLECT:                        //modify intellect
+			oss << "\n              +" << val << "ÖÇÁ¦";
+			break;
+		case ITEM_MOD_SPIRIT:                           //modify spirit
+			oss << "\n              +" << val << "¾«Éñ";
+			break;
+		case ITEM_MOD_STAMINA:                          //modify stamina
+			oss << "\n              +" << val << "ÄÍÁ¦";
+			break;
+		case ITEM_MOD_DEFENSE_SKILL_RATING:
+			oss << "\n              +" << val << "·ÀÓùµÈ¼¶";
+			break;
+		case ITEM_MOD_DODGE_RATING:
+			oss << "\n              +" << val << "¶ãÉÁµÈ¼¶";
+			break;
+		case ITEM_MOD_PARRY_RATING:
+			oss << "\n              +" << val << "ÕÐ¼ÜµÈ¼¶";
+			break;
+		case ITEM_MOD_BLOCK_RATING:
+			oss << "\n              +" << val << "¸ñµ²µÈ¼¶";
+			break;
+		case ITEM_MOD_HIT_MELEE_RATING:
+			oss << "\n              +" << val << "ÃüÖÐµÈ¼¶";
+			break;
+		case ITEM_MOD_HIT_RANGED_RATING:
+			oss << "\n              +" << val << "Ô¶³ÌÃüÖÐµÈ¼¶";
+			break;
+		case ITEM_MOD_HIT_SPELL_RATING:
+			oss << "\n              +" << val << "·¨ÊõÃüÖÐµÈ¼¶";
+			break;
+		case ITEM_MOD_CRIT_MELEE_RATING:
+			oss << "\n              +" << val << "±©»÷µÈ¼¶";
+			break;
+		case ITEM_MOD_CRIT_RANGED_RATING:
+			oss << "\n              +" << val << "Ô¶³Ì±©»÷µÈ¼¶";
+			break;
+		case ITEM_MOD_CRIT_SPELL_RATING:
+			oss << "\n              +" << val << "·¨Êõ±©»÷µÈ¼¶";
+			break;
+		case ITEM_MOD_HIT_TAKEN_MELEE_RATING:
+			oss << "\n              +" << val << "";
+			break;
+		case ITEM_MOD_HIT_TAKEN_RANGED_RATING:
+			oss << "\n              +" << val << "";
+			break;
+		case ITEM_MOD_HIT_TAKEN_SPELL_RATING:
+			oss << "\n              +" << val << "";
+			break;
+		case ITEM_MOD_CRIT_TAKEN_MELEE_RATING:
+			oss << "\n              +" << val << "";
+			break;
+		case ITEM_MOD_CRIT_TAKEN_RANGED_RATING:
+			oss << "\n              +" << val << "";
+			break;
+		case ITEM_MOD_CRIT_TAKEN_SPELL_RATING:
+			oss << "\n              +" << val << "";
+			break;
+		case ITEM_MOD_HASTE_MELEE_RATING:
+			oss << "\n              +" << val << "";
+			break;
+		case ITEM_MOD_HASTE_RANGED_RATING:
+			oss << "\n              +" << val << "";
+			break;
+		case ITEM_MOD_HASTE_SPELL_RATING:
+			oss << "\n              +" << val << "";
+			break;
+		case ITEM_MOD_HIT_RATING:
+			oss << "\n              +" << val << "";
+			break;
+		case ITEM_MOD_CRIT_RATING:
+			oss << "\n              +" << val << "";
+			break;
+		case ITEM_MOD_HIT_TAKEN_RATING:
+			oss << "\n              +" << val << "";
+			break;
+		case ITEM_MOD_CRIT_TAKEN_RATING:
+			oss << "\n              +" << val << "";
+			break;
+		case ITEM_MOD_RESILIENCE_RATING:
+			oss << "\n              +" << val << "";
+			break;
+		case ITEM_MOD_HASTE_RATING:
+			oss << "\n              +" << val << "¼±ËÙµÈ¼¶";
+			break;
+		case ITEM_MOD_EXPERTISE_RATING:
+			oss << "\n              +" << val << "ÈÍÐÔµÈ¼¶";
+			break;
+		case ITEM_MOD_ATTACK_POWER:
+			oss << "\n              +" << val << "¹¥»÷Ç¿¶È";
+			break;
+		case ITEM_MOD_RANGED_ATTACK_POWER:
+			oss << "\n              +" << val << "";
+			break;
+		case ITEM_MOD_MANA_REGENERATION:
+			oss << "\n              +" << val << "";
+			break;
+		case ITEM_MOD_ARMOR_PENETRATION_RATING:
+			oss << "\n              +" << val << "";
+			break;
+		case ITEM_MOD_SPELL_POWER:
+			oss << "\n              +" << val << "·¨ÊõÇ¿¶È";
+			break;
+		case ITEM_MOD_HEALTH_REGEN:
+			oss << "\n              +" << val << "";
+			break;
+		case ITEM_MOD_SPELL_PENETRATION:
+			oss << "\n              +" << val << "";
+			break;
+		case ITEM_MOD_BLOCK_VALUE:
+			oss << "\n              +" << val << "";
+			break;
+			// deprecated item mods
+		case ITEM_MOD_SPELL_HEALING_DONE:
+		case ITEM_MOD_SPELL_DAMAGE_DONE:
+			break;
+		}
+	}
+
+	return oss.str();
+}
+
+std::string ExtraEquipment::GetDes(Player* player, EquipmentSlots slot)
+{
+	std::ostringstream oss;
+	
+	oss << GetStatDes(GetItemEntry(player, slot));
+
+	uint32 len = player->ExtraEquimentVec.size();
+	for (size_t i = 0; i < len; i++)
+	{
+		if (slot == player->ExtraEquimentVec[i].slot)
+		{
+			uint32 entry = player->ExtraEquimentVec[i].itemEntry;
+
+			for (uint8 enchant_slot = PERM_ENCHANTMENT_SLOT; enchant_slot < PROP_ENCHANTMENT_SLOT_4; enchant_slot++)
+			{
+              uint32 enchantId = player->ExtraEquimentVec[i].enchant[enchant_slot];
+              if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchantId))
+              	oss << "\n              " << enchantEntry->description[4];              
+			}
+		}
+	}
+
+	return oss.str();
+}
+
+std::string ExtraEquipment::GetDes(Item* item)
+{
+	std::ostringstream oss;
+
+	oss << GetStatDes(item->GetEntry());
+
+	for (uint8 enchant_slot = PERM_ENCHANTMENT_SLOT; enchant_slot < MAX_ENCHANTMENT_SLOT; enchant_slot++)
+	{
+		uint32 enchantId = item->GetEnchantmentId(EnchantmentSlot(enchant_slot));
+		if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchantId))
+			oss << "\n              " << enchantEntry->description[4];
+	}
+	return oss.str();
+}
+
+uint32 ExtraEquipment::GetItemEntry(Player* player, EquipmentSlots slot)
+{
+	uint32 len = player->ExtraEquimentVec.size();
+	for (size_t i = 0; i < len; i++)
+		if (slot == player->ExtraEquimentVec[i].slot)
+			return player->ExtraEquimentVec[i].itemEntry;
+
+	return 0;
+}
+
+bool ExtraEquipment::IsForSlot(Item* item, EquipmentSlots slot)
+{
+	ItemTemplate const* proto = item->GetTemplate();
+	if (proto->Class != ITEM_CLASS_ARMOR && proto->Class != ITEM_CLASS_WEAPON)
+		return false;
+	
+	bool IsInEntryVec = std::find(ExtraEuipMentEntryVec.begin(), ExtraEuipMentEntryVec.end(), proto->ItemId) == ExtraEuipMentEntryVec.end() ? false : true;
+
+	if (!IsInEntryVec && !ExtraEuipMentEntryVec.empty())
+		return false;
+
+	switch (slot)
+	{
+	case EQUIPMENT_SLOT_HEAD:
+		return proto->InventoryType == INVTYPE_HEAD;
+	case EQUIPMENT_SLOT_NECK:
+		return proto->InventoryType == INVTYPE_NECK;
+	case EQUIPMENT_SLOT_SHOULDERS:
+		return proto->InventoryType == INVTYPE_SHOULDERS;
+	case EQUIPMENT_SLOT_BODY:
+		return proto->InventoryType == INVTYPE_BODY;
+	case EQUIPMENT_SLOT_CHEST:
+		return proto->InventoryType == INVTYPE_CHEST || proto->InventoryType == INVTYPE_ROBE;
+	case EQUIPMENT_SLOT_WAIST:
+		return proto->InventoryType == INVTYPE_WAIST;
+	case EQUIPMENT_SLOT_LEGS:
+		return proto->InventoryType == INVTYPE_LEGS;
+	case EQUIPMENT_SLOT_FEET:
+		return proto->InventoryType == INVTYPE_FEET;
+	case EQUIPMENT_SLOT_WRISTS:
+		return proto->InventoryType == INVTYPE_WRISTS;
+	case EQUIPMENT_SLOT_HANDS:
+		return proto->InventoryType == INVTYPE_HANDS;
+	case EQUIPMENT_SLOT_FINGER1:
+		return proto->InventoryType == INVTYPE_FINGER;
+	case EQUIPMENT_SLOT_FINGER2:
+		return proto->InventoryType == INVTYPE_FINGER;
+	case EQUIPMENT_SLOT_TRINKET1:
+		return proto->InventoryType == INVTYPE_TRINKET;
+	case EQUIPMENT_SLOT_TRINKET2:
+		return proto->InventoryType == INVTYPE_TRINKET;
+	case EQUIPMENT_SLOT_BACK:
+		return proto->InventoryType == INVTYPE_CLOAK;
+	case EQUIPMENT_SLOT_MAINHAND:
+		return proto->InventoryType == INVTYPE_2HWEAPON || proto->InventoryType == INVTYPE_WEAPONMAINHAND || proto->InventoryType == INVTYPE_WEAPON;
+	case EQUIPMENT_SLOT_OFFHAND:
+		return proto->InventoryType == INVTYPE_WEAPONOFFHAND || proto->InventoryType == INVTYPE_SHIELD || proto->InventoryType == INVTYPE_HOLDABLE;
+		break;
+	case EQUIPMENT_SLOT_RANGED:
+		return proto->InventoryType == INVTYPE_THROWN || proto->InventoryType == INVTYPE_RANGED || proto->InventoryType == INVTYPE_RANGEDRIGHT || proto->InventoryType == INVTYPE_RELIC;
+	case EQUIPMENT_SLOT_TABARD:
+		return proto->InventoryType == INVTYPE_TABARD;
+	default:
+		return false;
+	}
+}
+
+void ExtraEquipment::AddMenuList(Player* player, Object* obj)
+{
+	for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+	{
+		//if (slot == EQUIPMENT_SLOT_NECK || slot == EQUIPMENT_SLOT_BODY || slot > EQUIPMENT_SLOT_HANDS)
+		//	continue;
+
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GetSlotText(player, EquipmentSlots(slot)), slot, EXTRA_EQUIPMENT_NEXT_MENULIST);
+	}
+			
+	if (obj->ToCreature())
+		player->SEND_GOSSIP_MENU(obj->GetEntry(), obj->GetGUID());
+	else 
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+
+}
+
+void ExtraEquipment::AddNextMenuList(Player* player, Object* obj, uint32 sender,bool firstOpen,bool fordisplay)
+{
+	if (firstOpen)
+	{
+		player->selectedEquipmentSlot = sender;
+
+		player->GossipVec.clear();
+
+		//Ö÷±³°ü
+		for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
+			if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+              if (IsForSlot(item, EquipmentSlots(player->selectedEquipmentSlot)))
+              {
+              	ExtraEquimentGossipTemplate temp;
+              	temp.smallIcon = GOSSIP_ICON_CHAT;
+              	temp.text = GetItemName(item->GetEntry(), 30, 30, 0, 0) + GetDes(item);
+              	temp.sender = item->GetGUIDLow();
+              	temp.action = EXTRA_EQUIPMENT_UPDATE;
+              	temp.item = item;
+              	player->GossipVec.push_back(temp);
+              }
+
+		//¶îÍâÈý¸ö±³°ü
+		for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+			if (Bag* pBag = player->GetBagByPos(i))
+              for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+              	if (Item* item = player->GetItemByPos(i, j))
+              		if (IsForSlot(item, EquipmentSlots(player->selectedEquipmentSlot)))
+              		{
+              			ExtraEquimentGossipTemplate temp;
+              			temp.smallIcon = GOSSIP_ICON_CHAT;
+              			temp.text = GetItemName(item->GetEntry(), 30, 30, 0, 0) + GetDes(item);
+              			temp.sender = item->GetGUIDLow();
+              			temp.action = EXTRA_EQUIPMENT_UPDATE;
+              			player->GossipVec.push_back(temp);
+              		}
+	}
+		
+	for (size_t i = player->flag_i; i < player->GossipVec.size(); i++)
+	{
+		player->flag_i++;
+		player->rowId++;
+
+		player->ADD_GOSSIP_ITEM(player->GossipVec[i].smallIcon, player->GossipVec[i].text, player->GossipVec[i].sender, player->GossipVec[i].action);
+
+		if (player->rowId >= MAX_EXTRA_EQUIPMENT_ROWS_COUNT)
+		{
+			player->rowId = 0;
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "ÏÂÒ³", GOSSIP_SENDER_MAIN, EXTRA_EQUIPMENT_NEXT_PAGE);
+			if (player->pageId >= 2)
+              player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "ÉÏÒ³", GOSSIP_SENDER_MAIN, EXTRA_EQUIPMENT_PREV_PAGE);
+			break;
+		}
+	}
+
+
+	if (player->rowId < MAX_EXTRA_EQUIPMENT_ROWS_COUNT && player->rowId != 0 && player->pageId !=1)
+	{
+		player->flag_i = player->flag_i + MAX_EXTRA_EQUIPMENT_ROWS_COUNT - player->rowId;
+		player->rowId = 0;
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "ÉÏÒ³", GOSSIP_SENDER_MAIN, EXTRA_EQUIPMENT_PREV_PAGE);
+	}
+
+	if (!fordisplay)
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "·µ»Ø", GOSSIP_SENDER_MAIN, EXTRA_EQUIPMENT_BACK);
+
+	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+}
+
+void ExtraEquipment::Action(Player* player, Object* obj, uint32 sender, bool fordisplay)
+{
+	
+	if (Item* item = player->GetItemByGuid(MAKE_NEW_GUID(sender, 0, HIGHGUID_ITEM)))
+	{
+		//ÕâÀï´¦Àídisplay mainhand offhand ranged
+		if (fordisplay)
+		{
+			player->CLOSE_GOSSIP_MENU();
+			return;
+		}
+
+		if (item->GetTemplate()->Stackable > 1 && item->GetCount() > 1)
+		{
+			player->GetSession()->SendNotification("¸üÐÂÊ§°Ü£¬¸ÃÎïÆ·µþ¼ÓÊýÁ¿Ó¦Ð¡ÓÚ2£¬Çë·ÖÀë¸ÃÎïÆ·£¡");
+			player->CLOSE_GOSSIP_MENU();
+			return;
+		}
+	
+		GiveItemBack(player, EquipmentSlots(player->selectedEquipmentSlot));
+		Update(player, item, EquipmentSlots(player->selectedEquipmentSlot));
+		player->DestroyItem(item->GetBagSlot(), item->GetSlot(),true);
+		player->GetSession()->SendAreaTriggerMessage("¸üÐÂÍê³É£¡");
+	}
+	
+	player->CLOSE_GOSSIP_MENU();
+}
+
+void ExtraEquipment::GiveItemBack(Player* player, EquipmentSlots slot)
+{
+	if (!extra_origin_item_back)
+		return;
+
+	uint32 len = player->ExtraEquimentVec.size();
+	for (size_t i = 0; i < len; i++)
+		if (slot == player->ExtraEquimentVec[i].slot)
+		{
+			ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(player->ExtraEquimentVec[i].itemEntry);
+
+			if (!pProto)
+              continue;
+
+			if (Item* item = sItemMod->AddItem(player, player->ExtraEquimentVec[i].itemEntry, 1))
+              for (uint8 enchant_slot = PERM_ENCHANTMENT_SLOT; enchant_slot < MAX_ENCHANTMENT_SLOT; enchant_slot++)
+              	item->SetEnchantment(EnchantmentSlot(enchant_slot), player->ExtraEquimentVec[i].enchant[enchant_slot], 0, 0, 0, true);
+		}
+}
+
+void ExtraEquipment::Update(Player* player, Item* item, EquipmentSlots slot)
+{
+	if (!player || !item)
+		return;
+
+	uint32 guid = player->GetGUIDLow();
+	uint32 itemEntry = item->GetEntry();
+	std::ostringstream ssEnchants;
+	for (uint8 i = PERM_ENCHANTMENT_SLOT; i < MAX_ENCHANTMENT_SLOT; ++i)
+		ssEnchants << item->GetEnchantmentId(EnchantmentSlot(i)) << ' ';
+
+	//²åÈëÊý¾Ý¿â
+	QueryResult result = CharacterDatabase.PQuery("SELECT * FROM characters_extra_equipments WHERE guid = %d AND equip_slot = %d", guid, slot);
+
+	if (result)
+		CharacterDatabase.PExecute("UPDATE characters_extra_equipments SET enchantments = '%s',itemEntry = %d WHERE guid = %d AND equip_slot = %d", ssEnchants.str().c_str(), itemEntry, guid, slot);
+	else
+		CharacterDatabase.PExecute("INSERT INTO characters_extra_equipments(guid,itemEntry,equip_slot,enchantments) values(%d, %d, %d,'%s')", guid, itemEntry, slot, ssEnchants.str().c_str());
+
+	//³ýÈ¥Ë«¼×Ð§¹û
+	Apply(player, false);
+
+	//¸üÐÂvec
+	for (std::vector<ExtraEquipments>::iterator itr = player->ExtraEquimentVec.begin(); itr != player->ExtraEquimentVec.end();)
+		if (itr->slot == slot)
+			itr = player->ExtraEquimentVec.erase(itr);
+		else
+			++itr;
+
+	ExtraEquipments temp;
+	temp.itemEntry = itemEntry;
+	temp.slot = slot;
+	for (uint8 i = PERM_ENCHANTMENT_SLOT; i < MAX_ENCHANTMENT_SLOT; ++i)
+		temp.enchant[i] = item->GetEnchantmentId(EnchantmentSlot(i));
+	player->ExtraEquimentVec.push_back(temp);
+
+	//ÖØÔØË«¼×Ð§¹û
+	Apply(player, true);
+}
+
+void ExtraEquipment::Apply(Player* player, bool apply)
+{
+	if (!player)
+		return;
+
+	uint32 len = player->ExtraEquimentVec.size();
+
+	for (size_t i = 0; i < player->ExtraEquimentVec.size(); i++)
+	{	
+		ItemTemplate const* proto = sObjectMgr->GetItemTemplate(player->ExtraEquimentVec[i].itemEntry);
+
+		if (!proto)
+			continue;
+
+		//¸½Ä§²¿·Ö
+		for (size_t j = 0; j < MAX_ENCHANTMENT_SLOT; j++)
+		{		
+			uint32 enchant_id = player->ExtraEquimentVec[i].enchant[j];
+
+			SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+
+			if (!pEnchant)
+              continue;
+
+			for (int s = 0; s < MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+			{
+              uint32 enchant_display_type = pEnchant->type[s];
+              uint32 enchant_amount = pEnchant->amount[s] * extra_enchant_stat_muil;
+              uint32 enchant_spell_id = pEnchant->spellid[s];
+              
+#pragma region ×°±¸¼¼ÄÜ
+              if (enchant_display_type == ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL)
+              {
+              	if (enchant_spell_id)
+              	{
+              		if (apply)
+              			player->AddAura(enchant_spell_id, player);
+              		else
+              			player->RemoveAura(enchant_spell_id);
+              	}			
+              }
+#pragma endregion
+
+#pragma region ÊôÐÔ
+              if (enchant_display_type == ITEM_ENCHANTMENT_TYPE_STAT && enchant_amount != 0)
+              {
+              	switch (enchant_spell_id)
+              	{
+              	case ITEM_MOD_MANA:
+              		player->HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, float(enchant_amount), apply);
+              		break;
+              	case ITEM_MOD_HEALTH:
+              		player->HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, float(enchant_amount), apply);
+              		break;
+              	case ITEM_MOD_AGILITY:
+              		player->HandleStatModifier(UNIT_MOD_STAT_AGILITY, TOTAL_VALUE, float(enchant_amount), apply);
+              		player->ApplyStatBuffMod(STAT_AGILITY, (float)enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_STRENGTH:
+              		player->HandleStatModifier(UNIT_MOD_STAT_STRENGTH, TOTAL_VALUE, float(enchant_amount), apply);
+              		player->ApplyStatBuffMod(STAT_STRENGTH, (float)enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_INTELLECT:
+              		player->HandleStatModifier(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE, float(enchant_amount), apply);
+              		player->ApplyStatBuffMod(STAT_INTELLECT, (float)enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_SPIRIT:
+              		player->HandleStatModifier(UNIT_MOD_STAT_SPIRIT, TOTAL_VALUE, float(enchant_amount), apply);
+              		player->ApplyStatBuffMod(STAT_SPIRIT, (float)enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_STAMINA:
+              		player->HandleStatModifier(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE, float(enchant_amount), apply);
+              		player->ApplyStatBuffMod(STAT_STAMINA, (float)enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_DEFENSE_SKILL_RATING:
+              		player->ApplyRatingMod(CR_DEFENSE_SKILL, enchant_amount, apply);
+              		break;
+              	case  ITEM_MOD_DODGE_RATING:
+              		player->ApplyRatingMod(CR_DODGE, enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_PARRY_RATING:
+              		player->ApplyRatingMod(CR_PARRY, enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_BLOCK_RATING:
+              		player->ApplyRatingMod(CR_BLOCK, enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_HIT_MELEE_RATING:
+              		player->ApplyRatingMod(CR_HIT_MELEE, enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_HIT_RANGED_RATING:
+              		player->ApplyRatingMod(CR_HIT_RANGED, enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_HIT_SPELL_RATING:
+              		player->ApplyRatingMod(CR_HIT_SPELL, enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_CRIT_MELEE_RATING:
+              		player->ApplyRatingMod(CR_CRIT_MELEE, enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_CRIT_RANGED_RATING:
+              		player->ApplyRatingMod(CR_CRIT_RANGED, enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_CRIT_SPELL_RATING:
+              		player->ApplyRatingMod(CR_CRIT_SPELL, enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_HASTE_RANGED_RATING:
+              		player->ApplyRatingMod(CR_HASTE_RANGED, enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_HASTE_SPELL_RATING:
+              		player->ApplyRatingMod(CR_HASTE_SPELL, enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_HIT_RATING:
+              		player->ApplyRatingMod(CR_HIT_MELEE, enchant_amount, apply);
+              		player->ApplyRatingMod(CR_HIT_RANGED, enchant_amount, apply);
+              		player->ApplyRatingMod(CR_HIT_SPELL, enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_CRIT_RATING:
+              		player->ApplyRatingMod(CR_CRIT_MELEE, enchant_amount, apply);
+              		player->ApplyRatingMod(CR_CRIT_RANGED, enchant_amount, apply);
+              		player->ApplyRatingMod(CR_CRIT_SPELL, enchant_amount, apply);
+              		break;
+              		//                        Values ITEM_MOD_HIT_TAKEN_RATING and ITEM_MOD_CRIT_TAKEN_RATING are never used in Enchantment
+              		//                        case ITEM_MOD_HIT_TAKEN_RATING:
+              		//                            ApplyRatingMod(CR_HIT_TAKEN_MELEE, enchant_amount, apply);
+              		//                            ApplyRatingMod(CR_HIT_TAKEN_RANGED, enchant_amount, apply);
+              		//                            ApplyRatingMod(CR_HIT_TAKEN_SPELL, enchant_amount, apply);
+              		//                            break;
+              		//                        case ITEM_MOD_CRIT_TAKEN_RATING:
+              		//                            ApplyRatingMod(CR_CRIT_TAKEN_MELEE, enchant_amount, apply);
+              		//                            ApplyRatingMod(CR_CRIT_TAKEN_RANGED, enchant_amount, apply);
+              		//                            ApplyRatingMod(CR_CRIT_TAKEN_SPELL, enchant_amount, apply);
+              		//                            break;
+              	case ITEM_MOD_RESILIENCE_RATING:
+              		player->ApplyRatingMod(CR_CRIT_TAKEN_MELEE, enchant_amount, apply);
+              		player->ApplyRatingMod(CR_CRIT_TAKEN_RANGED, enchant_amount, apply);
+              		player->ApplyRatingMod(CR_CRIT_TAKEN_SPELL, enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_HASTE_RATING:
+              		player->ApplyRatingMod(CR_HASTE_MELEE, enchant_amount, apply);
+              		player->ApplyRatingMod(CR_HASTE_RANGED, enchant_amount, apply);
+              		player->ApplyRatingMod(CR_HASTE_SPELL, enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_EXPERTISE_RATING:
+              		player->ApplyRatingMod(CR_EXPERTISE, enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_ATTACK_POWER:
+              		player->HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(enchant_amount), apply);
+              		player->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(enchant_amount), apply);
+              		break;
+              	case ITEM_MOD_RANGED_ATTACK_POWER:
+              		player->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(enchant_amount), apply);
+              		break;
+              		//                        case ITEM_MOD_FERAL_ATTACK_POWER:
+              		//                            ApplyFeralAPBonus(enchant_amount, apply);
+              		//                            ;//sLog->outDebug(LOG_FILTER_PLAYER_ITEMS, "+ %u FERAL_ATTACK_POWER", enchant_amount);
+              		//                            break;
+              	case ITEM_MOD_MANA_REGENERATION:
+              		player->ApplyManaRegenBonus(enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_ARMOR_PENETRATION_RATING:
+              		player->ApplyRatingMod(CR_ARMOR_PENETRATION, enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_SPELL_POWER:
+              		player->ApplySpellPowerBonus(enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_HEALTH_REGEN:
+              		player->ApplyHealthRegenBonus(enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_SPELL_PENETRATION:
+              		player->ApplySpellPenetrationBonus(enchant_amount, apply);
+              		break;
+              	case ITEM_MOD_BLOCK_VALUE:
+              		player->HandleBaseModValue(SHIELD_BLOCK_VALUE, FLAT_MOD, float(enchant_amount), apply);
+              		break;
+              	case ITEM_MOD_SPELL_HEALING_DONE:   // deprecated
+              	case ITEM_MOD_SPELL_DAMAGE_DONE:    // deprecated
+              	default:
+              		break;
+              	}
+              }
+#pragma endregion
+              
+			}
+
+		}
+		
+		//×°±¸ÊôÐÔ
+		for (uint8 k = 0; k < MAX_ITEM_PROTO_STATS; ++k)
+		{
+			if (k >= proto->StatsCount)
+              break;
+
+			uint32 statType = proto->ItemStat[k].ItemStatType;
+			int32  val = proto->ItemStat[k].ItemStatValue *extra_stat_muil;
+
+			if (val == 0)
+              continue;
+
+			switch (statType)
+			{
+			case ITEM_MOD_MANA:
+              player->HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, float(val), apply);
+              break;
+			case ITEM_MOD_HEALTH:                           // modify HP
+              player->HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, float(val), apply);
+              break;
+			case ITEM_MOD_AGILITY:                          // modify agility
+              player->HandleStatModifier(UNIT_MOD_STAT_AGILITY, BASE_VALUE, float(val), apply);
+              player->ApplyStatBuffMod(STAT_AGILITY, float(val), apply);
+              break;
+			case ITEM_MOD_STRENGTH:                         //modify strength
+              player->HandleStatModifier(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, float(val), apply);
+              player->ApplyStatBuffMod(STAT_STRENGTH, float(val), apply);
+              break;
+			case ITEM_MOD_INTELLECT:                        //modify intellect
+              player->HandleStatModifier(UNIT_MOD_STAT_INTELLECT, BASE_VALUE, float(val), apply);
+              player->ApplyStatBuffMod(STAT_INTELLECT, float(val), apply);
+              break;
+			case ITEM_MOD_SPIRIT:                           //modify spirit
+              player->HandleStatModifier(UNIT_MOD_STAT_SPIRIT, BASE_VALUE, float(val), apply);
+              player->ApplyStatBuffMod(STAT_SPIRIT, float(val), apply);
+              break;
+			case ITEM_MOD_STAMINA:                          //modify stamina
+              player->HandleStatModifier(UNIT_MOD_STAT_STAMINA, BASE_VALUE, float(val), apply);
+              player->ApplyStatBuffMod(STAT_STAMINA, float(val), apply);
+              break;
+			case ITEM_MOD_DEFENSE_SKILL_RATING:
+              player->ApplyRatingMod(CR_DEFENSE_SKILL, int32(val), apply);
+              break;
+			case ITEM_MOD_DODGE_RATING:
+              player->ApplyRatingMod(CR_DODGE, int32(val), apply);
+              break;
+			case ITEM_MOD_PARRY_RATING:
+              player->ApplyRatingMod(CR_PARRY, int32(val), apply);
+              break;
+			case ITEM_MOD_BLOCK_RATING:
+              player->ApplyRatingMod(CR_BLOCK, int32(val), apply);
+              break;
+			case ITEM_MOD_HIT_MELEE_RATING:
+              player->ApplyRatingMod(CR_HIT_MELEE, int32(val), apply);
+              break;
+			case ITEM_MOD_HIT_RANGED_RATING:
+              player->ApplyRatingMod(CR_HIT_RANGED, int32(val), apply);
+              break;
+			case ITEM_MOD_HIT_SPELL_RATING:
+              player->ApplyRatingMod(CR_HIT_SPELL, int32(val), apply);
+              break;
+			case ITEM_MOD_CRIT_MELEE_RATING:
+              player->ApplyRatingMod(CR_CRIT_MELEE, int32(val), apply);
+              break;
+			case ITEM_MOD_CRIT_RANGED_RATING:
+              player->ApplyRatingMod(CR_CRIT_RANGED, int32(val), apply);
+              break;
+			case ITEM_MOD_CRIT_SPELL_RATING:
+              player->ApplyRatingMod(CR_CRIT_SPELL, int32(val), apply);
+              break;
+			case ITEM_MOD_HIT_TAKEN_MELEE_RATING:
+              player->ApplyRatingMod(CR_HIT_TAKEN_MELEE, int32(val), apply);
+              break;
+			case ITEM_MOD_HIT_TAKEN_RANGED_RATING:
+              player->ApplyRatingMod(CR_HIT_TAKEN_RANGED, int32(val), apply);
+              break;
+			case ITEM_MOD_HIT_TAKEN_SPELL_RATING:
+              player->ApplyRatingMod(CR_HIT_TAKEN_SPELL, int32(val), apply);
+              break;
+			case ITEM_MOD_CRIT_TAKEN_MELEE_RATING:
+              player->ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(val), apply);
+              break;
+			case ITEM_MOD_CRIT_TAKEN_RANGED_RATING:
+              player->ApplyRatingMod(CR_CRIT_TAKEN_RANGED, int32(val), apply);
+              break;
+			case ITEM_MOD_CRIT_TAKEN_SPELL_RATING:
+              player->ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(val), apply);
+              break;
+			case ITEM_MOD_HASTE_MELEE_RATING:
+              player->ApplyRatingMod(CR_HASTE_MELEE, int32(val), apply);
+              break;
+			case ITEM_MOD_HASTE_RANGED_RATING:
+              player->ApplyRatingMod(CR_HASTE_RANGED, int32(val), apply);
+              break;
+			case ITEM_MOD_HASTE_SPELL_RATING:
+              player->ApplyRatingMod(CR_HASTE_SPELL, int32(val), apply);
+              break;
+			case ITEM_MOD_HIT_RATING:
+              player->ApplyRatingMod(CR_HIT_MELEE, int32(val), apply);
+              player->ApplyRatingMod(CR_HIT_RANGED, int32(val), apply);
+              player->ApplyRatingMod(CR_HIT_SPELL, int32(val), apply);
+              break;
+			case ITEM_MOD_CRIT_RATING:
+              player->ApplyRatingMod(CR_CRIT_MELEE, int32(val), apply);
+              player->ApplyRatingMod(CR_CRIT_RANGED, int32(val), apply);
+              player->ApplyRatingMod(CR_CRIT_SPELL, int32(val), apply);
+              break;
+			case ITEM_MOD_HIT_TAKEN_RATING:
+              player->ApplyRatingMod(CR_HIT_TAKEN_MELEE, int32(val), apply);
+              player->ApplyRatingMod(CR_HIT_TAKEN_RANGED, int32(val), apply);
+              player->ApplyRatingMod(CR_HIT_TAKEN_SPELL, int32(val), apply);
+              break;
+			case ITEM_MOD_CRIT_TAKEN_RATING:
+              player->ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(val), apply);
+              player->ApplyRatingMod(CR_CRIT_TAKEN_RANGED, int32(val), apply);
+              player->ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(val), apply);
+              break;
+			case ITEM_MOD_RESILIENCE_RATING:
+              player->ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(val), apply);
+              player->ApplyRatingMod(CR_CRIT_TAKEN_RANGED, int32(val), apply);
+              player->ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(val), apply);
+              break;
+			case ITEM_MOD_HASTE_RATING:
+              player->ApplyRatingMod(CR_HASTE_MELEE, int32(val), apply);
+              player->ApplyRatingMod(CR_HASTE_RANGED, int32(val), apply);
+              player->ApplyRatingMod(CR_HASTE_SPELL, int32(val), apply);
+              break;
+			case ITEM_MOD_EXPERTISE_RATING:
+              player->ApplyRatingMod(CR_EXPERTISE, int32(val), apply);
+              break;
+			case ITEM_MOD_ATTACK_POWER:
+              player->HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(val), apply);
+              player->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(val), apply);
+              break;
+			case ITEM_MOD_RANGED_ATTACK_POWER:
+              player->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(val), apply);
+              break;
+              //            case ITEM_MOD_FERAL_ATTACK_POWER:
+              //                ApplyFeralAPBonus(int32(val), apply);
+              //                break;
+			case ITEM_MOD_MANA_REGENERATION:
+              player->ApplyManaRegenBonus(int32(val), apply);
+              break;
+			case ITEM_MOD_ARMOR_PENETRATION_RATING:
+              player->ApplyRatingMod(CR_ARMOR_PENETRATION, int32(val), apply);
+              break;
+			case ITEM_MOD_SPELL_POWER:
+              player->ApplySpellPowerBonus(int32(val), apply);
+              break;
+			case ITEM_MOD_HEALTH_REGEN:
+              player->ApplyHealthRegenBonus(int32(val), apply);
+              break;
+			case ITEM_MOD_SPELL_PENETRATION:
+              player->ApplySpellPenetrationBonus(val, apply);
+              break;
+			case ITEM_MOD_BLOCK_VALUE:
+              player->HandleBaseModValue(SHIELD_BLOCK_VALUE, FLAT_MOD, float(val), apply);
+              break;
+              // deprecated item mods
+			case ITEM_MOD_SPELL_HEALING_DONE:
+			case ITEM_MOD_SPELL_DAMAGE_DONE:
+              break;
+			}		
+		}
+	}
+}
+
+void ExtraEquipment::LoadPlayerData(Player* player)
+{
+	QueryResult result = CharacterDatabase.PQuery("SELECT itemEntry,equip_slot,enchantments FROM characters_extra_equipments where guid = %d",player->GetGUIDLow());
+	if (!result) 
+		return;
+	do
+	{
+		Field* fields = result->Fetch();
+		ExtraEquipments temp;
+		temp.itemEntry = fields[0].GetUInt32();
+		temp.slot = EquipmentSlots(fields[1].GetUInt8());
+		std::vector<std::string> str_vec = sCF->SplitStr(fields[2].GetString(), " ");
+		for (size_t i = 0; i < str_vec.size(); i++)
+			temp.enchant[i] = (uint32)atoi(str_vec[i].c_str());		
+			
+
+		player->ExtraEquimentVec.push_back(temp);
+	} while (result->NextRow());
+}
+
+
+class ExtraEquipment_PlayerScript : public PlayerScript
+{
+public:
+	ExtraEquipment_PlayerScript() : PlayerScript("ExtraEquipment_PlayerScript") {}
+
+	void OnLogin(Player* player)
+	{
+		sExtraEquipment->LoadPlayerData(player);
+		sExtraEquipment->Apply(player, true);
+	}
+};
+
+class NPCExtraEquipment : public CreatureScript
+{
+public:
+	NPCExtraEquipment() : CreatureScript("NPCExtraEquipment") { }
+	bool OnGossipHello(Player* player, Creature* creature)
+	{
+		player->PlayerTalkClass->ClearMenus();
+
+		player->flag_i = 0;
+		player->rowId = 0;
+		player->pageId = 0;
+		sExtraEquipment->AddMenuList(player, creature);
+		return true;
+	}
+
+	bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+	{
+		player->PlayerTalkClass->ClearMenus();
+
+		switch (action)
+		{
+		case EXTRA_EQUIPMENT_NEXT_MENULIST:
+			player->pageId += 1;
+			sExtraEquipment->AddNextMenuList(player, creature, sender);
+			break;
+		case EXTRA_EQUIPMENT_NEXT_PAGE:
+			player->pageId += 1;
+			sExtraEquipment->AddNextMenuList(player, creature, sender,false);
+			break;
+		case EXTRA_EQUIPMENT_PREV_PAGE:
+			player->pageId -= 1;
+			player->flag_i -= 2 * MAX_EXTRA_EQUIPMENT_ROWS_COUNT;
+			sExtraEquipment->AddNextMenuList(player, creature, sender,false);
+			break;
+		case EXTRA_EQUIPMENT_BACK:
+			player->flag_i = 0;
+			player->rowId = 0;
+			player->pageId = 0;
+			sExtraEquipment->AddMenuList(player, creature);
+			break;
+		case EXTRA_EQUIPMENT_UPDATE:
+			sExtraEquipment->Action(player, creature, sender);
+			break;
+		default:
+			break;
+		}
+		
+		return true;
+	}
+};
+
+void AddSC_ExtraEquipment()
+{
+	new ExtraEquipment_PlayerScript();
+	new NPCExtraEquipment();
+}
diff --git a/src/server/scripts/Custom/ExtraEquipment/ExtraEquipment.h b/src/server/scripts/Custom/ExtraEquipment/ExtraEquipment.h
new file mode 100644
index 0000000..9aaeb35
--- /dev/null
+++ b/src/server/scripts/Custom/ExtraEquipment/ExtraEquipment.h
@@ -0,0 +1,47 @@
+#define MAX_EXTRA_EQUIPMENT_ROWS_COUNT 25
+
+#define EXTRA_EQUIPMENT_NEXT_MENULIST 90004
+#define EXTRA_EQUIPMENT_NEXT_PAGE 90000
+#define EXTRA_EQUIPMENT_PREV_PAGE 90001
+#define EXTRA_EQUIPMENT_BACK 90002
+#define EXTRA_EQUIPMENT_UPDATE 90003
+
+extern float extra_stat_muil;
+extern float extra_enchant_stat_muil;
+extern bool extra_origin_item_back;
+
+extern std::vector<uint32 /*entry*/> ExtraEuipMentEntryVec;
+
+class ExtraEquipment
+{
+public:
+	static ExtraEquipment* instance()
+	{
+		static ExtraEquipment instance;
+		return &instance;
+	}
+	void Load();
+
+	std::string GetItemName(uint32 entry, uint32 width, uint32 height, int x, int y);
+	std::string GetSlotDefaultText(EquipmentSlots slot, uint32 width, uint32 height, int x, int y);
+	std::string GetSlotText(Player* player, EquipmentSlots slot);
+	std::string GetStatDes(uint32 entry);
+	std::string GetDes(Player* player, EquipmentSlots slot);
+	std::string GetDes(Item* item);
+	uint32 GetItemEntry(Player* player, EquipmentSlots slot);
+
+
+	void LoadPlayerData(Player* player);
+
+	void Apply(Player* player, bool apply);
+	void Update(Player* player, Item* item, EquipmentSlots slot);
+	void GiveItemBack(Player* player, EquipmentSlots slot);
+
+	void AddMenuList(Player* player, Object* obj);
+	void AddNextMenuList(Player* player, Object* obj, uint32 sender, bool firstOpen = true, bool fordisplay = false);
+	void Action(Player* player, Object* obj, uint32 sender,bool fordisplay = false);
+
+	bool IsForSlot(Item* item, EquipmentSlots slot);
+	
+};
+#define sExtraEquipment ExtraEquipment::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Faction/Faction.cpp b/src/server/scripts/Custom/Faction/Faction.cpp
new file mode 100644
index 0000000..4c645d7
--- /dev/null
+++ b/src/server/scripts/Custom/Faction/Faction.cpp
@@ -0,0 +1,211 @@
+#pragma execution_character_set("utf-8")
+#include "Faction.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../Reward/Reward.h"
+#include "../Requirement/Requirement.h"
+#include "../Switch/Switch.h"
+#include "../String/myString.h"
+#include "../CharNameMod/CharNameMod.h"
+#include "../FunctionCollection/FunctionCollection.h"
+#include "../CustomEvent/Event.h"
+#include "../MainFunc/MainFunc.h"
+
+std::map<uint32, FactionTemplate> FactionDataMap;
+
+void Faction::Load()
+{
+	FactionDataMap.clear();
+
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//		0				1				2		3					4		5
+		"SELECT ×Ô¶¨ÒåÕóÓªID, ×Ô¶¨ÒåÕóÓªÃû³Æ, ²Ëµ¥ÎÄ±¾, ¼ÓÈëÕóÓª½±ÀøÄ£°åID, Ãû×Öºó×º,ÍË³öÕóÓªÐèÇóÄ£°åID FROM __×Ô¶¨ÒåÕóÓª" :
+		//		0			1		2		3		4		5
+		"SELECT faction, name, gossipText, rewId, suffix,quitReqId FROM _faction");
+	
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 faction = fields[0].GetUInt32();
+
+			FactionTemplate Temp;
+			Temp.name = fields[1].GetString();
+			Temp.gossipText = fields[2].GetString();
+			Temp.rewId = fields[3].GetUInt32();
+			Temp.suffix = fields[4].GetString();
+			Temp.quitReqId = fields[5].GetUInt32();
+			FactionDataMap.insert(std::make_pair(faction, Temp));
+
+		} while (result->NextRow());
+	}
+}
+
+std::string Faction::GetName(uint32 faction)
+{
+	std::map<uint32, FactionTemplate>::iterator iter = FactionDataMap.find(faction);
+
+	if (iter != FactionDataMap.end())
+		return iter->second.name;
+
+	return "[ÎÞ]";
+}
+
+std::string Faction::GetGosstipText(uint32 faction)
+{
+	std::map<uint32, FactionTemplate>::iterator iter = FactionDataMap.find(faction);
+
+	if (iter != FactionDataMap.end())
+		return iter->second.gossipText;
+
+	return "";
+}
+
+uint32 Faction::GetRewId(uint32 faction)
+{
+	std::map<uint32, FactionTemplate>::iterator iter = FactionDataMap.find(faction);
+
+	if (iter != FactionDataMap.end())
+		return iter->second.rewId;
+
+	return 0;
+}
+
+uint32 Faction::GetReqId(uint32 faction)
+{
+	std::map<uint32, FactionTemplate>::iterator iter = FactionDataMap.find(faction);
+
+	if (iter != FactionDataMap.end())
+		return iter->second.quitReqId;
+
+	return 0;
+}
+
+std::string Faction::GetSuffix(uint32 faction)
+{
+	std::map<uint32, FactionTemplate>::iterator iter = FactionDataMap.find(faction);
+
+	if (iter != FactionDataMap.end())
+		return iter->second.suffix;
+
+	return "";
+}
+
+void Faction::Join(Player* player, uint32 faction)
+{
+	if (player->InEvent())
+	{
+		ChatHandler(player->GetSession()).PSendSysMessage("ÊÂ¼þÖÐ²»ÄÜ¼ÓÈëÃÅÅÉ£¡");
+		return;
+	}
+	
+	if (faction == 0)
+	{
+		//ÍË³ö
+		uint32 reqId = GetReqId(player->faction);
+
+		if (!sReq->Check(player, reqId))
+			return;
+
+		sReq->Des(player, reqId);
+	}
+	else
+	{
+		//¼ÓÈë
+		uint32 rewId = GetRewId(faction);
+		sRew->Rew(player, rewId);
+	}
+
+	player->faction = faction;	
+	CharacterDatabase.PExecute("UPDATE characters SET faction = %u WHERE guid = %u", faction, player->GetGUIDLow());
+	sCharNameMod->UpdateSuffix(player, GetSuffix(faction));
+}
+
+
+void Faction::AddGossip(Player* player, Object* obj)
+{
+	std::map<uint32, FactionTemplate>::iterator iter = FactionDataMap.find(player->faction);
+
+	if (iter != FactionDataMap.end())
+	{
+		std::string text = "|cff0033FF" + iter->second.name + "|r";
+		player->ADD_GOSSIP_ITEM(0, text, SENDER_FACTION, GOSSIP_ACTION_INFO_DEF + iter->first);
+	}	
+
+	for (std::map<uint32, FactionTemplate>::iterator iter = FactionDataMap.begin(); iter != FactionDataMap.end(); iter++)
+	{
+		if (iter->first != player->faction)
+		{
+			std::string text = iter->second.name;
+
+			if (player->faction != 0) 
+				text = "|cffFF0000" + iter->second.name + "|r";
+
+			player->ADD_GOSSIP_ITEM(0, text, SENDER_FACTION, GOSSIP_ACTION_INFO_DEF + iter->first);
+		}	
+	}
+
+	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+}
+
+void Faction::Action(Player*player, uint32 action, Object*obj)
+{
+	if (action > 2 * GOSSIP_ACTION_INFO_DEF)
+	{
+		uint32 faction = action - 2 * GOSSIP_ACTION_INFO_DEF;
+
+		if (faction == player->faction)
+		{
+			Join(player, 0);
+			ChatHandler(player->GetSession()).PSendSysMessage("ÍË³ö%s", GetName(faction).c_str());
+		}
+		else
+		{
+			Join(player, faction);
+			ChatHandler(player->GetSession()).PSendSysMessage("¼ÓÈë%s", GetName(faction).c_str());
+		}
+
+		player->CLOSE_GOSSIP_MENU();
+	}
+	else if (action > GOSSIP_ACTION_INFO_DEF)
+	{
+		uint32 faction = action - GOSSIP_ACTION_INFO_DEF;
+		std::string name = GetName(faction);
+
+		player->ADD_GOSSIP_ITEM(0, GetGosstipText(faction), SENDER_FACTION, GOSSIP_ACTION_INFO_DEF);
+
+		if (player->faction == faction)
+		{
+			std::string gossipText = ">> ÍË³ö" + name;
+			std::string noticeText = "È·¶¨ÍË³ö" + name + "Âð£¿";
+			player->ADD_GOSSIP_ITEM_EXTENDED(0, gossipText, SENDER_FACTION, 2 * GOSSIP_ACTION_INFO_DEF + player->faction, noticeText, 0, false);
+		}
+		else if (player->faction == 0)
+		{
+			std::string gossipText = ">> ¼ÓÈë" + name;
+			std::string noticeText = "È·¶¨¼ÓÈë" + name + "Âð£¿";
+			player->ADD_GOSSIP_ITEM_EXTENDED(0, gossipText, SENDER_FACTION, 2 * GOSSIP_ACTION_INFO_DEF + action - GOSSIP_ACTION_INFO_DEF, noticeText, 0, false);
+		}
+			
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+	}
+	else
+		sMF->AddGossip(player, obj, 0);
+}
+
+class FactionScript : PlayerScript
+{
+public:
+	FactionScript() : PlayerScript("FactionScript") {}
+
+	void OnLogin(Player* player)
+	{
+		if (QueryResult result = CharacterDatabase.PQuery("SELECT faction FROM characters WHERE guid = %u", player->GetGUIDLow()))
+			player->faction = result->Fetch()[0].GetUInt32();
+	}
+};
+
+void AddSC_FactionScript()
+{
+	new FactionScript();
+}
diff --git a/src/server/scripts/Custom/Faction/Faction.h b/src/server/scripts/Custom/Faction/Faction.h
new file mode 100644
index 0000000..d019a42
--- /dev/null
+++ b/src/server/scripts/Custom/Faction/Faction.h
@@ -0,0 +1,33 @@
+struct FactionTemplate
+{
+	std::string name;
+	std::string gossipText;
+	uint32 rewId;
+	std::string suffix;
+	uint32 quitReqId;
+};
+
+extern std::map<uint32, FactionTemplate> FactionDataMap;
+
+class Faction
+{
+public:
+	static Faction* instance()
+	{
+		static Faction instance;
+		return &instance;
+	}
+	void Load();
+	std::string GetName(uint32 faction);
+	std::string GetGosstipText(uint32 faction);
+	uint32 GetRewId(uint32 faction);
+	uint32 GetReqId(uint32 faction);
+	std::string GetSuffix(uint32 faction);
+
+	void Join(Player* player,uint32 faction);
+	void AddGossip(Player* player, Object* obj);
+	void Action(Player*player, uint32 action, Object*obj);
+private:
+
+};
+#define sFaction Faction::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/FakePlayers/FakePlayers.cpp b/src/server/scripts/Custom/FakePlayers/FakePlayers.cpp
new file mode 100644
index 0000000..95c8931
--- /dev/null
+++ b/src/server/scripts/Custom/FakePlayers/FakePlayers.cpp
@@ -0,0 +1,217 @@
+#pragma execution_character_set("utf-8")
+#include "FakePlayers.h"
+#include "../String/myString.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../Switch/Switch.h"
+#include <random>
+#include <algorithm>
+#include <vector>
+
+uint32 MAX_PLAYERS = 0;
+
+uint32  START_PLAYERS = 0;
+
+uint32 FakePlayerZones[MAX_FAKE_PLAYERS_ZONE]=
+{
+	4416, 3714, 33, 4742, 4131, 4812, 4493, 4809, 4265, 4603
+};
+
+std::vector<FakePlayersTemplate> FakePlayersVec;
+
+void FakePlayers::Load()
+{
+	FakePlayersVec.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//		0		1		2	3	4	5	6	7			8
+		"SELECT Ãû×Ö,¹«»áÃû³Æ,µÈ¼¶,Ö°Òµ,ÖÖ×å,ÐÔ±ð,ID,¾üÏÎµÈ¼¶,»áÔ±µÈ¼¶ FROM _¼ÙÈË_ÁÐ±í¼ÙÈË" :
+		//		0		1	2	3		4	5	   6 7  8
+		"SELECT name,gname,lvl,class_,race,gender,ID,hr,vip FROM _faker_list");
+	if (!result) return;
+	do
+	{
+		Field* fields = result->Fetch();
+		FakePlayersTemplate Temp;
+		Temp.pname		= fields[0].GetString();
+		Temp.gname		= fields[1].GetString();
+		Temp.lvl		= fields[2].GetUInt32();
+		Temp.class_		= fields[3].GetUInt32();
+		Temp.race		= fields[4].GetUInt32();
+		Temp.gender		= fields[5].GetUInt8();
+		Temp.pzoneid	= GenerateZoneId();
+		Temp.online		= false;
+		Temp.ID			= fields[6].GetUInt32();
+		Temp.hr			= fields[7].GetUInt32();
+		Temp.vip		= fields[8].GetUInt32();
+		FakePlayersVec.push_back(Temp);
+	} while (result->NextRow());
+}
+
+uint32 FakePlayers::GenerateZoneId()
+{
+	return FakePlayerZones[urand(0, MAX_FAKE_PLAYERS_ZONE - 1)];
+}
+
+void FakePlayers::LevelUp()
+{
+	if (FakePlayersVec.empty())
+		return;
+
+    std::default_random_engine generator{ std::random_device{}() };
+    std::shuffle(std::begin(FakePlayersVec), std::end(FakePlayersVec), generator);
+
+	std::vector<FakePlayersTemplate>::iterator itr;
+	for (itr = FakePlayersVec.begin(); itr != FakePlayersVec.end(); ++itr)
+	{
+		if (itr->lvl >= 80)
+			continue;
+		if (!itr->online)
+			continue;
+
+		if (urand(0, 2) == 0)
+		{
+			itr->lvl++;
+
+			WorldDatabase.PExecute("UPDATE _fake_players SET lvl = lvl + 1 WHERE ID = %u", itr->ID);
+		}	
+	}
+}
+
+void FakePlayers::LoginOrLogout()
+{
+
+	if (FakePlayersVec.empty())
+		return;
+
+	uint32 onlinecount = sWorld->GetPlayerCount();
+
+	std::vector<FakePlayersTemplate>::iterator itr;
+	for (itr = FakePlayersVec.begin(); itr != FakePlayersVec.end(); ++itr)
+		if (itr->online)
+			onlinecount++;
+
+
+    std::default_random_engine generator{ std::random_device{}() };
+    std::shuffle(std::begin(FakePlayersVec), std::end(FakePlayersVec), generator);
+
+	for (itr = FakePlayersVec.begin(); itr != FakePlayersVec.end(); ++itr)
+	{
+		if (!itr->online)
+		{
+			if (onlinecount >= MAX_PLAYERS)
+				break;
+
+			if (urand(0, 1) == 0)
+			{
+				itr->online = true;
+
+				if (sSwitch->GetOnOff(ST_LOG_IN))
+				{
+					std::string totalName = sCF->GetPlayerTotalName(NULL, sSwitch->GetFlag(ST_LOG_IN), true, itr->class_, itr->race, itr->hr, itr->pname, itr->vip, itr->gender);
+
+					std::string text = sString->Format(sString->GetText(CORE_STR_TYPES(STR_LOGIN)), totalName.c_str());
+					sWorld->SendGlobalText(text.c_str(), NULL);
+				}
+				
+				break;
+			}
+		}
+		else
+		{
+			if (urand(0, 3) == 0)
+			{
+				itr->online = false;
+
+				if (sSwitch->GetOnOff(ST_LOG_OUT))
+				{
+					std::string totalName = sCF->GetPlayerTotalName(NULL, sSwitch->GetFlag(ST_LOG_OUT), true, itr->class_, itr->race, itr->hr, itr->pname, itr->vip);
+
+					std::string text = sString->Format(sString->GetText(CORE_STR_TYPES(STR_LOGOUT)), totalName.c_str());
+					sWorld->SendGlobalText(text.c_str(), NULL);
+				}
+
+				break;
+			}
+		}
+	}
+}
+
+void FakePlayers::UpdateZone()
+{
+	if (FakePlayersVec.empty())
+		return;
+
+    std::default_random_engine generator{ std::random_device{}() };
+    std::shuffle(std::begin(FakePlayersVec), std::end(FakePlayersVec), generator);
+
+	std::vector<FakePlayersTemplate>::iterator itr;
+	for (itr = FakePlayersVec.begin(); itr != FakePlayersVec.end(); ++itr)
+	{
+		if (!itr->online)
+			continue;
+		if (urand(0, 3) == 0)
+			itr->pzoneid = GenerateZoneId();
+	}		
+}
+
+bool FakePlayers::Logout(std::string name)
+{
+	if (FakePlayersVec.empty())
+		return false;
+
+	std::vector<FakePlayersTemplate>::iterator itr;
+	for (itr = FakePlayersVec.begin(); itr != FakePlayersVec.end(); ++itr)
+		if (strcmp(name.c_str(), itr->pname.c_str()) == 0)
+		{
+			itr->online = false;
+			return true;
+		}
+
+	return false;
+}
+
+bool FakePlayers::isSameTeamId(Player* player,std::string name)
+{
+	std::vector<FakePlayersTemplate>::iterator itr;
+	for (itr = FakePlayersVec.begin(); itr != FakePlayersVec.end(); ++itr)
+		if (player->GetTeamId() == Player::TeamIdForRace(itr->race))
+			return true;
+
+	return false;
+}
+
+
+class FakePlayerScript : public WorldScript
+{
+public:
+	FakePlayerScript() : WorldScript("FakePlayerScript") {}
+
+	void OnAfterConfigLoad(bool)
+	{
+		if (!sSwitch->GetOnOff(ST_FAKE_PLAYERS))
+			return;
+
+		START_PLAYERS = atoi(sSwitch->GetFlagByIndex(ST_FAKE_PLAYERS, 1).c_str());
+		MAX_PLAYERS = atoi(sSwitch->GetFlagByIndex(ST_FAKE_PLAYERS, 2).c_str());
+
+		sFakePlayers->Load();
+
+        std::default_random_engine generator{ std::random_device{}() };
+        std::shuffle(std::begin(FakePlayersVec), std::end(FakePlayersVec), generator);
+
+		uint32 count = 0;
+
+		std::vector<FakePlayersTemplate>::iterator itr;
+		for (itr = FakePlayersVec.begin(); itr != FakePlayersVec.end(); ++itr)
+			if (!itr->online)
+				if (count <= START_PLAYERS)
+				{
+						itr->online = true;
+						count++;
+				}			
+	}
+};
+
+void AddSC_FakePlayerScript()
+{
+	new FakePlayerScript();
+}
diff --git a/src/server/scripts/Custom/FakePlayers/FakePlayers.h b/src/server/scripts/Custom/FakePlayers/FakePlayers.h
new file mode 100644
index 0000000..7cc74ed
--- /dev/null
+++ b/src/server/scripts/Custom/FakePlayers/FakePlayers.h
@@ -0,0 +1,48 @@
+extern uint32 MAX_PLAYERS;
+
+extern uint32  START_PLAYERS;
+
+struct FakePlayersTemplate
+{
+	uint32 ID;
+	std::string pname;                       // player name
+	std::string gname;                       // guild name
+	uint32 lvl;                              // player level
+	uint32 class_;                           // player class
+	uint32 race;                             // player race
+	uint8 gender;                            // player gender
+	uint32 pzoneid;
+	bool online;
+	uint32 hr;
+	uint32 vip;
+};
+extern std::vector<FakePlayersTemplate> FakePlayersVec;
+
+#define MAX_FAKE_PLAYERS_ZONE 10
+extern uint32 FakePlayerZones[MAX_FAKE_PLAYERS_ZONE];
+
+class FakePlayers
+{
+public:
+	static FakePlayers* instance()
+	{
+		static FakePlayers instance;
+		return &instance;
+	}
+	void Load();
+	uint32 GenerateZoneId();
+
+	void LoginOrLogout();
+	void LevelUp();
+	void UpdateZone();
+
+
+
+	bool isSameTeamId(Player* player, std::string name);
+	bool Logout(std::string name);
+
+
+private:
+
+};
+#define sFakePlayers FakePlayers::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Faker/Faker.cpp b/src/server/scripts/Custom/Faker/Faker.cpp
new file mode 100644
index 0000000..c991d43
--- /dev/null
+++ b/src/server/scripts/Custom/Faker/Faker.cpp
@@ -0,0 +1,220 @@
+#pragma execution_character_set("utf-8")
+#include "Faker.h"
+#include "../String/myString.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../Switch/Switch.h"
+#include "Battleground.h"
+#include "BattlegroundMgr.h"
+#include "WaypointManager.h"
+#include "WorldSession.h"
+
+std::unordered_map<uint32, bool>FakerMap;
+std::vector<FakerLocationTemplate> FakerLocation;
+std::vector<WorldSession *> FakerSessions;
+
+void Faker::Load()
+{
+	FakerMap.clear();
+	FakerLocation.clear();
+
+	QueryResult result;
+
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÕËºÅID FROM _¼ÙÈË_ÔÚÏß¼ÙÈË" :
+		"SELECT accountId FROM _faker_online"))
+	{
+		do
+		{
+			if (QueryResult charResult = CharacterDatabase.PQuery("SELECT guid FROM characters WHERE account = %u", result->Fetch()[0].GetUInt32()))
+			{
+				do
+				{
+					FakerMap.insert(std::make_pair(charResult->Fetch()[0].GetUInt32(), false));
+				} while (charResult->NextRow());
+			}
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+
+		"SELECT µØÍ¼ID,X×ø±ê,Y×ø±ê,Z×ø±ê,O×ø±ê FROM _¼ÙÈË_ÔÚÏß¼ÙÈË_×ø±ê" :
+		"SELECT Map,X,Y,Z,O FROM _faker_online_postion"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			FakerLocationTemplate Temp;
+			Temp.Map		= fields[0].GetUInt32();
+			Temp.X			= fields[1].GetFloat();
+			Temp.Y			= fields[2].GetFloat();
+			Temp.Z			= fields[3].GetFloat();
+			Temp.O			= fields[4].GetFloat();
+			FakerLocation.push_back(Temp);
+		} while (result->NextRow());
+	}
+}
+
+void Faker::Add(bool ingnoreLimit)
+{
+	uint32 count = 0;
+
+	for (auto itr = FakerMap.begin(); itr != FakerMap.end(); itr++)
+		if (itr->second)
+			count++;
+
+	if (!ingnoreLimit && count >= sSwitch->GetValue(ST_FAKER_ONLINE))
+		return;
+
+	//std::random_shuffle(FakerMap.begin(), FakerMap.end());
+	
+	for (auto itr = FakerMap.begin(); itr != FakerMap.end(); itr++)
+	{
+		if (itr->second)
+			continue;
+
+		AddFaker(itr->first);
+		break;
+	}
+}
+
+
+DWORD WINAPI FakerThread(LPVOID i)
+{
+	int guid = reinterpret_cast<int>(i);
+
+	QueryResult result = CharacterDatabase.PQuery("SELECT account FROM characters WHERE guid = %u", guid);
+
+	if (!result)
+		return 0;
+
+	uint32 account = result->Fetch()[0].GetUInt32();
+
+	WorldSession *FakerSession = new WorldSession(account, NULL, SEC_PLAYER, 2, time(NULL), LOCALE_zhCN, 0, false, true, 0);
+
+	if (!FakerSession)
+	{
+		delete FakerSession;
+		return 0;
+	}
+
+	FakerSession->SetPlayerLoading(true);
+
+	LoginQueryHolder *holder = new LoginQueryHolder(account, MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER));
+
+	if (!holder->Initialize())
+	{
+		delete holder;
+		FakerSession->SetPlayerLoading(false);
+		return 0;
+	}
+
+	QueryResultHolderFuture future = CharacterDatabase.DelayQueryHolder((SQLQueryHolder*)holder);
+
+	while (true)
+	{
+		if (future.ready())
+		{
+			SQLQueryHolder* param;
+			future.get(param);
+			LoginQueryHolder* holder = (LoginQueryHolder*)param;
+			FakerSession->HandleFakerLoginFromDB((LoginQueryHolder*)param);
+			future.cancel();
+			
+			FakerSessions.push_back(FakerSession);
+			auto itr = FakerMap.find(GUID_LOPART(holder->GetGuid()));
+			if (itr != FakerMap.end())
+				itr->second = true;
+
+			return 0;
+		}
+	}
+
+	return 0;
+}
+
+
+void AddFaker(int i)
+{
+	CloseHandle(CreateThread(NULL, 0, FakerThread, reinterpret_cast<LPVOID>(i), 0, NULL));
+}
+
+void Faker::Remove(uint64 guid)
+{
+	for (auto itr = FakerSessions.begin(); itr != FakerSessions.end();)
+	{
+		if ((*itr)->GetPlayer()->GetGUID() == guid)
+		{
+			WorldSession* s = *itr;
+			s->LogoutPlayer(true);
+			delete s;
+			itr = FakerSessions.erase(itr);
+		}
+		else
+			itr++;
+	}
+}
+		
+		
+void Faker::UpdateAllSessions(uint32 diff)
+{
+	for (auto itr = FakerSessions.begin(); itr != FakerSessions.end(); itr++)
+	{
+		WorldSession * s = *itr;
+		if (s && s->GetPlayer()->IsBeingTeleportedFar())
+			s->HandleMoveWorldportAckOpcode();
+	}
+}
+
+void Faker::Update(Player* faker, uint32 diff)
+{
+	if (!faker->IsFaker)
+		return;
+
+	if (faker->IsBeingTeleportedNear())
+	{
+		WorldPacket p = WorldPacket(MSG_MOVE_TELEPORT_ACK, 8 + 4 + 4);
+		p.appendPackGUID(faker->GetGUID());
+		p << (uint32)0;
+		p << (uint32)time(0);
+		faker->GetSession()->HandleMoveTeleportAck(p);
+	}
+	else if (faker->IsInWorld())
+		faker->GetSession()->HandleFakerPackets();
+
+
+	faker->FakerMoveTimer += diff;
+
+	if (faker->FakerMoveTimer >= 120 * IN_MILLISECONDS)
+	{
+		faker->FakerMoveTimer = 0;
+		
+		if (faker->isMoving() || faker->IsBeingTeleported() || FakerLocation.empty())
+			return;
+
+		FakerLocationTemplate location = FakerLocation[urand(0, FakerLocation.size() - 1)];
+
+		if (faker->GetMapId() != location.Map)
+			faker->TeleportTo(location.Map, location.X + frand(-1, 1), location.Y + frand(-1, 1), location.Z, location.O);		
+		else
+			faker->GetMotionMaster()->MoveCharge(location.X + frand(-1, 1), location.Y + frand(-1, 1), location.Z, faker->GetSpeed(MOVE_RUN));
+	}
+}
+
+
+class FakerLogin : PlayerScript
+{
+public:
+	FakerLogin() : PlayerScript("FakerLogin") {}
+
+	void OnLogin(Player* player)
+	{
+		if (player->IsFaker)
+			return;
+		
+		sFaker->Add(false);
+	}
+};
+void AddSC_FakerLogin()
+{
+	new FakerLogin();
+}
diff --git a/src/server/scripts/Custom/Faker/Faker.h b/src/server/scripts/Custom/Faker/Faker.h
new file mode 100644
index 0000000..644f150
--- /dev/null
+++ b/src/server/scripts/Custom/Faker/Faker.h
@@ -0,0 +1,85 @@
+enum FakerStateType
+{
+	COMBAT,
+	STAY,
+	MOVE,
+};
+
+enum FakerZoneType
+{
+	CITY,
+	WS,
+	AB,
+	OUTDOOR,
+	DUNGEON,
+};
+
+
+struct FakerLocationTemplate
+{
+	uint32 Map;
+	float X;
+	float Y;
+	float Z;
+	float O;
+};
+
+extern std::vector<FakerLocationTemplate> FakerLocation;
+extern std::vector<WorldSession *> FakerSessions;
+extern std::unordered_map<uint32, bool>FakerMap;
+
+void AddFaker(int i);
+
+class Faker
+{
+public:
+	static Faker* instance()
+	{
+		static Faker instance;
+		return &instance;
+	}
+
+	void Load();
+	void Add(bool ingnoreLimit);
+
+	void UpdateAllSessions(uint32 diff);
+	void Update(Player* faker, uint32 diff);
+
+	void Remove(uint64 guid);
+
+	
+
+	void SetStateType(FakerStateType state){ _state = state; }
+	FakerStateType GetStateType(){ return _state; }
+	void SetZoneType(FakerZoneType zone){ _zone = zone; }
+	FakerZoneType GetZoneType(){ return _zone; }
+
+
+
+
+	void OnLogin(Player* faker);
+	void OnLogout(Player* faker);
+	void OnMove(Player* faker);
+	void OnMoveToObject(Player* faker, Object* obj);
+	void OnDetectObject(Player* faker, Object* obj);
+
+	void OnEnterCombat(Player* faker, Unit* victim);
+
+	void OnUpdateZone(Player* faker);
+
+	void OnKilled(Player* faker, Unit* killer);
+	void OnKill(Player* faker, Unit* victim);
+
+	void OnRecvWhisper(Player* faker, Player* sender);
+
+	void OnEventStart(Player* faker, uint32 eventId);
+
+	void OnAcceptQuest(Player* faker, uint32 questId);
+	void OnCompeleteQuest(Player* faker, uint32 questId);
+
+private:
+	FakerZoneType _zone;
+	FakerStateType _state;
+
+};
+#define sFaker Faker::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Fix/Quest/QuelDelar.cpp b/src/server/scripts/Custom/Fix/Quest/QuelDelar.cpp
new file mode 100644
index 0000000..b9e108a
--- /dev/null
+++ b/src/server/scripts/Custom/Fix/Quest/QuelDelar.cpp
@@ -0,0 +1,1027 @@
+#pragma execution_character_set("utf-8")
+#include "../Custom/CommonFunc/CommonFunc.h"
+/*
+DELETE FROM creature WHERE id = 37552;
+INSERT INTO creature (guid, id, map, spawnMask, phaseMask, modelid, equipment_id, position_x, position_y, position_z, orientation, spawntimesecs, spawndist, currentwaypoint, curhealth, curmana, MovementType, npcflag, unit_flags, dynamicflags) VALUES('1976588','37552','530','1','2048','0','0','11781.6','-7068.71','24.9312','3.10074','300','0','0','123','180','0','1','768','32');
+
+DELETE FROM creature WHERE id = 37205;
+DELETE FROM creature_template WHERE entry = 37205;
+insert into creature_template (entry, difficulty_entry_1, difficulty_entry_2, difficulty_entry_3, KillCredit1, KillCredit2, modelid1, modelid2, modelid3, modelid4, name, subname, IconName, gossip_menu_id, minlevel, maxlevel, exp, faction, npcflag, speed_walk, speed_run, scale, rank, mindmg, maxdmg, dmgschool, attackpower, dmg_multiplier, baseattacktime, rangeattacktime, unit_class, unit_flags, unit_flags2, dynamicflags, family, trainer_type, trainer_spell, trainer_class, trainer_race, minrangedmg, maxrangedmg, rangedattackpower, type, type_flags, lootid, pickpocketloot, skinloot, resistance1, resistance2, resistance3, resistance4, resistance5, resistance6, spell1, spell2, spell3, spell4, spell5, spell6, spell7, spell8, PetSpellDataId, VehicleId, mingold, maxgold, AIName, MovementType, InhabitType, HoverHeight, Health_mod, Mana_mod, Armor_mod, RacialLeader, questItem1, questItem2, questItem3, questItem4, questItem5, questItem6, movementId, RegenHealth, mechanic_immune_mask, flags_extra, ScriptName, VerifiedBuild) values('37205','0','0','0','0','0','30570','0','0','0','ÈøÂåÈð°²¡¤Ñ°³¿Õß','','','0','80','80','2','250','0','1','1.14286','1','1','500','700','0','300','5','2000','2000','2','0','2048','0','0','0','0','0','0','0','0','0','7','4096','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','SmartAI','0','3','1','3.5','3','1','0','0','0','0','0','0','0','0','1','0','0','','12340');
+
+
+-- Thalorien Dawnseeker's Remains
+SET @ENTRY := 37552;
+
+DELETE FROM creature_template_addon WHERE(entry=@ENTRY);
+INSERT INTO creature_template_addon (entry,path_id,mount,bytes1,bytes2,emote,auras) VALUES
+(@ENTRY, 0, 0, 0, 0, 0, '25824 31261');
+
+UPDATE creature_template SET ScriptName="npc_thalorien" WHERE entry=@ENTRY;
+UPDATE creature_template SET faction=35 WHERE entry=@ENTRY;
+
+-- Thalorien Dawnseeker SAI
+SET @ENTRY := 37205;
+Delete FROM creature WHERE id = 37205;
+UPDATE creature_template SET faction=250 WHERE entry=@ENTRY;
+UPDATE creature_template SET AIName="SmartAI" WHERE entry=@ENTRY;
+DELETE FROM smart_scripts WHERE entryorguid=@ENTRY AND source_type=0;
+INSERT INTO smart_scripts (entryorguid,source_type,id,link,event_type,event_phase_mask,event_chance,event_flags,event_param1,event_param2,event_param3,event_param4,action_type,action_param1,action_param2,action_param3,action_param4,action_param5,action_param6,target_type,target_param1,target_param2,target_param3,target_x,target_y,target_z,target_o,comment) VALUES
+(@ENTRY, 0, 0, 0, 0, 0, 100, 0, 5000, 7000, 15000, 15000, 11, 67541, 3, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, "Thalorien Dawnseeker - In Combat - Cast 'Bladestorm' (Dungeon & Raid)"),
+(@ENTRY, 0, 1, 0, 0, 0, 100, 0, 2000, 2000, 13000, 13000, 11, 67542, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, "Thalorien Dawnseeker - In Combat - Cast 'Mortal Strike'"),
+(@ENTRY, 0, 2, 0, 0, 0, 100, 0, 19000, 19000, 19000, 19000, 11, 67716, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, "Thalorien Dawnseeker - In Combat - Cast 'Whirlwind'"),
+(@ENTRY, 0, 3, 0, 0, 0, 100, 0, 1000, 1000, 8000, 8000, 11, 57846, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, "Thalorien Dawnseeker - In Combat - Cast 'Heroic Strike'");
+
+-- Morlen Coldgrip SAI
+SET @ENTRY := 37542;
+UPDATE creature_template SET faction=16 WHERE entry=@ENTRY;
+UPDATE creature_template SET AIName="SmartAI" WHERE entry=@ENTRY;
+DELETE FROM smart_scripts WHERE entryorguid=@ENTRY AND source_type=0;
+INSERT INTO smart_scripts (entryorguid,source_type,id,link,event_type,event_phase_mask,event_chance,event_flags,event_param1,event_param2,event_param3,event_param4,action_type,action_param1,action_param2,action_param3,action_param4,action_param5,action_param6,target_type,target_param1,target_param2,target_param3,target_x,target_y,target_z,target_o,comment) VALUES
+(@ENTRY, 0, 0, 0, 0, 0, 100, 0, 2000, 3000, 9000, 10000, 11, 50688, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, "Morlen Coldgrip - In Combat - Cast 'Plague Strike' (Dungeon & Raid)");
+
+
+-- Crypt Raider SAI
+SET @ENTRY := 37541;
+UPDATE creature_template SET faction=16 WHERE entry=@ENTRY;
+UPDATE creature_template SET AIName="SmartAI" WHERE entry=@ENTRY;
+DELETE FROM smart_scripts WHERE entryorguid=@ENTRY AND source_type=0;
+INSERT INTO smart_scripts (entryorguid,source_type,id,link,event_type,event_phase_mask,event_chance,event_flags,event_param1,event_param2,event_param3,event_param4,action_type,action_param1,action_param2,action_param3,action_param4,action_param5,action_param6,target_type,target_param1,target_param2,target_param3,target_x,target_y,target_z,target_o,comment) VALUES
+(@ENTRY, 0, 0, 0, 0, 0, 100, 0, 1000, 2000, 4000, 5000, 11, 31600, 2, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, "Crypt Raider - In Combat - Cast 'Crypt Scarabs' (Dungeon & Raid)");
+
+-- Ghoul Invader SAI
+SET @ENTRY := 37539;
+UPDATE creature_template SET faction=16 WHERE entry=@ENTRY;
+UPDATE creature_template SET AIName="SmartAI" WHERE entry=@ENTRY;
+DELETE FROM smart_scripts WHERE entryorguid=@ENTRY AND source_type=0;
+INSERT INTO smart_scripts (entryorguid,source_type,id,link,event_type,event_phase_mask,event_chance,event_flags,event_param1,event_param2,event_param3,event_param4,action_type,action_param1,action_param2,action_param3,action_param4,action_param5,action_param6,target_type,target_param1,target_param2,target_param3,target_x,target_y,target_z,target_o,comment) VALUES
+(@ENTRY, 0, 0, 0, 0, 0, 100, 0, 1000, 2000, 9000, 10000, 11, 38056, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, "Ghoul Invader - In Combat - Cast 'Flesh Rip' (Dungeon & Raid)");
+
+-- Scourge Zombie SAI
+SET @ENTRY := 37538;
+UPDATE creature_template SET faction=16 WHERE entry=@ENTRY;
+UPDATE creature_template SET AIName="SmartAI" WHERE entry=@ENTRY;
+DELETE FROM smart_scripts WHERE entryorguid=@ENTRY AND source_type=0;
+INSERT INTO smart_scripts (entryorguid,source_type,id,link,event_type,event_phase_mask,event_chance,event_flags,event_param1,event_param2,event_param3,event_param4,action_type,action_param1,action_param2,action_param3,action_param4,action_param5,action_param6,target_type,target_param1,target_param2,target_param3,target_x,target_y,target_z,target_o,comment) VALUES
+(@ENTRY, 0, 0, 0, 0, 0, 100, 0, 1000, 2000, 9000, 10000, 11, 49861, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, "Scourge Zombie - In Combat - Cast 'Infected Bite' (Dungeon & Raid)");
+
+*/
+
+
+enum ThalorienNPCs
+{
+	THALORIEN_NPC_THALORIEN = 37205,
+	THALORIEN_NPC_DEFENDER	= 37211,
+	THALORIEN_NPC_BOSS		= 37542,
+	THALORIEN_NPC_ENEMY_1	= 37538,
+	THALORIEN_NPC_ENEMY_2	= 37539,
+	THALORIEN_NPC_ENEMY_3	= 37541,
+};
+
+Position const ThalorienNPCPos[16] =
+{
+	//[0]			Ñ°³¿Õß1
+	{ 11787.2,	-7070.56,	25.8603,	6.0444},
+	//[1 - 10]		ÎÀ±ø
+	{ 11791.2,	-7070.76,	26.129,		2.31049 },
+	{ 11789.4,	-7072.64,	26.0378,	2.63958 },
+	{ 11787,	-7074.43,	25.8398,	2.51784 },
+	{ 11785,	-7075.82,	25.7344,	2.2186 },
+	{ 11782.8,	-7078,		25.7069,	2.28615 },
+	{ 11784.8,	-7078.31,	25.7336,	2.24374 },
+	{ 11787.3,	-7076.61,	25.7956,	2.18483 },
+	{ 11789.3,	-7074.77,	26.0251,	2.17541 },
+	{ 11791.6,	-7073.19,	26.192,		2.16755 },
+	{ 11793.8,	-7071.21,	26.2234,	2.17619 },
+	//[11]			BOSS
+	{ 11759.3,	-7052.25,	25.9366,	5.70586 },
+	//[12 - 15]
+	{ 11760.6,	-7067.11,	25.1363,	0.286524 },
+	{ 11760.5,	-7059.13,	25.2377,	0.039123 },
+	{ 11760.6,	-7062.04,	25.2717,	0.0116341 },
+	{ 11760,	-7064.6,	25.3605,	0.137299 },
+};
+
+class npc_thalorien : public CreatureScript
+{
+public:
+	npc_thalorien() : CreatureScript("npc_thalorien") { }
+
+	bool OnGossipHello(Player* player, Creature* creature)
+	{
+		player->PlayerTalkClass->ClearMenus();
+
+		if (npc_thalorien::npc_thalorienAI* creatureAI = CAST_AI(npc_thalorien::npc_thalorienAI, creature->AI()))
+			if (creatureAI->HasBeginScence())
+			{
+				player->SEND_GOSSIP_MENU(creature->GetEntry(), creature->GetGUID());
+				return true;
+			}
+
+		if (player->GetQuestStatus(24563) == QUEST_STATUS_INCOMPLETE || player->GetQuestStatus(24535) == QUEST_STATUS_INCOMPLETE)
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "¼ì²éÒÅº¡", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
+
+		player->SEND_GOSSIP_MENU(creature->GetEntry(), creature->GetGUID());
+		return true;
+	}
+
+	bool OnGossipSelect(Player* player, Creature* creature, uint32 /*sender*/, uint32 /*action*/) 
+	{ 
+		player->CLOSE_GOSSIP_MENU();
+	
+		if (npc_thalorien::npc_thalorienAI* creatureAI = CAST_AI(npc_thalorien::npc_thalorienAI, creature->AI()))
+			creatureAI->BeginScene();
+
+		return true;
+	}
+
+	CreatureAI* GetAI(Creature* creature) const
+	{
+		return new npc_thalorienAI(creature);
+	}
+
+	struct npc_thalorienAI : public ScriptedAI
+	{
+		npc_thalorienAI(Creature* creature) : ScriptedAI(creature) 
+		{
+			Reset();
+		}
+
+		void Reset()
+		{
+			_Phase = 0;
+			_Timer = 0;
+
+			for (auto itr = _gurads.begin(); itr != _gurads.end(); itr++)
+				if (Creature* guard = *itr)
+					guard->DespawnOrUnsummon(0);
+			_gurads.clear();
+
+			for (auto itr = _enemies.begin(); itr != _enemies.end(); itr++)
+				if (Creature* guard = *itr)
+					guard->DespawnOrUnsummon(0);
+			_enemies.clear();
+
+			if (Creature* thalorien = me->GetMap()->GetCreature(_thalorien))
+				thalorien->DespawnOrUnsummon(0);
+			_thalorien = 0;
+
+			if (Creature* boss = me->GetMap()->GetCreature(_boss))
+				boss->DespawnOrUnsummon(0);
+			_boss = 0;
+
+		}
+
+		void BeginScene()
+		{
+			_Timer = 100;
+			_Phase = 1;
+		}
+
+		void EndScene(bool win)
+		{
+			if (win)
+			{
+				std::list<Player*> playersNearby;
+				me->GetPlayerListInGrid(playersNearby, 100);
+				if (!playersNearby.empty())
+					for (std::list<Player*>::iterator itr = playersNearby.begin(); itr != playersNearby.end(); ++itr)
+						if ((*itr) && (*itr)->IsInWorld())
+							(*itr)->KilledMonsterCredit(37601, 0);
+			}
+
+			Reset();
+		}
+
+		bool HasBeginScence()
+		{
+			return _Phase != 0;
+		}
+
+		void AddThalorienThreat(Creature* c)
+		{
+			if (Creature* thalorien = me->GetMap()->GetCreature(_thalorien))
+			{
+				thalorien->AddThreat(c, 100.0f);	
+				c->AddThreat(thalorien, 100.0f);
+				thalorien->AI()->AttackStart(c);
+			}
+		}
+
+		void JustSummoned(Creature* summon) override
+		{
+			switch (summon->GetEntry())
+			{
+			case THALORIEN_NPC_DEFENDER:
+				_gurads.push_back(summon);
+				break;
+			case THALORIEN_NPC_THALORIEN:
+				_thalorien = summon->GetGUID();
+				break;
+			case THALORIEN_NPC_BOSS:
+				_boss = summon->GetGUID();
+				summon->Mount(25678);
+				summon->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC);
+				break;
+			default:
+				summon->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC);
+				_enemies.push_back(summon);
+				break;
+			}
+		}
+
+		void SummonedCreatureDies(Creature* summon, Unit* /*killer*/) override
+		{
+			switch (summon->GetEntry())
+			{
+			case THALORIEN_NPC_THALORIEN:
+				EndScene(false);
+				break;
+			case THALORIEN_NPC_BOSS:
+				_Timer = 2000;
+				break;
+			default:
+				for (auto itr = _enemies.begin(); itr != _enemies.end();)
+					if ((*itr)->GetGUID() == summon->GetGUID())
+						_enemies.erase(itr++);
+					else
+						itr++;
+				if (_enemies.empty())
+					_Timer = 2000;
+				break;
+			}
+		}
+
+		void UpdateAI(uint32 diff)
+		{
+			if (_Timer)
+			{
+				if (_Timer <= diff)
+				{
+					switch (_Phase)
+					{
+					//ÕÙ»½ Ñ°³¿Õß ÎÀ±ø BOSS
+					case 1:
+						me->SummonCreature(THALORIEN_NPC_THALORIEN, ThalorienNPCPos[0]);
+						for (size_t i = 1; i < 11; i++)
+							me->SummonCreature(THALORIEN_NPC_DEFENDER, ThalorienNPCPos[i]);
+						me->SummonCreature(THALORIEN_NPC_BOSS, ThalorienNPCPos[11]);
+						_Timer = 1000;
+						_Phase++;
+						break;
+					//Ñ°³¿Õß¶ÔÎÀ±øËµ»°1
+					case 2:
+						if (Creature* thalorien = me->GetMap()->GetCreature(_thalorien))
+						{
+							thalorien->MonsterSay("ÎÒÃÇ±ØÐë²»Ï§Ò»ÇÐ´ú¼Û±£ÎÀÌ«ÑôÖ®¾®¡£", LANG_UNIVERSAL, NULL);
+							thalorien->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+						}
+							
+						_Timer = 3000;
+						_Phase++;
+						break;
+					//Ñ°³¿Õß¶ÔÎÀ±øËµ»°2
+					case 3:
+						if (Creature* thalorien = me->GetMap()->GetCreature(_thalorien))
+						{
+							thalorien->MonsterSay("ÎÒÃüÁîÄãÃÇÁ¢¼´»Ø·ÀÌ«ÑôÖ®¾®£¬ÈÙÒ«ÓëÎÒÃÇÍ¬ÔÚ¡£", LANG_UNIVERSAL, NULL);
+							thalorien->HandleEmoteCommand(EMOTE_ONESHOT_SALUTE);
+						}
+							
+						_Timer = 3000;
+						_Phase++;
+						break;
+					//Ñ°³¿Õß¶ÔÎÀ±øËµ»°3
+					case 4:
+						if (Creature* thalorien = me->GetMap()->GetCreature(_thalorien))
+						{
+							thalorien->MonsterSay("ÎÒ»áÁôÔÚÕâÀïÎªÄãÃÇÕùÈ¡¾¡¿ÉÄÜ¶àµÄÊ±¼ä¡£", LANG_UNIVERSAL, NULL);
+							thalorien->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+						}
+							
+						_Timer = 3000;
+						_Phase++;
+						break;
+					//Ñ°³¿Õß¶ÔÎÀ±øËµ»°4
+					case 5:
+						if (Creature* thalorien = me->GetMap()->GetCreature(_thalorien))
+						{
+							thalorien->MonsterSay("ÓëÄãÃÇ²¢¼çÕ½¶·£¬ÊØÎÀÎÒÃÇµÄÁìÍÁºÍÈËÃñ£¬ÊÇÎÒ×î´óµÄÈÙÒ«¡£", LANG_UNIVERSAL, NULL);
+							thalorien->HandleEmoteCommand(EMOTE_ONESHOT_SALUTE);
+						}
+							
+						_Timer = 3000;
+						_Phase++;
+						break;
+					//ÎÀ±øËµ»°
+					case 6:
+						for (auto itr = _gurads.begin(); itr != _gurads.end(); itr++)
+						{
+							if (Creature* guard = *itr)
+							{
+								guard->MonsterSay("×ñÃü£¬³¤¹Ù£¡", LANG_UNIVERSAL, NULL);
+								guard->HandleEmoteCommand(EMOTE_ONESHOT_SALUTE);
+							}
+						}				
+						_Timer = 1000;
+						_Phase++;
+						break;
+					//ÎÀ±øÀë¿ª
+					case 7:
+						for (auto itr = _gurads.begin(); itr != _gurads.end();)
+						{
+							if (Creature* guard = *itr)
+							{
+								_gurads.erase(itr++);																	
+								guard->SetWalk(false);
+								guard->GetMotionMaster()->MovePoint(0, 11836.7, -7070.49, 26.9794);
+								guard->DespawnOrUnsummon(3000);
+							}
+							else
+								itr++;
+						}
+						_Timer = 1000;
+						_Phase++;
+						break;
+					//Ñ°³¿ÕßÒÆ¶¯µ½BOSSÇ°£¬ÒÆ¶¯¹ý³ÌÖÐÒª½²»°
+					case 8:
+						if (Creature* thalorien = me->GetMap()->GetCreature(_thalorien))
+						{
+							thalorien->MonsterSay("Ä°ÉúÈË...Äã²»ÊÇÎÒµÄÊ¿±ø¡£Äã½«»áºÍÎÒÒ»ÆðÃæ¶ÔÇ¿´óµÄµÐÈËÂð£¿", LANG_UNIVERSAL, NULL);
+							thalorien->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+							thalorien->SetWalk(true);
+							thalorien->GetMotionMaster()->MovePoint(0, 11777.6, -7063.79, 24.7945);
+							if (Creature* boss = me->GetMap()->GetCreature(_boss))
+								thalorien->SetFacingToObject(boss);
+						}						
+						_Timer = 5000;
+						_Phase++;
+						break;
+					//Ñ°³¿Õß¶ÔBOSS´óº°1
+					case 9:
+						if (Creature* thalorien = me->GetMap()->GetCreature(_thalorien))
+						{
+							thalorien->SetWalk(false);
+							thalorien->MonsterYell("ÌýºÃÁË£¬ÌìÔÖ¾üÍÅµÄÔü×ÓÃÇ¡£Ö»ÒªÎÒ»¹»î×Å£¬ÄãÃÇÐÝÏë½øÈëÌ«ÑôÖ®¾®£¡", LANG_UNIVERSAL, NULL);
+							thalorien->HandleEmoteCommand(EMOTE_ONESHOT_ROAR);
+							thalorien->SetHomePosition(thalorien->GetPositionX(), thalorien->GetPositionY(), thalorien->GetPositionZ(), thalorien->GetOrientation());
+						}					
+						_Timer = 1000;
+						_Phase++;
+						break;
+					case 10:
+						if (Creature* boss = me->GetMap()->GetCreature(_boss))
+							boss->MonsterYell("Äã½«ºÍÄãµÄ³ÇÊÐÒ»Æð»ÙÃð¡£Î×ÑýÍõ½«»á»ñµÃÎ°´óµÄÊ¤Àû£¬È»¶øÈ´Ã»ÓÐÈË»á¼ÇµÃÄã£¡", LANG_UNIVERSAL, NULL);
+						_Timer = 1000;
+						_Phase++;
+						break;
+					//BOSS´óº°1£¬ÕÙ»½µÚÒ»²¨Ð¡¹Ö
+					case 11:
+						if (Creature* boss = me->GetMap()->GetCreature(_boss))
+						{
+							boss->HandleEmoteCommand(EMOTE_ONESHOT_POINT);
+							boss->MonsterYell("½ø¹¥£¡", LANG_UNIVERSAL, NULL);
+						}
+
+						for (size_t i = 12; i < 16; i++)
+						{
+							if (Creature* c = me->SummonCreature(THALORIEN_NPC_ENEMY_1, ThalorienNPCPos[i]))
+								AddThalorienThreat(c);
+						}
+							
+						_Timer = 0;
+						_Phase++;
+						break;
+					//ÕÙ»½µÚ¶þ²¨Ð¡¹Ö
+					case 12:
+						if (Creature* boss = me->GetMap()->GetCreature(_boss))
+						{
+							boss->MonsterYell("Ê³Ê¬¹í£¬¸ÉµôÄÇ¸ö¾«Áé£¡", LANG_UNIVERSAL, NULL);
+							boss->HandleEmoteCommand(EMOTE_ONESHOT_POINT);
+						}
+							
+						for (size_t i = 12; i < 16; i++)
+						{
+							if (Creature* c = me->SummonCreature(THALORIEN_NPC_ENEMY_2, ThalorienNPCPos[i]))
+								AddThalorienThreat(c);
+						}
+						_Timer = 0;
+						_Phase++;
+						break;
+					//ÕÙ»½µÚÈý²¨Ð¡¹Ö
+					case 13:
+						if (Creature* boss = me->GetMap()->GetCreature(_boss))
+						{
+							boss->MonsterYell("ÌìÔÖ¾üÍÅÕ½ÎÞ²»Ê¤£¡Ö©ÖëÃÇ£¬ÏÖÔÚ½ø¹¥£¡", LANG_UNIVERSAL, NULL);
+							boss->HandleEmoteCommand(EMOTE_ONESHOT_POINT);
+						}
+
+						for (size_t i = 12; i < 15; i++)
+						{
+							if (Creature* c = me->SummonCreature(THALORIEN_NPC_ENEMY_3, ThalorienNPCPos[i]))
+								AddThalorienThreat(c);
+						}
+						_Timer = 0;
+						_Phase++;
+						break;
+					//BOSS¼¤»î
+					case 14:
+						if (Creature* boss = me->GetMap()->GetCreature(_boss))
+						{
+							boss->MonsterYell("ÎÒÒªÇ××ÔÉ±ÁËÄã£¡", LANG_UNIVERSAL, NULL);
+							boss->HandleEmoteCommand(EMOTE_ONESHOT_ROAR);
+						}			
+
+						if (Creature* boss = me->GetMap()->GetCreature(_boss))
+						{
+							boss->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC);
+							AddThalorienThreat(boss);
+						}				
+						_Timer = 0;
+						_Phase++;
+						break;
+					//ÓëÍæ¼Ò¶Ô»°
+					case 15:
+						if (Creature* thalorien = me->GetMap()->GetCreature(_thalorien))
+						{
+							thalorien->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+							thalorien->MonsterSay("ÎÒ...´ÓÎ´Ïë¹ýÄÜ´ÓÕâ³¡Õ½¶·ÖÐÉú´æÏÂÀ´¡£", LANG_UNIVERSAL, NULL);
+						}					
+						_Timer = 5000;
+						_Phase++;
+						break;
+					case 16:
+						if (Creature* thalorien = me->GetMap()->GetCreature(_thalorien))
+						{
+							thalorien->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+							thalorien->MonsterSay("·¢ÉúÁËÊ²Ã´£¿ÎÒÔõÃ´ÔÚÕâÀï£¿", LANG_UNIVERSAL, NULL);
+						}
+							
+						_Timer = 5000;
+						_Phase++;
+						break;
+					case 17:
+						if (Creature* thalorien = me->GetMap()->GetCreature(_thalorien))
+						{
+							thalorien->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+							thalorien->MonsterSay("ÕâÊÇ...¿ü¶ûµÂÀ­£¡ÄãµÃµ½ÁËÕâ°Ñ½££¡", LANG_UNIVERSAL, NULL);
+						}
+							
+						_Timer = 5000;
+						_Phase++;
+						break;
+					case 18:
+						if (Creature* thalorien = me->GetMap()->GetCreature(_thalorien))
+							thalorien->MonsterSay("Õâ°Ñ½£Ñ¡ÔñÁËÄã³ÉÎªÐÂµÄÖ÷ÈË£¬ÕâÊÇÎÒµÄ×£¸££¬ÇëÏñÎÒÒ»ÑùÓëÌìÔÖ¾üÍÅÕ½¶·£¡", LANG_UNIVERSAL, NULL);
+							
+						_Timer = 5000;
+						_Phase++;
+						break;
+					case 19:
+						EndScene(true);
+						break;
+					}
+				}
+				else
+					_Timer -= diff;
+			}	
+		}
+
+	private:
+		uint32 _Timer;
+		uint32 _Phase;
+		std::list<Creature*> _gurads;
+		std::list<Creature*> _enemies;
+		uint64 _thalorien;
+		uint64 _boss;
+	};
+};
+
+
+//¾»»¯¿ü¶ûµÂÀ­
+/*
+-- creature
+DELETE FROM creature_template WHERE entry IN (37781,36991,38047,37746,37763,37764,37765,38056);
+
+INSERT INTO creature_template (entry, difficulty_entry_1, difficulty_entry_2, difficulty_entry_3, KillCredit1, KillCredit2, modelid1, modelid2, modelid3, modelid4, name, subname, IconName, gossip_menu_id, minlevel, maxlevel, exp, faction, npcflag, speed_walk, speed_run, scale, rank, mindmg, maxdmg, dmgschool, attackpower, dmg_multiplier, baseattacktime, rangeattacktime, unit_class, unit_flags, unit_flags2, dynamicflags, family, trainer_type, trainer_spell, trainer_class, trainer_race, minrangedmg, maxrangedmg, rangedattackpower, type, type_flags, lootid, pickpocketloot, skinloot, resistance1, resistance2, resistance3, resistance4, resistance5, resistance6, spell1, spell2, spell3, spell4, spell5, spell6, spell7, spell8, PetSpellDataId, VehicleId, mingold, maxgold, AIName, MovementType, InhabitType, HoverHeight, Health_mod, Mana_mod, Armor_mod, RacialLeader, questItem1, questItem2, questItem3, questItem4, questItem5, questItem6, movementId, RegenHealth, mechanic_immune_mask, flags_extra, ScriptName, VerifiedBuild) VALUES('36991','0','0','0','0','0','21460','0','0','0','Ì«ÑôÖ®¾®ÊØ»¤Õß','','','0','80','80','1','1960','0','1','1.14286','1','0','0','0','0','0','1','2000','2000','1','0','2048','0','0','0','0','0','0','0','0','0','9','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','NullCreatureAI','0','3','1','2','1','1','0','0','0','0','0','0','0','144','1','0','0','','12340');
+INSERT INTO creature_template (entry, difficulty_entry_1, difficulty_entry_2, difficulty_entry_3, KillCredit1, KillCredit2, modelid1, modelid2, modelid3, modelid4, name, subname, IconName, gossip_menu_id, minlevel, maxlevel, exp, faction, npcflag, speed_walk, speed_run, scale, rank, mindmg, maxdmg, dmgschool, attackpower, dmg_multiplier, baseattacktime, rangeattacktime, unit_class, unit_flags, unit_flags2, dynamicflags, family, trainer_type, trainer_spell, trainer_class, trainer_race, minrangedmg, maxrangedmg, rangedattackpower, type, type_flags, lootid, pickpocketloot, skinloot, resistance1, resistance2, resistance3, resistance4, resistance5, resistance6, spell1, spell2, spell3, spell4, spell5, spell6, spell7, spell8, PetSpellDataId, VehicleId, mingold, maxgold, AIName, MovementType, InhabitType, HoverHeight, Health_mod, Mana_mod, Armor_mod, RacialLeader, questItem1, questItem2, questItem3, questItem4, questItem5, questItem6, movementId, RegenHealth, mechanic_immune_mask, flags_extra, ScriptName, VerifiedBuild) VALUES('37746','0','0','0','0','0','11686','0','0','0','Ì«ÑôÖ®¾®Ê©·¨¼ÙÈË','','','0','80','80','2','114','0','1','1.14286','1','0','0','0','0','0','1','2000','2000','1','33554432','2048','0','0','0','0','0','0','0','0','0','10','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','NullCreatureAI','0','4','1','1','1','1','0','0','0','0','0','0','0','0','1','0','0','','12340');
+INSERT INTO creature_template (entry, difficulty_entry_1, difficulty_entry_2, difficulty_entry_3, KillCredit1, KillCredit2, modelid1, modelid2, modelid3, modelid4, name, subname, IconName, gossip_menu_id, minlevel, maxlevel, exp, faction, npcflag, speed_walk, speed_run, scale, rank, mindmg, maxdmg, dmgschool, attackpower, dmg_multiplier, baseattacktime, rangeattacktime, unit_class, unit_flags, unit_flags2, dynamicflags, family, trainer_type, trainer_spell, trainer_class, trainer_race, minrangedmg, maxrangedmg, rangedattackpower, type, type_flags, lootid, pickpocketloot, skinloot, resistance1, resistance2, resistance3, resistance4, resistance5, resistance6, spell1, spell2, spell3, spell4, spell5, spell6, spell7, spell8, PetSpellDataId, VehicleId, mingold, maxgold, AIName, MovementType, InhabitType, HoverHeight, Health_mod, Mana_mod, Armor_mod, RacialLeader, questItem1, questItem2, questItem3, questItem4, questItem5, questItem6, movementId, RegenHealth, mechanic_immune_mask, flags_extra, ScriptName, VerifiedBuild) VALUES('37763','0','0','0','0','0','19706','0','0','0','´ó²©Ñ§ÕßÂåÄ¦Ë¹','','','0','80','80','1','35','0','1','1.14286','1','3','0','0','0','0','1','2000','2000','2','0','2048','0','0','0','0','0','0','0','0','0','7','4','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','200','20','1','0','0','0','0','0','0','0','0','1','0','0','','12340');
+INSERT INTO creature_template (entry, difficulty_entry_1, difficulty_entry_2, difficulty_entry_3, KillCredit1, KillCredit2, modelid1, modelid2, modelid3, modelid4, name, subname, IconName, gossip_menu_id, minlevel, maxlevel, exp, faction, npcflag, speed_walk, speed_run, scale, rank, mindmg, maxdmg, dmgschool, attackpower, dmg_multiplier, baseattacktime, rangeattacktime, unit_class, unit_flags, unit_flags2, dynamicflags, family, trainer_type, trainer_spell, trainer_class, trainer_race, minrangedmg, maxrangedmg, rangedattackpower, type, type_flags, lootid, pickpocketloot, skinloot, resistance1, resistance2, resistance3, resistance4, resistance5, resistance6, spell1, spell2, spell3, spell4, spell5, spell6, spell7, spell8, PetSpellDataId, VehicleId, mingold, maxgold, AIName, MovementType, InhabitType, HoverHeight, Health_mod, Mana_mod, Armor_mod, RacialLeader, questItem1, questItem2, questItem3, questItem4, questItem5, questItem6, movementId, RegenHealth, mechanic_immune_mask, flags_extra, ScriptName, VerifiedBuild) VALUES('37764','0','0','0','0','0','17122','0','0','0','ÂåË÷Âê¡¤ÈûÂ¡','¿ü¶ûÈøÀ­Ë¹ÉãÕþÍõ','','0','80','80','2','35','0','1','1.14286','1','3','0','0','0','0','1','2000','2000','2','0','2048','0','0','0','0','0','0','0','0','0','7','76','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','NullCreatureAI','0','3','1','400','30','1','1','0','0','0','0','0','0','0','1','0','0','','12340');
+INSERT INTO creature_template (entry, difficulty_entry_1, difficulty_entry_2, difficulty_entry_3, KillCredit1, KillCredit2, modelid1, modelid2, modelid3, modelid4, name, subname, IconName, gossip_menu_id, minlevel, maxlevel, exp, faction, npcflag, speed_walk, speed_run, scale, rank, mindmg, maxdmg, dmgschool, attackpower, dmg_multiplier, baseattacktime, rangeattacktime, unit_class, unit_flags, unit_flags2, dynamicflags, family, trainer_type, trainer_spell, trainer_class, trainer_race, minrangedmg, maxrangedmg, rangedattackpower, type, type_flags, lootid, pickpocketloot, skinloot, resistance1, resistance2, resistance3, resistance4, resistance5, resistance6, spell1, spell2, spell3, spell4, spell5, spell6, spell7, spell8, PetSpellDataId, VehicleId, mingold, maxgold, AIName, MovementType, InhabitType, HoverHeight, Health_mod, Mana_mod, Armor_mod, RacialLeader, questItem1, questItem2, questItem3, questItem4, questItem5, questItem6, movementId, RegenHealth, mechanic_immune_mask, flags_extra, ScriptName, VerifiedBuild) VALUES('37765','0','0','0','0','0','18146','0','0','0','°¢Èð¿Ë¡¤×·ÈÕÕßÉÏÎ¾','¸ßµÈ¾«Áé´ú±í','','0','80','80','1','534','0','1','1.14286','1','0','0','0','0','0','1','2000','2000','1','0','2048','0','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','NullCreatureAI','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','0','0','','12340');
+INSERT INTO creature_template (entry, difficulty_entry_1, difficulty_entry_2, difficulty_entry_3, KillCredit1, KillCredit2, modelid1, modelid2, modelid3, modelid4, name, subname, IconName, gossip_menu_id, minlevel, maxlevel, exp, faction, npcflag, speed_walk, speed_run, scale, rank, mindmg, maxdmg, dmgschool, attackpower, dmg_multiplier, baseattacktime, rangeattacktime, unit_class, unit_flags, unit_flags2, dynamicflags, family, trainer_type, trainer_spell, trainer_class, trainer_race, minrangedmg, maxrangedmg, rangedattackpower, type, type_flags, lootid, pickpocketloot, skinloot, resistance1, resistance2, resistance3, resistance4, resistance5, resistance6, spell1, spell2, spell3, spell4, spell5, spell6, spell7, spell8, PetSpellDataId, VehicleId, mingold, maxgold, AIName, MovementType, InhabitType, HoverHeight, Health_mod, Mana_mod, Armor_mod, RacialLeader, questItem1, questItem2, questItem3, questItem4, questItem5, questItem6, movementId, RegenHealth, mechanic_immune_mask, flags_extra, ScriptName, VerifiedBuild) VALUES('37781','0','0','0','0','0','15511','0','0','0','Ì«ÑôÖ®¾®ÈÙÓþÊØÎÀ','','','0','80','80','2','35','0','1','1.14286','1','1','0','0','0','0','1','2000','2000','1','0','2048','0','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','NullCreatureAI','0','3','1','3','1','1','0','0','0','0','0','0','0','144','1','0','0','','12340');
+INSERT INTO creature_template (entry, difficulty_entry_1, difficulty_entry_2, difficulty_entry_3, KillCredit1, KillCredit2, modelid1, modelid2, modelid3, modelid4, name, subname, IconName, gossip_menu_id, minlevel, maxlevel, exp, faction, npcflag, speed_walk, speed_run, scale, rank, mindmg, maxdmg, dmgschool, attackpower, dmg_multiplier, baseattacktime, rangeattacktime, unit_class, unit_flags, unit_flags2, dynamicflags, family, trainer_type, trainer_spell, trainer_class, trainer_race, minrangedmg, maxrangedmg, rangedattackpower, type, type_flags, lootid, pickpocketloot, skinloot, resistance1, resistance2, resistance3, resistance4, resistance5, resistance6, spell1, spell2, spell3, spell4, spell5, spell6, spell7, spell8, PetSpellDataId, VehicleId, mingold, maxgold, AIName, MovementType, InhabitType, HoverHeight, Health_mod, Mana_mod, Armor_mod, RacialLeader, questItem1, questItem2, questItem3, questItem4, questItem5, questItem6, movementId, RegenHealth, mechanic_immune_mask, flags_extra, ScriptName, VerifiedBuild) VALUES('38047','0','0','0','0','0','30894','30896','30895','30897','Ñª¾«Áé³¯Ê¥Õß','','','0','80','80','2','35','0','1','1.14286','1','0','0','0','0','0','1','2000','2000','2','0','2048','0','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','NullCreatureAI','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','0','0','','12340');
+INSERT INTO creature_template (entry, difficulty_entry_1, difficulty_entry_2, difficulty_entry_3, KillCredit1, KillCredit2, modelid1, modelid2, modelid3, modelid4, name, subname, IconName, gossip_menu_id, minlevel, maxlevel, exp, faction, npcflag, speed_walk, speed_run, scale, rank, mindmg, maxdmg, dmgschool, attackpower, dmg_multiplier, baseattacktime, rangeattacktime, unit_class, unit_flags, unit_flags2, dynamicflags, family, trainer_type, trainer_spell, trainer_class, trainer_race, minrangedmg, maxrangedmg, rangedattackpower, type, type_flags, lootid, pickpocketloot, skinloot, resistance1, resistance2, resistance3, resistance4, resistance5, resistance6, spell1, spell2, spell3, spell4, spell5, spell6, spell7, spell8, PetSpellDataId, VehicleId, mingold, maxgold, AIName, MovementType, InhabitType, HoverHeight, Health_mod, Mana_mod, Armor_mod, RacialLeader, questItem1, questItem2, questItem3, questItem4, questItem5, questItem6, movementId, RegenHealth, mechanic_immune_mask, flags_extra, ScriptName, VerifiedBuild) VALUES('38056','0','0','0','0','0','21008','0','0','0','Ë¾¿â¼ÎÁ¢ÂåË¹','','','0','80','80','2','35','0','1','1.14286','1','0','0','0','0','0','1','2000','2000','2','0','2048','0','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','NullCreatureAI','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','0','0','npc_queldelar_sunwell_plateau','12340');
+DELETE FROM creature WHERE map = 580 AND id IN (37781,36991,38047,37746,37763,37764,37765,38056);
+DELETE FROM creature WHERE guid = 1976653;
+INSERT INTO creature (guid, id, map, spawnMask, phaseMask, modelid, equipment_id, position_x, position_y, position_z, orientation, spawntimesecs, spawndist, currentwaypoint, curhealth, curmana, MovementType, npcflag, unit_flags, dynamicflags) VALUES('1976653','38056','580','1','2048','0','0','1671.49','606.427','28.0503','3.79407','300','0','0','41','60','0','0','0','0');
+
+-- spell
+DELETE FROM spell_script_names WHERE spell_id IN(70477,70548);
+INSERT INTO spell_script_names (spell_id, ScriptName) VALUES('70477','spell_bh_cleanse_quel_delar');
+INSERT INTO spell_script_names (spell_id, ScriptName) VALUES('70548','spell_bh_cleanse_quel_delar');
+
+-- gob
+delete from gameobject_template where entry =195682;
+insert into gameobject_template (entry, type, displayId, name, IconName, castBarCaption, unk1, faction, flags, size, questItem1, questItem2, questItem3, questItem4, questItem5, questItem6, data0, data1, data2, data3, data4, data5, data6, data7, data8, data9, data10, data11, data12, data13, data14, data15, data16, data17, data18, data19, data20, data21, data22, data23, AIName, ScriptName, VerifiedBuild) values('195682','22','8111','´ïÀ­È»´«ËÍÃÅ','','','','94','0','1','0','0','0','0','0','0','68328','0','0','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','','12340');
+DELETE FROM gameobject WHERE map = 580 AND id = 195682;
+*/
+
+
+enum QuelDelarCreatures
+{
+	NPC_ROMMATH = 37763,
+	NPC_THERON = 37764,
+	NPC_AURIC = 37765,
+	NPC_QUEL_GUARD = 37781,
+	NPC_TRIGGER = 38056
+};
+
+enum QuelDelarGameobjects
+{
+	GO_QUEL_DANAR = 201794
+};
+enum QuelDelarMisc
+{
+	ITEM_TAINTED_QUELDANAR_1 = 49879,
+	ITEM_TAINTED_QUELDANAR_2 = 49889,
+	SPELL_WRATH_QUEL_DANAR = 70493,
+	SPELL_ICY_PRISON = 70540
+};
+
+class npc_sunwell_warder : public CreatureScript
+{
+public:
+	npc_sunwell_warder() : CreatureScript("npc_sunwell_warder") { }
+	bool OnGossipHello(Player* player, Creature* creature)
+	{
+		player->PlayerTalkClass->ClearMenus();
+
+		if (player->HasItemCount(ITEM_TAINTED_QUELDANAR_1, 1) || player->HasItemCount(ITEM_TAINTED_QUELDANAR_2, 1))
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "´øÎÒÈ¥Ì«ÑôÖ®¾®", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
+
+		player->SEND_GOSSIP_MENU(creature->GetEntry(), creature->GetGUID());
+		return true;
+	}
+	bool OnGossipSelect(Player* player, Creature* creature, uint32 /*uiSender*/, uint32 uiAction)
+	{
+		player->PlayerTalkClass->ClearMenus();
+
+		player->SetGameMaster(true);
+		player->TeleportTo(580, 1728.5f, 709.219f, 71.1905f, 2.78676f);
+		player->SetGameMaster(false);
+		player->SetPhaseMask(2048, true);
+		player->CLOSE_GOSSIP_MENU();
+
+		return true;
+	}
+};
+
+
+class npc_queldelar_sunwell_plateau : public CreatureScript
+{
+public:
+	npc_queldelar_sunwell_plateau() : CreatureScript("npc_queldelar_sunwell_plateau") { }
+
+	CreatureAI* GetAI(Creature* creature) const
+	{
+		return new npc_queldelar_sunwell_plateauAI(creature);
+	}
+
+	struct npc_queldelar_sunwell_plateauAI : public ScriptedAI
+	{
+		npc_queldelar_sunwell_plateauAI(Creature* creature) : ScriptedAI(creature)
+		{
+			Reset();
+		}
+
+		void Reset()
+		{
+			_Phase = 0;
+			_Timer = 0;
+		}
+
+		void BeginScene()
+		{
+			_Timer = 100;
+			_Phase = 1;
+		}
+
+		void MoveInLineOfSight(Unit* who) override
+		{
+			if (_Phase != 0)
+				return;
+
+			if (who->GetDistance2d(me) > 20.0f)
+				return;
+
+			std::ostringstream oss;
+			oss << "ÏÈÉúÃÇ£¬Å®Ê¿ÃÇ£¬ÓÐÇë¿ü¶ûµÂÀ­µÄÐÂÖ÷ÈË£¬" << who->GetName() << "¡£";
+			me->MonsterYell(oss.str().c_str(), LANG_UNIVERSAL, NULL);
+
+			if (who->GetTypeId() == TYPEID_PLAYER)
+				_player = who->GetGUID();
+
+			_Phase++;
+
+			me->SummonCreature(37781, 1614.89, 598.706, 33.3211, 0.367885);
+			me->SummonCreature(37781, 1677.1, 570.175, 33.3212, 4.29488);
+			me->SummonCreature(37781, 1669.38, 573.631, 33.3212, 4.2242);
+			me->SummonCreature(37781, 1654.74, 583.131, 33.3212, 4.03963);
+			me->SummonCreature(37781, 1649.73, 588.163, 33.3212, 3.86292);
+			me->SummonCreature(37781, 1638.94, 602.943, 33.3212, 3.5252);
+			me->SummonCreature(37781, 1635.69, 610.968, 33.3212, 3.45451);
+			me->SummonCreature(37781, 1632.77, 627.612, 32.9608, 3.26994);
+			me->SummonCreature(37781, 1735.87, 599.171, 28.0505, 2.41);
+			me->SummonCreature(37781, 1727.98, 591.396, 28.0505, 2.23);
+			me->SummonCreature(37781, 1670.23, 665.44, 28.0503, 5.41);
+			me->SummonCreature(37781, 1662.86, 658.458, 28.0503, 5.59);
+			me->SummonCreature(37781, 1663.75, 633.058, 28.0503, 4.49);
+			me->SummonCreature(37781, 1665.48, 640.896, 28.0503, 4.49);
+			me->SummonCreature(37781, 1674.14, 638.984, 28.0503, 4.49);
+			me->SummonCreature(37781, 1672.48, 631.053, 28.0503, 4.55);
+			me->SummonCreature(37781, 1688.26, 616.497, 27.3452, 3.95);
+			me->SummonCreature(37781, 1683.62, 624.152, 27.3538, 3.42);
+			me->SummonCreature(37781, 1781.84, 680.202, 71.1904, 3.67);
+			me->SummonCreature(37781, 1767.5, 697.132, 71.1904, 3.91);
+			me->SummonCreature(37781, 1748.77, 709.204, 71.1904, 4.24);
+			me->SummonCreature(37781, 1727.06, 716.86, 71.1904, 4.48);
+			me->SummonCreature(37781, 1704.8, 720.264, 71.058, 4.78);
+			me->SummonCreature(37781, 1718.79, 698.847, 71.1902, 1.34);
+			me->SummonCreature(37781, 1727.47, 696.601, 71.1902, 1.10);
+			me->SummonCreature(37781, 1742.9, 688.146, 71.1902, 1.05);
+			me->SummonCreature(37781, 1748.59, 683.721, 71.1902, 0.62);
+			me->SummonCreature(37781, 1760.28, 670.492, 71.1902, 0.67);
+			me->SummonCreature(37781, 1764.82, 663.761, 71.1902, 0.63);
+			me->SummonCreature(37781, 1769.97, 650.558, 71.1914, 1.95);
+			me->SummonCreature(37781, 1776.09, 652.853, 71.1943, 2.17);
+			me->SummonCreature(37781, 1793.8, 661.515, 71.1943, 2.19);
+			me->SummonCreature(36991, 1619.75, 634.382, 33.486, 4.90);
+			me->SummonCreature(36991, 1625.67, 577.498, 33.3213, 0.62);
+			me->SummonCreature(36991, 1640.45, 558.392, 33.3213, 0.85);
+			me->SummonCreature(36991, 1658.87, 545.124, 33.3213, 1.16);
+			me->SummonCreature(36991, 1704.09, 583.276, 28.182, 1.75);
+			me->SummonCreature(36991, 1653.75, 634.033, 28.085, 6.10);
+			me->SummonCreature(36991, 1694.93, 674.09, 28.0503, 4.76);
+			me->SummonCreature(36991, 1744.84, 621.776, 28.0503, 3.00);
+			me->SummonCreature(38047, 1695.1, 583.061, 28.2018, 3.56);
+			me->SummonCreature(38047, 1692.36, 582.342, 29.06, 0.23);
+			me->SummonCreature(38047, 1688.99, 604.902, 28.0608, 0.48);
+			me->SummonCreature(38047, 1690.91, 605.88, 28.3581, 3.61);
+			me->SummonCreature(38047, 1669.28, 624.177, 28.0504, 2.57);
+			me->SummonCreature(38047, 1667.75, 625.38, 28.0504, 5.73);
+			me->SummonCreature(38047, 1716.75, 632.675, 27.7991, 3.43);
+			me->SummonCreature(38047, 1705.7, 612.287, 27.6113, 1.99);
+			me->SummonCreature(38047, 1702.86, 611.087, 27.6827, 1.85);
+			me->SummonCreature(38047, 1700.1, 610.616, 27.6777, 1.69);
+			me->SummonCreature(38047, 1685.62, 638.985, 27.6363, 5.59);
+			me->SummonCreature(38047, 1683.64, 636.337, 27.6529, 5.82);
+			me->SummonCreature(38047, 1682.23, 633.38, 27.638, 6.01);
+			me->SummonCreature(38047, 1699.66, 659.52, 28.0503, 4.68);
+			me->SummonCreature(38047, 1702.88, 659.398, 28.0503, 4.55);
+			me->SummonCreature(38047, 1706.31, 658.903, 28.0503, 4.53);
+			me->SummonCreature(38047, 1707.11, 656.197, 28.0503, 4.48);
+			me->SummonCreature(38047, 1701.32, 657.371, 28.0503, 4.61);
+			me->SummonCreature(38047, 1704.05, 656.947, 28.0503, 4.53);
+			me->SummonCreature(37746, 1698.87, 628.417, 28.1989, 3.69);
+			me->SummonCreature(37763, 1662.56, 622.758, 28.0502, 4.88);
+			me->SummonCreature(37764, 1666.48, 620.999, 28.0504, 5.00);
+			me->SummonCreature(37765, 1686.1, 607.186, 28.1281, 1.99);
+
+			if (GameObject* go = me->SummonGameObject(195682, 1666.13, 662.584, 28.0504, 5.44551, 0, 0, 0, 0, 0))
+			{
+				go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_NOT_SELECTABLE);
+				_portal1 = go->GetGUID();
+			}
+				
+			if (GameObject* go = me->SummonGameObject(195682, 1732.62, 594.658, 28.0503, 2.27643, 0, 0, 0, 0, 0))
+			{
+				go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_NOT_SELECTABLE);
+				_portal2 = go->GetGUID();
+			}
+				
+		}
+
+		void JustSummoned(Creature* summon) override
+		{
+			_summonmap.insert(std::make_pair(summon->GetGUID(), summon->GetOrientation()));
+
+			switch (summon->GetEntry())
+			{
+			case NPC_THERON:
+				summon->SetWalk(true);
+				_theron = summon->GetGUID();
+				break;
+			case NPC_ROMMATH:
+				summon->SetWalk(true);
+				_rommath = summon->GetGUID();
+				break;
+			case NPC_AURIC:
+				summon->SetWalk(true);
+				_auric = summon->GetGUID();
+				break;
+			case NPC_QUEL_GUARD:
+				_guards.push_back(summon);
+			default:
+				break;
+			}
+		}
+
+		void GuardAction(uint8 aciton)
+		{
+			if (aciton == 0)
+			{
+				if (Player* pl = ObjectAccessor::GetPlayer(*me, _player))
+					if (Creature* guard = pl->FindNearestCreature(NPC_QUEL_GUARD, 500.0f))
+					{
+						guard->GetMotionMaster()->MoveChase(pl, 1.0f);
+						guard->MonsterSay("·ÅÏÂÎäÆ÷Í¶½µ£¬ÄãÕâ¸öÅÑÍ½£¡", LANG_UNIVERSAL, NULL);
+						guard->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_READY1H);
+						guard->CastSpell(pl, SPELL_ICY_PRISON);
+						guard->SetTarget(_player);
+					}
+
+				if (Creature* auric = ObjectAccessor::GetCreature(*me, _auric))
+					if (Creature* guard = auric->FindNearestCreature(NPC_QUEL_GUARD, 500.0f))
+					{
+						_summonmap.insert(std::make_pair(guard->GetGUID(), guard->GetOrientation()));
+						guard->GetMotionMaster()->MoveChase(auric, 1.0f);
+						guard->MonsterSay("·ÅÏÂÎäÆ÷Í¶½µ£¬ÄãÕâ¸öÅÑÍ½£¡", LANG_UNIVERSAL, NULL);
+						guard->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_READY1H);
+						guard->SetTarget(_auric);
+					}
+			}
+			else
+			{
+				for (auto itr = _guards.begin(); itr != _guards.end(); itr++)
+				{
+					if (Creature* guard = *itr)
+					{
+						guard->SetTarget(0);
+						guard->SetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_STAND);
+						guard->GetMotionMaster()->MovePoint(0, guard->GetHomePosition());
+					}
+				}
+			}
+		}
+
+		void SummonedMovementInform(Creature* summon, uint32 type, uint32 point)
+		{
+			if (type != CHASE_MOTION_TYPE && type != POINT_MOTION_TYPE)
+				return;
+
+			switch (summon->GetEntry())
+			{
+			case NPC_THERON:
+			case NPC_ROMMATH:
+			case NPC_AURIC:
+				if (point == 0)
+				{
+					if (GameObject* quelDelar = ObjectAccessor::GetGameObject(*me, _QuelDelar))
+						summon->SetFacingToObject(quelDelar);
+				}
+				else if (point == 1)
+				{
+					auto itr = _summonmap.find(summon->GetGUID());
+					if (itr != _summonmap.end())
+						summon->SetOrientation(itr->second);
+				}
+				
+				break;
+			case NPC_QUEL_GUARD:
+				if (type == CHASE_MOTION_TYPE)
+				{
+					Unit* target = ObjectAccessor::GetUnit(*me, summon->GetTarget());
+						summon->SetFacingToObject(target);
+				}
+				else if (type == POINT_MOTION_TYPE)
+				{
+					auto itr = _summonmap.find(summon->GetGUID());
+					if (itr != _summonmap.end())
+						summon->SetOrientation(itr->second);
+				}
+				break;
+			}
+		}
+
+		void UpdateAI(uint32 diff)
+		{
+			if (_Timer)
+			{
+				if (_Timer <= diff)
+				{
+					switch (_Phase)
+					{
+					case 1:
+						if (GameObject* quelDelar = me->SummonGameObject(GO_QUEL_DANAR, 1683.99f, 620.231f, 29.3599f, 0.410932f, 0, 0, 0, 0, 0))
+						{
+							_QuelDelar = quelDelar->GetGUID();
+							quelDelar->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_NOT_SELECTABLE);
+						}
+						_Timer = 1000;
+						_Phase++;
+						break;
+					case 2:
+						if (Creature* guard = me->FindNearestCreature(NPC_QUEL_GUARD, 100.0f, true))
+							guard->MonsterSay("ÕæµÄÊÇ¿ü¶ûµÂÀ­Âð£¿", LANG_UNIVERSAL, NULL);
+						_Timer = 4000;
+						_Phase++;
+						break;
+					
+					case 3:
+						if (Creature* theron = ObjectAccessor::GetCreature(*me, _theron))
+							theron->MonsterSay("ÈÃÎÒÃÇ¿´Ò»¿´...", LANG_UNIVERSAL, NULL);
+						
+						if (Creature* rommath = ObjectAccessor::GetCreature(*me, _rommath))
+							rommath->GetMotionMaster()->MovePoint(0, 1675.8f, 617.19f, 28.0504f);
+
+						if (Creature*auric = ObjectAccessor::GetCreature(*me, _auric))
+							auric->GetMotionMaster()->MovePoint(0, 1681.77f, 612.084f, 28.4409f);
+
+						if (Creature* theron = ObjectAccessor::GetCreature(*me, _theron))
+							theron->GetMotionMaster()->MovePoint(0, 1677.07f, 613.122f, 28.0504f);
+
+						_Timer = 10000;
+						_Phase++;
+						break;
+					case 4:
+						if (Creature* rommath = ObjectAccessor::GetCreature(*me, _rommath))
+							rommath->MonsterSay("ÂåÈûÂê£¬¿´£¬ºÁÎÞÒÉÎÊ£¬ÕâÊÇ¿ü¶ûµÂÀ­¡£", LANG_UNIVERSAL, NULL);
+
+						_Timer = 10000;
+						_Phase++;
+						break;
+					case 5:
+						if (Creature* theron = ObjectAccessor::GetCreature(*me, _theron))
+						{
+							std::ostringstream oss;
+							if (Player* pl = ObjectAccessor::GetPlayer(*me, _player))
+								oss << "ºÃ¼«ÁË£¬·Ç³£¸ÐÐ»Äã½«¿ü¶ûµÂÀ­´ø¸øËüÕæÕýµÄÖ÷ÈË£¬" << pl->GetName() << "¡£";
+							theron->MonsterSay(oss.str().c_str(), LANG_UNIVERSAL, NULL);
+							theron->GetMotionMaster()->MovePoint(0, 1681.9f, 619.13f, 27.95f);
+						}
+							
+						_Timer = 10000;
+						_Phase++;
+						break;
+						
+					case 6:
+						if (Creature* theron = ObjectAccessor::GetCreature(*me, _theron))
+							theron->HandleEmoteCommand(EMOTE_ONESHOT_POINT);
+						_Timer = 1000;
+						_Phase++;
+						break;
+						
+					case 7:
+						if (Creature* theron = ObjectAccessor::GetCreature(*me, _theron))
+						{
+							theron->CastSpell(theron, SPELL_WRATH_QUEL_DANAR, true);
+							theron->KnockbackFrom(theron->GetPositionX(), theron->GetPositionY(), 20.0f, 10.0f);
+						}
+							
+						_Timer = 1000;
+						_Phase++;
+						break;
+						
+					case 8:
+						if (Creature* rommath = ObjectAccessor::GetCreature(*me, _rommath))
+						{
+							if (Player* player = me->SelectNearestPlayer(200.0f))
+								rommath->AddAura(SPELL_ICY_PRISON, player);
+	
+							rommath->MonsterSay("±³ÅÑ£¿", LANG_UNIVERSAL, NULL);
+						}
+
+						GuardAction(0);
+						_Timer = 5000;
+						_Phase++;
+						break;
+					case 9:
+						_Timer = 1000;
+						_Phase++;
+						break;
+					case 10:
+						if (Creature* auric = ObjectAccessor::GetCreature(*me, _auric))
+							auric->MonsterSay("Õâ²»ÊÇÎÒµÄ´í£¬ÂåÈûÂê¡£Õâ²»ÊÇÒ»¸öÅÑÍ½¡£", LANG_UNIVERSAL, NULL);
+						_Timer = 5000;
+						_Phase++;
+						break;
+					case 11:
+						if (Creature* auric = ObjectAccessor::GetCreature(*me, _auric))
+							auric->MonsterSay("ÈÃÄãµÄÈËÍËÏÂ£¬ÊÇÂåÈûÂêµÄÓÞ´Àµ¼ÖÂËûÊÜÁËÉË¡£ÈËÃÇ²»¿ÉÒÔÑ¡Ôñ¿ü¶ûµÂÀ­£¬¿ü¶ûµÂÀ­×Ô¼ºÑ¡ÔñÖ÷ÈË¡£", LANG_UNIVERSAL, NULL);
+
+						_Timer = 5000;
+						_Phase++;
+						break;
+					case 12:
+						if (Creature* rommath = ObjectAccessor::GetCreature(*me, _rommath))
+							rommath->MonsterSay("ÎÀ±ø£¬ÍËÏÂ¡£", LANG_UNIVERSAL, NULL);
+						_Timer = 5000;
+						_Phase++;
+						break;
+					case 13:
+						GuardAction(1);
+						if (Creature* rommath = ObjectAccessor::GetCreature(*me, _rommath))
+						{
+							rommath->HandleEmoteCommand(EMOTE_ONESHOT_POINT);
+							std::ostringstream oss;
+							if (Player* pl = ObjectAccessor::GetPlayer(*me, _player))
+								oss << "ÄãµÃµ½ÁËÒ»Ö±Ñ°ÕÒµÄÁ¦Á¿£¬" << pl->GetName() << "¡£ÄÃÉÏÕâ°Ñ½££¬Àë¿ª°É¡£ÖÁÓÚÄã£¬°¢Èð¿Ë£¬ÔÚÕâÉñÊ¥Ö®µØ£¬Çë¼Ç×¡Äã×Ô¼ºËµ¹ýµÄ»°¡£";
+
+							rommath->MonsterSay(oss.str().c_str(), LANG_UNIVERSAL, NULL);
+						}
+						_Timer = 1000;
+						_Phase++;
+						break;
+					case 14:
+						if (Creature* auric = ObjectAccessor::GetCreature(*me, _auric))
+						{
+							auric->HandleEmoteCommand(EMOTE_ONESHOT_POINT);
+							auric->MonsterSay("ÄÃ×ÅÕâ°Ñ½££¬´©¹ýÈ¥´ïÀ­È»µÄ´«ËÍÃÅ¡£ÄãÍê³ÉÁËºÜ¶àÈËÃÎÃÂÒÔÇó¶àÄêµÄÊÂ£¬ÄãÖØÖýÁË¿ü¶ûµÂÀ­¡£", LANG_UNIVERSAL, NULL);
+						}
+
+						if (GameObject* quelDelar = ObjectAccessor::GetGameObject(*me, _QuelDelar))
+						{
+							quelDelar->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_NOT_SELECTABLE);
+							if (Player* pl = ObjectAccessor::GetPlayer(*me, _player))
+								pl->GetSession()->SendAreaTriggerMessage("¿ü¶ûµÂÀ­ÏÖÔÚ¿ÉÒÔÊ°È¡ÁË");
+						}
+							
+
+						if (GameObject* go = ObjectAccessor::GetGameObject(*me, _portal1))
+							go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_NOT_SELECTABLE);
+
+						if (GameObject* go = ObjectAccessor::GetGameObject(*me, _portal2))
+							go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_NOT_SELECTABLE);
+					
+						_Timer = 1000;
+						_Phase++;
+						break;
+					case 15:
+						if (Creature* auric = ObjectAccessor::GetCreature(*me, _auric))
+							auric->GetMotionMaster()->MovePoint(1, auric->GetHomePosition());
+						if (Creature* rommath = ObjectAccessor::GetCreature(*me, _rommath))
+							rommath->GetMotionMaster()->MovePoint(1, rommath->GetHomePosition());
+						if (Creature* theron = ObjectAccessor::GetCreature(*me, _theron))	
+							theron->GetMotionMaster()->MovePoint(1, theron->GetHomePosition());
+						_Timer = 5000;
+						_Phase++;
+						break;
+					}
+				}
+				else
+					_Timer -= diff;
+			}
+		}
+
+	private:
+		uint32 _Timer;
+		uint32 _Phase;
+		
+		uint64 _rommath;
+		uint64 _auric;
+		uint64 _theron;
+		uint64 _player;
+		uint64 _QuelDelar;
+		uint64 _portal1;
+		uint64 _portal2;
+
+		std::list<Creature*> _guards;
+		std::unordered_map<uint64, float> _summonmap;
+	};
+};
+
+class spell_bh_cleanse_quel_delar : public SpellScriptLoader
+{
+public:
+	spell_bh_cleanse_quel_delar() : SpellScriptLoader("spell_bh_cleanse_quel_delar") { }
+
+	class spell_bh_cleanse_quel_delar_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_bh_cleanse_quel_delar_SpellScript);
+
+		void OnEffect(SpellEffIndex effIndex)
+		{
+			if (Unit* caster = GetCaster())
+				if (Creature* creature = caster->FindNearestCreature(NPC_TRIGGER, 200.0f, true))
+					if (npc_queldelar_sunwell_plateau::npc_queldelar_sunwell_plateauAI* creatureAI = CAST_AI(npc_queldelar_sunwell_plateau::npc_queldelar_sunwell_plateauAI, creature->AI()))
+						creatureAI->BeginScene();
+		}
+
+		void Register()
+		{
+			OnEffectLaunch += SpellEffectFn(spell_bh_cleanse_quel_delar_SpellScript::OnEffect, EFFECT_0, SPELL_EFFECT_SEND_EVENT);
+		}
+	};
+
+	SpellScript* GetSpellScript() const
+	{
+		return new spell_bh_cleanse_quel_delar_SpellScript();
+	}
+};
+
+void AddSC_queldelar()
+{
+	new npc_thalorien();
+	new npc_sunwell_warder();
+	new npc_queldelar_sunwell_plateau();
+	new spell_bh_cleanse_quel_delar();
+}
diff --git a/src/server/scripts/Custom/FunctionCollection/FunctionCollection.cpp b/src/server/scripts/Custom/FunctionCollection/FunctionCollection.cpp
new file mode 100644
index 0000000..1e752cb
--- /dev/null
+++ b/src/server/scripts/Custom/FunctionCollection/FunctionCollection.cpp
@@ -0,0 +1,901 @@
+//#pragma execution_character_set("utf-8")
+//#include "FunctionCollection.h"
+//#include "../Custom/HonorRank/HonorRank.h"
+//#include "../Lottery/Lottery.h"
+//#include "../CommonFunc/CommonFunc.h"
+//#include "../Recruit/Recruit.h"
+//#include "../CustomEvent/Event.h"
+//#include "Guild.h"
+//#include "../Requirement/Requirement.h"
+//#include "../Reward/Reward.h"
+//#include "../Quest/QuestMod.h"
+//#include "../VIP/VIP.h"
+//#include "Group.h"
+//#include "MapManager.h"
+//#include "../ResetInstance/ResetInstance.h"
+//#include "../Switch/Switch.h"
+//#include "../Skill/Skill.h"
+//#include "../Rank/Rank.h"
+//#include "../Faction/Faction.h"
+//#include "../Morph/Morph.h"
+//#include "../GCAddon/GCAddon.h"
+//#include "../LuckDraw/LuckDraw.h"
+//#include "../SignIn/SignIn.h"
+//#include "../Recovery/Recovery.h"
+//#include "../StatPoints/StatPoints.h"
+//#include "../Command/CustomCommand.h"
+//#include "../Reincarnation/Reincarnation.h"
+//#include "../String/myString.h"
+//#include "../UnitMod/CharMod/CharMod.h"
+//
+//std::vector<FunctionTemplate> FunctionVec;
+//
+//std::vector<GossipTemplate> GossipVec;
+//
+//std::vector<GossipTemplate> AboveMenuVec;
+//
+//bool GreaterSort(GossipTemplate a, GossipTemplate b) { return (a.menuId <b.menuId); }
+//
+//void FunctionCollection::Load()
+//{
+//	FunctionVec.clear();
+//	GossipVec.clear();
+//	QueryResult result = WorldDatabase.PQuery("SELECT funcIndex,reqId,telePosId_A,telePosId_H,desReq FROM _function_index");
+//	QueryResult result1 = WorldDatabase.PQuery("SELECT entry,type,menuId,prevMenuId,funcIndex, smallIconType, bigIconName,menuText,teamId FROM _function_menu");
+//
+//	if (!result || !result1) return;
+//	do
+//	{
+//		Field* fields = result->Fetch();
+//		FunctionTemplate FunctionTemp;
+//		FunctionTemp.index = fields[0].GetUInt32();
+//		FunctionTemp.reqId = fields[1].GetUInt32();
+//
+//		Tokenizer telePosId_A_Data(fields[2].GetString(), ' ');
+//
+//		for (Tokenizer::const_iterator itr = telePosId_A_Data.begin(); itr != telePosId_A_Data.end(); ++itr)
+//			FunctionTemp.telePosId_A.push_back(atoi(*itr));
+//
+//		Tokenizer telePosId_H_Data(fields[3].GetString(), ' ');
+//
+//		for (Tokenizer::const_iterator itr = telePosId_A_Data.begin(); itr != telePosId_A_Data.end(); ++itr)
+//			FunctionTemp.telePosId_H.push_back(atoi(*itr));
+//
+//		FunctionTemp.desReq = fields[4].GetBool();
+//		FunctionVec.push_back(FunctionTemp);
+//	} while (result->NextRow());
+//
+//	do
+//	{
+//		Field* fields = result1->Fetch();
+//		GossipTemplate GossipTemp;
+//		GossipTemp.entry = fields[0].GetUInt32();
+//		GossipTemp.type = fields[1].GetUInt32();
+//		GossipTemp.menuId = fields[2].GetUInt32();
+//		GossipTemp.prevMenuId = fields[3].GetUInt32();
+//		GossipTemp.funcIndex = fields[4].GetInt32();
+//		GossipTemp.smallIconType = fields[5].GetUInt8();
+//		GossipTemp.bigIconName = fields[6].GetString();
+//		GossipTemp.menuText = fields[7].GetString();
+//		GossipTemp.teamId = TeamId(fields[8].GetUInt32());
+//		GossipVec.push_back(GossipTemp);
+//	} while (result1->NextRow());
+//
+//
+//	
+//	sort(GossipVec.begin(), GossipVec.end(), GreaterSort);//ÉýÐòÅÅÁÐ
+//
+//}
+//uint32 FunctionCollection::GetOjectType(Object* obj)
+//{
+//	switch (obj->GetTypeId())
+//	{
+//	case TYPEID_GAMEOBJECT:
+//		return 2;
+//	case TYPEID_UNIT:
+//		return 1;
+//	case TYPEID_ITEM:
+//		return 0;
+//	}
+//
+//	return 100;
+//}
+//uint32 FunctionCollection::DoAction(Player* player, FunctionTypes type, Object* obj, bool destroy)
+//{
+//	if (!obj)
+//		return 0;
+//
+//	uint32 reqId = GetReqId(uint32(type));
+//	WorldLocation telePos = GetTelePos(player,uint32(type));
+//
+//	if (reqId != 0 && !sReq->Check(player, reqId))
+//		return 0;
+//	
+//	sReq->Des(player, reqId);
+//
+//	switch (type)
+//	{
+//	case FT_MOD_CHAR_NAME:
+//		ChangeName(player);
+//		break;
+//	case FT_MOD_CHAR_RACE:
+//		ChangeRace(player);
+//		break;
+//	case FT_MOD_CHAR_FACTION:
+//		ChangeFaction(player);
+//		break;
+//	case FT_MOD_CHAR_CUSTOMIZE:
+//		Customize(player);
+//		break;
+//	case FT_RESET_TALENTS:
+//		RestTalents(player);
+//		break;
+//	case FT_UPGRADE_WEAPON_SKILLS:
+//		UpgradeWeaponSkills(player);
+//		break;
+//	case FT_QUERY_TOKEN:
+//		QueryToken(player);
+//		break;
+//	case FT_RANDOM_QUEST:
+//		sQuestMod->AddRandomQuest(player);
+//		break;
+//	case FT_COMBATE_STOP:
+//		CombateStop(player);
+//		break;
+//	case FT_ABTAIN_TIME_REWARD:
+//		AbtainTimeReward(player);
+//		break;
+//	case FT_BUY_LOTTERY:
+//		sLottery->AddLotteryGossip(player, obj);
+//		break;
+//	case FT_SHOW_ACTIVE_EVENTS:
+//		ShowActiveEvents(player, obj);
+//		break;
+//	case FT_UPGRADE_HR:
+//		sHR->AddNextHRMenu(player, obj);
+//		break;
+//	case FT_RECRUIT:
+//		sRecruit->AddMainMenu(player, obj);
+//		break;
+//	case FT_BACK_MENU:
+//		break;
+//	case FT_QUEST_TELE:
+//		sQuestMod->AddTeleGossip(player, obj);
+//		break;
+//	case FT_UPGRADE_VIP:
+//		sVIP->AddGossip(player, obj);
+//		break;
+//	case FT_RESET_INSTANCE_ALL:
+//		sCustomCommand->DoCommand(player, ".instance unbind all");
+//		break;
+//	case FT_HOME_BIND:
+//		if (AreaTableEntry const* areaEntry = GetAreaEntryByAreaID(player->GetAreaId()))
+//		{
+//			if (player->GetMap()->Instanceable())
+//			{
+//				ChatHandler(player->GetSession()).PSendSysMessage("Äã´¦ÔÚ¸±±¾¡¢¾º¼¼³¡»òÕ½³¡ÖÐ£¬Â¯Ê¯µã²»ÄÜ°ó¶¨µ½µ±Ç°Î»ÖÃ£º%s", areaEntry->area_name[4]);
+//				return 0;
+//			}
+//
+//			player->SetHomebind(player->GetWorldLocation(), player->GetAreaId());
+//			ChatHandler(player->GetSession()).PSendSysMessage("Â¯Ê¯µãÒÑ¾­°ó¶¨µ½µ±Ç°Î»ÖÃ£º%s", areaEntry->area_name[4]);
+//		}	
+//		break;
+//	case FT_HOME_TELE:
+//		player->TeleportTo(player->m_homebindMapId, player->m_homebindX, player->m_homebindY, player->m_homebindZ, player->GetOrientation());
+//		break;
+//	case FT_RESET_INSTANCE:
+//		sResetIns->AddGossip(player, obj);
+//		break;
+//	case FT_REPAIR:
+//		player->DurabilityRepairAll(false, 0, false);
+//		player->GetSession()->SendAreaTriggerMessage("ÐÞÀíÍê³É");
+//		break;
+//	case FT_BANK:
+//		player->GetSession()->SendShowBank(player->GetGUID());
+//		break;
+//	case FT_MAIL:
+//		if (!player->HasSpellCooldown(54710))
+//		{
+//			player->CastSpell(player, 54710, true);
+//			player->AddSpellCooldown(54710, 0, 90 * IN_MILLISECONDS);
+//		}
+//		else
+//			player->GetSession()->SendNotification("ÓÊÏä¹¦ÄÜÀäÈ´Ê£ÓàÊ±¼ä%dÃë", player->GetSpellCooldownDelay(54710) / IN_MILLISECONDS);
+//		break;
+//	case FT_CUSTOM_SKILL:
+//		sCustomSkill->AddGossip(player, obj);
+//		break;
+//	case FT_RANK:
+//		sRank->AddGossip(player, obj);
+//		break;
+//	case FT_FACTION:
+//		sFaction->AddGossip(player, obj);
+//		break;
+//	case FT_RESET_DAILY_QUEST:
+//		player->ResetDailyQuestStatus();
+//		break;
+//	case FT_LUCKDRAW:
+//		sLuckDraw->OpenPanel(player);
+//		break;
+//	case FT_SIGNIN:
+//		sSignIn->OpenPanel(player);
+//		break;
+//	case FT_RECOVERY:
+//		sRecovery->OpenPanel(player);
+//		break;
+//	case FT_STATPOINTS:
+//		sStatPoints->OpenPanel(player);
+//		break;
+//	case FT_REINCARNATION:
+//		sReincarnation->AddGossip(player, obj);
+//		break;
+//	case FT_ALT_CLASS:
+//		sCharMod->AddGossip(player, obj);
+//		break;
+//	default:
+//		if (player->IsInCombat() && !player->IsGameMaster())
+//			player->GetSession()->SendNotification("Õ½¶·×´Ì¬ÎÞ·¨´«ËÍ£¡");
+//		else
+//		{
+//			if (telePos.GetMapId() == 0 && telePos.GetPositionX() == 0 && telePos.GetPositionY() == 0 && telePos.GetPositionZ() == 0 && telePos.GetOrientation() == 0)
+//				;
+//			else
+//				player->TeleportTo(telePos);
+//		}	
+//		break;
+//	}
+//
+//
+//	if (destroy)
+//		player->DestroyItemCount(obj->GetEntry(), 1, true);
+//
+//	return 0;
+//}
+//
+//void FunctionCollection::AddAboveMenu(Player* player, Object* obj, uint32 menuId)
+//{
+//	player->PlayerTalkClass->ClearMenus();
+//
+//	if (!obj)
+//		return;
+//
+//	AboveMenuVec.clear();
+//
+//	uint32 prevMenuId = 0;
+//	uint32 len = GossipVec.size();
+//	for (size_t i = 0; i < len; i++)
+//	{
+//		if (menuId == GossipVec[i].menuId)
+//		{
+//			prevMenuId = GossipVec[i].prevMenuId;
+//			break;
+//		}
+//	}
+//	for (size_t i = 0; i < len; i++)
+//	{
+//		if (prevMenuId == GossipVec[i].menuId)
+//		{
+//			for (size_t j = 0; j < len; j++)
+//			{
+//				if (GossipVec[j].prevMenuId == GossipVec[i].prevMenuId && obj->GetEntry() == GossipVec[j].entry && GossipVec[j].type == sFC->GetOjectType(obj))
+//				{
+//					GossipTemplate GossipTemp;
+//					GossipTemp.entry = GossipVec[j].entry;
+//					GossipTemp.type = GossipVec[j].type;
+//					GossipTemp.funcIndex = GossipVec[j].funcIndex;
+//					GossipTemp.menuId = GossipVec[j].menuId;
+//					GossipTemp.smallIconType = GossipVec[j].smallIconType;
+//					GossipTemp.menuText = GossipVec[j].menuText;
+//					GossipTemp.prevMenuId = GossipVec[j].prevMenuId;
+//					GossipTemp.bigIconName = GossipVec[j].bigIconName;
+//					AboveMenuVec.push_back(GossipTemp);
+//				}
+//			}
+//
+//			break;
+//		}
+//	}
+//
+//	player->PlayerTalkClass->ClearMenus();
+//
+//	if (!AboveMenuVec.empty())
+//	{
+//		for (size_t i = 0; i < AboveMenuVec.size(); i++)
+//		{
+//			uint32 funcIndex = AboveMenuVec[i].funcIndex;
+//			uint32 reqId = sFC->GetReqId(funcIndex);
+//			uint8 smallIconType = AboveMenuVec[i].smallIconType;
+//			std::string text = AboveMenuVec[i].bigIconName.empty() ? AboveMenuVec[i].menuText : "|TInterface/ICONS/" + AboveMenuVec[i].bigIconName + ":30:30:0:0|t" + AboveMenuVec[i].menuText;
+//			std::string notice = GossipVec[i].menuText;
+//			TeamId teamId = GossipVec[i].teamId;
+//
+//			if (teamId == TEAM_NEUTRAL || player->GetTeamId() == teamId)
+//			{
+//				if (reqId != 0)
+//					player->ADD_GOSSIP_ITEM_EXTENDED(smallIconType, text, AboveMenuVec[i].menuId, funcIndex, sReq->Notice(player, reqId, notice, ""), sReq->Golds(reqId), false);
+//				else
+//					player->ADD_GOSSIP_ITEM(smallIconType, text, AboveMenuVec[i].menuId, funcIndex);
+//			}
+//		}
+//
+//		if (obj->ToCreature())
+//			player->SEND_GOSSIP_MENU(obj->GetEntry(), obj->GetGUID());
+//		else
+//			player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+//	}
+//}
+//
+//uint32 FunctionCollection::GetReqId(uint32 funcIndex)
+//{
+//	uint32 len = FunctionVec.size();
+//
+//	for (size_t i = 0; i < len; i++)
+//	{
+//		if (funcIndex == FunctionVec[i].index)
+//			return FunctionVec[i].reqId;
+//	}
+//
+//	return 0;
+//}
+//
+//
+//bool FunctionCollection::GetDesReq(uint32 funcIndex)
+//{
+//	uint32 len = FunctionVec.size();
+//
+//	for (size_t i = 0; i <len; i++)
+//	{
+//		if (funcIndex == FunctionVec[i].index)
+//			return FunctionVec[i].desReq;
+//	}
+//
+//	return false;
+//}
+//
+//uint32 FunctionCollection::GetPrevId(uint32 entry,uint32 funcIndex)
+//{
+//	uint32 len = GossipVec.size();
+//
+//	for (size_t i = 0; i <len; i++)
+//		if (entry == GossipVec[i].entry && funcIndex == GossipVec[i].funcIndex)
+//			return GossipVec[i].prevMenuId;
+//
+//	return 0;
+//}
+//
+//uint32 FunctionCollection::GetExtraTPs(Player* player)
+//{
+//	QueryResult resultExtraTPs = CharacterDatabase.PQuery("SELECT extraTalentPoints FROM characters WHERE guid = '%u'", player->GetGUIDLow());
+//	if (resultExtraTPs)
+//		return resultExtraTPs->Fetch()[0].GetUInt32();
+//	return 0;
+//}
+//
+//void FunctionCollection::AddTalentPoints(Player* player,Object* obj)
+//{
+//	player->GetSession()->SendAreaTriggerMessage("»ñµÃ¶îÍâÒ»¸öÌì¸³µã");
+//	player->SetFreeTalentPoints(player->GetFreeTalentPoints() + 1);
+//	player->SendTalentsInfoData(false);
+//	CharacterDatabase.DirectPExecute("UPDATE characters SET extraTalentPoints = extraTalentPoints + 1 WHERE guid = '%u'", player->GetGUIDLow());
+//
+//}
+//
+//void FunctionCollection::ChangeFaction(Player* player)
+//{
+//	PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ADD_AT_LOGIN_FLAG);
+//	stmt->setUInt16(0, uint16(AT_LOGIN_CHANGE_FACTION));
+//	player->SetAtLoginFlag(AT_LOGIN_CHANGE_FACTION);
+//	stmt->setUInt32(1, player->GetGUIDLow());
+//	CharacterDatabase.Execute(stmt);
+//	player->GetSession()->SendAreaTriggerMessage("ÖØÐÂÉÏÏßÒÔÍê³É¸ü¸Ä£¡");
+//
+//	if (Guild* guild = player->GetGuild())
+//		guild->HandleLeaveMember(player->GetSession());
+//
+//}
+//
+//void FunctionCollection::Customize(Player* player)
+//{
+//	PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ADD_AT_LOGIN_FLAG);
+//	stmt->setUInt16(0, uint16(AT_LOGIN_CUSTOMIZE));
+//	player->SetAtLoginFlag(AT_LOGIN_CUSTOMIZE);
+//	stmt->setUInt32(1, player->GetGUIDLow());
+//	CharacterDatabase.Execute(stmt);
+//	player->GetSession()->SendAreaTriggerMessage("ÖØÐÂÉÏÏßÒÔÍê³É¸ü¸Ä£¡");
+//}
+//
+//void FunctionCollection::ChangeName(Player* player)
+//{
+//	player->SetAtLoginFlag(AT_LOGIN_RENAME);
+//	player->GetSession()->SendAreaTriggerMessage("ÖØÐÂÉÏÏßÒÔÍê³É¸ü¸Ä£¡");
+//}
+//
+//void FunctionCollection::ChangeRace(Player* player)
+//{
+//	PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ADD_AT_LOGIN_FLAG);
+//	stmt->setUInt16(0, uint16(AT_LOGIN_CHANGE_RACE));
+//	player->SetAtLoginFlag(AT_LOGIN_CHANGE_RACE);
+//	stmt->setUInt32(1, player->GetGUIDLow());
+//	CharacterDatabase.Execute(stmt);
+//	player->GetSession()->SendAreaTriggerMessage("ÖØÐÂÉÏÏßÒÔÍê³É¸ü¸Ä£¡");
+//
+//	if (Guild* guild = player->GetGuild())
+//		guild->HandleLeaveMember(player->GetSession());
+//}
+//
+//void FunctionCollection::RestTalents(Player* player)
+//{
+//	player->resetTalents(true);
+//	player->SendTalentsInfoData(false);
+//	player->GetSession()->SendAreaTriggerMessage("ÒÑÖØÖÃ½ÇÉ«Ìì¸³");
+//}
+//
+//void FunctionCollection::UpgradeWeaponSkills(Player* player)
+//{
+//	player->UpdateSkillsToMaxSkillsForLevel();
+//	player->GetSession()->SendAreaTriggerMessage("ÎäÆ÷¼¼ÄÜÒÑÌáÉýÖÁ×î´óÖµ");
+//}
+//
+//void FunctionCollection::QueryToken(Player* player)
+//{
+//	std::ostringstream oss;
+//	oss << "Äãµ±Ç°µÄ" << sString->GetText(CORE_STR_TYPES(STR_TOKEN) << "ÊýÁ¿£º" << sCF->GetTokenAmount(player);
+//
+//	player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+//	ChatHandler(player->GetSession()).PSendSysMessage(oss.str().c_str());
+//}
+//
+//void FunctionCollection::CombateStop(Player* player)
+//{
+//	if (!player->canStopCombat && sSwitch->GetValue(ST_STOP_COMBAT_CD) != 0)
+//	{
+//		uint32 cd = player->stopCombatCD / IN_MILLISECONDS;
+//		std::ostringstream oss;
+//		oss << "ÍÑÕ½¹¦ÄÜ½«ÔÚ" << cd << "ÃëºóÀäÈ´£¡";
+//		player->GetSession()->SendNotification(oss.str().c_str());
+//		return;
+//	}
+//		
+//	player->ClearInCombat();
+//	player->GetSession()->SendAreaTriggerMessage("ÒÑÇå³ýÕ½¶·×´Ì¬");
+//	player->canStopCombat = false;
+//	player->stopCombatCD = sSwitch->GetValue(ST_STOP_COMBAT_CD) * IN_MILLISECONDS;
+//}
+//
+//void FunctionCollection::AbtainTimeReward(Player* player)
+//{
+//	if (PlayerTimeRewType != 1)
+//	{
+//		if (PlayerTimeRewType != 2)
+//			player->GetSession()->SendNotification("ÅÝµã½±ÀøÒÑ¹Ø±Õ£¡");
+//		else
+//			player->GetSession()->SendNotification("ÁìÈ¡ÅÝµãÒÑ¹Ø±Õ£¬Çë±£³ÖÔÚÏß£¬µÈ´ýÏµÍ³·¢·Å½±Àø");
+//
+//		return;
+//	}
+//		
+//
+//	int32 unRewardNum = player->GetTotalPlayedTime() / 3600 - player->onlineRewardedCount;
+//	if (unRewardNum <= 0)
+//	{
+//		uint32 minu = player->GetTotalPlayedTime() > 3600 ? uint32(60 - (float(player->GetTotalPlayedTime()) / 3600 - player->GetTotalPlayedTime() / 3600) * 60) : (60 - player->GetTotalPlayedTime() / 60);
+//
+//		std::ostringstream oss;
+//		oss << minu << "·ÖÖÓºó¿ÉÁìÈ¡ÅÝµã";
+//		player->GetSession()->SendNotification(oss.str().c_str());
+//
+//		ChatHandler(player->GetSession()).PSendSysMessage(oss.str().c_str());
+//		return;
+//	}
+//	sCF->SetOnlineRewardedCount(player, unRewardNum + player->onlineRewardedCount);
+//	for (int32 i = 0; i < unRewardNum; i++)
+//	{
+//		sRew->Rew(player, player->timeRewId);
+//	}
+//}
+//
+////»ñÈ¡ÉÌÒµ¼¼ÄÜÊýÁ¿
+//
+//void FunctionCollection::BuyLottery(Player* player, uint32 lotteryAmount, uint8 lotteryType)
+//{
+//	sLottery->PlayerBuyLottery(player, LotteryType(lotteryType), lotteryAmount);
+//}
+//
+//void FunctionCollection::ShowActiveEvents(Player* player, Object* obj)
+//{
+//	sEvent->AddEventList(player, obj);
+//}
+//
+//void FunctionCollection::Teleport(Player* player, uint32 map, float x, float y, float z, float o)
+//{
+//	player->TeleportTo(map, x, y, z, o);
+//}
+//
+//WorldLocation FunctionCollection::GetTelePos(Player*player, uint32 funcIndex)
+//{
+//	uint32 telePosId = 0;
+//
+//	for (size_t i = 0; i < FunctionVec.size(); i++)
+//		if (funcIndex == FunctionVec[i].index)
+//		{
+//			player->GetTeamId() == TEAM_ALLIANCE ? telePosId = FunctionVec[i].telePosId_A[urand(0, FunctionVec[i].telePosId_A.size() - 1)] : telePosId = FunctionVec[i].telePosId_H[urand(0, FunctionVec[i].telePosId_H.size() - 1)];
+//			break;
+//		}
+//
+//
+//	std::unordered_map<uint32, PosTemplate>::iterator it = PosMap.find(telePosId);
+//
+//	if (it != PosMap.end())
+//		return WorldLocation(it->second.map, it->second.x, it->second.y, it->second.z, it->second.o);
+//
+//	return WorldLocation(0, 0, 0, 0, 0);
+//}
+//
+//void FunctionCollection::RestAllInstance(Player* player)
+//{
+//	/*if (Group* group = player->GetGroup())
+//	{
+//		if (group->IsLeader(player->GetGUID()))
+//			group->ResetInstances(INSTANCE_RESET_ALL, false, player);
+//	}
+//	else
+//		Player::ResetInstances(player->GetGUIDLow(), INSTANCE_RESET_ALL, false);
+//
+//	if (Group* group = player->GetGroup())
+//	{
+//		if (group->IsLeader(player->GetGUID()))
+//			group->ResetInstances(INSTANCE_RESET_CHANGE_DIFFICULTY, true, player);
+//	}
+//	else
+//		Player::ResetInstances(player->GetGUIDLow(), INSTANCE_RESET_CHANGE_DIFFICULTY, true);
+//
+//*/
+//	for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
+//	{
+//
+//		std::vector<InstanceSave*> toUnbind;
+//		BoundInstancesMap const& m_boundInstances = sInstanceSaveMgr->PlayerGetBoundInstances(player->GetGUIDLow(), Difficulty(i));
+//		for (BoundInstancesMap::const_iterator itr = m_boundInstances.begin(); itr != m_boundInstances.end(); ++itr)
+//		{
+//			InstanceSave* instanceSave = itr->second.save;
+//			const MapEntry* entry = sMapStore.LookupEntry(itr->first);
+//			if (!entry)
+//				continue;
+//
+//			Map* map = sMapMgr->FindMap(instanceSave->GetMapId(), instanceSave->GetInstanceId());
+//			if (!map || map->ToInstanceMap()->Reset(INSTANCE_RESET_GLOBAL))
+//			{
+//				player->SendResetInstanceSuccess(instanceSave->GetMapId());
+//				toUnbind.push_back(instanceSave);
+//			}
+//			else
+//				player->SendResetInstanceFailed(0, instanceSave->GetMapId());
+//		}
+//		for (std::vector<InstanceSave*>::const_iterator itr = toUnbind.begin(); itr != toUnbind.end(); ++itr)
+//			sInstanceSaveMgr->UnbindAllFor(*itr);
+//	}
+//}
+//
+//void FunctionCollection::AddGossipOrDoAction(Player* player, Object* obj, uint32 sender, uint32 action)
+//{
+//	player->PlayerTalkClass->ClearMenus();
+//
+//	if (!obj)
+//		return;
+//
+//#pragma region ÈÎÎñ´«ËÍ
+//	if (sender == SENDER_QUEST_TELE)
+//	{
+//		sQuestMod->Tele(player, action);
+//		return;
+//	}
+//#pragma endregion
+//
+//#pragma region ÖØÖÃ¸±±¾
+//	if (sender == SENDER_RESET_INS)
+//	{
+//		sResetIns->Action(player, action);
+//		return;
+//	}
+//#pragma endregion
+//
+//#pragma region ÕÐÄ¼´¦Àí
+//	if (sender == SENDER_RECRUIT)
+//	{
+//		sFC->DoAction(player, FT_RECRUIT, obj);
+//		return;
+//	}
+//#pragma endregion
+//
+//#pragma region Éý¼¶¾üÏÎ´¦Àí
+//	if (sender == SENDER_HR_MENU)
+//	{
+//		sFC->DoAction(player, FT_UPGRADE_HR, obj);
+//		return;
+//	}
+//	
+//	if (sender == SENDER_HR_UP)
+//	{
+//		sHR->SetHRTitle(player, action);
+//		player->CLOSE_GOSSIP_MENU();
+//		return;
+//	}
+//#pragma endregion
+//
+//#pragma region Éý¼¶VIP´¦Àí
+//	if (sender == SENDER_VIP_CURR)
+//	{
+//		sFC->DoAction(player, FT_UPGRADE_VIP, obj);
+//		return;
+//	}
+//
+//	if (sender == SENDER_VIP_UP)
+//	{
+//		sVIP->Up(player);
+//		player->CLOSE_GOSSIP_MENU();
+//		return;
+//	}
+//#pragma endregion
+//
+//
+//#pragma region ×ªÉú
+//	if (sender == SENDER_REINCARNATION)
+//	{
+//		sReincarnation->DoAction(player, obj, action);
+//		return;
+//	}
+//#pragma endregion
+//
+//#pragma region ÊÂ¼þ
+//	if (sender == SENDER_CUSTOM_EVENT)
+//	{
+//		sEvent->AcceptInvitation(player, action + 1000000);
+//		player->CLOSE_GOSSIP_MENU();
+//		return;
+//	}
+//#pragma endregion
+//
+//#pragma region CustomSkill
+//	if (sender == SENDER_CUSTOM_SKILL)
+//	{
+//		sCustomSkill->Action(player, action, obj);
+//		return;
+//	}
+//#pragma endregion
+//
+//#pragma region Rank
+//	if (sender == SENDER_RANK)
+//	{
+//		sRank->Action(player, action, obj);
+//		return;
+//	}
+//#pragma endregion
+//
+//#pragma region Faction
+//	if (sender == SENDER_FACTION)
+//	{
+//		sFaction->Action(player, action, obj);
+//		return;
+//	}
+//#pragma endregion
+//
+//#pragma region Morph
+//	if (sender == SENDER_MORPH)
+//	{
+//		//sMorph->Action(player, action, obj);
+//		return;
+//	}
+//#pragma endregion
+//
+//#pragma region ×ªÖ°
+//	if (sender == SENDER_ALT_CLASS)
+//	{
+//		sCharMod->ModClass(player, action);
+//		return;
+//	}
+//#pragma endregion
+//
+//#pragma region ·µ»ØÉÏ¼¶²Ëµ¥¡¢Ö÷²Ëµ¥
+//	if (action == uint32(FT_BACK_MENU))
+//	{
+//		AddAboveMenu(player, obj, sender);
+//		return;
+//	}
+//
+//	if (action == uint32(FT_MAIN_MENU))
+//	{
+//		AddGossipOrDoAction(player, obj, 0, 0);
+//		return;
+//	}
+//#pragma endregion
+//
+//#pragma region Ìí¼Ógossip»òÖ±½ÓÖ´ÐÐ¹¦ÄÜ
+//
+//	for (size_t i = 0; i < GossipVec.size(); i++)
+//	{
+//		if (obj->GetEntry() == GossipVec[i].entry && GossipVec[i].type == sFC->GetOjectType(obj))
+//		{
+//			int32 prevMenuId = GossipVec[i].prevMenuId;
+//			uint32 funcIndex = GossipVec[i].funcIndex;
+//
+//			switch (prevMenuId)
+//			{
+//				//doaction:1,do not destroy item 2,destroy item
+//			case -1:
+//				sFC->DoAction(player, FunctionTypes(funcIndex), obj);
+//				return;
+//			case -2:
+//				if (IS_ITEM_GUID(obj->GetGUID()))
+//					sFC->DoAction(player, FunctionTypes(funcIndex), obj,true);
+//				else
+//					sFC->DoAction(player, FunctionTypes(funcIndex), obj);
+//				return;
+//			default:
+//				break;
+//			}
+//
+//			//add gossip
+//			uint8 smallIconType = GossipVec[i].smallIconType;
+//			std::string text = GossipVec[i].bigIconName.empty() ? GossipVec[i].menuText : "|TInterface/ICONS/" + GossipVec[i].bigIconName + ":30:30:0:0|t" + GossipVec[i].menuText;
+// 			std::string notice = GossipVec[i].menuText;
+//
+//			if (sender == prevMenuId)
+//			{
+//				uint32 reqId = sFC->GetReqId(funcIndex);
+//				TeamId teamId = GossipVec[i].teamId;
+//
+//				if (teamId == TEAM_NEUTRAL || player->GetTeamId() == teamId)
+//				{
+//					if (reqId != 0)
+//						player->ADD_GOSSIP_ITEM_EXTENDED(smallIconType, text, GossipVec[i].menuId, funcIndex, sReq->Notice(player, reqId, notice, ""), sReq->Golds(reqId), false);
+//					else
+//						player->ADD_GOSSIP_ITEM(smallIconType, text, GossipVec[i].menuId, funcIndex);
+//				}		
+//			}
+//		}
+//	}
+//
+//	if (obj->ToCreature())
+//		player->SEND_GOSSIP_MENU(obj->GetEntry(), obj->GetGUID());
+//	else
+//		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+//
+//#pragma endregion
+//
+//#pragma region ²Ëµ¥ÖÐ³£ÓÃ¹¦ÄÜ´¦Àí
+//
+//	if (action > uint32(FT_START))
+//	{
+//		sFC->DoAction(player, FunctionTypes(action),obj);
+//
+//		if (action != uint32(FT_ALT_CLASS) && action != uint32(FT_FACTION) && action != uint32(FT_RANK) && action != uint32(FT_CUSTOM_SKILL) && action != uint32(FT_RESET_INSTANCE) && action != uint32(FT_BUY_LOTTERY) && action != uint32(FT_UPGRADE_HR) && action != uint32(FT_RECRUIT) && action != uint32(FT_QUEST_TELE) && action != FT_UPGRADE_VIP && action != FT_REINCARNATION && action != FT_SHOW_ACTIVE_EVENTS)
+//			player->CLOSE_GOSSIP_MENU();
+//	}
+//
+//#pragma endregion
+//}
+//
+///*
+//class Func_ItemScript : public ItemScript
+//{
+//public:
+//	Func_ItemScript() : ItemScript("Func_ItemScript") { }
+//
+//	bool OnUse(Player* player, Item* item, SpellCastTargets const& targets) override
+//	{
+//		sFC->AddGossipOrDoAction(player, item, 0, 0);
+//		return true;
+//	}
+//
+//	void OnGossipSelect(Player* player, Item* item, uint32 sender, uint32 action) override
+//	{
+//		if (sRecruit->AddSubMenuOrDoAction(player, item, sender, action))
+//			return;
+//		sFC->AddGossipOrDoAction(player, item, sender, action);
+//	}
+//
+//	void OnGossipSelectCode(Player* player, Item* item, uint32 sender, uint32 action, const char* code) override
+//	{
+//		player->PlayerTalkClass->ClearMenus();
+//
+//		if (!*code)
+//			return;
+//
+//		if (sRecruit->RecruitFriend(player, sender, code))
+//			return;
+//
+//		if (sLottery->PlayerBuyLottery(player, LotteryType(sender), (uint32)atoi(code)))
+//			return;
+//	}
+//
+//};
+//
+//class Func_CreatureScript : public CreatureScript
+//{
+//public:
+//	Func_CreatureScript() : CreatureScript("Func_CreatureScript") { }
+//
+//
+//	bool OnGossipHello(Player* player, Creature* creature) override
+//	{
+//		sFC->AddGossipOrDoAction(player, creature, 0, 0);
+//		return true;
+//	}
+//
+//	bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action) override
+//	{
+//		if (sRecruit->AddSubMenuOrDoAction(player, creature, sender, action))
+//			return true;
+//		sFC->AddGossipOrDoAction(player, creature, sender, action);
+//		return true;
+//	}
+//
+//	bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, const char* code) override
+//	{ 
+//		player->PlayerTalkClass->ClearMenus();
+//
+//		if (!*code)
+//			return false;
+//
+//		if (sRecruit->RecruitFriend(player, sender, code))
+//			return true;
+//
+//		if (sLottery->PlayerBuyLottery(player, LotteryType(sender), (uint32)atoi(code)))
+//			return true;
+//		return false;
+//	}
+//};
+//
+//class Func_GameObjectScript :public GameObjectScript
+//{
+//public:
+//	Func_GameObjectScript() : GameObjectScript("Func_GameObjectScript") { }
+//
+//	bool OnGossipHello(Player* player, GameObject* go) override
+//	{
+//		sFC->AddGossipOrDoAction(player, go, 0, 0);
+//		return true;
+//	}
+//
+//	bool OnGossipSelect(Player* player, GameObject* go, uint32 sender, uint32 action) override
+//	{
+//		if (sRecruit->AddSubMenuOrDoAction(player, go, sender, action))
+//			return true;
+//		sFC->AddGossipOrDoAction(player, go, sender, action);
+//		return true;
+//	}
+//
+//	bool OnGossipSelectCode(Player* player, GameObject* go, uint32 sender, uint32 action, const char* code) override
+//	{
+//		player->PlayerTalkClass->ClearMenus();
+//
+//		if (!*code)
+//			return false;
+//
+//		if (sRecruit->RecruitFriend(player, sender, code))
+//			return true;
+//
+//		if (sLottery->PlayerBuyLottery(player, LotteryType(sender), (uint32)atoi(code)))
+//			return true;
+//		return false;
+//	}
+//};
+//
+//class Func_PlayerScript : PlayerScript
+//{
+//public:
+//	Func_PlayerScript() : PlayerScript("Func_PlayerScript") {}
+//	void OnLogin(Player* player, bool) override
+//	{
+//		sFC->SetCommercePoints(player);
+//	}
+//};
+//*/
+//void AddSC_FunctionCollection()
+//{
+//	//new Func_PlayerScript();
+//	//new Func_ItemScript();
+//	//new Func_CreatureScript();
+//	//new Func_GameObjectScript();
+//}
diff --git a/src/server/scripts/Custom/FunctionCollection/FunctionCollection.h b/src/server/scripts/Custom/FunctionCollection/FunctionCollection.h
new file mode 100644
index 0000000..906e506
--- /dev/null
+++ b/src/server/scripts/Custom/FunctionCollection/FunctionCollection.h
@@ -0,0 +1,133 @@
+#define SENDER_REINCARNATION			4001
+#define SENDER_HR_UP					7991
+#define SENDER_HR_MENU					7992
+#define SENDER_RECRUIT					6000
+#define SENDER_QUEST_TELE				7000
+#define SENDER_CUSTOM_SKILL				7777
+#define SENDER_RESET_INS				8888
+#define SENDER_VIP_CURR					8000
+#define SENDER_VIP_UP					8001
+#define SENDER_CUSTOM_EVENT_ACTIVE		9008
+#define SENDER_CUSTOM_EVENT_DEACTIVE	9009
+#define SENDER_ALT_CLASS				8002
+#define SENDER_RANK						9001
+#define SENDER_FACTION					9002
+#define SENDER_MORPH					9003
+
+//enum FunctionTypes
+//{
+//	FT_START,
+//	FT_MAIN_MENU,				//ä¸»èå
+//	FT_BACK_MENU,				//è¿å
+//	FT_MOD_CHAR_NAME,			//å§å
+//	FT_MOD_CHAR_RACE,			//ç§æ
+//	FT_MOD_CHAR_FACTION,		//éµè¥
+//	FT_MOD_CHAR_CUSTOMIZE,		//å¤å½¢
+//	FT_RESET_TALENTS,			//éç½®å¤©èµ
+//	FT_UPGRADE_WEAPON_SKILLS,	//æ­¦å¨æè½å¨æ»¡
+//	FT_QUERY_TOKEN,				//ç§¯åæ¥è¯¢
+//	FT_COMBATE_STOP,			//è±æ
+//	FT_ABTAIN_TIME_REWARD,		//æ³¡ç¹
+//	FT_BUY_LOTTERY,				//å½©ç¥¨
+//	FT_SHOW_ACTIVE_EVENTS,		//æ´»å¨åè¡¨
+//	FT_UPGRADE_HR,				//åè¡èå
+//	FT_RECRUIT,					//æå
+//	FT_QUEST_TELE,				//ä»»å¡ä¼ é
+//	FT_UPGRADE_VIP,				//VIPèå
+//	FT_REINCARNATION,			//è½¬ç
+//	FT_RESET_INSTANCE,			//éç½®ç¹å®å¯æ¬
+//	FT_CUSTOM_SKILL,			//èªå®ä¹åä¸æè½
+//	FT_RANK,					//èªå®ä¹ç­çº§
+//	FT_FACTION,					//èªå®ä¹éµè¥
+//	FT_RESET_DAILY_QUEST,		//éç½®æ¥å¸¸ä»»å¡
+//	FT_LUCKDRAW,				//å¹¸è¿æ½å¥
+//	FT_SIGNIN,					//ç­¾å°
+//	FT_RECOVERY,				//ç©ååæ¶
+//	FT_STATPOINTS,				//ææ°
+//	FT_RANDOM_QUEST,			//éæºä»»å¡
+//	FT_RESET_INSTANCE_ALL,		//éç½®ææå¯æ¬
+//	FT_HOME_BIND,				//ç»å®çç³ç¹
+//	FT_HOME_TELE,				//ä¼ éçç³ç¹
+//	FT_REPAIR,					//ä¿®ç
+//	FT_BANK,					//é¶è¡
+//	FT_MAIL,					//é®ç®±
+//	FT_ALT_CLASS,				//è½¬è
+//};
+//
+//struct FunctionTemplate
+//{
+//	uint32 index;
+//	uint32 reqId;
+//	std::vector<uint32> telePosId_A;
+//	std::vector<uint32> telePosId_H;
+//	uint32 desReq;
+//};
+//
+//extern std::vector<FunctionTemplate> FunctionVec;
+//
+//struct GossipTemplate
+//{
+//	uint32 entry;
+//	uint32 type;
+//	uint32 menuId;
+//	int32 prevMenuId;
+//	uint32 funcIndex;
+//	uint8 smallIconType;
+//	std::string bigIconName;
+//	std::string menuText;
+//	TeamId teamId;
+//};
+//
+//extern std::vector<GossipTemplate> GossipVec;
+//extern std::vector<GossipTemplate> AboveMenuVec;
+//
+//class FunctionCollection
+//{
+//public:
+//	static FunctionCollection* instance()
+//	{
+//		static FunctionCollection instance;
+//		return &instance;
+//	}
+//
+//	void Load();
+//	uint32 GetOjectType(Object* obj);
+//	uint32 DoAction(Player* player, FunctionTypes type, Object* obj,bool destroy = false);
+//
+//	void ChangeFaction(Player* player);
+//	void Customize(Player* player);
+//	void ChangeName(Player* player);
+//	void ChangeRace(Player* player);
+//	void RestTalents(Player* player);
+//	void UpgradeWeaponSkills(Player* player);
+//
+//	void QueryToken(Player* player);
+//	void CombateStop(Player* player);
+//	void AbtainTimeReward(Player* player);
+//
+//
+//	void BuyLottery(Player* player, uint32 lotteryAmount, uint8 lotteryType);
+//	void ShowActiveEvents(Player* player,Object* obj);
+//	void Teleport(Player* player, uint32 map, float x, float y, float z, float o);
+//	void AddTalentPoints(Player* player, Object* obj);
+//
+//	//gossipç¸å³
+//	void AddGossipOrDoAction(Player* player, Object* obj, uint32 sender, uint32 action);
+//	void AddAboveMenu(Player* player, Object* obj, uint32 menuId);
+//	
+//	//limit reqId rewdId telePos 
+//	bool GetDesReq(uint32 funcIndex);
+//	uint32 GetReqId(uint32 funcIndex);
+//	WorldLocation GetTelePos(Player*player,uint32 funcIndex);
+//
+//	//prevId 
+//	uint32 GetPrevId(uint32 entry, uint32 funcIndex);
+//
+//	uint32 GetExtraTPs(Player* player);
+//
+//	void RestAllInstance(Player* player);
+//	
+//private:
+//
+//};
+//#define sFC FunctionCollection::instance()
diff --git a/src/server/scripts/Custom/GCAddon/GCAddon.cpp b/src/server/scripts/Custom/GCAddon/GCAddon.cpp
new file mode 100644
index 0000000..56472ad
--- /dev/null
+++ b/src/server/scripts/Custom/GCAddon/GCAddon.cpp
@@ -0,0 +1,1206 @@
+#pragma execution_character_set("utf-8")
+#include "GCAddon.h"
+#include "../ItemMod/ItemMod.h"
+#include "../Requirement/Requirement.h"
+#include "../Reward/Reward.h"
+#include "../DataLoader/DataLoader.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "Object.h"
+#include "../VIP/VIP.h"
+#include "../HonorRank/HonorRank.h"
+#include "../ExtraEquipment/ExtraEquipment.h"
+#include "../String/myString.h"
+#include "../Switch/Switch.h"
+#include "../Transmogrification/Transmogrification.h"
+#include "../Armory/Armory.h"
+#include "../SignIn/SignIn.h"
+#include "../Talisman/Talisman.h"
+#include "../Rank/Rank.h"
+#include "../SpiritPower/SpiritPower.h"
+#include "../LuckDraw/LuckDraw.h"
+#include "../Recovery/Recovery.h"
+#include "../StatPoints/StatPoints.h"
+#include "../Market/Market.h"
+#include "../AntiFarm/AntiFarm.h"
+#include "../Faction/Faction.h"
+#include "../Reincarnation/Reincarnation.h"
+#include "../UI/Rune/Rune.h"
+#include "../UI/BlackMarket/BlackMarket.h"
+#include "../GS/GS.h"
+#include "../SoulStone/SoulStone.h"
+#include "../SoulStoneEx/SoulStoneEx.h"
+
+void GCAddon::Load()
+{
+}
+
+std::string GCAddon::SplitStr(std::string msg, uint32 index)
+{
+	std::string::size_type idx = msg.find(" ");
+
+	if (idx != std::string::npos)
+	{
+		std::vector<std::string> vec = sCF->SplitStr(msg, " ");
+
+		if (index >= vec.size())
+			index = 0;
+
+		return vec[index];
+	}
+	else
+		return msg;
+}
+
+bool IsOpcode(std::string opcode, std::string _opcode)
+{
+	return strcmp(opcode.c_str(), _opcode.c_str()) == 0;
+}
+
+bool GCAddon::OnRecv(Player* player, std::string msg)
+{
+	stripLineInvisibleChars(msg);
+
+	std::string opcode = SplitStr(msg, 0);
+
+	if (IsOpcode(opcode, "GC_C_LUCKDRAW_V3"))
+	{
+		uint32 action = atoi(SplitStr(msg, 1).c_str());
+
+		if (action != 1 && action != 10)
+			return true;
+
+		uint32 reqId = 0;
+
+		if (action == 1)
+			reqId = atoi(sSwitch->GetFlagByIndex(ST_LUCKDRAW, 1).c_str());
+		else
+			reqId = atoi(sSwitch->GetFlagByIndex(ST_LUCKDRAW, 2).c_str());
+
+		if (action == 1)
+		{
+			if (!sReq->Check(player, reqId))
+				return true;
+
+			if (player->LuckDrawTotalCount == 0)
+			{
+				player->LuckDrawTotalCount = 1;
+				player->LuckDrawCount = 1;
+				player->LuckDrawTimer = 0;
+			}
+			else
+				return true;
+
+			sReq->Des(player, reqId);
+		}
+		else if (action == 10)
+		{
+			if (!sReq->Check(player, reqId))
+				return true;
+
+			if (player->LuckDrawTotalCount == 0)
+			{
+				player->LuckDrawTotalCount = 10;
+				player->LuckDrawCount = 10;
+				player->LuckDrawTimer = 0;
+			}
+			else
+				return true;
+
+			sReq->Des(player, reqId);
+		}
+
+		sGCAddon->SendPacketTo(player, "GC_S_LUCKDRAW_V3", "START");
+
+		return true;
+	}
+	else if (IsOpcode(opcode, "GC_C_RECOVERY"))
+	{
+		uint32 action = atoi(SplitStr(msg, 1).c_str());
+		uint32 id = atoi(SplitStr(msg, 2).c_str());
+
+		if (action == 0)
+			sRecovery->SendCategoryMsg(player, id);
+		else if (action == 1)
+			sRecovery->Action(player, id);
+		return true;
+	}
+	else if (IsOpcode(opcode, "GC_C_STATPOINTS"))
+	{
+		uint32 action = atoi(SplitStr(msg, 1).c_str());
+		uint32 id = atoi(SplitStr(msg, 2).c_str());
+
+		if (action == 0)
+			sStatPoints->Ins(player, id);
+		else if (action == 1)
+			sStatPoints->Des(player, id);
+		return true;
+	}
+	else if (IsOpcode(opcode, "GC_C_ANTIFARM"))
+	{
+		uint32 num = atoi(SplitStr(msg, 1).c_str());
+		sAntiFarm->DoCheck(player, num);
+		return true;
+	}
+	else if (IsOpcode(opcode, "GC_C_RELOAD"))
+	{
+		sGCAddon->SendAllData(player);
+		return true;
+	}
+	else if (IsOpcode(opcode, "GC_C_CHECK_REQ_POP"))
+	{
+		uint32 reqId = atoi(SplitStr(msg, 1).c_str());
+	
+		SendReqCheck(player, reqId, true);
+	
+		return true;
+	}
+	else if (IsOpcode(opcode, "GC_C_CHECK_REQ_PANEL"))
+	{
+		uint32 reqId = atoi(SplitStr(msg, 1).c_str());
+	
+		SendReqCheck(player, reqId, false);
+	
+		return true;
+	}
+	else if (IsOpcode(opcode, "GC_C_BUY_RUNE"))
+	{
+		uint32 page = atoi(SplitStr(msg, 1).c_str());
+		uint32 id = atoi(SplitStr(msg, 2).c_str());
+		sRune->Update(player, page, id);
+		return true;
+	}
+	else if (IsOpcode(opcode, "GC_C_BUY_BLACKMARKET"))
+	{
+		uint32 id = atoi(SplitStr(msg, 1).c_str());
+		sBlackMarket->Update(player, id);
+		return true;
+	}
+	else if (IsOpcode(opcode, "GC_C_BUY_LUCKDRAW"))
+	{
+		uint32 count = atoi(SplitStr(msg, 1).c_str());
+		
+		if (count != 1 && count != 10)
+		{
+			ChatHandler(player->GetSession()).PSendSysMessage("´íÎóµÄ³é½±´ÎÊý");
+			sGCAddon->SendPacketTo(player, "GC_S_LUCKDRAW_STOP", "");
+			return true;
+		}
+			
+		uint32 reqId = 0;
+	
+		if (count == 1)
+			reqId = atoi(sSwitch->GetFlagByIndex(ST_LUCKDRAW, 1).c_str());
+		else
+			reqId = atoi(sSwitch->GetFlagByIndex(ST_LUCKDRAW, 2).c_str());
+	
+		if (sReq->Check(player, reqId))
+		{
+			sReq->Des(player, reqId);
+			player->UI_LuckDrawCount = count;
+			player->UI_LuckDrawUpdateTimer = 100;
+			player->UI_LuckDrawRewCount = 0;
+		}else
+			sGCAddon->SendPacketTo(player, "GC_S_LUCKDRAW_STOP", "");
+	
+		return true;
+	}
+	else if (IsOpcode(opcode, "GC_C_TRANSMOG"))
+	{
+		SendTransMogData(player);
+		return true;
+	}
+	else if (IsOpcode(opcode, "GC_C_BUY_TRANSMOG"))
+	{
+		uint32 id = atoi(SplitStr(msg, 1).c_str());
+		uint32 fakeEntry = atoll(SplitStr(msg, 2).c_str());
+	
+		EquipmentSlots slot = EQUIPMENT_SLOT_END;
+	
+		switch (id)
+		{
+		case 1:slot = EQUIPMENT_SLOT_HEAD; break;
+		case 2:slot = EQUIPMENT_SLOT_SHOULDERS; break;
+		case 3:slot = EQUIPMENT_SLOT_BODY; break;
+		case 4:slot = EQUIPMENT_SLOT_CHEST; break;
+		case 5:slot = EQUIPMENT_SLOT_WAIST; break;
+		case 6:slot = EQUIPMENT_SLOT_LEGS; break;
+		case 7:slot = EQUIPMENT_SLOT_FEET; break;
+		case 8:slot = EQUIPMENT_SLOT_WRISTS; break;
+		case 9:slot = EQUIPMENT_SLOT_HANDS; break;
+		case 10:slot = EQUIPMENT_SLOT_BACK; break;
+		case 11:slot = EQUIPMENT_SLOT_MAINHAND; break;
+		case 12:slot = EQUIPMENT_SLOT_OFFHAND; break;
+		case 13:slot = EQUIPMENT_SLOT_RANGED; break;
+		case 14:slot = EQUIPMENT_SLOT_TABARD; break;
+		default:return true;
+		}
+	
+		if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+		{
+			if (ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(fakeEntry))
+			{
+				if (sTransmogrification->PresetTransmog(player, item, fakeEntry, slot))
+					SendTransMogData(player);
+				else
+					ChatHandler(player->GetSession()).PSendSysMessage("»Ã»¯Ê§°Ü£¬Ïà¹Ø²¿Î»²»ÄÜ»Ã»¯´ËÎïÆ·");
+			}
+		}
+	
+		return true;
+	}
+	else if (IsOpcode(opcode, "GC_C_TALISMAN"))
+	{
+		uint32 action = atoi(SplitStr(msg, 1).c_str());
+
+		if (action == 0)
+		{
+			uint32 ID = atoi(SplitStr(msg, 2).c_str());
+			uint32 entry = atoi(SplitStr(msg, 3).c_str());
+			sTalisman->EquipTalisman(player, ID, entry);
+		}
+		else if (action == 1)
+			sTalisman->SendPacket(player);
+	}
+	else if (IsOpcode(opcode, "GC_TRANS_BUY"))
+	{
+		int32 i = atoi(SplitStr(msg, 1).c_str());
+
+		uint32 entry = abs(i);
+
+		ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(entry);
+		if (!pProto)
+		{
+			player->GetSession()->SendNotification("¸ÃÎïÆ·²»´æÔÚ");
+			return true;
+		}
+
+		uint32 reqId = GetTransReqId(entry);
+
+		if (!sReq->Check(player, reqId))
+			return true;
+
+		EquipmentSlots slot = EQUIPMENT_SLOT_END;
+
+		switch (pProto->InventoryType)
+		{
+		case INVTYPE_HEAD:
+			slot = EQUIPMENT_SLOT_HEAD;
+			break;
+		case INVTYPE_SHOULDERS:
+			slot = EQUIPMENT_SLOT_SHOULDERS;
+			break;
+		case INVTYPE_BODY:
+			slot = EQUIPMENT_SLOT_BODY;
+			break;
+		case INVTYPE_CHEST:
+		case INVTYPE_ROBE:
+			slot = EQUIPMENT_SLOT_CHEST;
+			break;
+		case INVTYPE_WAIST:
+			slot = EQUIPMENT_SLOT_WAIST;
+			break;
+		case INVTYPE_LEGS:
+			slot = EQUIPMENT_SLOT_LEGS;
+			break;
+		case INVTYPE_FEET:
+			slot = EQUIPMENT_SLOT_FEET;
+			break;
+		case INVTYPE_WRISTS:
+			slot = EQUIPMENT_SLOT_WRISTS;
+			break;
+		case INVTYPE_HANDS:
+			slot = EQUIPMENT_SLOT_HANDS;
+			break;
+		case INVTYPE_CLOAK:
+			slot = EQUIPMENT_SLOT_BACK;
+			break;
+		case INVTYPE_WEAPON:
+		case INVTYPE_WEAPONMAINHAND:
+		case INVTYPE_2HWEAPON:
+			slot = EQUIPMENT_SLOT_MAINHAND;
+			break;
+		case INVTYPE_WEAPONOFFHAND:
+		case INVTYPE_SHIELD:
+			slot = EQUIPMENT_SLOT_OFFHAND;
+			break;
+		case INVTYPE_RANGEDRIGHT:
+		case INVTYPE_RANGED:
+			slot = EQUIPMENT_SLOT_OFFHAND;
+			break;
+		default:
+			break;
+		}
+
+		if (slot == EQUIPMENT_SLOT_END)
+		{
+			player->GetSession()->SendNotification("¸ÃÎïÆ·²»ÄÜÓÃÓÚ»Ã»¯");
+			return true;
+		}
+
+		if (entry > 56806 && !player->HasItemCount(entry, 1, true))
+		{
+			std::ostringstream oss;
+			oss << "ÇëÏÈ¹ºÂò" << sCF->GetItemLink(entry);
+			player->GetSession()->SendNotification(oss.str().c_str());
+			return true;
+		}
+
+		if (i < 0)
+			slot = EQUIPMENT_SLOT_OFFHAND;
+
+		if (Item* itemTransmogrified = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+		{
+			if (sTransmogrification->PresetTransmog(player, itemTransmogrified, entry, slot))
+			{
+				player->GetSession()->SendAreaTriggerMessage("»Ã»¯³É¹¦");
+				sReq->Des(player, reqId);
+			}
+			else
+				player->GetSession()->SendNotification("Ä¿±ê²¿Î»²»ÔÊÐí»Ã»¯³É¸ÃÎïÆ·£¬»Ã»¯Ê§°Ü");
+		}
+		else
+			player->GetSession()->SendNotification("¸Ã²¿Î»Î´×°±¸ÎïÆ·£¬»Ã»¯Ê§°Ü");
+
+		return true;
+	}else if (IsOpcode(opcode, "GC_C_ITEMENTRY"))
+	{
+		sGCAddon->SendItemEntryData(player, atoi(SplitStr(msg, 1).c_str()));
+		return true;
+	}
+	else if (IsOpcode(opcode, "SSC_ITEM_TO_SLOT"))
+	{
+		sLog->outString("ÊÕµ½»êÓñ²Ù×÷Âë5");
+		sLog->outString(msg.c_str());
+		std::string str = SplitStr(msg, 1);
+		std::vector<std::string> vec = sSoulStone->split(str, "#");
+
+		uint32 page = atoi(vec[0].c_str());
+		uint32 slot = atoi(vec[1].c_str());
+		uint32 item = atoi(vec[2].c_str());
+		sLog->outString("page = %s, slot = %d, item = %d", vec[0].c_str(), slot, item);
+		sSoulStone->CanInSetToSlot(player, page, slot, item, str);
+	}
+	else if (IsOpcode(opcode, "SSC_REMOVE_SLOT_ITEM"))
+	{
+		sLog->outString("ÊÕµ½»êÓñ²Ù×÷Âë4");
+		std::string str = SplitStr(msg, 1);
+		std::vector<std::string> vec = sSoulStone->split(str, "#");
+
+		uint32 page = atoi(vec[0].c_str());
+		uint32 slot = atoi(vec[1].c_str());
+
+		sSoulStone->CanRemoveSlot(player, page, slot, str);
+	}
+	else if (IsOpcode(opcode, "SSC_LIMIT"))
+	{
+		if (SplitStr(msg, 1) == "VAL")
+		{
+			sLog->outString("ÊÕµ½»êÓñ²Ù×÷Âë1");
+			sSoulStone->SendMutualData(player);
+		}
+	}
+	else if (IsOpcode(opcode, "SSC_ACTI"))
+	{
+		if (SplitStr(msg, 1) == "ISOK")
+		{
+			sLog->outString("ÊÕµ½»êÓñ²Ù×÷Âë2");
+			sSoulStone->SendAllActiData(player);
+		}
+	}
+	else if (IsOpcode(opcode, "SSC_BUY_PAGE"))
+	{
+		sLog->outString("ÊÕµ½»êÓñ²Ù×÷Âë3");
+		std::string str = SplitStr(msg, 1);
+		uint32 page = atoi(str.c_str());
+
+		if (!sSoulStone->IsBuyPageReq(player, page))
+		{
+			return false;
+		}
+	}
+	else if (IsOpcode(opcode, "SSCEX_ITEM_TO_SLOT"))
+	{
+		sLog->outString("ÊÕµ½»êÓñÀ©Õ¹²Ù×÷Âë5");
+		sLog->outString(msg.c_str());
+		std::string str = SplitStr(msg, 1);
+		std::vector<std::string> vec = sSoulStoneEx->split(str, "#");
+
+		uint32 page = atoi(vec[0].c_str());
+		uint32 slot = atoi(vec[1].c_str());
+		uint32 item = atoi(vec[2].c_str());
+		sLog->outString("page = %s, slot = %d, item = %d", vec[0].c_str(), slot, item);
+		sSoulStoneEx->CanInSetToSlot(player, page, slot, item, str);
+	}
+	else if (IsOpcode(opcode, "SSCEX_REMOVE_SLOT_ITEM"))
+	{
+		sLog->outString("ÊÕµ½»êÓñÀ©Õ¹²Ù×÷Âë4");
+		std::string str = SplitStr(msg, 1);
+		std::vector<std::string> vec = sSoulStoneEx->split(str, "#");
+
+		uint32 page = atoi(vec[0].c_str());
+		uint32 slot = atoi(vec[1].c_str());
+
+		sSoulStoneEx->CanRemoveSlot(player, page, slot, str);
+	}
+	else if (IsOpcode(opcode, "SSCEX_LIMIT"))
+	{
+		if (SplitStr(msg, 1) == "VAL")
+		{
+			sLog->outString("ÊÕµ½»êÓñÀ©Õ¹²Ù×÷Âë1");
+			sSoulStoneEx->SendMutualData(player);
+		}
+	}
+	else if (IsOpcode(opcode, "SSCEX_ACTI"))
+	{
+		if (SplitStr(msg, 1) == "ISOK")
+		{
+			sLog->outString("ÊÕµ½»êÓñÀ©Õ¹²Ù×÷Âë2");
+			sSoulStoneEx->SendAllActiData(player);
+		}
+	}
+	else if (IsOpcode(opcode, "SSCEX_BUY_PAGE"))
+	{
+		sLog->outString("ÊÕµ½»êÓñÀ©Õ¹²Ù×÷Âë3");
+		std::string str = SplitStr(msg, 1);
+		uint32 page = atoi(str.c_str());
+
+		if (!sSoulStoneEx->IsBuyPageReq(player, page))
+		{
+			return false;
+		}
+	}
+	return false;
+}
+
+std::string GCAddon::GetStrByIndex(uint32 index, std::string buff)
+{
+	std::string::size_type idx = buff.find("#");
+
+	if (idx != std::string::npos)
+	{
+		std::vector<std::string> vec = sCF->SplitStr(buff, "#");
+
+		if (index > vec.size())
+			return vec[0];
+		else
+			return vec[index - 1];
+	}
+	else
+		return buff;
+}
+
+uint32 GCAddon::GetItemEntry(std::string itemLink)
+{
+	std::string::size_type idx = itemLink.find(":");
+
+	if (idx != std::string::npos)
+	{
+		std::vector<std::string> vec = sCF->SplitStr(itemLink, ":");
+
+		if (vec.size() > 2)
+			return atoi(vec[1].c_str());
+	}
+
+	return 0;
+}
+
+std::string GCAddon::GetItemLink(Item* item, WorldSession* session)
+{
+	int loc_idx = session->GetSessionDbLocaleIndex();
+	const ItemTemplate* temp = item->GetTemplate();
+	std::string name = temp->Name1;
+
+	if (int32 itemRandPropId = item->GetItemRandomPropertyId())
+	{
+		char* const* suffix = NULL;
+		if (itemRandPropId < 0)
+		{
+			const ItemRandomSuffixEntry* itemRandEntry = sItemRandomSuffixStore.LookupEntry(-item->GetItemRandomPropertyId());
+			if (itemRandEntry)
+				suffix = itemRandEntry->nameSuffix;
+		}
+		else
+		{
+			const ItemRandomPropertiesEntry* itemRandEntry = sItemRandomPropertiesStore.LookupEntry(item->GetItemRandomPropertyId());
+			if (itemRandEntry)
+				suffix = itemRandEntry->nameSuffix;
+		}
+		if (suffix)
+		{
+			std::string test(suffix[(name != temp->Name1) ? loc_idx : DEFAULT_LOCALE]);
+			if (!test.empty())
+			{
+				name += ' ';
+				name += test;
+			}
+		}
+	}
+
+	std::ostringstream oss;
+	oss << "|c" << std::hex << ItemQualityColors[temp->Quality] << std::dec <<
+		"|Hitem:" << temp->ItemId << ":" <<
+		item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ":" <<
+		item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT) << ":" <<
+		item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_2) << ":" <<
+		item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_3) << ":" <<
+		item->GetEnchantmentId(BONUS_ENCHANTMENT_SLOT) << ":" <<
+		item->GetItemRandomPropertyId() << ":" << item->GetItemSuffixFactor() << ":" <<
+		(uint32)item->GetOwner()->getLevel() << "|h[" << name << "]|h|r";
+
+	return oss.str();
+}
+
+std::string GCAddon::GetItemIcon(uint32 entry)
+{
+	//if(ItemEntry const* dbcitem = sItemStore.LookupEntry(entry))
+	//	return "";
+
+	const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+	const ItemDisplayInfoEntry* dispInfo = NULL;
+	if (temp)
+	{
+		dispInfo = sItemDisplayInfoStore.LookupEntry(temp->DisplayInfoID);
+		if (dispInfo)
+			return  dispInfo->inventoryIcon;
+	}
+
+	return "";
+}
+
+std::string GCAddon::GetReqString(Player* player, uint32 reqId)
+{
+	return "";
+}
+
+std::string GCAddon::GetRewString(Player* player, uint32 rewId)
+{
+	std::ostringstream oss;
+
+	std::unordered_map<uint32, RewTemplate>::iterator itr = RewMap.find(rewId);
+	if (itr != RewMap.end())
+	{
+		if (itr->second.hrPoints > 0)
+			oss << sSwitch->GetValue(ST_BG_QUEQUE_INTERVALS) << "-" << GetItemIcon(sSwitch->GetValue(ST_BG_QUEQUE_INTERVALS)) << "-" << itr->second.hrPoints << ":";
+
+		if (itr->second.arenaPoints > 0)
+			oss << sSwitch->GetValue(ST_TALISMAN) << "-" << GetItemIcon(sSwitch->GetValue(ST_TALISMAN)) << "-" << itr->second.arenaPoints << ":";
+
+
+		if (itr->second.tokenCount > 0)
+			oss << sSwitch->GetValue(ST_TOKEN_ID) << "-" << GetItemIcon(sSwitch->GetValue(ST_TOKEN_ID)) << "-" << itr->second.tokenCount << ":";
+
+		if (itr->second.xp > 0)
+			oss << sSwitch->GetValue(ST_CF_GROUP) << "-" << GetItemIcon(sSwitch->GetValue(ST_CF_GROUP)) << "-" << itr->second.xp << ":";
+
+		if (itr->second.goldCount > 0)
+			oss << sSwitch->GetValue(ST_BG_FIXTIME_ENABLE) << "-" << GetItemIcon(sSwitch->GetValue(ST_BG_FIXTIME_ENABLE)) << "-" << itr->second.goldCount / GOLD << ":";
+		
+		for (auto it = itr->second.ItemDataVec.begin(); it != itr->second.ItemDataVec.end(); it++)
+			oss << it->itemId << "-" << GetItemIcon(it->itemId) << "-" << it->itemCount << ":";
+	}
+
+	return oss.str();
+}
+
+uint32 GCAddon::GetTransReqId(uint32 itemId)
+{
+	std::unordered_map<uint32, uint32>::iterator iter = BuyTransItemMap.find(itemId);
+	if (iter != BuyTransItemMap.end())
+		return iter->second;
+
+	iter = BuyTransItemMap.find(0);
+	if (iter != BuyTransItemMap.end())
+		return iter->second;
+
+	return 0;
+}
+
+//#include "mail.h"
+// subject ÓÊ¼þ±êÌâ
+// text		ÓÊ¼þÄÚÈÝ
+//guid		Íæ¼Òguid
+//itemEntry ÎïÆ·ID
+//itemCount ÎïÆ·ÊýÁ¿
+
+void SendMail(std::string subject, std::string text,uint32 guid,uint32 itemEntry,uint32 itemCount)
+{
+
+	MailSender sender(MAIL_NORMAL, 0, MAIL_STATIONERY_GM);
+
+	SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+	MailDraft draft(subject, text);
+
+	if (Item* item = Item::CreateItem(itemEntry, itemCount))
+	{
+		item->SaveToDB(trans);
+		draft.AddItem(item);
+	}
+
+	draft.SendMailTo(trans, MailReceiver(guid), sender);
+
+	CharacterDatabase.CommitTransaction(trans);
+}
+
+void SendMail(std::string subject, std::string text, std::string name, uint32 itemEntry, uint32 itemCount)
+{
+
+	uint32 guid = sWorld->GetGlobalPlayerGUID(name);
+
+	MailSender sender(MAIL_NORMAL, 0, MAIL_STATIONERY_GM);
+
+	SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+	MailDraft draft(subject, text);
+
+	if (Item* item = Item::CreateItem(itemEntry, itemCount))
+	{
+		item->SaveToDB(trans);
+		draft.AddItem(item);
+	}
+
+	draft.SendMailTo(trans, MailReceiver(guid), sender);
+
+	CharacterDatabase.CommitTransaction(trans);
+}
+
+class GCAddonPlayerScript : PlayerScript
+{
+public:
+	GCAddonPlayerScript() : PlayerScript("GCAddonPlayerScript") {}
+
+	void OnUpdateZone(Player* player, uint32 /*newZone*/, uint32 /*newArea*/) override
+	{
+		sGCAddon->SendCharData(player);
+	}
+};
+
+void AddSC_GCAddon()
+{
+	new GCAddonPlayerScript();
+}
+
+void GCAddon::SendAllData(Player* player)
+{
+	SendDBData(player);
+	SendCharData(player);
+	SendTokenData(player);
+	sTalisman->SendTalisManValue(player);
+	sRank->SendPacket(player);
+	sSpiritPower->SendPacket(player);
+	sGS->SendVisableGSData(player, true);
+}
+
+void GCAddon::SendDBData(Player* player)
+{
+	std::ostringstream oss;
+	oss << atoi(sSwitch->GetFlagByIndex(ST_LUCKDRAW, 1).c_str()) << " ";
+	oss << atoi(sSwitch->GetFlagByIndex(ST_LUCKDRAW, 2).c_str());
+	SendPacketTo(player, "GC_S_OTHER_DATA", oss.str());
+
+	SendVIPData(player);
+	SendHRData(player);
+	SendFactionData(player);
+	SendReincarnationData(player);
+	SendRankData(player);
+	SendReqData(player);
+	SendRewData(player);
+	SendEnchantData(player);
+	sRune->SendData(player);
+	sBlackMarket->SendData(player);
+	sLuckDraw->SendData(player);
+	sGS->SendSpellGSData(player);
+	SendItemDayLimitData(player);
+}
+
+void GCAddon::SendReqData(Player* player)
+{
+	for (auto iter = ReqMap.begin(); iter != ReqMap.end(); iter++)
+	{
+		std::ostringstream oss;
+
+		oss << iter->first << "#";
+		oss << iter->second.meetLevel << "#";
+		oss << iter->second.meetVipLevel << "#";
+		oss << iter->second.meetHRRank << "#";
+		oss << iter->second.meetFaction << "#";
+		oss << iter->second.meetRankLevel << "#";
+		oss << iter->second.reincarnation << "#";
+		oss << iter->second.meetAchievementPoints << "#";
+		oss << iter->second.desGoldCount << "#";
+		oss << iter->second.desTokenCount << "#";
+		oss << iter->second.desXp << "#";
+		oss << iter->second.desHRPoints << "#";
+		oss << iter->second.desArenaPoints << "#";
+		oss << iter->second.desSpiritPower << "#";
+
+		for (size_t i = 0; i < 10; i++)
+		{
+			uint32 entry = iter->second.desItem[i];
+			uint32 count = iter->second.desItemCount[i];
+
+			oss << entry << "#";
+			oss << count << "#";
+		}
+
+		if (iter->second.MapDataVec.empty())
+			oss << "0";
+		else
+		{
+			for (auto i = iter->second.MapDataVec.begin(); i != iter->second.MapDataVec.end(); i++)
+			{
+				std::string name = GetMapNameById(i->map);
+				std::string zone = GetZoneNameById(i->zone);
+				if (!zone.empty())
+					name += "/" + zone;
+				std::string area = GetAreaNameById(i->area);
+				if (!zone.empty())
+					name += "/" + area;
+				oss << name << ",";
+			}
+		}
+		oss << "#";
+		
+		if (iter->second.SpellDataVec.empty())
+			oss << "0";
+		else
+		{
+			for (auto i = iter->second.SpellDataVec.begin(); i != iter->second.SpellDataVec.end(); i++)
+			{
+				int32 spell = *i;
+
+				if (SpellInfo const*  spellInfo = sSpellMgr->GetSpellInfo(abs(spell)))
+				{
+					if (spell > 0)
+						oss << 1 << "*" << std::string(spellInfo->SpellName[4]) << ",";
+					else
+						oss << -1 << "*" << std::string(spellInfo->SpellName[4]) << ",";
+				}
+					
+			}
+		}
+		oss << "#";
+
+		if (iter->second.QuestDataVec.empty())
+			oss << "0";
+		else
+		{
+			for (auto i = iter->second.QuestDataVec.begin(); i != iter->second.QuestDataVec.end(); i++)
+			{
+				int32 quest = *i;
+
+				if (Quest const* questProto = sObjectMgr->GetQuestTemplate(abs(quest)))
+				{
+					if (quest > 0)
+						oss << 1 << "*" << questProto->GetTitle() << "$";
+					else
+						oss << -1 << "*" << questProto->GetTitle() << "$";
+				}
+					
+			}
+		}
+		oss << "#";
+
+		if (iter->second.AchieveDataVec.empty())
+			oss << "0";
+		else
+		{
+			for (auto i = iter->second.AchieveDataVec.begin(); i != iter->second.AchieveDataVec.end(); i++)
+			{
+				uint32 entryId = *i;
+				if (AchievementEntry const* achieve = sAchievementStore.LookupEntry(entryId))
+					oss << std::string(achieve->name[4]) << ",";
+			}
+		}
+
+		oss << "#";
+		//command
+		uint32 count = 0;
+		for (auto itr = iter->second.CommandDataVec.begin(); itr != iter->second.CommandDataVec.end(); itr++)
+		{
+			if (!itr->command.empty())
+			{
+				oss << itr->des << "#";
+				oss << itr->icon << "#";
+				count++;
+			}
+		}
+		for (size_t i = count; i < 10; i++)
+		{
+			oss << 0 << "#";
+			oss << 0 << "#";
+		}
+
+		SendPacketTo(player, "GC_S_REQ", oss.str());
+	}
+}
+
+void GCAddon::SendRewData(Player* player)
+{
+	for (auto iter = RewMap.begin(); iter != RewMap.end(); iter++)
+	{
+		std::ostringstream oss;
+
+		oss << iter->first << "#";
+		oss << iter->second.goldCount << "#";
+		oss << iter->second.tokenCount << "#";
+		oss << iter->second.xp << "#";
+		oss << iter->second.statPoints << "#";
+		oss << iter->second.hrPoints << "#"; 
+		oss << iter->second.arenaPoints << "#";
+
+		//item
+		uint32 count = 0;
+		for (auto itr = iter->second.ItemDataVec.begin(); itr != iter->second.ItemDataVec.end(); itr++)
+		{
+			if (count > 10)
+				continue;
+
+			oss << itr->itemId << "#";
+			oss << itr->itemCount << "#";
+			count++;
+		}
+		for (size_t i = count; i < 10; i++)
+		{
+			oss << 0 << "#";
+			oss << 0 << "#";
+		}
+			
+		//spell
+		count = 0;
+		for (auto itr = iter->second.SpellDataVec.begin(); itr != iter->second.SpellDataVec.end(); itr++)
+		{
+			if (*itr < 0 || count > 10)
+				continue;
+
+			oss << *itr << "#";
+			count++;
+		}
+		for (size_t i = count; i < 10; i++)
+			oss << 0 << "#";
+
+		//aura
+		count = 0;
+		for (auto itr = iter->second.SpellDataVec.begin(); itr != iter->second.SpellDataVec.end(); itr++)
+		{
+			if (*itr > 0 || count > 10)
+				continue;
+
+			oss << abs(*itr) << "#";
+			count++;
+		}
+		for (size_t i = count; i < 10; i++)
+			oss << 0 << "#";
+
+		//command
+		count = 0;
+		for (auto itr = iter->second.CommandDataVec.begin(); itr != iter->second.CommandDataVec.end(); itr++)
+		{
+			if (!itr->command.empty())
+			{
+				oss << itr->des << "#";
+				oss << itr->icon << "#";
+				count++;
+			}
+		}
+		for (size_t i = count; i < 10; i++)
+		{
+			oss << 0 << "#";
+			oss << 0 << "#";
+		}
+			
+		SendPacketTo(player, "GC_S_REW", oss.str());
+	}
+}
+
+void GCAddon::SendVIPData(Player* player)
+{
+	for (auto iter = VIPVec.begin(); iter != VIPVec.end(); ++iter)
+	{
+		std::ostringstream oss;
+		oss << iter->vipLv << " ";
+		oss << iter->icon << " ";
+		oss << iter->name << " ";
+		oss << iter->reqId << " ";
+		oss << iter->rewId;
+		SendPacketTo(player, "GC_S_VIP", oss.str());
+	}
+}
+
+void GCAddon::SendHRData(Player* player)
+{
+	for (auto iter = HRUpVec.begin(); iter != HRUpVec.end(); ++iter)
+	{
+		std::ostringstream oss;
+		oss << iter->title << " ";
+		oss << iter->reqId << " ";
+		oss << iter->rewId;
+		SendPacketTo(player, "GC_S_HR", oss.str());
+	}
+}
+
+void GCAddon::SendFactionData(Player* player)
+{
+	std::ostringstream oss;
+	for (auto iter = FactionDataMap.begin(); iter != FactionDataMap.end(); ++iter)
+		oss << iter->first << "-" << iter->second.name << " ";
+	SendPacketTo(player, "GC_S_FACTION", oss.str());
+}
+
+void GCAddon::SendReincarnationData(Player* player)
+{
+	std::ostringstream oss;
+	for (auto iter = ReincarnationMap.begin(); iter != ReincarnationMap.end(); ++iter)
+		oss << iter->first << "-" << iter->second.gossipText << " ";
+	SendPacketTo(player, "GC_S_REINCARNATION", oss.str());
+}
+
+void GCAddon::SendRankData(Player* player)
+{
+	std::ostringstream oss;
+	for (auto iter = RankDataMap.begin(); iter != RankDataMap.end(); ++iter)
+		oss << iter->first << "-" << iter->second.name << " ";
+	SendPacketTo(player, "GC_S_RANK", oss.str());
+}
+
+void GCAddon::SendEnchantData(Player* player)
+{
+	for (auto itr = GCAddonEnchantGroupVec.begin(); itr != GCAddonEnchantGroupVec.end(); itr++)
+	{
+		SpellItemEnchantmentEntry const* info = sSpellItemEnchantmentStore.LookupEntry(*itr);
+
+		if (!info)
+			continue;
+
+		std::ostringstream oss;
+		oss << info->ID << "^";
+		oss << info->description[4];
+		SendPacketTo(player, "GC_S_ENCHANT", oss.str());
+	}
+
+	//Ö÷±³°ü
+	for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
+		if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+			SendItemEnchantData(player, item);
+			
+
+	//¶îÍâÈý¸ö±³°ü
+	for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+		if (Bag* pBag = player->GetBagByPos(i))
+			for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+				if (Item* item = player->GetItemByPos(i, j))
+					SendItemEnchantData(player, item);
+
+	//ÒøÐÐ
+	for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
+		if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+			SendItemEnchantData(player, item);
+				
+	//ÒøÐÐ±³°ü
+	for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+		if (Bag* pBag = player->GetBagByPos(i))
+			for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+				if (Item* item = player->GetItemByPos(i, j))
+					SendItemEnchantData(player, item);
+}
+
+void GCAddon::SendItemEnchantData(Player* player, Item* item)
+{
+	if (!item->IsNoPatch())
+		return;
+
+	for (size_t slot = PROP_ENCHANTMENT_SLOT_0; slot < MAX_ENCHANTMENT_SLOT; slot++)
+	{
+		std::ostringstream oss;
+		oss << item->GetGUIDLow() << " ";
+		oss << slot - 6 << " ";
+		oss << item->GetEnchantmentId(EnchantmentSlot(slot)) << " ";
+		SendPacketTo(player, "GC_S_ITEMGUID", oss.str());
+	}
+}
+
+void GCAddon::SendItemEntryData(Player* player, uint32 entry)
+{
+	auto iter = UIItemEntryMap.find(entry);
+
+	if (iter != UIItemEntryMap.end())
+	{
+		std::ostringstream oss;
+		oss << iter->first << "^";
+		oss << iter->second.des << "^";
+		oss << iter->second.heroText << "^";
+		oss << iter->second.daylimit << "^";
+		oss << iter->second.maxGems << "^";
+		oss << iter->second.exchange1 << "^";
+		oss << iter->second.exchangeReqId1 << "^";
+		oss << iter->second.exchange2 << "^";
+		oss << iter->second.exchangeReqId2 << "^";
+		oss << iter->second.unbindReqId << "^";
+		oss << iter->second.useReqId << "^";
+		oss << iter->second.equipReqId << "^";
+		oss << iter->second.buyReqId << "^";
+		oss << iter->second.sellRewId << "^";
+		oss << iter->second.recoveryRewId << "^";
+		oss << iter->second.gs;
+		SendPacketTo(player, "GC_S_ITEMENTRY", oss.str());
+	}
+}
+
+void GCAddon::SendItemDayLimitData(Player* player)
+{
+	for (auto itr = player->PDayLimitItemMap.begin(); itr != player->PDayLimitItemMap.end(); itr++)
+	{
+		std::ostringstream oss;
+		oss << itr->first << " ";
+		oss << itr->second;
+		SendPacketTo(player, "GC_S_DAYLIMIT", oss.str());
+	}
+}
+
+void GCAddon::SendCharData(Player* player)
+{
+	std::ostringstream oss;
+	oss << player->vipLevel			<< " ";
+	oss << sHR->GetHRTiteId(player) << " ";
+	oss << player->faction			<< " ";
+	oss << player->rankLevel		<< " ";
+	oss << player->reincarnationLv	<< " ";
+	oss << player->GetMapId()		<< " ";
+	oss << player->GetZoneId()		<< " ";
+	oss << player->GetAreaId()		<< " ";
+
+	SendPacketTo(player, "GC_S_CHAR", oss.str());
+}
+
+
+void GCAddon::SendTokenData(Player* player)
+{
+	std::ostringstream oss;
+	oss << sCF->GetTokenAmount(player);
+	SendPacketTo(player, "GC_S_TOKEN", oss.str());
+}
+
+void GCAddon::SendTokenUpdateData(Player* player, int64 count, bool add)
+{
+	std::ostringstream oss;
+	add ? oss << count : oss << -count;
+	SendPacketTo(player, "GC_S_TOKEN_UPDATE", oss.str());
+}
+
+//check map achieve spell quest
+void GCAddon::SendReqCheck(Player* player, uint32 req, bool pop)
+{
+	std::ostringstream oss;
+	
+	oss << req;
+
+	oss << " ";
+
+	if (sReq->CheckMap(player, req, false))
+		oss << 1;
+	else
+		oss << -1;
+	
+	oss << " ";
+
+	if (sReq->CheckQuest(player, req, false))
+		oss << 1;
+	else
+		oss << -1;
+
+	oss << " ";
+
+	if (sReq->CheckSpell(player, req, false))
+		oss << 1;
+	else
+		oss << -1;
+
+	oss << " ";
+
+	if (sReq->CheckAcheive(player, req, false))
+		oss << 1;
+	else
+		oss << -1;
+
+	if (pop)
+		SendPacketTo(player, "GC_S_REQ_CHECK_POP", oss.str());
+	else
+		SendPacketTo(player, "GC_S_REQ_CHECK_PANEL", oss.str());
+}
+
+void GCAddon::SendTransMogData(Player* player)
+{
+	std::ostringstream oss;
+	
+	if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD))
+		oss << item->GetEntry() << "-" << sTransmogrification->GetFakeEntry(item->GetGUID()) << " ";
+	else
+		oss << 0 << "-" << 0 << " ";
+
+	if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS))
+		oss << item->GetEntry() << "-" << sTransmogrification->GetFakeEntry(item->GetGUID()) << " ";
+	else
+		oss << 0 << "-" << 0 << " ";
+
+	if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BODY))
+		oss << item->GetEntry() << "-" << sTransmogrification->GetFakeEntry(item->GetGUID()) << " ";
+	else
+		oss << 0 << "-" << 0 << " ";
+
+	if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_CHEST))
+		oss << item->GetEntry() << "-" << sTransmogrification->GetFakeEntry(item->GetGUID()) << " ";
+	else
+		oss << 0 << "-" << 0 << " ";
+
+	if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WAIST))
+		oss << item->GetEntry() << "-" << sTransmogrification->GetFakeEntry(item->GetGUID()) << " ";
+	else
+		oss << 0 << "-" << 0 << " ";
+
+	if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS))
+		oss << item->GetEntry() << "-" << sTransmogrification->GetFakeEntry(item->GetGUID()) << " ";
+	else
+		oss << 0 << "-" << 0 << " ";
+
+	if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET))
+		oss << item->GetEntry() << "-" << sTransmogrification->GetFakeEntry(item->GetGUID()) << " ";
+	else
+		oss << 0 << "-" << 0 << " ";
+
+	if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS))
+		oss << item->GetEntry() << "-" << sTransmogrification->GetFakeEntry(item->GetGUID()) << " ";
+	else
+		oss << 0 << "-" << 0 << " ";
+
+	if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS))
+		oss << item->GetEntry() << "-" << sTransmogrification->GetFakeEntry(item->GetGUID()) << " ";
+	else
+		oss << 0 << "-" << 0 << " ";
+
+	if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK))
+		oss << item->GetEntry() << "-" << sTransmogrification->GetFakeEntry(item->GetGUID()) << " ";
+	else
+		oss << 0 << "-" << 0 << " ";
+
+	if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
+		oss << item->GetEntry() << "-" << sTransmogrification->GetFakeEntry(item->GetGUID()) << " ";
+	else
+		oss << 0 << "-" << 0 << " ";
+
+	if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
+		oss << item->GetEntry() << "-" << sTransmogrification->GetFakeEntry(item->GetGUID()) << " ";
+	else
+		oss << 0 << "-" << 0 << " ";
+
+	if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_RANGED))
+		oss << item->GetEntry() << "-" << sTransmogrification->GetFakeEntry(item->GetGUID()) << " ";
+	else
+		oss << 0 << "-" << 0 << " ";
+
+	if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_TABARD))
+		oss << item->GetEntry() << "-" << sTransmogrification->GetFakeEntry(item->GetGUID());
+	else
+		oss << 0 << "-" << 0;
+
+	SendPacketTo(player, "GC_S_TRANSMOG", oss.str());
+}
diff --git a/src/server/scripts/Custom/GCAddon/GCAddon.h b/src/server/scripts/Custom/GCAddon/GCAddon.h
new file mode 100644
index 0000000..b7feb0f
--- /dev/null
+++ b/src/server/scripts/Custom/GCAddon/GCAddon.h
@@ -0,0 +1,71 @@
+class GCAddon
+{
+public:
+	static GCAddon* instance()
+	{
+		static GCAddon instance;
+		return &instance;
+	}
+	
+	std::string SplitStr(std::string msg, uint32 index);
+
+	bool OnRecv(Player* player, std::string msg);
+
+	void SendPacketTo(const Player* player, std::string opcode, std::string msg)
+	{
+		msg = opcode + "\t" + msg;
+		WorldPacket data(SMSG_MESSAGECHAT, 100);
+		data << uint8(CHAT_MSG_WHISPER);
+		data << int32(LANG_ADDON);
+		data << uint64(player->GetGUID());
+		data << uint32(0);
+		data << uint64(player->GetGUID());
+		data << uint32(msg.length() + 1);
+		data << msg;
+		data << uint8(0);
+		player->GetSession()->SendPacket(&data);
+	}
+	
+	std::string GetStrByIndex(uint32 index, std::string buff);
+
+	void Load();
+
+	uint32 GetItemEntry(std::string itemLink);
+	std::string GetItemLink(Item* item, WorldSession* session);
+
+	//»ñÈ¡ÏûºÄ¡¢½±Àø×Ö·û´®
+	std::string GetReqString(Player* player, uint32 reqId);
+	std::string GetRewString(Player* player, uint32 rewId);
+
+	//»Ã»¯
+	uint32 GetTransReqId(uint32 itemId);
+	std::string GetItemIcon(uint32 entry);
+
+	void SendAllData(Player* player);
+	void SendDBData(Player* player);
+	void SendReqData(Player* player);
+	void SendRewData(Player* player);
+	void SendVIPData(Player* player);
+	void SendHRData(Player* player);
+	void SendFactionData(Player* player);
+	void SendReincarnationData(Player* player);
+	void SendRankData(Player* player);
+	void SendEnchantData(Player* player);
+	void SendItemEnchantData(Player* player, Item* item);
+	void SendItemEntryData(Player* player, uint32 entry);
+	void SendItemDayLimitData(Player* player);
+
+
+	//char data
+	void SendCharData(Player* player);
+	void SendTokenData(Player* player);
+	void SendTokenUpdateData(Player* player, int64 count, bool add);
+
+	void SendTransMogData(Player* player);
+
+	//check map achieve spell quest
+	void SendReqCheck(Player* player, uint32 req, bool pop);
+private:
+
+};
+#define sGCAddon GCAddon::instance()
diff --git a/src/server/scripts/Custom/GS/GS.cpp b/src/server/scripts/Custom/GS/GS.cpp
new file mode 100644
index 0000000..a8040cd
--- /dev/null
+++ b/src/server/scripts/Custom/GS/GS.cpp
@@ -0,0 +1,142 @@
+#pragma execution_character_set("utf-8")
+#include "GS.h"
+#include "../ItemMod/ItemMod.h"
+#include "../GCAddon/GCAddon.h"
+
+std::vector<GSTemplate> GSVec;
+
+void GS::Load()
+{
+	GSVec.clear();
+	
+	//QueryResult result = WorldDatabase.PQuery("SELECT Id, Type, GS FROM _gs");
+
+	//if (!result)
+	//	return;
+	//do
+	//{
+	//	Field* fields = result->Fetch();
+	//	GSTemplate Temp;
+	//	Temp.id = fields[0].GetUInt32();
+	//
+	//	const char*  str = fields[1].GetCString();
+	//
+	//	if (strcmp("×°±¸", str) == 0)
+	//		Temp.type = GS_TYPE_ITEM_EQUIP;
+	//	else if (strcmp("¼¼ÄÜ", str) == 0)
+	//		Temp.type = GS_TYPE_SPELL;
+	//	else if (strcmp("Òþ²ØÎïÆ·", str) == 0)
+	//		Temp.type = GS_TYPE_ITEM_HIDDEN;
+	//
+	//	Temp.gs = fields[2].GetUInt32();
+	//
+	//	GSVec.push_back(Temp);
+	//} while (result->NextRow());
+}
+
+uint32 GS::GetGS(uint32 id, GSTypes type)
+{
+	if (id == 0)
+		return 0;
+
+	for (auto itr = GSVec.begin(); itr != GSVec.end(); itr++)
+		if (id == itr->id && type == itr->type)
+			return itr->gs;
+
+	return 0;
+}
+
+void GS::UpdateGS(Player* pl)
+{
+	uint32 gs = 0;
+
+	//¼¼ÄÜ
+	PlayerSpellMap spellMap = pl->GetSpellMap();
+	for (PlayerSpellMap::const_iterator iter = spellMap.begin(); iter != spellMap.end(); ++iter)
+		gs += GetGS(iter->first, GS_TYPE_SPELL); 
+
+	//×°±¸À¸
+	for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
+		if (Item* item = pl->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+			gs += GetGS(item->GetEntry(), GS_TYPE_ITEM_EQUIP);
+
+	//Ö÷±³°ü
+	for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
+		if (Item* item = pl->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+			for (uint32 k = 0; k < HiddenItemInfo.size(); k++)
+				if (item->GetEntry() == HiddenItemInfo[k].entry)
+					gs += GetGS(item->GetEntry(), GS_TYPE_ITEM_HIDDEN);
+
+	//¶îÍâÈý¸ö±³°ü
+	for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+		if (Bag* pBag = pl->GetBagByPos(i))
+			for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+				if (Item* item = pl->GetItemByPos(i, j))
+					for (uint32 k = 0; k < HiddenItemInfo.size(); k++)
+						if (item->GetEntry() == HiddenItemInfo[k].entry)
+							gs += GetGS(item->GetEntry(), GS_TYPE_ITEM_HIDDEN);
+
+	//ÒøÐÐ
+	for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
+		if (Item* item = pl->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+			for (uint32 k = 0; k < HiddenItemInfo.size(); k++)
+				if (item->GetEntry() == HiddenItemInfo[k].entry)
+					gs += GetGS(item->GetEntry(), GS_TYPE_ITEM_HIDDEN);
+	//ÒøÐÐ±³°ü
+	for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+		if (Bag* pBag = pl->GetBagByPos(i))
+			for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+				if (Item* item = pl->GetItemByPos(i, j))
+					for (uint32 k = 0; k < HiddenItemInfo.size(); k++)
+						if (item->GetEntry() == HiddenItemInfo[k].entry)
+							gs += GetGS(item->GetEntry(), GS_TYPE_ITEM_HIDDEN);
+
+	pl->GS = gs;
+}
+
+void GS::UpdateGS(Player* pl, uint32 id, GSTypes type, bool add)
+{
+	uint32 gs = GetGS(id, type);
+
+	if (gs == 0)
+		return;
+
+	add ? pl->GS += gs : pl->GS -= gs;
+
+	SendVisableGSData(pl, false);
+}
+
+void GS::SendGSData(Player* player, Player* target)
+{
+	std::ostringstream oss;
+	oss << target->namePrefix + target->GetName() + target->nameSuffix << " ";
+	oss << target->GetName() << " ";
+	oss << target->GS;
+	sGCAddon->SendPacketTo(player, "GC_S_GS", oss.str());
+}
+
+void GS::SendVisableGSData(Player* player, bool sendtoself)
+{
+	std::list<Player*> playersNearby;
+	player->GetPlayerListInGrid(playersNearby, player->GetVisibilityRange(), false);
+
+	if (!playersNearby.empty())
+		for (std::list<Player*>::iterator iter = playersNearby.begin(); iter != playersNearby.end(); ++iter)
+			if (Player* tar = *iter)
+				sendtoself ? SendGSData(player, tar) : SendGSData(tar, player);
+}
+
+
+uint32 GS::GetItemGS(uint32 id)
+{
+	for (auto itr = GSVec.begin(); itr != GSVec.end(); itr++)
+		if (id == itr->id && GS_TYPE_ITEM_EQUIP == itr->type && GS_TYPE_ITEM_HIDDEN == itr->type)
+			return itr->gs;
+}
+
+void GS::SendSpellGSData(Player* pl)
+{
+	for (auto itr = GSVec.begin(); itr != GSVec.end(); itr++)
+		if (GS_TYPE_SPELL == itr->type)
+			sGCAddon->SendPacketTo(pl, "GC_S_GS_SPELLDATA", std::to_string(itr->id) + " " + std::to_string(itr->gs));
+}
diff --git a/src/server/scripts/Custom/GS/GS.h b/src/server/scripts/Custom/GS/GS.h
new file mode 100644
index 0000000..aee47d7
--- /dev/null
+++ b/src/server/scripts/Custom/GS/GS.h
@@ -0,0 +1,35 @@
+enum GSTypes
+{
+	GS_TYPE_SPELL,
+	GS_TYPE_ITEM_EQUIP,
+	GS_TYPE_ITEM_HIDDEN,
+};
+struct GSTemplate
+{
+	uint32 id;
+	GSTypes type;
+	uint32 gs;
+};
+
+extern std::vector<GSTemplate> GSVec;
+
+class GS
+{
+public:
+	static GS* instance()
+	{
+		static GS instance;
+		return &instance;
+	}
+	void Load();
+	uint32 GetGS(uint32 id, GSTypes type);
+	void UpdateGS(Player* pl);
+	void UpdateGS(Player* pl, uint32 id, GSTypes type, bool add);
+	void SendGSData(Player* player, Player* target);
+	void SendVisableGSData(Player* player, bool sendtoself);
+	uint32 GetItemGS(uint32 id);
+	void SendSpellGSData(Player* pl);
+private:
+
+};
+#define sGS GS::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/GateWay/GateWay.cpp b/src/server/scripts/Custom/GateWay/GateWay.cpp
new file mode 100644
index 0000000..15f2ef2
--- /dev/null
+++ b/src/server/scripts/Custom/GateWay/GateWay.cpp
@@ -0,0 +1,326 @@
+#include "GateWay.h"
+#include <Winsock2.h>
+#include "AccountMgr.h"
+#include "../CommonFunc/CommonFunc.h"
+
+std::string string_To_UTF8(const std::string & str)
+{
+	int nwLen = ::MultiByteToWideChar(CP_ACP, 0, str.c_str(), -1, NULL, 0);
+
+	wchar_t * pwBuf = new wchar_t[nwLen + 1];//Ò»¶¨Òª¼Ó1£¬²»È»»á³öÏÖÎ²°Í
+	ZeroMemory(pwBuf, nwLen * 2 + 2);
+
+	::MultiByteToWideChar(CP_ACP, 0, str.c_str(), str.length(), pwBuf, nwLen);
+
+	int nLen = ::WideCharToMultiByte(CP_UTF8, 0, pwBuf, -1, NULL, NULL, NULL, NULL);
+
+	char * pBuf = new char[nLen + 1];
+	ZeroMemory(pBuf, nLen + 1);
+
+	::WideCharToMultiByte(CP_UTF8, 0, pwBuf, nwLen, pBuf, nLen, NULL, NULL);
+
+	std::string retStr(pBuf);
+
+	delete[]pwBuf;
+	delete[]pBuf;
+
+	pwBuf = NULL;
+	pBuf = NULL;
+
+	return retStr;
+}
+//////////////////////////////////////////////////////////////////////////
+std::string UTF8_To_string(const std::string & str)
+{
+	int nwLen = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, NULL, 0);
+
+	wchar_t * pwBuf = new wchar_t[nwLen + 1];//Ò»¶¨Òª¼Ó1£¬²»È»»á³öÏÖÎ²°Í
+	memset(pwBuf, 0, nwLen * 2 + 2);
+
+	MultiByteToWideChar(CP_UTF8, 0, str.c_str(), str.length(), pwBuf, nwLen);
+
+	int nLen = WideCharToMultiByte(CP_ACP, 0, pwBuf, -1, NULL, NULL, NULL, NULL);
+
+	char * pBuf = new char[nLen + 1];
+	memset(pBuf, 0, nLen + 1);
+
+	WideCharToMultiByte(CP_ACP, 0, pwBuf, nwLen, pBuf, nLen, NULL, NULL);
+
+	std::string retStr = pBuf;
+
+	delete[]pBuf;
+	delete[]pwBuf;
+
+	pBuf = NULL;
+	pwBuf = NULL;
+
+	return retStr;
+}
+//////////////////////////////////////////////////////////////////////////
+
+std::string GetStrByIndex(uint32 index,std::string buff)
+{
+	std::string::size_type idx = buff.find("|");
+
+	if (idx != std::string::npos)
+	{
+		std::vector<std::string> vec = sCF->SplitStr(buff, "|");
+
+		if (index > vec.size())
+			return vec[0];
+		else
+			return vec[index - 1];
+	}
+	else
+		return buff;
+}
+
+char* CreateAccount(std::string accountName, std::string password, std::string macAdress)
+{
+	if (sGateWay->IsMacBaned(macAdress))
+		return "·â»úÆ÷Âë";
+
+	AccountOpResult result = AccountMgr::CreateAccount(accountName, password, macAdress);
+
+	if (result == AOR_OK)
+	{
+		PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_PWD);
+		stmt->setString(0, password);
+		stmt->setString(1, accountName);
+		LoginDatabase.Execute(stmt);
+
+		return "×¢²á³É¹¦";
+	}
+		
+
+	return "ÕËºÅ´æÔÚ";
+}
+
+char* ModPassword(std::string accountName, std::string oldPassword, std::string newPassword, std::string macAdress)
+{
+	if (sGateWay->IsMacBaned(macAdress))
+		return "·â»úÆ÷Âë";
+
+	uint32 accountId = AccountMgr::GetId(accountName);
+
+	if (!accountId)
+		return "ÕËºÅ²»´æÔÚ";
+
+	if (!AccountMgr::CheckPassword(accountId, oldPassword))
+		return "Ô­ÃÜÂë²»ÕýÈ·";
+
+	AccountOpResult result = AccountMgr::ChangePassword(accountId, newPassword);
+	if (result == AOR_OK)
+		return "¸ÄÃÜ³É¹¦";
+
+	return "¸ÄÃÜÊ§°Ü";
+}
+
+char* ResetChar(std::string accountName, std::string password, std::string charName, std::string macAdress)
+{
+	if (sGateWay->IsMacBaned(macAdress))
+		return "·â»úÆ÷Âë";
+
+	uint32 accountId = AccountMgr::GetId(accountName);
+
+	if (!accountId)
+		return "ÕËºÅ²»´æÔÚ";
+
+	if (!AccountMgr::CheckPassword(accountId, password))
+		return "ÃÜÂë´íÎó";
+
+	uint32 guid = sWorld->GetGlobalPlayerGUID(string_To_UTF8(charName));
+	
+	if (!guid)
+		return "½ÇÉ«²»´æÔÚ";
+
+	if (guid)
+	{
+
+		Player* player = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER));
+
+		if (player && player->GetSession())
+			player->TeleportTo(571, 5804.15f, 624.771f, 647.767f, 0);
+		else
+			CharacterDatabase.DirectPExecute("UPDATE characters SET position_x = 5804.15,position_y = 624.771,position_z = 647.767,map = 571 WHERE guid = %d", guid);
+		return "½â¿¨³É¹¦";
+	}
+
+	return "½â¿¨Ê§°Ü";
+}
+
+DWORD WINAPI GateWayRun(PVOID pvParam)	
+{
+	WORD wVersionRequested;
+	WSADATA wsaData;
+	int err;
+
+	wVersionRequested = MAKEWORD(1, 1);
+
+	err = WSAStartup(wVersionRequested, &wsaData);
+	if (err != 0) {
+		return 0;
+	}
+
+	if (LOBYTE(wsaData.wVersion) != 1 ||
+		HIBYTE(wsaData.wVersion) != 1) {
+		WSACleanup();
+		return 0;
+	}
+	SOCKET sockSrv = socket(AF_INET, SOCK_STREAM, 0);
+
+	SOCKADDR_IN addrSrv;
+	addrSrv.sin_addr.S_un.S_addr = htonl(INADDR_ANY);
+	addrSrv.sin_family = AF_INET;
+	addrSrv.sin_port = htons(6000);
+
+	bind(sockSrv, (SOCKADDR*)&addrSrv, sizeof(SOCKADDR));
+
+	listen(sockSrv, SOMAXCONN);
+
+	SOCKADDR_IN addrClient;
+	int len = sizeof(SOCKADDR);
+	while (1)
+	{
+		SOCKET sockConn = accept(sockSrv, (SOCKADDR*)&addrClient, &len);
+		
+		char recvBuf[256];
+		recv(sockConn, recvBuf, 256, 0);
+
+		std::string buff = recvBuf;
+
+		char *sendBuff;
+
+		std::string opcode = GetStrByIndex(1, buff);
+
+		if (std::strcmp(opcode.c_str(), "opcode_check") == 0)
+		{
+			std::string macAdress = GetStrByIndex(2, buff);
+			if (sGateWay->IsMacBaned(macAdress))
+				sendBuff = "·â»úÆ÷Âë";
+			else
+				sendBuff = "ÑéÖ¤Í¨¹ý";
+		}else if (std::strcmp(opcode.c_str(), "opcode_acc") == 0)
+		{
+			std::string accountName = GetStrByIndex(2, buff);
+			std::string password = GetStrByIndex(3, buff);
+			std::string macAdress = GetStrByIndex(4, buff);
+			sendBuff = CreateAccount(accountName, password, macAdress);
+		}
+		else if (std::strcmp(opcode.c_str(), "opcode_pwd") == 0)
+		{
+			std::string accountName = GetStrByIndex(2, buff);
+			std::string oldPassword = GetStrByIndex(3, buff);
+			std::string newPassword = GetStrByIndex(4, buff);
+			std::string macAdress = GetStrByIndex(5, buff);
+			sendBuff = ModPassword(accountName, oldPassword, newPassword, macAdress);
+		}
+		else if (std::strcmp(opcode.c_str(), "opcode_char") == 0)
+		{
+			std::string accountName = GetStrByIndex(2, buff);
+			std::string password = GetStrByIndex(3, buff);
+			std::string charName = GetStrByIndex(4, buff);
+			std::string macAdress = GetStrByIndex(5, buff);
+			sendBuff = ResetChar(accountName, password, charName, macAdress);
+		}
+	
+		send(sockConn, sendBuff, strlen(sendBuff) + 1, 0);
+		closesocket(sockConn);
+	}
+
+	return 0;
+}
+
+
+std::vector<std::string/*ban mac*/> MacBanedVec;
+void GateWay::Load()
+{
+	MacBanedVec.clear();
+	QueryResult result = LoginDatabase.PQuery("SELECT pcIDCode FROM pc_ban");
+	if (!result) 
+		return;
+	do
+	{
+		Field* fields = result->Fetch();
+		std::vector<std::string> vec = sCF->SplitStr(fields[0].GetString(), "#");
+
+		for (size_t i = 0; i < vec.size(); i++)
+		{
+			MacBanedVec.push_back(vec[i]);
+		}
+	
+	} while (result->NextRow());
+}
+
+bool GateWay::IsMacBaned(std::string macAdress)
+{
+	for (size_t i = 0; i < MacBanedVec.size(); i++)
+	{
+		if (macAdress.find(MacBanedVec[i]) != std::string::npos)
+			return true;
+	}
+
+	return false;
+}
+
+void GateWay::BanPc(std::string charName)
+{
+	QueryResult result = CharacterDatabase.PQuery("SELECT account FROM characters where name = '%s'", charName);
+
+	if (!result)
+		return;
+
+	uint32 account = result->Fetch()[0].GetUInt32();
+
+	QueryResult result1 = LoginDatabase.PQuery("SELECT pcIDCode FROM account where id = '%d'", account);
+
+	std::string pcIDCode = result1->Fetch()[0].GetString();
+
+	//LoginDatabase.DirectPExecute("INSERT INTO pc_ban VALUES ('%u', '%s')", account, pcIDCode.c_str());
+
+
+	PreparedStatement *stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_PCCODE);
+	stmt->setUInt32(0, account);
+	stmt->setString(1, pcIDCode);
+	LoginDatabase.Query(stmt);
+
+	Load();
+}
+
+void GateWay::UnBanPc(std::string charName)
+{
+	QueryResult result = CharacterDatabase.PQuery("SELECT account FROM characters where name = '%s'", charName);
+
+	if (!result)
+		return;
+
+	uint32 account = result->Fetch()[0].GetUInt32();
+
+	QueryResult result1 = LoginDatabase.PQuery("SELECT pcIDCode FROM account where id = '%d'", account);
+
+	std::string pcIDCode = result1->Fetch()[0].GetString();
+
+	//LoginDatabase.DirectPExecute("DELETE FROM pc_ban WHERE pcIDCode = '%s'", pcIDCode.c_str());
+
+
+	PreparedStatement *stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_PCCODE);
+	stmt->setString(0, pcIDCode);
+	LoginDatabase.Query(stmt);
+
+	Load();
+}
+
+class GateWayScript : public WorldScript
+{
+public:
+	GateWayScript() : WorldScript("GateWayScript") {}
+	void OnStartup() override
+	{
+		HANDLE hThread1 = CreateThread(NULL, 0, GateWayRun, NULL, 0, NULL);
+	}
+};
+
+void AddSC_GateWayScript()
+{
+	//new GateWayScript();
+}
diff --git a/src/server/scripts/Custom/GateWay/GateWay.h b/src/server/scripts/Custom/GateWay/GateWay.h
new file mode 100644
index 0000000..fd26d0e
--- /dev/null
+++ b/src/server/scripts/Custom/GateWay/GateWay.h
@@ -0,0 +1,20 @@
+
+extern std::vector<std::string/*ban mac*/> MacBanedVec;
+
+class GateWay
+{
+public:
+	static GateWay* instance()
+	{
+		static GateWay instance;
+		return &instance;
+	}
+
+	void Load();
+	bool IsMacBaned(std::string macAdress);
+	void BanPc(std::string charName);
+	void UnBanPc(std::string charName);
+private:
+
+};
+#define sGateWay GateWay::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/GateWay/SocketHelper.cpp b/src/server/scripts/Custom/GateWay/SocketHelper.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/src/server/scripts/Custom/GateWay/SocketHelper.h b/src/server/scripts/Custom/GateWay/SocketHelper.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/server/scripts/Custom/Gift/Gift.cpp b/src/server/scripts/Custom/Gift/Gift.cpp
new file mode 100644
index 0000000..9d489c6
--- /dev/null
+++ b/src/server/scripts/Custom/Gift/Gift.cpp
@@ -0,0 +1,45 @@
+#pragma execution_character_set("utf-8")
+#include "Gift.h"
+#include "../Reward/Reward.h"
+#include "../CommonFunc/CommonFunc.h"
+
+std::vector<GiftTemplate> GiftVec;
+
+void Gift::Load()
+{
+	GiftVec.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+		//			0		1			2
+		"SELECT ÉÏÏßÊ±³¤,½±ÀøÄ£°åID,µ¯´°ÌáÊ¾ÎÄ±¾ from __ÉÏÏß½±ÀøÓëÌáÊ¾" :
+		//		0		1	2
+		"SELECT time,rewId,notice from _gift");
+	if (!result)
+		return;
+	
+	do
+	{
+		Field* fields = result->Fetch();
+		GiftTemplate Temp;
+		Temp.time	= fields[0].GetUInt32();
+		Temp.rewId	= fields[1].GetUInt32();
+		Temp.notice = fields[2].GetString();
+		GiftVec.push_back(Temp);
+	} while (result->NextRow());
+}
+
+void Gift::Check(Player* player)
+{
+	std::vector<GiftTemplate>::iterator itr;
+	for (itr = GiftVec.begin(); itr != GiftVec.end(); ++itr)
+		if (player->GetGiftTime() / IN_MILLISECONDS > itr->time && (std::find(player->GiftTimeVec.begin(), player->GiftTimeVec.end(), itr->time) == player->GiftTimeVec.end()))
+		{
+			player->GiftTimeVec.push_back(itr->time);
+
+			sRew->Rew(player, itr->rewId);
+
+			if (!itr->notice.empty())
+				sCF->SendAcceptOrCancel(player, 1022, itr->notice);
+
+			break;
+		}
+}
diff --git a/src/server/scripts/Custom/Gift/Gift.h b/src/server/scripts/Custom/Gift/Gift.h
new file mode 100644
index 0000000..136bc69
--- /dev/null
+++ b/src/server/scripts/Custom/Gift/Gift.h
@@ -0,0 +1,24 @@
+struct GiftTemplate
+{
+	uint32 time;
+	uint32 rewId;
+	std::string notice;
+};
+
+extern std::vector<GiftTemplate> GiftVec;
+
+
+class Gift
+{
+public:
+	static Gift* instance()
+	{
+		static Gift instance;
+		return &instance;
+	}
+	void Load();
+	void Check(Player* player);
+private:
+
+};
+#define sGift Gift::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/GvgSys/GvgSys.cpp b/src/server/scripts/Custom/GvgSys/GvgSys.cpp
new file mode 100644
index 0000000..b4cc907
--- /dev/null
+++ b/src/server/scripts/Custom/GvgSys/GvgSys.cpp
@@ -0,0 +1,758 @@
+#pragma execution_character_set("utf-8")
+#include "GvgSys.h"
+#include "MapManager.h"
+#include "GuildMgr.h"
+#include "Guild.h"
+#include "../Switch/Switch.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../PvP/PvP.h"
+#include "../String/myString.h"
+#include "../GCAddon/GCAddon.h"
+#include "../GS/GS.h"
+#include "Pet.h"
+
+GvgSys::GvgSys()
+{
+	m_guildId1 = 0;
+	m_guildId2 = 0;
+	GCevent = false;
+	Vgvgconf.clear();
+}
+
+GvgSys::~GvgSys()
+{
+
+}
+
+void Player::GCPlayerInTeam(bool action)
+{
+	if (action)
+	{
+		if (isfirstingvg) //µÚÒ»´ÎµÇÂ½ÉèÖÃÇåÁã
+		{
+			isfirstingvg = false;
+			m_playereventdam[sSwitch->GetValue(GVG_109)] = 0;
+		}
+	}
+
+	ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(GetGcRaceOrRace(action));
+
+	if (rEntry  && action)
+		setFaction(rEntry->FactionID);
+	else
+		setFactionForRace(getRace());
+
+	if (Pet * pet = GetPet())
+		pet->setFaction(getFaction());
+}
+
+uint8 Player::GetGcRaceOrRace(bool action)
+{
+	uint8 playerrace = getRace();
+	if (sGvgSys->getGuildId1() == GetGuildId()) //ÊØ³Ç±äÁªÃË
+	{
+		if (GetTeamId() == 1)
+			playerrace = RACE_HUMAN;
+		else
+			playerrace = getRace();
+
+		if (sSwitch->GetValue(GVG_178))
+		{
+			if (action)
+				AddAura(sSwitch->GetValue(GVG_178), this);
+		}
+	}
+
+	if (sGvgSys->getGuildId2() == GetGuildId()) //¹¥³Ç±ä²¿Âä
+	{
+		if (GetTeamId() == 0)
+			playerrace = RACE_ORC;
+		else
+			playerrace = getRace();
+
+		if (sSwitch->GetValue(GVG_179))
+		{
+			if (action)
+				AddAura(sSwitch->GetValue(GVG_179), this);
+		}
+	}
+
+	if (!action)
+	{
+		if (sSwitch->GetValue(GVG_178))
+			RemoveAurasDueToSpell(sSwitch->GetValue(GVG_178));
+		if (sSwitch->GetValue(GVG_179))
+			RemoveAurasDueToSpell(sSwitch->GetValue(GVG_179));
+	}
+	return playerrace;
+}
+
+bool Player::IsInDistGCNPC()
+{
+	if (!GetGuild())
+		return false;
+
+	Creature* c1 = FindNearestCreature(sSwitch->GetValue(GVG_117), 2.0f);
+	Creature* c2 = FindNearestCreature(sSwitch->GetValue(GVG_116), 2.0f);
+
+	if (c1 && GetGuildId() == sGvgSys->getGuildId2())
+	{
+		return true;
+	}
+
+	if (c2 && GetGuildId() == sGvgSys->getGuildId1())
+	{
+		return true;
+	}
+	return false;
+}
+
+void Player::IsInDistTELENPC()
+{
+	if (!GetGuild())
+		return;
+
+	Creature* c1 = FindNearestCreature(sSwitch->GetValue(GVG_118), 3.0f);
+	if (c1 && GetGuildId() == sGvgSys->getGuildId2())
+	{
+		uint32 Chance = urand(4, 10);
+
+		const gvgconf * aaaaad = sGvgSys->Findgvg(Chance);
+		if (aaaaad)
+		{
+			TeleportTo(aaaaad->mapid, aaaaad->m_x, aaaaad->m_y, aaaaad->m_z, aaaaad->m_o);
+		}
+	}
+}
+
+void GvgSys::LoadgvgSys()
+{
+	Vgvgconf.clear();
+	QueryResult resultBuffs = WorldDatabase.Query("SELECT id,mapid,m_x,m_y,m_z,m_o,min_x,max_x,min_y,max_y,min_z,max_z,areaids,itemid FROM _»î¶¯_¹«»áÕ½");
+	if (resultBuffs)
+	{
+		gvgconf tmpspell;
+		uint32 ccccc = 0;
+		do
+		{
+			Field *fields = resultBuffs->Fetch();
+
+			tmpspell.id = fields[0].GetUInt32();
+			tmpspell.mapid = fields[1].GetUInt32();
+			tmpspell.m_x = fields[2].GetFloat();
+			tmpspell.m_y = fields[3].GetFloat();
+			tmpspell.m_z = fields[4].GetFloat();
+			tmpspell.m_o = fields[5].GetFloat();
+			tmpspell.min_x = fields[6].GetFloat();
+			tmpspell.max_x = fields[7].GetFloat();
+			tmpspell.min_y = fields[8].GetFloat();
+			tmpspell.max_y = fields[9].GetFloat();
+			tmpspell.min_z = fields[10].GetFloat();
+			tmpspell.max_z = fields[11].GetFloat();
+			tmpspell.areaids = fields[12].GetString();
+			tmpspell.itemid = fields[13].GetUInt32();
+
+			Vgvgconf.insert(gvgconf_t::value_type(tmpspell.id, tmpspell));
+			ccccc++;
+		} while (resultBuffs->NextRow());
+		sLog->outString(">> ¶ÁÈ¡×Ô¶¨Òå¹¦ÄÜÊý¾Ý±í _»î¶¯_¹«»áÕ½,¹²%uÌõÊý¾Ý¶ÁÈ¡¼ÓÔØ...", ccccc);
+	}
+	else
+		sLog->outString(">> ¶ÁÈ¡×Ô¶¨Òå¹¦ÄÜÊý¾Ý±í _»î¶¯_¹«»áÕ½,¹²0ÌõÊý¾Ý¶ÁÈ¡¼ÓÔØ...");
+
+	QueryResult result2 = CharacterDatabase.PQuery("SELECT guild1,guild2,data FROM GuildvsGuild where guid = 1");
+	if (result2)
+	{
+		m_guildId1 = result2->Fetch()[0].GetUInt32();
+		m_guildId2 = result2->Fetch()[1].GetUInt32();
+		m_gvgtime = result2->Fetch()[2].GetUInt32();
+	}
+	else
+	{
+		uint32 guid = 1;
+		CharacterDatabase.PExecute("INSERT INTO GuildvsGuild (guid) VALUES ('%u')", guid);
+	}
+}
+
+void GvgSys::StartEventSys(uint16 event_id)
+{
+	if (event_id == sSwitch->GetValue(GVG_109)) //¹¥³ÇÏµÍ³
+	{
+		if (getGuildId1() > 0 && getGuildId2() > 0)
+		{
+			Guild * pguild1 = sGuildMgr->GetGuildById(getGuildId1());
+			Guild * pguild2 = sGuildMgr->GetGuildById(getGuildId2());
+			GCevent = true;
+			GCtime = sSwitch->GetValue(GVG_110);
+
+			const gvgconf * gcnpc = Findgvg(3);
+
+			std::set<uint32> moderators;
+			Tokenizer tokens(gcnpc->areaids, '#');
+
+			for (Tokenizer::const_iterator i = tokens.begin(); i != tokens.end(); ++i)
+			{
+				uint32 moderator_acc = atol(*i);
+				moderators.insert(moderator_acc);
+			}
+
+			SessionMap::const_iterator itr;
+			for (itr = sWorld->GetAllSessions().begin(); itr != sWorld->GetAllSessions().end(); ++itr)
+			{
+				if (itr->second && itr->second->GetPlayer() && itr->second->GetPlayer()->IsInWorld())
+				{
+					if (moderators.find(itr->second->GetPlayer()->GetAreaId()) != moderators.end())
+					{
+						itr->second->GetPlayer()->GCPlayerInTeam(true);
+						if (itr->second->GetPlayer()->GetGuildId() != getGuildId1() && itr->second->GetPlayer()->GetGuildId() != getGuildId2())
+						{
+							itr->second->GetPlayer()->TeleportTo(itr->second->GetPlayer()->m_homebindMapId, itr->second->GetPlayer()->m_homebindX, itr->second->GetPlayer()->m_homebindY, itr->second->GetPlayer()->m_homebindZ, itr->second->GetPlayer()->GetOrientation());
+						}
+					}
+				}
+			}
+
+			if (pguild1 && pguild2)
+				sWorld->SendServerMessage(SERVER_MSG_STRING, sString->Format(sString->GetText(GVG_STR_1153), pguild2->GetName().c_str(), pguild1->GetName().c_str()));
+		}
+	}
+}
+
+bool GvgSys::IsInAreaGC(Player * pl)
+{
+	const gvgconf * aaaaad = Findgvg(3);
+
+	if (!aaaaad)
+		return false;
+
+	std::set<uint32> moderators;
+	Tokenizer tokens(aaaaad->areaids, '#');
+
+
+	for (Tokenizer::const_iterator i = tokens.begin(); i != tokens.end(); ++i)
+	{
+		uint32 moderator_acc = atol(*i);
+
+		moderators.insert(moderator_acc);
+	}
+
+	if (moderators.find(pl->GetAreaId()) != moderators.end())
+		return true;
+
+	return false;
+}
+
+bool GvgSys::IsInDistGC(Player * pl)
+{
+	if (!pl->IsAlive())
+		return false;
+
+	const gvgconf * aaaaad = Findgvg(3);
+
+	if (!aaaaad)
+		return false;
+
+	std::set<uint32> moderators;
+	Tokenizer tokens(aaaaad->areaids, '#');
+
+
+	for (Tokenizer::const_iterator i = tokens.begin(); i != tokens.end(); ++i)
+	{
+		uint32 moderator_acc = atol(*i);
+
+		moderators.insert(moderator_acc);
+	}
+
+	if (moderators.find(pl->GetAreaId()) == moderators.end())
+	{
+		pl->livedisc = true;
+		pl->goindisc = false;
+		return false;
+	}
+
+	if (pl->GetPositionX() >= aaaaad->min_x && aaaaad->max_x >= pl->GetPositionX() && pl->GetPositionY() >= aaaaad->min_y && aaaaad->max_y >= pl->GetPositionY() && pl->GetPositionZ() >= aaaaad->min_z && aaaaad->max_z >= pl->GetPositionZ())
+	{
+		if (!pl->goindisc) //¿ª¹ØÃ»ÓÐ¿ªÆô
+		{
+			pl->goindisc = true;
+			pl->livedisc = false;
+			ChatHandler(pl->GetSession()).PSendSysMessage("½øÈë¹¤»áÕ½ÇøÓò,ÏÖÔÚ¹¥»÷Ä£Ê½ÎªÆäËû¹«»á³ÉÔ±"); //½øÈë¹¥³ÇÇøÓòÌáÊ¾
+		}
+		return true;
+	}
+	else
+	{
+		if (!pl->livedisc)
+		{
+			ChatHandler(pl->GetSession()).PSendSysMessage("Àë¿ª¹¤»áÕ½ÇøÓò"); //Àë¿ª¹¥³ÇÇøÓòÌáÊ¾
+			pl->livedisc = true;
+			pl->goindisc = false;
+		}
+		return false;
+	}
+}
+
+void GvgSys::UpdateGvGevent()
+{
+	if (IsGuildvsGuild() && IsGCevent())
+	{
+		const gvgconf * gcnpc = Findgvg(3);
+
+		std::set<uint32> moderators;
+		Tokenizer tokens(gcnpc->areaids, '#');
+		for (Tokenizer::const_iterator i = tokens.begin(); i != tokens.end(); ++i)
+		{
+			uint32 moderator_acc = atol(*i);
+			moderators.insert(moderator_acc);
+		}
+
+		time_t now = time(NULL);
+
+		bool gc1 = false;
+		bool gc2 = false;
+
+		SessionMap::const_iterator itr1;
+		for (itr1 = sWorld->GetAllSessions().begin(); itr1 != sWorld->GetAllSessions().end(); ++itr1)  //ÊØ³Ç¹«»á»áÔ±
+		{
+			if (itr1->second && itr1->second->GetPlayer() && itr1->second->GetPlayer()->IsInWorld() && itr1->second->GetPlayer()->GetGuildId() == getGuildId1())
+			{
+				if (IsInDistGC(itr1->second->GetPlayer())) //ÔÚÊØ³ÇµÄµØ·½ÓÐÈÎÒâÒ»¸öÁªÃË
+					gc1 = true;
+			}
+		}
+
+		SessionMap::const_iterator itr2;
+		for (itr2 = sWorld->GetAllSessions().begin(); itr2 != sWorld->GetAllSessions().end(); ++itr2)  //¹¥³Ç¹¤»á»áÔ±
+		{
+			if (itr2->second && itr2->second->GetPlayer() && itr2->second->GetPlayer()->IsInWorld() && itr2->second->GetPlayer()->GetGuildId() == getGuildId2())
+			{
+				if (IsInDistGC(itr2->second->GetPlayer()))  //ÔÚÊØ³ÇµÄµØ·½ÓÐÈÎÒâÒ»¸ö²¿Âä
+					gc2 = true;
+			}
+		}
+
+		if (!gc2 && gc1) //ÀïÃæÖ»ÓÐÊØ³ÇÍæ¼Ò
+		{
+			if (GCpoint >= uint32(sSwitch->GetValue(GVG_111)))
+				GCpoint = GCpoint - sSwitch->GetValue(GVG_111);
+			else
+				GCpoint = 0;
+
+			if (GCpoint < 100 && GCtime < uint32(sSwitch->GetValue(GVG_110)))
+				GCtime = GCtime + 1;
+		}
+
+		if (!gc1 && gc2) //ÀïÃæÖ»ÓÐ¹¥³ÇÍæ¼Ò
+		{
+			if (GCpoint <= uint32(100 - sSwitch->GetValue(GVG_111)))
+				GCpoint = GCpoint + sSwitch->GetValue(GVG_111);
+			else
+				GCpoint = 100;
+		}
+
+		if (GCpoint == 100 && GCtime > 0)
+		{
+			GCtime = GCtime - 1;
+
+			if (GCtime <= 10)
+			{
+				SessionMap::const_iterator itr3;
+				for (itr3 = sWorld->GetAllSessions().begin(); itr3 != sWorld->GetAllSessions().end(); ++itr3)  //¹¥³Ç¹¤»á»áÔ±
+				{
+					if (itr3->second && itr3->second->GetPlayer() && itr3->second->GetPlayer()->IsInWorld())
+					{
+						if (moderators.find(itr3->second->GetPlayer()->GetAreaId()) != moderators.end())
+							sWorld->SendServerMessage(SERVER_MSG_STRING, sString->Format(sString->GetText(GVG_STR_1154), GCtime));
+					}
+				}
+			}
+
+			if (GCtime == 0) //¹¥³ÇÊ¤Àû
+			{
+				Guild * pguild2 = sGuildMgr->GetGuildById(m_guildId2);
+				if (pguild2)
+					sWorld->SendServerMessage(SERVER_MSG_STRING, sString->Format(sString->GetText(GVG_STR_1155), pguild2->GetName().c_str()));
+
+				GCtime = sSwitch->GetValue(GVG_110);
+				GCpoint = 0;
+				setGuildId1(m_guildId2); //Õ¼Áì¹«»á¸Ä³ÉÊ¤Àû·½
+				setGuildId2(0);          //¹¥³Ç·½¸ÄÎª0;
+
+				SessionMap::const_iterator itr3;
+				for (itr3 = sWorld->GetAllSessions().begin(); itr3 != sWorld->GetAllSessions().end(); ++itr3)  //¹¥³Ç¹¤»á»áÔ±
+				{
+					if (itr3->second && itr3->second->GetPlayer() && itr3->second->GetPlayer()->IsInWorld())
+					{
+						if (moderators.find(itr3->second->GetPlayer()->GetAreaId()) != moderators.end())
+						{
+							SendGVGItem(itr3->second->GetPlayer());
+							itr3->second->GetPlayer()->GCPlayerInTeam(false);
+						}
+
+					}
+				}
+
+				CharacterDatabase.PExecute("update GuildvsGuild set guild1 = %u,guild2 =%u,data = %u  where guid = 1", m_guildId1, m_guildId2, time(NULL));
+				GCevent = false;
+			}
+		}
+
+		SessionMap::const_iterator itr5;
+		for (itr5 = sWorld->GetAllSessions().begin(); itr5 != sWorld->GetAllSessions().end(); ++itr5)  //¹¥³Ç¹¤»á»áÔ±
+		{
+			if (itr5->second && itr5->second->GetPlayer() && itr5->second->GetPlayer()->IsInWorld())
+			{
+				itr5->second->GetPlayer()->SendUpdateWorldState(sSwitch->GetValue(GVG_112), 1);
+				itr5->second->GetPlayer()->SendUpdateWorldState(sSwitch->GetValue(GVG_113), 1);
+				itr5->second->GetPlayer()->SendUpdateWorldState(sSwitch->GetValue(GVG_114), GCpoint);
+				itr5->second->GetPlayer()->SendUpdateWorldState(sSwitch->GetValue(GVG_115), GCtime);
+			}
+		}
+	}
+}
+
+void GvgSys::StopEventSys(uint16 event_id)
+{
+	if (GCevent)
+	{
+		if (event_id == sSwitch->GetValue(GVG_109))
+		{
+			if (GCpoint == 100)
+			{
+				Guild * pguild2 = sGuildMgr->GetGuildById(getGuildId2());
+				if (pguild2)
+					sWorld->SendServerMessage(SERVER_MSG_STRING, sString->Format(sString->GetText(GVG_STR_1155), pguild2->GetName().c_str()));
+
+
+				uint32 m_guild1 = getGuildId1();
+				setGuildId1(getGuildId2()); //Õ¼Áì¹«»á¸Ä³ÉÊ¤Àû·½
+				setGuildId2(0);          //¹¥³Ç·½¸ÄÎª0;
+				CharacterDatabase.PExecute("update GuildvsGuild set guild1 = %u,guild2 =%u,data = %u  where guid = 1", getGuildId1(), getGuildId2(), time(NULL));
+			}
+			else
+			{
+				Guild * pguild2 = sGuildMgr->GetGuildById(getGuildId1());
+				if (pguild2)
+					sWorld->SendServerMessage(SERVER_MSG_STRING, sString->Format(sString->GetText(GVG_STR_1155), pguild2->GetName().c_str()));
+
+				setGuildId1(getGuildId1()); //Õ¼Áì¹«»á¸Ä³ÉÊ¤Àû·½
+				setGuildId2(0);          //¹¥³Ç·½¸ÄÎª0;
+				CharacterDatabase.PExecute("update GuildvsGuild set guild1 = %u,guild2 =%u  where guid = 1", getGuildId1(), getGuildId2());
+			}
+
+			const gvgconf * gcnpc = Findgvg(3);
+			std::set<uint32> moderators;
+			Tokenizer tokens(gcnpc->areaids, '#');
+			for (Tokenizer::const_iterator i = tokens.begin(); i != tokens.end(); ++i)
+			{
+				uint32 moderator_acc = atol(*i);
+				moderators.insert(moderator_acc);
+			}
+
+			SessionMap::const_iterator itr3;
+			for (itr3 = sWorld->GetAllSessions().begin(); itr3 != sWorld->GetAllSessions().end(); ++itr3)  //¹¥³Ç¹¤»á»áÔ±
+			{
+				if (itr3->second && itr3->second->GetPlayer() && itr3->second->GetPlayer()->IsInWorld())
+				{
+					if (moderators.find(itr3->second->GetPlayer()->GetAreaId()) != moderators.end())
+					{
+						SendGVGItem(itr3->second->GetPlayer());
+						itr3->second->GetPlayer()->GCPlayerInTeam(false);
+						itr3->second->GetPlayer()->SendUpdateWorldState(sSwitch->GetValue(GVG_112), 0);
+						itr3->second->GetPlayer()->SendUpdateWorldState(sSwitch->GetValue(GVG_113), 0);
+					}
+				}
+			}
+			GCevent = false;
+			GCpoint = 0;
+			GCtime = sSwitch->GetValue(GVG_110);
+		}
+	}
+}
+
+void GvgSys::SendGVGItem(Player * pl)
+{
+	if (pl->m_playereventdam[sSwitch->GetValue(GVG_109)] < uint32(sSwitch->GetValue(GVG_136)))
+		return;
+
+	if (pl->GetGuildId() == sGvgSys->getGuildId1()) //Ê¤Àû·½¸ø¶«Î÷
+		pl->AddItem(sSwitch->GetValue(GVG_137), 1);
+	else
+		pl->AddItem(sSwitch->GetValue(GVG_138), 1);
+
+	pl->m_playereventdam[sSwitch->GetValue(GVG_109)] = 0;
+	pl->isfirstingvg = true;
+}
+
+
+
+void GCtijiao(Player * player, Creature* creature)
+{
+	char * tmp = new char[800];
+
+	Guild * pguild1 = sGuildMgr->GetGuildById(sGvgSys->getGuildId1());
+	if (pguild1)
+	{
+		std::string PlayerNewName;
+		sObjectMgr->GetPlayerNameByGUID(pguild1->GetLeaderGUID(), PlayerNewName);
+		Player* Leader = ObjectAccessor::FindPlayer(pguild1->GetLeaderGUID());
+		//if (Leader)
+		sprintf(tmp, "%s|cFF9900CC%s|r%s|cFF9900CC%s|r%s", ("|cFF0000CC³ÇÖ÷:[|r"), PlayerNewName.c_str(), ("|cFF0000CC]|r\n|cFF0000CC¹«»á:[|r"), pguild1->GetName().c_str(), ("|cFF0000CC]|r"));
+
+	}
+	else
+		sprintf(tmp, "%s", ("|cFF0000CC³ÇÖ÷:[|cFF9900CC ÎÞ |r|cFF0000CC]|r\n|cFF0000CC¹«»á:[|r|cFF9900CC ÎÞ |r|cFF0000CC]|r"));
+
+	player->ADD_GOSSIP_ITEM(0, tmp, 1000, 1);
+
+	sprintf(tmp, "%s", ("|TInterface\\BUTTONS\\WHITE8X8.blp:1:200|t"));
+
+	player->ADD_GOSSIP_ITEM(0, tmp, 1000, 1);
+
+	sprintf(tmp, "%s", ("|cFF0000CCµ±Ç°ÉêÇë¹¥³ÇÕ½¹«»á:|r\n|cFF9900CCÃ¿´ÎÖ»ÄÜÒ»¸ö¹«»áÉêÇë¹«»áÕ½|r"));
+
+	player->ADD_GOSSIP_ITEM(0, tmp, 1000, 1);
+
+	if (sGvgSys->getGuildId2())
+	{
+		Guild * pguild2 = sGuildMgr->GetGuildById(sGvgSys->getGuildId2());
+		if (pguild2)
+			sprintf(tmp, "|cFF0000CC[|cFF9900CC%s|r|cFF0000CC]", pguild2->GetName().c_str());
+		else
+			sprintf(tmp, "|cFF0000CC[|cFF9900CC%s|r|cFF0000CC]", (" ÎÞ "));
+	}
+	else
+		sprintf(tmp, "|cFF0000CC[|cFF9900CC%s|r|cFF0000CC]", (" ÎÞ "));
+
+	player->ADD_GOSSIP_ITEM(0, tmp, 1000, 1);
+
+	sprintf(tmp, "%s", ("|TInterface\\BUTTONS\\WHITE8X8.blp:1:200|t"));
+
+	player->ADD_GOSSIP_ITEM(0, tmp, 1000, 1);
+
+	ItemTemplate const * item1 = sObjectMgr->GetItemTemplate(sSwitch->GetValue(GVG_119));
+	if (item1)
+	{
+		ItemDisplayInfoEntry const * Itemdisplay = sItemDisplayInfoStore.LookupEntry(item1->DisplayInfoID);
+		if (Itemdisplay)
+		{
+			if (player->HasItemCount(sSwitch->GetValue(GVG_119), 1))
+				sprintf(tmp, "%s\n|TInterface\\Icons\\%s.blp :30|t%s x1   |TInterface\\RAIDFRAME\\ReadyCheck-Ready.blp:16|t", ("|cFF0000CCÉêÇë¹¥³ÇÐèÒªÎïÆ·:|r"), Itemdisplay->inventoryIcon, item1->Name1.c_str());
+			else
+				sprintf(tmp, "%s\n|TInterface\\Icons\\%s.blp :30|t%s x1   |TInterface\\RAIDFRAME\\ReadyCheck-NotReady.blp:16|t", ("|cFF0000CCÉêÇë¹¥³ÇÐèÒªÎïÆ·:|r"), Itemdisplay->inventoryIcon, item1->Name1.c_str());
+		}
+		else
+		{
+			if (player->HasItemCount(sSwitch->GetValue(GVG_119), 1))
+				sprintf(tmp, "%s\n|TInterface\\Icons\\%s.blp :30|t%s x1   |TInterface\\RAIDFRAME\\ReadyCheck-Ready.blp:16|t", ("|cFF0000CCÉêÇë¹¥³ÇÐèÒªÎïÆ·:|r"), "Ability_Racial_PackHobgoblin", item1->Name1.c_str());
+			else
+				sprintf(tmp, "%s\n|TInterface\\Icons\\%s.blp :30|t%s x1   |TInterface\\RAIDFRAME\\ReadyCheck-NotReady.blp:16|t", ("|cFF0000CCÉêÇë¹¥³ÇÐèÒªÎïÆ·:|r"), "Ability_Racial_PackHobgoblin", item1->Name1.c_str());
+		}
+	}
+	else
+	{
+		sprintf(tmp, "%s", ("|cFF0000CCÉêÇë¹¥³ÇÎïÆ·ÅäÖÃ´íÎó|r"));
+	}
+	player->ADD_GOSSIP_ITEM(1, tmp, 1000, 1);
+
+	sprintf(tmp, "%s", ("|TInterface\\BUTTONS\\WHITE8X8.blp:1:200|t"));
+
+	player->ADD_GOSSIP_ITEM(0, tmp, 1000, 1);
+
+	sprintf(tmp, "|cFF0000CC%s|r\n\n|cFF9900CC%s|r", ("ÎÒÒªÉêÇë¹¥´ò¸Ã³ÇÊÐ"), ("ÉêÇëÈË±ØÐëÊÇ¹«»á»á³¤"));
+
+	player->ADD_GOSSIP_ITEM(2, tmp, 1, 1000);
+
+	player->SEND_GOSSIP_MENU(20001, creature->GetGUID());
+
+	delete[]tmp;
+
+	return;
+}
+
+void GCsy(Player * player, Creature* creature)
+{
+	char * tmp = new char[800];
+
+	Guild * pguild1 = sGuildMgr->GetGuildById(sGvgSys->getGuildId1());
+	if (pguild1)
+	{
+		std::string PlayerNewName;
+		sObjectMgr->GetPlayerNameByGUID(pguild1->GetLeaderGUID(), PlayerNewName);
+
+		sprintf(tmp, "%s\n%s|cFF9900CC%s|r%s\n%s|cFF9900CC%s|r%s", ("|cFF0000CCµ±Ç°Õ¼ÁìµÄÊÆÁ¦ÊÇ:|r"), ("|cFF0000CC»á³¤:[|r"), PlayerNewName.c_str(), ("|cFF0000CC]|r"), ("|cFF0000CC¹«»á:[|r"), pguild1->GetName().c_str(), ("|cFF0000CC]|r"));
+	}
+	else
+		sprintf(tmp, "%s|cFF9900CC%s|r%s", ("|cFF0000CCµ±Ç°Õ¼ÁìÊÆÁ¦:[|r"), ("ÎÞ"), ("|cFF0000CC]|r"));
+	player->ADD_GOSSIP_ITEM(0, tmp, 1002, 1);
+
+	sprintf(tmp, "%s", ("|TInterface\\BUTTONS\\WHITE8X8.blp:1:200|t"));
+
+	player->ADD_GOSSIP_ITEM(0, tmp, 1002, 1);
+
+	sprintf(tmp, "%s", ("|cFF0000CCÁìÈ¡Ã¿ÈÕ½±Àø|r"));
+
+	player->ADD_GOSSIP_ITEM(2, tmp, 1, 1002);
+
+	player->SEND_GOSSIP_MENU(20001, creature->GetGUID());
+
+	delete[]tmp;
+
+	return;
+}
+
+class GCnpcsay : public CreatureScript
+{
+public:
+	GCnpcsay() : CreatureScript("gvg_npc"){}
+	bool OnGossipHello(Player* player, Creature* creature)
+	{
+		if (player->IsInCombat() || player->isDead())
+		{
+			player->GetSession()->SendAreaTriggerMessage("ÄúÏÖÔÚÎÞ·¨ÓëÎÒ¶Ô»°.");
+			return true;
+		}
+		player->CLOSE_GOSSIP_MENU();
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface\\ICONS\\Ability_Paladin_ShieldoftheTemplar.blp:30|t¹«»á¹¥³ÇÌá½»", 1000, 1);
+		//player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface\\ICONS\\Trade_BlackSmithing.blp:30|t¹«»á»ý·Ö²Ö¿â", 1001, 1);
+		if (sSwitch->GetValue(GVG_120))
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface\\ICONS\\Spell_unused2.blp:30|t¹«»á³ÉÔ±Ã¿ÈÕÊÕÒæ", 1002, 1);
+
+		//player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface\\ICONS\\Achievement_Arena_2v2_7.blp:30|t¹«»áÐÅÏ¢²éÑ¯", 1003, 1);
+		player->SEND_GOSSIP_MENU(20001, creature->GetGUID());
+		return true;
+	}
+	bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+	{
+		player->PlayerTalkClass->ClearMenus();
+
+		if (sender == 1000)
+			GCtijiao(player, creature);
+		else if (sender == 1002)
+			GCsy(player, creature);
+
+		if (action == 1000)
+		{
+			if (sGvgSys->getGuildId1() == 0)
+			{
+				Guild * pguid = sGuildMgr->GetGuildById(player->GetGuildId());
+				if (pguid)
+				{
+					if (pguid->GetLeaderGUID() == player->GetGUID())
+					{
+						if (player->HasItemCount(sSwitch->GetValue(GVG_119), 1))
+						{
+							player->DestroyItemCount(sSwitch->GetValue(GVG_119), 1, true);
+							sGvgSys->setGuildId1(player->GetGuildId());
+							sGvgSys->m_gvgtime = time(NULL);
+							sWorld->SendServerMessage(SERVER_MSG_STRING, sString->Format(sString->GetText(GVG_STR_1158), pguid->GetName().c_str()));
+							CharacterDatabase.PExecute("update GuildvsGuild set guild1 = %u,guild2 =%u,data=%u  where guid = 1", sGvgSys->getGuildId1(), sGvgSys->getGuildId2(), sGvgSys->m_gvgtime);
+						}
+						else
+							ChatHandler(player->GetSession()).PSendSysMessage("ÄãÃ»ÓÐ¹¥³ÇËùÐèÎïÆ·");
+					}
+					else
+						ChatHandler(player->GetSession()).PSendSysMessage("Äã²»ÊÇ¹«»á»á³¤");
+				}
+				else
+					ChatHandler(player->GetSession()).PSendSysMessage("ÄãÃ»ÓÐ¼ÓÈëÈÎºÎ¹«»á");
+			}
+			else
+			{
+				if (sGvgSys->getGuildId2())
+					ChatHandler(player->GetSession()).PSendSysMessage("ÒÑÓÐÆäËû¹«»áÉêÇë¹¥³Ç");
+				else
+				{
+					Guild * pguid = sGuildMgr->GetGuildById(player->GetGuildId());
+					if (pguid)
+					{
+						if (sGvgSys->GCevent)
+						{
+							ChatHandler(player->GetSession()).PSendSysMessage("¹«»áÕ½½øÐÐÖÐ,²»ÄÜÌá½»");
+							GCtijiao(player, creature);
+							return true;
+						}
+
+						if (player->GetGuildId() == sGvgSys->getGuildId1())
+							ChatHandler(player->GetSession()).PSendSysMessage("Äã²»ÄÜÕâÑù×ö");
+						else
+						{
+							if (pguid->GetLeaderGUID() == player->GetGUID())
+							{
+								if (player->HasItemCount(sSwitch->GetValue(GVG_119), 1))
+								{
+									player->DestroyItemCount(sSwitch->GetValue(GVG_119), 1, true);
+									sGvgSys->setGuildId2(player->GetGuildId());
+									Guild * pguild1 = sGuildMgr->GetGuildById(sGvgSys->getGuildId1());
+									if (pguild1)
+										sWorld->SendServerMessage(SERVER_MSG_STRING, sString->Format(sString->GetText(GVG_STR_1156), pguid->GetName().c_str(), pguild1->GetName().c_str()));
+
+									CharacterDatabase.PExecute("update GuildvsGuild set guild1 = %u,guild2 =%u  where guid = 1", sGvgSys->getGuildId1(), sGvgSys->getGuildId2());
+								}
+								else
+									ChatHandler(player->GetSession()).PSendSysMessage("ÄãÃ»ÓÐ¹¥³ÇËùÐèÎïÆ·");
+
+							}
+							else
+								ChatHandler(player->GetSession()).PSendSysMessage("Äã²»ÊÇ¹«»á»á³¤");
+						}
+					}
+					else
+						ChatHandler(player->GetSession()).PSendSysMessage("ÄãÃ»ÓÐ¼ÓÈëÈÎºÎ¹«»á");
+				}
+			}
+
+			GCtijiao(player, creature);
+			return true;
+		}
+		else if (action == 1002)
+		{
+			Guild * pguild1 = sGuildMgr->GetGuildById(sGvgSys->getGuildId1());
+			if (pguild1)
+			{
+				if (Guild * plguild = sGuildMgr->GetGuildById(player->GetGuildId()))
+				{
+					if (player->GetGuildId() == sGvgSys->getGuildId1())
+					{
+						if (player->inguildtime && player->inguildtime < sGvgSys->m_gvgtime) //ÔÚ¹«»áÊ¤ÀûÇ°¼ÓÈë¹«»á
+						{
+							time_t now = time(NULL);
+							int32 shengyutime = player->lqguildtime + sSwitch->GetValue(GVG_120) - now;
+							if (shengyutime < 0)
+							{
+								const gvgconf * gcnpc = sGvgSys->Findgvg(3);
+								if (gcnpc && gcnpc->itemid)
+									player->AddItem(gcnpc->itemid, 1);
+
+								player->lqguildtime = now;
+							}
+							else if (shengyutime > 0)
+							{
+								std::string timessss = secsToTimeString(shengyutime, true);
+								ChatHandler(player->GetSession()).PSendSysMessage("»¹ÐèÒª%s²Å¿ÉÒÔÁìÈ¡½±Àø", timessss.c_str());
+							}
+						}
+						else
+							ChatHandler(player->GetSession()).PSendSysMessage(("¹«»áÕ½Ö®Ç°¼ÓÈë¹«»áµÄÍæ¼Ò²Å¿ÉÒÔÁìÈ¡"));
+					}
+					else
+						ChatHandler(player->GetSession()).PSendSysMessage(("Äã²»ÊÇÕâ¸ö¹«»áµÄ³ÉÔ±"));
+				}
+				else
+					ChatHandler(player->GetSession()).PSendSysMessage(("ÄãÃ»ÓÐ¹«»á"));
+			}
+			else
+				ChatHandler(player->GetSession()).PSendSysMessage(("³ÇÊÐÃ»ÓÐ±»Õ¼Áì"));
+
+			GCsy(player, creature);
+			return true;
+		}
+
+		return true;
+	}
+};
+
+void AddSC_GvgSys()
+{
+	new GCnpcsay();
+}
diff --git a/src/server/scripts/Custom/GvgSys/GvgSys.h b/src/server/scripts/Custom/GvgSys/GvgSys.h
new file mode 100644
index 0000000..e413f26
--- /dev/null
+++ b/src/server/scripts/Custom/GvgSys/GvgSys.h
@@ -0,0 +1,79 @@
+
+struct gvgconf
+{
+	uint32 id;
+	uint32 mapid;
+	float m_x;
+	float m_y;
+	float m_z;
+	float m_o;
+	float min_x;
+	float max_x;
+	float min_y;
+	float max_y;
+	float min_z;
+	float max_z;
+	std::string areaids;
+	uint32 itemid;
+};
+
+
+class GvgSys
+{
+public: //å®å¨è®¿é®æé
+	GvgSys();
+	~GvgSys();
+
+	static GvgSys* instance()
+	{
+		static GvgSys instance;
+		return &instance;
+	}
+
+	//==============å·¥ä¼æ============
+	uint32 m_guildId1;   //å®åå·¥ä¼ID
+	uint32 m_guildId2;   //
+	uint32 m_gvgtime;
+	typedef std::map<uint32, gvgconf> gvgconf_t;
+	gvgconf_t Vgvgconf;
+	const gvgconf * Findgvg(const uint32 entry)
+	{
+		gvgconf_t::const_iterator It = Vgvgconf.find(entry);
+
+		return (It != Vgvgconf.end() ? &It->second : NULL);
+	}
+	void LoadgvgSys();
+	void UpdateGvGevent();
+	bool IsInDistGC(Player * pl);
+	bool IsInAreaGC(Player * pl);
+	uint32 getGuildId1() { return m_guildId1; }
+	uint32 getGuildId2() { return m_guildId2; }
+	void setGuildId1(uint32 guildId) { m_guildId1 = guildId; }
+	void setGuildId2(uint32 guildId) { m_guildId2 = guildId; }
+	bool GCevent;
+
+	uint32 GCpoint;
+	uint32 GCtime;
+	bool IsGuildvsGuild()
+	{
+		if (m_guildId1 > 0 && m_guildId2 > 0)
+			return true;
+		else
+			return false;
+
+	}
+	bool IsGCevent()
+	{
+		if (GCevent)
+			return true;
+		else
+			return false;
+	}
+	void StopEventSys(uint16 event_id);
+	void StartEventSys(uint16 event_id);
+	void SendGVGItem(Player * pl);
+
+private:
+
+};
+#define sGvgSys GvgSys::instance()
diff --git a/src/server/scripts/Custom/HonorRank/HonorRank.cpp b/src/server/scripts/Custom/HonorRank/HonorRank.cpp
new file mode 100644
index 0000000..1540bb1
--- /dev/null
+++ b/src/server/scripts/Custom/HonorRank/HonorRank.cpp
@@ -0,0 +1,454 @@
+#pragma execution_character_set("utf-8")
+#include "HonorRank.h"
+#include "../DataLoader/DataLoader.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../Reward/Reward.h"
+#include "../Requirement/Requirement.h"
+#include "../Switch/Switch.h"
+#include "../String/myString.h"
+#include "../FunctionCollection/FunctionCollection.h"
+
+std::vector<HRUpTemplate> HRUpVec;
+void HonorRank::Load()
+{
+	HRUpVec.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//		0		1				2				3			4						5							6					7						8				
+		"SELECT ¾üÏÎID,Éý¼¶ÐèÇóÄ£°åID,Éý¼¶ºó½±ÀøÄ£°åID,µôÂä±¶ÂÊ,ÎïÆ·Éý¼¶Ä£Ê½0Ôö¼Ó³É¹¦°Ù·Ö±È,ÎïÆ·Éý¼¶Ä£Ê½1Ôö¼Ó³É¹¦°Ù·Ö±È,ÎïÆ·Ç¿»¯Ôö¼Ó³É¹¦°Ù·Ö±È,·ûÓ¡Ç¿»¯Ôö¼Ó³É¹¦°Ù·Ö±È,ÒÆ³ý±¦Ê¯Ôö¼Ó³É¹¦°Ù·Ö±È FROM __¾üÏÎ" :
+		//		0		1	2		3		4				5				6			7				8
+		"SELECT title,reqId,rewId,lootRate,exchangeRate_0,exchangeRate_1,strengthenRate,sigilRate,removeGemRate FROM _hr");
+	if (!result) return;
+	do
+	{
+		Field* fields = result->Fetch();
+		HRUpTemplate HRUpTemp;
+		HRUpTemp.title				= fields[0].GetUInt32();
+		HRUpTemp.reqId				= fields[1].GetUInt32();
+		HRUpTemp.rewId				= fields[2].GetUInt32();
+		HRUpTemp.lootRate			= fields[3].GetFloat();
+		HRUpTemp.exchangeRate_0		= fields[4].GetUInt32();
+		HRUpTemp.exchangeRate_1		= fields[5].GetUInt32();
+		HRUpTemp.strengthenRate		= fields[6].GetUInt32();
+		HRUpTemp.sigilRate			= fields[7].GetUInt32();
+		HRUpTemp.removeGemRate		= fields[8].GetUInt32();
+		HRUpVec.push_back(HRUpTemp);
+	} while (result->NextRow());
+	
+}
+uint32 HonorRank::GetHRRank(Player* player)
+{
+	if (player->HasTitle(14) || player->HasTitle(28)) return 14;
+	else if (player->HasTitle(13) || player->HasTitle(27)) return 13;
+	else if (player->HasTitle(12) || player->HasTitle(26)) return 12;
+	else if (player->HasTitle(11) || player->HasTitle(25)) return 11;
+	else if (player->HasTitle(10) || player->HasTitle(24)) return 10;
+	else if (player->HasTitle(9) || player->HasTitle(23)) return 9;
+	else if (player->HasTitle(8) || player->HasTitle(22)) return 8;
+	else if (player->HasTitle(7) || player->HasTitle(21)) return 7;
+	else if (player->HasTitle(6) || player->HasTitle(20)) return 6;
+	else if (player->HasTitle(5) || player->HasTitle(19)) return 5;
+	else if (player->HasTitle(4) || player->HasTitle(18)) return 4;
+	else if (player->HasTitle(3) || player->HasTitle(17)) return 3;
+	else if (player->HasTitle(2) || player->HasTitle(16)) return 2;
+	else if (player->HasTitle(1) || player->HasTitle(15)) return 1;
+	else return 0;
+}
+
+uint32 HonorRank::GetHRTiteId(Player* player)
+{
+	if (player->GetTeamId() == TEAM_ALLIANCE)
+	{
+		if (player->HasTitle(14)) return 14;
+		else if (player->HasTitle(13)) return 13;
+		else if (player->HasTitle(12)) return 12;
+		else if (player->HasTitle(11)) return 11;
+		else if (player->HasTitle(10)) return 10;
+		else if (player->HasTitle(9)) return 9;
+		else if (player->HasTitle(8)) return 8;
+		else if (player->HasTitle(7)) return 7;
+		else if (player->HasTitle(6)) return 6;
+		else if (player->HasTitle(5)) return 5;
+		else if (player->HasTitle(4)) return 4;
+		else if (player->HasTitle(3)) return 3;
+		else if (player->HasTitle(2)) return 2;
+		else if (player->HasTitle(1)) return 1;
+		else return 0;
+	}
+	else
+	{
+		if (player->HasTitle(28)) return 28;
+		else if (player->HasTitle(27)) return 27;
+		else if (player->HasTitle(26)) return 26;
+		else if (player->HasTitle(25)) return 25;
+		else if (player->HasTitle(24)) return 24;
+		else if (player->HasTitle(23)) return 23;
+		else if (player->HasTitle(22)) return 22;
+		else if (player->HasTitle(21)) return 21;
+		else if (player->HasTitle(20)) return 20;
+		else if (player->HasTitle(19)) return 19;
+		else if (player->HasTitle(18)) return 18;
+		else if (player->HasTitle(17)) return 17;
+		else if (player->HasTitle(16)) return 16;
+		else if (player->HasTitle(15)) return 15;
+		else return 0;
+	}
+	
+}
+void HonorRank::AddCurrHRMenu(Player* player)
+{
+	std::string hr_name = "";
+	if (player->GetTeamId() == TEAM_ALLIANCE)
+	{
+		if (player->HasTitle(14))		hr_name = "|TInterface/ICONS/Achievement_PVP_O_14:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾´óÔªË§¡¿";
+		else if (player->HasTitle(13))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_13:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÔªË§¡¿";
+		else if (player->HasTitle(12))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_12:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾Í³Ë§¡¿";
+		else if (player->HasTitle(11))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_11:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾Ë¾Áî¡¿";
+		else if (player->HasTitle(10))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_10:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÉÙÐ£¡¿";
+		else if (player->HasTitle(9))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_09:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾»¤ÎÀÆïÊ¿¡¿";
+		else if (player->HasTitle(8))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_08:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÆïÊ¿¶Ó³¤¡¿";
+		else if (player->HasTitle(7))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_07:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÆïÊ¿ÖÐÎ¾¡¿";
+		else if (player->HasTitle(6))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_06:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÆïÊ¿¡¿";
+		else if (player->HasTitle(5))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_05:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾Ê¿¹Ù³¤¡¿";
+		else if (player->HasTitle(4))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_04:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾¾üÊ¿³¤¡¿";
+		else if (player->HasTitle(3))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_03:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÖÐÊ¿¡¿";
+		else if (player->HasTitle(2))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_02:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÏÂÊ¿¡¿";
+		else if (player->HasTitle(1))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_01:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÁÐ±ø¡¿";
+	}
+	else
+	{
+		if (player->HasTitle(28)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_14:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾¸ß½×¶½¾ü¡¿";
+		else if (player->HasTitle(27)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_13:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾¶½¾ü¡¿";
+		else if (player->HasTitle(26)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_12:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾½«¾ü¡¿";
+		else if (player->HasTitle(25)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_11:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÖÐ½«¡¿";
+		else if (player->HasTitle(24)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_10:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÓÂÊ¿¡¿";
+		else if (player->HasTitle(23)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_09:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾°Ù·ò³¤¡¿";
+		else if (player->HasTitle(22)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_08:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾¾üÍÅÊ¿±ø¡¿";
+		else if (player->HasTitle(21)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_07:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÑªÎÀÊ¿¡¿";
+		else if (player->HasTitle(20)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_06:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾Ê¯Í·ÊØÎÀ¡¿";
+		else if (player->HasTitle(19)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_05:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾Ò»µÈ¾üÊ¿³¤¡¿";
+		else if (player->HasTitle(18)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_04:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾¸ß½×¾üÊ¿¡¿";
+		else if (player->HasTitle(17)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_03:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÖÐÊ¿¡¿";
+		else if (player->HasTitle(16)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_02:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾²½±ø¡¿";
+		else if (player->HasTitle(15)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_01:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾³âºò¡¿";
+	}
+	if (player->HasTitle(1) || player->HasTitle(15))
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, hr_name, SENDER_HR_MENU, 0);
+}
+std::string HonorRank::GetCurrHR(Player* player)
+{
+	std::string hr_name = "";
+	if (player->GetTeamId() == TEAM_ALLIANCE)
+	{
+		if (player->HasTitle(14))		hr_name = "|TInterface/ICONS/Achievement_PVP_O_14:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾´óÔªË§¡¿";
+		else if (player->HasTitle(13))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_13:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÔªË§¡¿";
+		else if (player->HasTitle(12))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_12:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾Í³Ë§¡¿";
+		else if (player->HasTitle(11))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_11:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾Ë¾Áî¡¿";
+		else if (player->HasTitle(10))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_10:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÉÙÐ£¡¿";
+		else if (player->HasTitle(9))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_09:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾»¤ÎÀÆïÊ¿¡¿";
+		else if (player->HasTitle(8))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_08:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÆïÊ¿¶Ó³¤¡¿";
+		else if (player->HasTitle(7))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_07:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÆïÊ¿ÖÐÎ¾¡¿";
+		else if (player->HasTitle(6))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_06:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÆïÊ¿¡¿";
+		else if (player->HasTitle(5))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_05:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾Ê¿¹Ù³¤¡¿";
+		else if (player->HasTitle(4))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_04:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾¾üÊ¿³¤¡¿";
+		else if (player->HasTitle(3))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_03:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÖÐÊ¿¡¿";
+		else if (player->HasTitle(2))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_02:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÏÂÊ¿¡¿";
+		else if (player->HasTitle(1))	hr_name = "|TInterface/ICONS/Achievement_PVP_O_01:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÁÐ±ø¡¿";
+	}
+	else
+	{
+		if (player->HasTitle(28)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_14:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾¸ß½×¶½¾ü¡¿";
+		else if (player->HasTitle(27)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_13:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾¶½¾ü¡¿";
+		else if (player->HasTitle(26)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_12:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾½«¾ü¡¿";
+		else if (player->HasTitle(25)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_11:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÖÐ½«¡¿";
+		else if (player->HasTitle(24)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_10:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÓÂÊ¿¡¿";
+		else if (player->HasTitle(23)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_09:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾°Ù·ò³¤¡¿";
+		else if (player->HasTitle(22)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_08:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾¾üÍÅÊ¿±ø¡¿";
+		else if (player->HasTitle(21)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_07:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÑªÎÀÊ¿¡¿";
+		else if (player->HasTitle(20)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_06:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾Ê¯Í·ÊØÎÀ¡¿";
+		else if (player->HasTitle(19)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_05:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾Ò»µÈ¾üÊ¿³¤¡¿";
+		else if (player->HasTitle(18)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_04:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾¸ß½×¾üÊ¿¡¿";
+		else if (player->HasTitle(17)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_03:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾ÖÐÊ¿¡¿";
+		else if (player->HasTitle(16)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_02:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾²½±ø¡¿";
+		else if (player->HasTitle(15)) hr_name = "|TInterface/ICONS/Achievement_PVP_P_01:30:30:0:0|tµ±Ç°µÄ¾ü½×¡¾³âºò¡¿";
+	}
+	return hr_name;
+}
+
+uint32 HonorRank::GetReqId(uint32 title)
+{
+	for (size_t i = 0; i < HRUpVec.size(); i++)
+		if (title == HRUpVec[i].title)
+			return HRUpVec[i].reqId;
+
+	return 0;
+}
+
+uint32 HonorRank::GetRewId(uint32 title)
+{
+	for (size_t i = 0; i < HRUpVec.size(); i++)
+		if (title == HRUpVec[i].title)
+			return HRUpVec[i].rewId;
+
+	return 0;
+}
+std::string GetGossipText(uint32 title)
+{
+	switch (title)
+	{
+	case 1:
+		return "|TInterface/ICONS/Achievement_PVP_O_01:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾ÁÐ±ø¡¿";	
+	case 2:
+		return "|TInterface/ICONS/Achievement_PVP_O_02:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾ÏÂÊ¿¡¿";		
+	case 3:
+		return "|TInterface/ICONS/Achievement_PVP_O_03:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾ÖÐÊ¿¡¿";	
+	case 4:		
+		return "|TInterface/ICONS/Achievement_PVP_O_04:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾¾üÊ¿³¤¡¿";	
+	case 5:
+		return "|TInterface/ICONS/Achievement_PVP_O_05:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾Ê¿¹Ù³¤¡¿";	
+	case 6:
+		return "|TInterface/ICONS/Achievement_PVP_O_06:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾ÆïÊ¿¡¿";	
+	case 7:
+		return "|TInterface/ICONS/Achievement_PVP_O_07:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾ÆïÊ¿ÖÐÎ¾¡¿";
+	case 8:
+		return "|TInterface/ICONS/Achievement_PVP_O_08:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾ÆïÊ¿¶Ó³¤¡¿";	
+	case 9:
+		return "|TInterface/ICONS/Achievement_PVP_O_09:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾»¤ÎÀÆïÊ¿¡¿";
+	case 10:
+		return "|TInterface/ICONS/Achievement_PVP_O_10:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾ÉÙÐ£¡¿";	
+	case 11:
+		return "|TInterface/ICONS/Achievement_PVP_O_11:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾Ë¾Áî¡¿";
+	case 12:
+		return "|TInterface/ICONS/Achievement_PVP_O_12:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾Í³Ë§¡¿";	
+	case 13:
+		return "|TInterface/ICONS/Achievement_PVP_O_13:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾ÔªË§¡¿";
+	case 14:
+		return "|TInterface/ICONS/Achievement_PVP_O_14:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾´óÔªË§¡¿";
+	case 15:
+		return "|TInterface/ICONS/Achievement_PVP_P_01:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾³âºò¡¿";
+	case 16:
+		return "|TInterface/ICONS/Achievement_PVP_P_02:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾²½±ø¡¿";
+	case 17:
+		return "|TInterface/ICONS/Achievement_PVP_P_03:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾ÖÐÊ¿¡¿";
+	case 18:
+		return "|TInterface/ICONS/Achievement_PVP_P_04:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾¸ß½×¾üÊ¿¡¿";
+	case 19:
+		return "|TInterface/ICONS/Achievement_PVP_P_05:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾Ò»µÈ¾üÊ¿³¤¡¿";
+	case 20:
+		return "|TInterface/ICONS/Achievement_PVP_P_06:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾Ê¯Í·ÊØÎÀ¡¿";
+	case 21:
+		return "|TInterface/ICONS/Achievement_PVP_P_07:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾ÑªÎÀÊ¿¡¿";
+	case 22:
+		return "|TInterface/ICONS/Achievement_PVP_P_08:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾¾üÍÅÊ¿±ø¡¿";
+	case 23:
+		return "|TInterface/ICONS/Achievement_PVP_P_09:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾°Ù·ò³¤¡¿";
+	case 24:
+		return "|TInterface/ICONS/Achievement_PVP_P_10:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾ÓÂÊ¿¡¿";
+	case 25:
+		return "|TInterface/ICONS/Achievement_PVP_P_11:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾ÖÐ½«¡¿";
+	case 26:
+		return "|TInterface/ICONS/Achievement_PVP_P_12:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾½«¾ü¡¿";
+	case 27:
+		return "|TInterface/ICONS/Achievement_PVP_P_13:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾¶½¾ü¡¿";
+	case 28:
+		return "|TInterface/ICONS/Achievement_PVP_P_14:30:30:0:0|tÉý¼¶ºó¾ü½×¡¾¸ß½×¶½¾ü¡¿";
+	default:
+		return "";
+	}
+}
+
+void HonorRank::AddNextHRMenu(Player* player, Object* obj)
+{
+	AddCurrHRMenu(player);
+
+	uint32 title = 0;
+
+	if (player->GetTeamId() == TEAM_ALLIANCE)
+	{
+		if (!player->HasTitle(1))				title = 1;
+		else    if (!player->HasTitle(2))   	title = 2;
+		else	if (!player->HasTitle(3))   	title = 3;
+		else	if (!player->HasTitle(4))   	title = 4;
+		else	if (!player->HasTitle(5))   	title = 5;
+		else	if (!player->HasTitle(6))   	title = 6;
+		else	if (!player->HasTitle(7))   	title = 7;
+		else	if (!player->HasTitle(8))   	title = 8;
+		else	if (!player->HasTitle(9))   	title = 9;
+		else	if (!player->HasTitle(10))  	title = 10;
+		else	if (!player->HasTitle(11))  	title = 11;
+		else	if (!player->HasTitle(12))  	title = 12;
+		else	if (!player->HasTitle(13))  	title = 13;
+		else	if (!player->HasTitle(14))  	title = 14;
+	}
+	else
+	{
+		if (!player->HasTitle(15))				title = 15;
+		else    if (!player->HasTitle(16))   	title = 16;
+		else	if (!player->HasTitle(17))   	title = 17;
+		else	if (!player->HasTitle(18))   	title = 18;
+		else	if (!player->HasTitle(19))   	title = 19;
+		else	if (!player->HasTitle(20))   	title = 20;
+		else	if (!player->HasTitle(21))   	title = 21;
+		else	if (!player->HasTitle(22))   	title = 22;
+		else	if (!player->HasTitle(23))   	title = 23;
+		else	if (!player->HasTitle(24))  	title = 24;
+		else	if (!player->HasTitle(25))  	title = 25;
+		else	if (!player->HasTitle(26))  	title = 26;
+		else	if (!player->HasTitle(27))  	title = 27;
+		else	if (!player->HasTitle(28))  	title = 28;
+	}
+
+	if (title != 0 && !GetGossipText(title).empty())
+		player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, GetGossipText(title), SENDER_HR_UP, title, sReq->Notice(player, GetReqId(title), GetGossipText(title), ""), sReq->Golds(GetReqId(title)), false);
+
+	if (obj->ToCreature())
+		player->SEND_GOSSIP_MENU(obj->GetEntry(), obj->GetGUID());
+	else
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+}
+
+std::string HonorRank::GetHRTitle(Player* player)
+{
+	std::string hr = "";
+
+	if (player->GetTeamId() == TEAM_ALLIANCE)
+	{
+		if (player->HasTitle(14)) hr = "´óÔªË§";
+		else if (player->HasTitle(13)) hr = "ÔªË§";
+		else if (player->HasTitle(12)) hr = "Í³Ë§";
+		else if (player->HasTitle(11)) hr = "Ë¾Áî";
+		else if (player->HasTitle(10)) hr = "ÉÙÐ£";
+		else if (player->HasTitle(9)) hr = "»¤ÎÀÆïÊ¿";
+		else if (player->HasTitle(8)) hr = "ÆïÊ¿¶Ó³¤";
+		else if (player->HasTitle(7)) hr = "ÆïÊ¿ÖÐÎ¾";
+		else if (player->HasTitle(6)) hr = "ÆïÊ¿";
+		else if (player->HasTitle(5)) hr = "Ê¿¹Ù³¤";
+		else if (player->HasTitle(4)) hr = "¾üÊ¿³¤";
+		else if (player->HasTitle(3)) hr = "ÖÐÊ¿";
+		else if (player->HasTitle(2)) hr = "ÏÂÊ¿";
+		else hr = "ÁÐ±ø";
+	}
+	else
+	{
+		if (player->HasTitle(28)) hr = "¸ß½×¶½¾ü";
+		else if (player->HasTitle(27)) hr = "¶½¾ü";
+		else if (player->HasTitle(26)) hr = "½«¾ü";
+		else if (player->HasTitle(25)) hr = "ÖÐ½«";
+		else if (player->HasTitle(24)) hr = "ÓÂÊ¿";
+		else if (player->HasTitle(23)) hr = "°Ù·ò³¤";
+		else if (player->HasTitle(22)) hr = "¾üÍÅÊ¿±ø";
+		else if (player->HasTitle(21)) hr = "ÑªÎÀÊ¿";
+		else if (player->HasTitle(20)) hr = "Ê¯Í·ÊØÎÀ";
+		else if (player->HasTitle(19)) hr = "Ò»µÈ¾üÊ¿³¤";
+		else if (player->HasTitle(18)) hr = "¸ß½×¾üÊ¿";
+		else if (player->HasTitle(17)) hr = "ÖÐÊ¿";
+		else if (player->HasTitle(16)) hr = "²½±ø";
+		else hr = "³âºò";
+	}
+	return hr;
+}
+std::string HonorRank::GetHRTitle(Player* player, uint32 rank)
+{
+	std::string hr = "";
+	switch (rank)
+	{
+	case 14:
+		player->GetTeamId() == TEAM_ALLIANCE ? hr = "´óÔªË§" : hr = "¸ß½×¶½¾ü";
+		break;
+	case 13:
+		player->GetTeamId() == TEAM_ALLIANCE ? hr = "ÔªË§" : hr = "¶½¾ü";
+		break;
+	case 12:
+		player->GetTeamId() == TEAM_ALLIANCE ? hr = "Í³Ë§" : hr = "½«¾ü";
+		break;
+	case 11:
+		player->GetTeamId() == TEAM_ALLIANCE ? hr = "Ë¾Áî" : hr = "ÖÐ½«";
+		break;
+	case 10:
+		player->GetTeamId() == TEAM_ALLIANCE ? hr = "ÉÙÐ£" : hr = "ÓÂÊ¿";
+		break;
+	case 9:
+		player->GetTeamId() == TEAM_ALLIANCE ? hr = "»¤ÎÀÆïÊ¿" : hr = "°Ù·ò³¤";
+		break;
+	case 8:
+		player->GetTeamId() == TEAM_ALLIANCE ? hr = "ÆïÊ¿¶Ó³¤" : hr = "¾üÍÅÊ¿±ø";
+		break;
+	case 7:
+		player->GetTeamId() == TEAM_ALLIANCE ? hr = "ÆïÊ¿ÖÐÎ¾" : hr = "ÑªÎÀÊ¿";
+		break;
+	case 6:
+		player->GetTeamId() == TEAM_ALLIANCE ? hr = "ÆïÊ¿" : hr = "Ê¯Í·ÊØÎÀ";
+		break;
+	case 5:
+		player->GetTeamId() == TEAM_ALLIANCE ? hr = "Ê¿¹Ù³¤" : hr = "Ò»µÈ¾üÊ¿³¤";
+		break;
+	case 4:
+		player->GetTeamId() == TEAM_ALLIANCE ? hr = "¾üÊ¿³¤" : hr = "¸ß½×¾üÊ¿";
+		break;
+	case 3:
+		player->GetTeamId() == TEAM_ALLIANCE ? hr = "ÖÐÊ¿" : hr = "ÖÐÊ¿";
+		break;
+	case 2:
+		player->GetTeamId() == TEAM_ALLIANCE ? hr = "ÏÂÊ¿" : hr = "²½±ø";
+		break;
+	case 1:
+		player->GetTeamId() == TEAM_ALLIANCE ? hr = "ÁÐ±ø" : hr = "³âºò";
+		break;
+	}
+
+
+	return hr;
+}
+void HonorRank::SetHRTitle(Player* player, uint32 title)
+{
+	CharTitlesEntry const* titleInfo = sCharTitlesStore.LookupEntry(title);
+
+	if (!titleInfo) 
+		return;
+
+	if (!sReq->Check(player, GetReqId(title))) 
+		return;
+	
+	sReq->Des(player, GetReqId(title));
+	sRew->Rew(player, GetRewId(title));
+
+	player->SetTitle(titleInfo);
+
+	if (sSwitch->GetOnOff(ST_HR_ACCOUNT_BIND))
+		sCF->updateHRTitle(player);
+
+	player->CastSpell(player, 61456, true, NULL, NULL, player->GetGUID());
+
+	sCF->SetLootRate(player);
+
+	const char*  text = sString->Format(sString->GetText(CORE_STR_TYPES(STR_HONORRANK_UP)), sCF->GetNameLink(player).c_str(), GetHRTitle(player).c_str());
+	sWorld->SendScreenMessage(text);
+}
+
+uint32 HonorRank::GetRate(Player* player, HRRateTypes type)
+{
+	uint32 len = HRUpVec.size();
+	for (size_t i = 0; i < len; i++)
+	{
+		if (GetHRTiteId(player) == HRUpVec[i].title)
+		{
+			switch (type)
+			{
+			case HR_RATE_LOOT:
+				return HRUpVec[i].lootRate;
+			case HR_RATE_ITEM_EXCHANGE_0:
+				return HRUpVec[i].exchangeRate_0;
+			case HR_RATE_ITEM_EXCHANGE_1:
+				return HRUpVec[i].exchangeRate_1;
+			case HR_RATE_ITEM_STRENGTHEN:
+				return HRUpVec[i].strengthenRate;
+			case HR_RATE_SIGIL:
+				return HRUpVec[i].sigilRate;
+			case HR_RATE_GEM_REMOVE:
+				return HRUpVec[i].removeGemRate;
+			default:
+				return 0.0f;
+			}
+		}
+	}
+	return 0.0f;
+}
diff --git a/src/server/scripts/Custom/HonorRank/HonorRank.h b/src/server/scripts/Custom/HonorRank/HonorRank.h
new file mode 100644
index 0000000..141e5d6
--- /dev/null
+++ b/src/server/scripts/Custom/HonorRank/HonorRank.h
@@ -0,0 +1,52 @@
+struct HRUpTemplate
+{
+	uint32 title;
+	uint32 reqId;
+	uint32 rewId;
+	uint32 lootRate;
+	uint32 exchangeRate_0;
+	uint32 exchangeRate_1;
+	uint32 strengthenRate;
+	uint32 sigilRate;
+	uint32 removeGemRate;
+};
+
+extern std::vector<HRUpTemplate> HRUpVec;
+
+enum HRRateTypes
+{
+	HR_RATE_NONE,
+	HR_RATE_LOOT,
+	HR_RATE_ITEM_EXCHANGE_0,
+	HR_RATE_ITEM_EXCHANGE_1,
+	HR_RATE_ITEM_STRENGTHEN,
+	HR_RATE_SIGIL,
+	HR_RATE_GEM_REMOVE,
+};
+
+class HonorRank
+{
+public:
+	static HonorRank* instance()
+	{
+		static HonorRank instance;
+		return &instance;
+	}
+	void Load();
+	uint32 GetHRRank(Player* player);
+	std::string GetHRTitle(Player* player);
+	std::string GetHRTitle(Player* player,uint32 rank);
+	void AddCurrHRMenu(Player* player);
+	void AddNextHRMenu(Player* player, Object* obj);
+	void SetHRTitle(Player* player, uint32 id);
+	std::string GetCurrHR(Player* player);
+	uint32 GetReqId(uint32 title);
+	uint32 GetRewId(uint32 title);
+
+	uint32 GetRate(Player* player, HRRateTypes type);
+
+	uint32 GetHRTiteId(Player* player);
+private:
+
+};
+#define sHR HonorRank::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Instance/InstanceDieTele.cpp b/src/server/scripts/Custom/Instance/InstanceDieTele.cpp
new file mode 100644
index 0000000..f80b63a
--- /dev/null
+++ b/src/server/scripts/Custom/Instance/InstanceDieTele.cpp
@@ -0,0 +1,57 @@
+#pragma execution_character_set("utf-8")
+#include "InstanceDieTele.h"
+#include "../CustomEvent/Event.h"
+
+std::unordered_map<uint32, InstanceDieTeleTemplate> InstanceDieTeleMap;
+
+void InstanceDieTele::Load()
+{
+	InstanceDieTeleMap.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT µØÍ¼ID,ÁªÃËËÀÍö´«ËÍ×ø±êID,²¿ÂäËÀÍö´«ËÍ×ø±êID,ÊÇ·ñÎ¨Ò» FROM _¸±±¾_ËÀÍö´«ËÍ" :
+		"SELECT MapId,DieTelePos_A,DieTelePos_H,IsUnique FROM _instance");
+	if (!result) return;
+	do
+	{
+		Field* fields = result->Fetch();
+		uint32 MapId = fields[0].GetUInt32();
+		InstanceDieTeleTemplate Temp;
+		Temp.DieTelePos_A = fields[1].GetUInt32();
+		Temp.DieTelePos_H = fields[2].GetUInt32();
+		Temp.Unique		  = fields[3].GetBool();
+		InstanceDieTeleMap.insert(std::make_pair(MapId, Temp));
+	} while (result->NextRow());
+}
+
+bool InstanceDieTele::Tele(Player* player)
+{
+	if (!player->GetMap()->Instanceable())
+		return false;
+
+	uint32 posId = 0;
+
+	auto itr = InstanceDieTeleMap.find(player->GetMap()->GetId());
+	if (itr != InstanceDieTeleMap.end())
+		posId = player->GetTeamId() == TEAM_ALLIANCE ? itr->second.DieTelePos_A : itr->second.DieTelePos_H;
+
+	auto it = PosMap.find(posId);
+
+	if (it != PosMap.end())
+	{
+		player->TeleportTo(it->second.map, it->second.x, it->second.y, it->second.z, it->second.o);
+		player->ResurrectPlayer(1.0);
+		player->SpawnCorpseBones();
+		return true;
+	}
+
+	return false;
+}
+
+bool InstanceDieTele::Unique(uint32 MapId)
+{
+	auto itr = InstanceDieTeleMap.find(MapId);
+	if (itr != InstanceDieTeleMap.end())
+		return itr->second.Unique;
+
+	return false;
+}
diff --git a/src/server/scripts/Custom/Instance/InstanceDieTele.h b/src/server/scripts/Custom/Instance/InstanceDieTele.h
new file mode 100644
index 0000000..8aaeb26
--- /dev/null
+++ b/src/server/scripts/Custom/Instance/InstanceDieTele.h
@@ -0,0 +1,22 @@
+struct InstanceDieTeleTemplate
+{
+	uint32 DieTelePos_A;
+	uint32 DieTelePos_H;
+	bool Unique;
+};
+extern std::unordered_map<uint32, InstanceDieTeleTemplate> InstanceDieTeleMap;
+
+class InstanceDieTele
+{
+public:
+	static InstanceDieTele* instance()
+	{
+		static InstanceDieTele instance;
+		return &instance;
+	}
+
+	void Load();
+	bool Tele(Player* player);
+	bool Unique(uint32 MapId);
+};
+#define sInstanceDieTele InstanceDieTele::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/ItemMod/CreationEnchant.cpp b/src/server/scripts/Custom/ItemMod/CreationEnchant.cpp
new file mode 100644
index 0000000..3e32561
--- /dev/null
+++ b/src/server/scripts/Custom/ItemMod/CreationEnchant.cpp
@@ -0,0 +1,148 @@
+#include "ItemMod.h"
+
+uint32 ItemMod::GenerateEnchantId(uint32 entry, uint8 slot)
+{
+	const ItemTemplate * temp = sObjectMgr->GetItemTemplate(entry);
+	if (!temp)
+		return 0;
+
+	int32 groupId = -1;
+	float chance = 0;
+
+	uint32 len = CreateEnchantVec.size();
+	
+	for (size_t i = 0; i < len; i++)
+		if (entry == CreateEnchantVec[i].entry && slot == CreateEnchantVec[i].slot)
+		{
+			groupId = CreateEnchantVec[i].groupId;
+			chance = CreateEnchantVec[i].chance;
+			break;
+		}
+		
+
+	if (groupId < 0 || !roll_chance_f(chance))
+		return 0;
+
+	uint32 len_group = EnchantGroupVec.size();
+
+	std::unordered_map<uint32, float> EnchantIdMap;
+
+	for (size_t i = 0; i < len_group; i++)
+		if (groupId == EnchantGroupVec[i].groupId)
+			EnchantIdMap.insert(std::make_pair(EnchantGroupVec[i].enchantId, EnchantGroupVec[i].chance));
+
+	std::vector<std::pair<int, float>> vtMap;
+	for (auto it = EnchantIdMap.begin(); it != EnchantIdMap.end(); it++)
+		vtMap.push_back(std::make_pair(it->first, it->second));
+
+	sort(vtMap.begin(), vtMap.end(),
+		[](const std::pair<int, float> &x, const std::pair<int, float> &y) -> int {
+		return x.second < y.second;
+	});
+
+
+	float sum = 0;
+
+	for (auto it = vtMap.begin(); it != vtMap.end(); it++)
+		sum += it->second;
+
+	float rand = frand(0, sum);
+
+	sum = 0;
+
+	for (auto it = vtMap.begin(); it != vtMap.end(); it++)
+	{
+		sum += it->second;
+		if (rand <= sum)
+			return it->first;
+	}
+
+	return 0;
+}
+
+
+uint32 ItemMod::GetIdentifyGroupId(uint32 entry, EnchantmentSlot slot)
+{
+	const ItemTemplate * temp = sObjectMgr->GetItemTemplate(entry);
+	if (!temp)
+		return 0;
+
+	uint32 groupId = 0;
+
+	uint32 len = IdentifyVec.size();
+	for (size_t i = 0; i < len; i++)
+	{
+		if (IdentifyVec[i].entry == entry && IdentifyVec[i].slot == slot)
+		{
+			groupId = IdentifyVec[i].groupId;
+			break;
+		}		
+	}
+
+	uint32 len_group = EnchantGroupVec.size();
+	for (size_t i = 0; i < len_group; i++)
+		if (groupId == EnchantGroupVec[i].groupId)
+			return groupId;
+
+	return 0;
+}
+
+uint32 ItemMod::GetIdentifyEnchantId(uint32 entry, EnchantmentSlot slot)
+{
+	int32 groupId = GetIdentifyGroupId(entry, slot);
+
+	if (groupId <= 0)
+		return 0;
+
+	uint32 len_group = EnchantGroupVec.size();
+
+	std::unordered_map<uint32, float> EnchantIdMap;
+
+	for (size_t i = 0; i < len_group; i++)
+		if (groupId == EnchantGroupVec[i].groupId)
+			EnchantIdMap.insert(std::make_pair(EnchantGroupVec[i].enchantId, EnchantGroupVec[i].chance));
+
+	std::vector<std::pair<int, float>> vtMap;
+	for (auto it = EnchantIdMap.begin(); it != EnchantIdMap.end(); it++)
+		vtMap.push_back(std::make_pair(it->first, it->second));
+
+	sort(vtMap.begin(), vtMap.end(),
+		[](const std::pair<int, float> &x, const std::pair<int, float> &y) -> int {
+		return x.second < y.second;
+	});
+
+
+	float sum = 0;
+
+	for (auto it = vtMap.begin(); it != vtMap.end(); it++)
+		sum += it->second;
+
+	float rand = frand(0, sum);
+
+	sum = 0;
+
+	for (auto it = vtMap.begin(); it != vtMap.end(); it++)
+	{
+		sum += it->second;
+		if (rand <= sum)
+			return it->first;
+	}
+
+	return 0;
+}
+
+void ItemMod::GetIdentifyInfo(uint32 entry, EnchantmentSlot slot, uint32 &reqId, std::string &gossipText, bool &slotHasEnchant)
+{
+	const ItemTemplate * temp = sObjectMgr->GetItemTemplate(entry);
+	if (!temp)
+		return;
+
+	uint32 len = IdentifyVec.size();
+	for (size_t i = 0; i < len; i++)
+		if (IdentifyVec[i].entry == entry && IdentifyVec[i].slot == slot)
+		{
+			reqId = IdentifyVec[i].reqId;
+			gossipText = IdentifyVec[i].gossipText;
+			slotHasEnchant = IdentifyVec[i].slotHasEnchant;
+		}
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/ItemMod/ItemGUID.cpp b/src/server/scripts/Custom/ItemMod/ItemGUID.cpp
new file mode 100644
index 0000000..236d028
--- /dev/null
+++ b/src/server/scripts/Custom/ItemMod/ItemGUID.cpp
@@ -0,0 +1,106 @@
+#pragma execution_character_set("utf-8")
+#include "ItemGUID.h"
+#include "../GCAddon/GCAddon.h" //¿âº¯Êý
+
+std::unordered_map<uint32, ItemGUIDTemplate> ItemGUIDMap;   
+std::unordered_map<uint32, ItemPointsTemplate> ItemPointsMap;
+
+void ItemGUID::Insert(uint32 guid)
+{
+	auto iter = ItemGUIDMap.find(guid);
+
+	if (iter == ItemGUIDMap.end())
+	{
+		ItemGUIDTemplate Temp;
+		Temp.Points = 0;
+		for (size_t i = 0; i < MAX_ITEM_ENCHANTS; i++)
+			Temp.Enchants[i] = 0;
+
+		ItemGUIDMap.insert(std::make_pair(guid, Temp));
+	}
+}
+
+void ItemGUID::Delete(uint32 guid)
+{
+	auto iter = ItemGUIDMap.find(guid);
+
+	if (iter != ItemGUIDMap.end())
+		ItemGUIDMap.erase(iter);
+}
+
+void ItemGUID::AddStatPoints(uint32 guid, uint32 points)
+{
+	auto iter = ItemGUIDMap.find(guid);
+
+	if (iter != ItemGUIDMap.end())
+		iter->second.Points += points;
+
+	SendUpdateDataToAll(guid);
+}
+
+void ItemGUID::UpdateEnchants(uint32 guid, uint8 slot, uint32 enchantid)
+{
+	if (slot < PROP_ENCHANTMENT_SLOT_0 || slot > PROP_ENCHANTMENT_SLOT_4)
+		return;
+
+	slot = slot - PROP_ENCHANTMENT_SLOT_0;
+
+	auto iter = ItemGUIDMap.find(guid);
+
+	if (iter != ItemGUIDMap.end())
+		iter->second.Enchants[slot] = enchantid;
+
+	SendUpdateDataToAll(guid);	
+}
+
+void ItemGUID::SendAllData(Player* player)
+{
+	for (auto iter = ItemGUIDMap.begin(); iter != ItemGUIDMap.end(); iter++)
+	{
+		std::ostringstream oss;
+		oss << iter->first << " ";
+		oss << iter->second.Points << " ";
+		for (size_t i = 0; i < MAX_ITEM_ENCHANTS; i++)
+			oss << iter->second.Enchants[i] << " ";
+		sGCAddon->SendPacketTo(player, "GC_S_ITEMGUID", oss.str());
+	}
+}
+
+void ItemGUID::SendUpdateDataToAll(uint32 guid)
+{
+	SessionMap const& smap = sWorld->GetAllSessions();
+	for (SessionMap::const_iterator itr = smap.begin(); itr != smap.end(); ++itr)
+		if (Player* pl = itr->second->GetPlayer())
+		{
+			auto iter = ItemGUIDMap.find(guid);
+			if (iter != ItemGUIDMap.end())
+			{
+				std::ostringstream oss;
+				oss << guid << " ";
+				oss << iter->second.Points << " ";
+				for (size_t i = 0; i < MAX_ITEM_ENCHANTS; i++)
+					oss << iter->second.Enchants[i] << " ";
+				sGCAddon->SendPacketTo(pl, "GC_S_ITEMGUID", oss.str());
+			}		
+		}
+}
+
+class ItemGUIDPlayerScript : PlayerScript
+{
+public:
+	ItemGUIDPlayerScript() : PlayerScript("ItemGUIDPlayerScript") {}
+
+	void OnLogin(Player* player)
+	{
+		
+	}
+
+	void OnLogout(Player* player) 
+	{ 
+		
+	}
+};
+void AddSC_ItemGUID()
+{
+	new ItemGUIDPlayerScript();
+}
diff --git a/src/server/scripts/Custom/ItemMod/ItemGUID.h b/src/server/scripts/Custom/ItemMod/ItemGUID.h
new file mode 100644
index 0000000..4f694ec
--- /dev/null
+++ b/src/server/scripts/Custom/ItemMod/ItemGUID.h
@@ -0,0 +1,37 @@
+#define MAX_ITEM_ENCHANTS 5
+
+struct ItemGUIDTemplate
+{
+	uint32 Points;
+	uint32 Enchants[MAX_ITEM_ENCHANTS];
+};
+
+extern std::unordered_map<uint32, ItemGUIDTemplate> ItemGUIDMap;
+
+struct ItemPointsTemplate
+{
+	uint32 Points;
+	uint32 TargetEntry;
+};
+
+extern std::unordered_map<uint32, ItemPointsTemplate> ItemPointsMap;
+
+class ItemGUID
+{
+public:
+	static ItemGUID* instance()
+	{
+		static ItemGUID instance;
+		return &instance;
+	}
+
+	void Insert(uint32 guid);
+	void Delete(uint32 guid);
+	void AddStatPoints(uint32 guid, uint32 statpoints);
+	void UpdateEnchants(uint32 guid, uint8 slot, uint32 enchantid);
+	void SendAllData(Player* player);
+	void SendUpdateDataToAll(uint32 guid);
+private:
+
+};
+#define sItemGUID ItemGUID::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/ItemMod/ItemMod.cpp b/src/server/scripts/Custom/ItemMod/ItemMod.cpp
new file mode 100644
index 0000000..a058205
--- /dev/null
+++ b/src/server/scripts/Custom/ItemMod/ItemMod.cpp
@@ -0,0 +1,2486 @@
+#pragma execution_character_set("utf-8")
+#include "../PrecompiledHeaders/ScriptPCH.h"
+#include "../DataLoader/DataLoader.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../Requirement/Requirement.h"
+#include "../Reward/Reward.h"
+#include "ItemMod.h"
+#include "Object.h"
+#include "../VIP/VIP.h"
+#include "../HonorRank/HonorRank.h"
+#include "../ExtraEquipment/ExtraEquipment.h"
+#include "../String/myString.h"
+#include "../GCAddon/GCAddon.h"
+#include "../ItemSet/ItemSet.h"
+#include "../DBCCreate/DBCCreate.h"
+#include "NoPatchItem.h"
+#include "../Switch/Switch.h"
+#include "../Recovery/Recovery.h"
+#include "../GS/GS.h"
+
+std::unordered_map<uint32/*entry*/, UIItemEntryTemplate> UIItemEntryMap;
+
+uint8 ItemMod::GetEnchantStartSlot(uint32 itemMask)
+{
+	switch (itemMask)
+	{
+	case ITEM_MASK_SUIT:
+		return MAX_ENCHANTMENT_SLOT - atoi(sSwitch->GetFlagByIndex(ST_ENCHANTSLOT_MAX, 1).c_str());
+	case ITEM_MASK_ORNAMENT:
+		return MAX_ENCHANTMENT_SLOT - atoi(sSwitch->GetFlagByIndex(ST_ENCHANTSLOT_MAX, 2).c_str());
+	case ITEM_MASK_2H_WEAPON:		 
+		return MAX_ENCHANTMENT_SLOT - atoi(sSwitch->GetFlagByIndex(ST_ENCHANTSLOT_MAX, 3).c_str());
+	case ITEM_MASK_1H_WEAPON:		 
+		return MAX_ENCHANTMENT_SLOT - atoi(sSwitch->GetFlagByIndex(ST_ENCHANTSLOT_MAX, 4).c_str());
+	case ITEM_MASK_OFFHAND:			  
+		return MAX_ENCHANTMENT_SLOT - atoi(sSwitch->GetFlagByIndex(ST_ENCHANTSLOT_MAX, 5).c_str());
+	case ITEM_MASK_RANGED:			
+		return MAX_ENCHANTMENT_SLOT - atoi(sSwitch->GetFlagByIndex(ST_ENCHANTSLOT_MAX, 6).c_str());
+	case ITEM_MASK_SHIRT:			
+		return MAX_ENCHANTMENT_SLOT - atoi(sSwitch->GetFlagByIndex(ST_ENCHANTSLOT_MAX, 7).c_str());
+	case ITEM_MASK_TABARD:			
+		return MAX_ENCHANTMENT_SLOT - atoi(sSwitch->GetFlagByIndex(ST_ENCHANTSLOT_MAX, 8).c_str());
+	case ITEM_MASK_SIGIL:
+		return MAX_ENCHANTMENT_SLOT - COUNT_SIGIL;
+	}
+
+	return 0;
+}
+
+
+std::vector<ItemModTemplate> ItemModVec;
+std::vector<ItemUnbindCostTemplate> ItemUnbindCostInfo;
+std::vector<RemoveGemTemplate> RemoveGemInfo;
+std::vector<ItemExchangeTemplate> ItemExchangeInfo;
+std::vector<ItemUpgradeTemplate> UpgradeVec;
+std::vector<FilterTemplate> FilterVec;
+std::vector<GemCountLimitTemplate> GemCountLimitInfo;
+std::vector<HiddenItemTemplate> HiddenItemInfo;
+std::vector<IdentifyTemplate> IdentifyVec;
+std::vector<RateStoneTemplate> RateStoneVec;
+std::vector<CreateEnchantTemplate> CreateEnchantVec;
+std::vector<EnchantGroupTemplate> EnchantGroupVec;
+std::list<uint32> GCAddonEnchantGroupVec;
+std::vector<ItemBuyTemplate> ItemBuyVec;
+std::vector<ItemVendorBuyTemplate> ItemVendorBuyVec;
+std::unordered_map<uint32/*entry*/, uint32/*reqId*/> ItemEquipMap;
+std::vector<ItemSaleTemplate> ItemSaleVec;
+std::vector<ItemUseTemplate> ItemUseVec;
+std::vector<uint32 /*itemid*/> CurrencyLikeItemVec;
+std::unordered_map<uint32, uint32> DayLimitItemMap;
+std::unordered_map<uint32, ItemDesTemplate> ItemDesMap;
+std::vector<ItemAddTemplate> ItemAddVec;
+
+std::unordered_map<uint32/*entry*/, uint32/*count*/> GetmCountLimitMap;
+
+void ItemMod::LoadBuyEquipSaleUse()
+{
+	ItemVendorBuyVec.clear();
+	QueryResult result = WorldDatabase.PQuery("SELECT item, reqId, entry, clientSlot, buyMaxCount from npc_vendor");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			ItemVendorBuyTemplate Temp;
+			Temp.item = fields[0].GetUInt32();
+			Temp.reqId = fields[1].GetUInt32();
+			Temp.vendor = fields[2].GetUInt32();
+			Temp.clientSlot = fields[3].GetUInt8();
+			Temp.buyMaxCount = fields[4].GetUInt32();
+			ItemVendorBuyVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	ItemBuyVec.clear();
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÎïÆ·ID,ÐèÇóÄ£°åID from _ÎïÆ·_µ±¹ºÂòÊ±" :
+		"SELECT entry,reqId from _itemmod_on_buy");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			ItemBuyTemplate Temp;
+			Temp.entry = fields[0].GetUInt32();
+			Temp.reqId = fields[1].GetUInt32();
+			ItemBuyVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	ItemEquipMap.clear();
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+		"SELECT ÎïÆ·ID,ÐèÇóÄ£°åID from _ÎïÆ·_µ±×°±¸Ê±" :
+		"SELECT entry,reqId from _itemmod_on_equip");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			ItemEquipMap.insert(std::make_pair(fields[0].GetUInt32(), fields[1].GetUInt32()));
+		} while (result->NextRow());
+	}
+
+	ItemSaleVec.clear();
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+		"SELECT ÎïÆ·ID,½±ÀøÄ£°åID,»ñµÃ½±Àø¼¸ÂÊ,GMÃüÁî×é from _ÎïÆ·_µ±ÊÛÂôÊ±" :
+		"SELECT entry,rewId,rewChance,command from _itemmod_on_sale");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			ItemSaleTemplate Temp;
+			Temp.entry		= fields[0].GetUInt32();
+			Temp.rewId		= fields[1].GetUInt32();
+			Temp.rewChance	= fields[2].GetUInt32();
+			Temp.command	= fields[3].GetString();
+			ItemSaleVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	ItemUseVec.clear();
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+		"SELECT ÎïÆ·ID,ÐèÇóÄ£°åID,½±ÀøÄ£°åID,»ñµÃ½±Àø¼¸ÂÊ,GMÃüÁî×é,´¥·¢¼¼ÄÜID1,´¥·¢¼¼ÄÜID2,´¥·¢¼¼ÄÜID3 from  _ÎïÆ·_µ±Ê¹ÓÃÊ±" :
+		"SELECT entry,reqId,rewId,rewChance,command,spell1,spell2,spell3 from _itemmod_on_use");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			ItemUseTemplate Temp;
+			Temp.entry		= fields[0].GetUInt32();
+			Temp.reqId		= fields[1].GetUInt32();
+			Temp.rewId		= fields[2].GetUInt32();
+			Temp.rewChance	= fields[3].GetUInt32();
+			Temp.command	= fields[4].GetString();
+			Temp.spellId1	= fields[5].GetUInt32();
+			Temp.spellId2	= fields[6].GetUInt32();
+			Temp.spellId3	= fields[7].GetUInt32();
+			ItemUseVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	ItemDesMap.clear();
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÎïÆ·ID,¶îÍâÃèÊö,Ó¢ÐÛÄ£Ê½ÎÄ±¾ from _ÎïÆ·_¶îÍâÃèÊö" :
+		"SELECT Entry,Description,HeroText from _itemmod_description");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 entry = fields[0].GetUInt32();
+			ItemDesTemplate temp;
+			temp.description = fields[1].GetString();
+			temp.heroText = fields[2].GetString();
+			ItemDesMap.insert(std::make_pair(entry, temp));
+		} while (result->NextRow());
+	}
+
+	ItemAddVec.clear();
+	//result = WorldDatabase.PQuery("SELECT categoryId,entry,count from _itemmod_add");
+	//if (result)
+	//{
+	//	do
+	//	{
+	//		Field* fields = result->Fetch();
+	//		ItemAddTemplate Temp;
+	//		Temp.categoryId = fields[0].GetUInt32();
+	//		Temp.entry		= fields[1].GetUInt32();
+	//		Temp.count		= fields[2].GetUInt32();
+	//		ItemAddVec.push_back(Temp);
+	//	} while (result->NextRow());
+	//}
+}
+
+
+void ItemMod::Load()
+{
+	LoadBuyEquipSaleUse();
+
+	RateStoneVec.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÎïÆ·ID,ÀàÐÍ,Ìá¸ß³É¹¦¼¸ÂÊ from _ÎïÆ·_¼¸ÂÊ±¦Ê¯" :
+		"SELECT entry,type,rate from _itemmod_rate_stone");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			RateStoneTemplate Temp;
+			Temp.entry	= fields[0].GetUInt32();
+			Temp.type	= RateStoneTypes(fields[1].GetUInt32());
+			Temp.rate	= fields[2].GetUInt32();
+			RateStoneVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+
+	ItemUnbindCostInfo.clear();
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÎïÆ·ID,ÐèÇóÄ£°åID from _ÎïÆ·_½â³ý°ó¶¨" :
+		"SELECT entry,reqId from _itemmod_unbind");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			ItemUnbindCostTemplate ItemUnbindCostTemp;
+			ItemUnbindCostTemp.entry = fields[0].GetUInt32();
+			ItemUnbindCostTemp.reqId = fields[1].GetUInt32();
+
+			ItemUnbindCostInfo.push_back(ItemUnbindCostTemp);
+		} while (result->NextRow());
+	}
+
+
+	RemoveGemInfo.clear();
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ±¦Ê¯ÎïÆ·ID, ÐèÇóÄ£°åID,³É¹¦¼¸ÂÊ FROM _ÎïÆ·_ÒÆ³ý±¦Ê¯" :
+		"SELECT entry, reqId,chance FROM _itemmod_gem_remove");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			RemoveGemTemplate RemoveGemTemp;
+			RemoveGemTemp.entry = fields[0].GetUInt32();
+			RemoveGemTemp.reqId = fields[1].GetUInt32();
+			RemoveGemTemp.chance = fields[2].GetUInt32();
+			RemoveGemInfo.push_back(RemoveGemTemp);
+		} while (result->NextRow());
+	}
+
+
+	ItemExchangeInfo.clear();
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÎïÆ·ID, Éý¼¶ºóÎïÆ·ID, ÐèÇóÄ£°åID,³É¹¦¼¸ÂÊ,Éý¼¶·½Ê½,Ê§°ÜÊ±½±ÀøÄ£°åID,Ê§°ÜÊ±ÊÇ·ñ´Ý»ÙÔ­ÎïÆ·,Éý¼¶ºóÊÇ·ñ±£Áô¸½Ä§Ð§¹û FROM _ÎïÆ·_Éý¼¶" :
+		"SELECT item, exchangedItem, reqId,chance,upFlag,rewIdOnFail,destroyOnFail,keepEnchant FROM _itemmod_exchange_item");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			ItemExchangeTemplate ItemExchangeTemp;
+			ItemExchangeTemp.item			= fields[0].GetUInt32();
+			ItemExchangeTemp.exchangeditem	= fields[1].GetUInt32();
+			ItemExchangeTemp.reqId			= fields[2].GetUInt32();
+			ItemExchangeTemp.chance			= fields[3].GetUInt32();
+			ItemExchangeTemp.flag			= fields[4].GetBool();
+			ItemExchangeTemp.rewIdOnFail	= fields[5].GetUInt32();
+			ItemExchangeTemp.destroyOnFail	= fields[6].GetBool();
+			ItemExchangeTemp.keepEnchant	= fields[7].GetBool();
+			ItemExchangeInfo.push_back(ItemExchangeTemp);
+		} while (result->NextRow());
+	}
+
+	UpgradeVec.clear();
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ¸½Ä§ID, ÉÏ¼¶¸½Ä§ID, ÐèÇóÄ£°åID,ÒÆ³ýÊ±¸½Ä§½±ÀøÄ£°åID,²Ëµ¥ÎÄ±¾,³É¹¦¼¸ÂÊ,ÎïÆ·ÀàÐÍÑÚÂë,·Ö×éÑÚÂë,Ö°ÒµÑÚÂë FROM _ÎïÆ·_Ç¿»¯" :
+		"SELECT enchant_id, prev_enchant_id, enchantReqId,removeEnchantRewId,description,chance,itemMask,flagMask,classMask FROM _itemmod_strengthen_item");
+
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+
+			ItemUpgradeTemplate ItemUpgradeTemp;
+			ItemUpgradeTemp.enchantId = fields[0].GetUInt32();
+			ItemUpgradeTemp.prevEnchantId = fields[1].GetUInt32();
+			ItemUpgradeTemp.enchantReqId = fields[2].GetUInt32();
+			ItemUpgradeTemp.removeEnchantRewId = fields[3].GetUInt32();
+			ItemUpgradeTemp.description = fields[4].GetString();
+			ItemUpgradeTemp.chance = fields[5].GetUInt32();
+			ItemUpgradeTemp.itemMask = fields[6].GetUInt32();
+			ItemUpgradeTemp.enchantMask = fields[7].GetUInt32();
+			ItemUpgradeTemp.classMask = fields[8].GetUInt32();
+			UpgradeVec.push_back(ItemUpgradeTemp);
+		} while (result->NextRow());
+	}
+
+	GemCountLimitInfo.clear();
+	GetmCountLimitMap.clear();
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ±¦Ê¯ÎïÆ·ID,ÊýÁ¿ÉÏÏÞ FROM _ÎïÆ·_±¦Ê¯ÉÏÏÞ" :
+		"SELECT entry,limitCount FROM _itemmod_gem_limit");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			
+
+			uint32 entry = fields[0].GetUInt32();
+			if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(entry))
+				if (uint32 count = fields[1].GetUInt32())
+				{
+					GetmCountLimitMap.insert(std::make_pair(entry, count));
+
+					GemCountLimitTemplate GemCountLimitTemp;
+					GemCountLimitTemp.entry = entry;
+					GemCountLimitTemp.limitCount = count;
+					GemCountLimitInfo.push_back(GemCountLimitTemp);
+				}
+					
+
+		} while (result->NextRow());
+	}
+	
+	IdentifyVec.clear();
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÎïÆ·ID,¸½Ä§×éÄ£°åID,ÐèÇóÄ£°åID,¸½Ä§Î»ÖÃ,²Ëµ¥ÎÄ±¾,ÊÇ·ñÐèÒªµ±Ç°Î»ÖÃÓÐ¸½Ä§ FROM _ÎïÆ·_Ë¢ÐÂ¸½Ä§" :
+		"SELECT entry,groupId,reqId,slot,gossipText FROM _itemmod_refresh");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			IdentifyTemplate Temp;
+			Temp.entry = fields[0].GetUInt32();
+			Temp.groupId = fields[1].GetUInt32();
+			Temp.reqId = fields[2].GetUInt32();
+			Temp.slot = fields[3].GetUInt32();
+			Temp.gossipText = fields[4].GetString();
+			Temp.slotHasEnchant = fields[5].GetBool();
+			IdentifyVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+
+	CreateEnchantVec.clear();
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÎïÆ·ID,¸½Ä§×éÄ£°åID,¸½Ä§Î»ÖÃ,×Ô´ø¸½Ä§¼¸ÂÊ FROM _ÎïÆ·_×Ô´ø¸½Ä§" :
+		"SELECT entry,groupId,slot,chance FROM _itemmod_creation_enchant");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			CreateEnchantTemplate Temp;
+			Temp.entry = fields[0].GetUInt32();
+			Temp.groupId = fields[1].GetUInt32();
+			Temp.slot = fields[2].GetUInt8();
+			Temp.chance = fields[3].GetFloat();
+			CreateEnchantVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+	
+
+	EnchantGroupVec.clear();
+	GCAddonEnchantGroupVec.clear();
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ¸½Ä§×éÄ£°åID,¸½Ä§ID,³éÈ¡¼¸ÂÊ FROM _Ä£°å_¸½Ä§×é" :
+		"SELECT groupId,enchantId,chance FROM _itemmod_enchant_groups");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			EnchantGroupTemplate Temp;
+			Temp.groupId = fields[0].GetUInt32();
+			uint32 EnchantId = fields[1].GetUInt32();
+			Temp.enchantId = EnchantId;
+			Temp.chance = fields[2].GetFloat();
+			EnchantGroupVec.push_back(Temp);
+
+			auto it = std::find(GCAddonEnchantGroupVec.begin(), GCAddonEnchantGroupVec.end(), EnchantId);
+			if (it == GCAddonEnchantGroupVec.end())
+				GCAddonEnchantGroupVec.push_back(EnchantId);
+
+		} while (result->NextRow());
+	}
+	
+
+	sObjectMgr->RestItemQueryData();
+
+	HiddenItemInfo.clear();
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÎïÆ·ID FROM _ÎïÆ·_±³°üÖÐ»ñµÃÊôÐÔ" :
+		"SELECT entry FROM _itemmod_hidden");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			HiddenItemTemplate HiddenItemTemp;
+			HiddenItemTemp.entry = fields[0].GetUInt32();
+			HiddenItemInfo.push_back(HiddenItemTemp);
+		} while (result->NextRow());
+	}
+
+	CurrencyLikeItemVec.clear();
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÎïÆ·ID FROM _ÎïÆ·_»ÕÕÂµôÂä·½Ê½" :
+		"SELECT entry FROM _itemmod_currency_like");
+	if (result)
+	{
+		do
+		{
+			CurrencyLikeItemVec.push_back(result->Fetch()[0].GetUInt32());
+		} while (result->NextRow());
+	}
+
+
+	DayLimitItemMap.clear();
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÎïÆ·ID,Ã¿ÈÕÉÏÏÞ FROM _ÎïÆ·_Ã¿ÈÕÉÏÏÞ" :
+		"SELECT entry,limitCount FROM _itemmod_day_limit");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			DayLimitItemMap.insert(std::make_pair(fields[0].GetUInt32(), fields[1].GetUInt32()));
+		} while (result->NextRow());
+	}
+}
+
+std::string ItemMod::GetExDes(uint32 entry, uint32 flag)
+{
+	std::ostringstream oss;
+	uint32 reqId = 0;
+	uint32 len = ItemExchangeInfo.size();
+
+	for (size_t i = 0; i < len; i++)
+		if (entry == ItemExchangeInfo[i].item && flag == ItemExchangeInfo[i].flag)
+		{
+			ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(ItemExchangeInfo[i].exchangeditem);
+			if (pProto)
+			{
+				reqId = ItemExchangeInfo[i].reqId;
+				break;
+			}
+		}
+	
+	if (reqId != 0)
+	{
+		if (flag == 0)
+			oss << "|cFF00FF00¡¸Éý¼¶ÐèÒªÂú×ã¡¹|r\n";
+		else
+			oss << "|cFF00FF00¡¸Éý¼¶ÐèÒªÂú×ã¡¹|r\n";
+
+		oss << sReq->GetExtraDes(reqId);
+	}
+	
+	return oss.str();
+}
+
+std::string ItemMod::GetUnbindDes(uint32 entry)
+{
+	const ItemTemplate * temp = sObjectMgr->GetItemTemplate(entry);
+	if (!temp)
+		return "";
+
+	std::ostringstream oss;
+	uint32 reqId = 0;
+
+	uint32 len = ItemUnbindCostInfo.size();
+
+	for (size_t i = 0; i < len; i++)
+	{
+		if (entry == ItemUnbindCostInfo[i].entry)
+		{
+			reqId = ItemUnbindCostInfo[i].reqId;
+			break;
+		}			
+	}
+
+	if (reqId != 0)
+	{
+		oss << "|cFF00FF00¡¸½â°óÐèÒªÂú×ã¡¹|r\n";
+		oss << sReq->GetExtraDes(reqId);
+	}
+	
+	return oss.str();
+}
+
+std::string ItemMod::GetMaxGemDes(uint32 entry)
+{
+	std::ostringstream oss;
+
+	uint32 len = GemCountLimitInfo.size();
+
+	for (size_t i = 0; i < len; i++)
+	{
+		if (entry == GemCountLimitInfo[i].entry)
+		{
+			oss << "|cFF00FF00¡¸×î´óÏâÇ¶ÊýÁ¿";
+			oss << GemCountLimitInfo[i].limitCount;
+			oss << "¡¹|r\n";
+			return oss.str();
+		}			
+	}
+	return "";
+}
+
+uint32 ItemMod::GetBuyReqId(uint32 entry, uint32 vendor, uint8 slot)
+{
+	std::vector<ItemVendorBuyTemplate>::iterator it;
+	for (it = ItemVendorBuyVec.begin(); it != ItemVendorBuyVec.end(); ++it)
+		if (entry == it->item && vendor == it->vendor && slot == it->clientSlot)
+		{
+			if (it->reqId != 0)
+				return it->reqId;
+
+			break;
+		}
+
+
+	std::vector<ItemBuyTemplate>::iterator itr;
+	for (itr = ItemBuyVec.begin(); itr != ItemBuyVec.end(); ++itr)
+		if (entry == itr->entry)
+			return itr->reqId;
+
+	return 0;
+}
+
+uint32 ItemMod::GetBuyMaxCount(uint32 entry, uint32 vendor, uint8 slot)
+{
+	std::vector<ItemVendorBuyTemplate>::iterator it;
+	for (it = ItemVendorBuyVec.begin(); it != ItemVendorBuyVec.end(); ++it)
+		if (entry == it->item && vendor == it->vendor && slot == it->clientSlot)
+			return it->buyMaxCount;
+
+	return 0;
+}
+
+uint32 ItemMod::GetEquipInfo(uint32 entry)
+{
+	const ItemTemplate * temp = sObjectMgr->GetItemTemplate(entry);
+	if (!temp)
+		return 0;
+
+	std::unordered_map<uint32/*entry*/, uint32/*reqId*/>::iterator itr = ItemEquipMap.find(entry);
+	if (itr != ItemEquipMap.end())
+		return itr->second;
+
+	return 0;
+}
+void ItemMod::GetSaleInfo(uint32 entry, uint32 &rewId, uint32 &rewChance, std::string &command)
+{
+	const ItemTemplate * temp = sObjectMgr->GetItemTemplate(entry);
+	if (!temp)
+		return;
+
+	std::vector<ItemSaleTemplate>::iterator itr;
+	for (itr = ItemSaleVec.begin(); itr != ItemSaleVec.end(); ++itr)
+		if (entry == itr->entry)
+		{
+			rewId = itr->rewId;
+			rewChance = itr->rewChance;
+			command = itr->command;
+			break;
+		}
+}
+void ItemMod::GetUseInfo(uint32 entry, uint32 &reqId, uint32 &rewId, uint32 &rewChance, std::string &command, uint32 &spellId1, uint32 &spellId2, uint32 &spellId3)
+{
+	const ItemTemplate * temp = sObjectMgr->GetItemTemplate(entry);
+	if (!temp)
+		return;
+
+	std::vector<ItemUseTemplate>::iterator itr;
+	for (itr = ItemUseVec.begin(); itr != ItemUseVec.end(); ++itr)
+		if (entry == itr->entry)
+		{
+			reqId = itr->reqId;
+			rewId = itr->rewId;
+			rewChance = itr->rewChance;
+			command = itr->command;
+			spellId1 = itr->spellId1;
+			spellId2 = itr->spellId2;
+			spellId3 = itr->spellId3;
+			break;
+		}
+}
+
+uint8 ItemMod::getSlot(uint32 sender) {
+	return (uint8)((sender - GOSSIP_SENDER_MAIN) >> 24);
+}
+
+uint32 ItemMod::getEnchant(uint32 sender) {
+	return (uint32)((sender - GOSSIP_SENDER_MAIN) & 0xFFFFFF);//ÆÁ±Î¸ß8Î»
+}
+
+uint32 ItemMod::getGemId(uint32 sender) {
+	return (uint32)((sender - GOSSIP_SENDER_MAIN) & 0xFFFFFF);
+}
+
+uint32 ItemMod::senderValue(uint8 slot, uint32 id) {
+	return (uint32)(GOSSIP_SENDER_MAIN + ((slot << 24) | (id & 0xFFFFFF)));
+}
+
+std::string ItemMod::GetEnchantDescription(Item* item, uint32 enchantId)
+{
+	SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchantId);
+	if (!enchantEntry) return sString->GetText(CORE_STR_TYPES(STR_NO_EFFECT));
+
+	for (uint8 i = 0; i < 16; ++i)
+		if (strlen(enchantEntry->description[i]))
+			return enchantEntry->description[i];
+
+	return sString->GetText(CORE_STR_TYPES(STR_NO_EFFECT));
+}
+
+std::string ItemMod::GetItemEnchantDescription(Player* player, uint32 enchantId)
+{
+	SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchantId);
+	if (!enchantEntry) 
+		return sString->GetText(CORE_STR_TYPES(STR_NO_EFFECT));
+	
+	for (uint32 i = 0; i < UpgradeVec.size(); i++)
+		if (enchantEntry->ID == UpgradeVec[i].enchantId)
+			if (!UpgradeVec[i].description.empty())
+					return UpgradeVec[i].description;
+	
+	for (uint8 i = 0; i < 16; ++i)
+		if (strlen(enchantEntry->description[i]))
+			return enchantEntry->description[i];
+
+	return sString->GetText(CORE_STR_TYPES(STR_NO_EFFECT));
+}
+
+std::string ItemMod::GetGemName(Item* item, uint8 slot)
+{
+	uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(slot));
+
+	if (!enchant_id) 
+		return "";
+
+	SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+
+	if (!enchantEntry) 
+		return "";
+
+	uint32 gemid = enchantEntry->GemID;
+
+	if (!gemid) 
+		return "";
+
+	ItemTemplate const* gemProto = sObjectMgr->GetItemTemplate(gemid);
+
+	if (!gemProto) 
+		return "";
+
+	ItemDisplayInfoEntry const* displayInfo = sItemDisplayInfoStore.LookupEntry(gemProto->DisplayInfoID);
+
+	if (!displayInfo)
+		return "";
+
+	std::ostringstream oss;
+
+	oss << "|TInterface/ICONS/" << displayInfo->inventoryIcon << ":28:28:0:0|t " << "|c" << std::hex << ItemQualityColors[gemProto->Quality] << std::dec <<
+		"|Hitem:" << gemid << ":0:0:0:0:0:0:0:0:0|h[" << gemProto->Name1 << "]|h|r";
+
+	return oss.str();
+}
+
+uint32 ItemMod::getGemId(Item* item, uint8 slot)
+{
+	uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(slot));
+	if (!enchant_id) return 0;
+	SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+	if (!enchantEntry) return 0;
+	return enchantEntry->GemID;
+}
+
+bool ItemMod::AddRemoveGemMenu(Player* player, Item* item)
+{
+	for (uint8 slot = SOCK_ENCHANTMENT_SLOT; slot < SOCK_ENCHANTMENT_SLOT + MAX_GEM_SOCKETS; slot++)
+	{
+		std::string gemName = GetGemName(item, slot);
+		if (!gemName.empty())
+		{
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sString->GetText(CORE_STR_TYPES(STR_GEM_REMOVE)), GOSSIP_SENDER_MAIN, ACTION_GEM_MENU_SHOW);
+			return true;
+		}
+	}
+
+	return false;
+}
+
+bool ItemMod::AddItemRemovBindMenu(Player* player, Item* item)
+{
+	const ItemTemplate * temp = sObjectMgr->GetItemTemplate(item->GetEntry());
+	if (!temp)
+		return false;
+
+	uint32 len = ItemUnbindCostInfo.size();
+	for (uint32 i = 0; i < len; i++)
+	{
+		if (item->GetEntry() == ItemUnbindCostInfo[i].entry && !item->UnBinded && item->IsSoulBound())
+		{
+			std::ostringstream oss;
+			oss << sReq->Notice(player, ItemUnbindCostInfo[i].reqId, "½â°ó", sCF->GetItemLink(item->GetEntry()),item->GetCount());
+			player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, sString->GetText(CORE_STR_TYPES(STR_ITEM_UNBIND)), GOSSIP_SENDER_MAIN, ACTION_ITEM_REMOVEBIND, oss.str().c_str(), sReq->Golds(ItemUnbindCostInfo[i].reqId), 0);
+			return true;
+		}
+	}
+
+	return false;
+}
+
+bool ItemMod::AddItemExchangeMenu(Player* player, Item* item, uint32 update)
+{
+	bool flag = false;
+
+	if (item->IsNoPatch() && update == 0)
+	{
+		uint32 L_ReqId = 0;
+		float L_Chance = 100;
+
+		if (sNoPatchItem->GetExchange(item, L_ReqId, L_Chance))
+		{
+			std::ostringstream oss;
+			oss << sCF->GetItemLink(item->GetEntry());
+			oss << sReq->Notice(player, L_ReqId, "\nÉý¼¶\n", "", 1, L_Chance, VIP_RATE_ITEM_EXCHANGE_0, HR_RATE_ITEM_EXCHANGE_0);
+			player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, sString->GetText(CORE_STR_TYPES(STR_ITEM_EXCHANGE)), update, ACTION_ITEM_EXCHANGE, oss.str().c_str(), L_ReqId, 0);
+			flag = true;
+		}
+
+		if (sNoPatchItem->CanCompound(item))
+		{
+			std::ostringstream oss;
+			oss << sCF->GetItemLink(item->GetEntry()) << " X 2" << "\n\nºÏ³É\n\n";
+			player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, sString->GetText(CORE_STR_TYPES(STR_STAT_PANEL)), update, ACTION_ITEM_NO_PATCH_COMPOUND, oss.str().c_str(), 0, 0);
+			flag = true;
+		}
+	}
+	else
+	{
+		uint32 len = ItemExchangeInfo.size();
+		for (uint32 i = 0; i < len; i++){
+			if (item->GetEntry() == ItemExchangeInfo[i].item && item->GetTemplate()->Stackable == 1 && ItemExchangeInfo[i].flag == update)
+			{
+				std::ostringstream oss;
+				oss << sCF->GetItemLink(item->GetEntry());
+
+				if (update == 0)
+					oss << sReq->Notice(player, ItemExchangeInfo[i].reqId, "\nÉý¼¶Îª\n", sCF->GetItemLink(ItemExchangeInfo[i].exchangeditem), 1, ItemExchangeInfo[i].chance, VIP_RATE_ITEM_EXCHANGE_0, HR_RATE_ITEM_EXCHANGE_0);
+				else
+					oss << sReq->Notice(player, ItemExchangeInfo[i].reqId, "\nÉý¼¶Îª\n", sCF->GetItemLink(ItemExchangeInfo[i].exchangeditem), 1, ItemExchangeInfo[i].chance, VIP_RATE_ITEM_EXCHANGE_1, HR_RATE_ITEM_EXCHANGE_1);
+
+				player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, update == 0 ? sString->GetText(CORE_STR_TYPES(STR_ITEM_EXCHANGE)) : sString->GetText(CORE_STR_TYPES(STR_ITEM_UPGRADE)), update, ACTION_ITEM_EXCHANGE, oss.str().c_str(), sReq->Golds(ItemExchangeInfo[i].reqId), 0);
+				flag = true;
+			}
+		}
+	}
+
+	return flag;
+}
+
+void ItemMod::AddCastMenu(Player* player, Item* item)
+{
+	//if (HasTransFlag(item))
+	//{
+	//	player->CLOSE_GOSSIP_MENU();
+	//	return;
+	//}
+
+	player->flag_i = 0;
+	player->rowId = 0;
+	player->pageId = 0;
+
+	player->PlayerTalkClass->ClearMenus();
+
+	setEnchantMask(item);
+
+	bool reGem = AddRemoveGemMenu(player, item);
+	bool reBind = AddItemRemovBindMenu(player, item);
+	bool ItemEnchant = AddItemEnchantMenu(player, item);
+	bool ItemExchange = AddItemExchangeMenu(player, item);
+	bool ItemExchange2 = AddItemExchangeMenu(player, item, 1);
+	bool Identify = AddIdentifyMenu(player, item);
+
+	if (reGem || reBind || ItemEnchant || ItemExchange || ItemExchange2 || Identify)
+	{
+		player->PlayerTalkClass->GetGossipMenu().SetMenuId(MENU_ID);
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+	}
+	else
+		player->CLOSE_GOSSIP_MENU();
+}
+
+bool ItemMod::hasEnchantByMask(Item* item, uint32 enchantId)
+{
+	uint32 enchantMask = 0;
+	for (uint32 i = 0; i < UpgradeVec.size(); i++)
+	{
+		if (enchantId == UpgradeVec[i].enchantId)
+			enchantMask = UpgradeVec[i].enchantMask;
+	}
+
+	if (enchantMask == 0)
+		return true;
+
+	return (enchantMask & item->enchantMask) != enchantMask;
+}
+
+void ItemMod::setEnchantMask(Item* item)
+{
+	item->enchantMask = 0;
+
+	for (uint8 slot = PROP_ENCHANTMENT_SLOT_0; slot < MAX_ENCHANTMENT_SLOT; slot++)
+	{
+		uint32 currEnchantId = item->GetEnchantmentId(EnchantmentSlot(slot));
+
+		for (uint32 i = 0; i < UpgradeVec.size(); i++)
+		{
+			if (UpgradeVec[i].enchantId == currEnchantId)
+			{
+				if ((item->enchantMask & UpgradeVec[i].enchantMask) != UpgradeVec[i].enchantMask)
+					item->enchantMask = item->enchantMask | UpgradeVec[i].enchantMask;
+			}
+		}
+	}
+}
+
+uint32 ItemMod::GetItemMask(uint32 entry)
+{
+	ItemTemplate const* proto = sObjectMgr->GetItemTemplate(entry);
+	if (!proto)
+		return ITEM_MASK_NONE;
+	
+	if (proto->Class != ITEM_CLASS_WEAPON && proto->Class != ITEM_CLASS_ARMOR)
+		return ITEM_MASK_NONE;
+
+	if (proto->Class == ITEM_CLASS_WEAPON && proto->SubClass == ITEM_SUBCLASS_WEAPON_WAND)
+		return ITEM_MASK_RANGED;
+
+	switch (proto->InventoryType)
+	{
+		//ÊÎÎï
+	case INVTYPE_NECK:
+	case INVTYPE_FINGER:
+	case INVTYPE_TRINKET:
+	case INVTYPE_CLOAK:
+		return ITEM_MASK_ORNAMENT;
+	//°Ë¼þÌ×
+	case INVTYPE_HEAD:
+	case INVTYPE_SHOULDERS:	
+	case INVTYPE_CHEST:
+	case INVTYPE_WAIST:
+	case INVTYPE_LEGS:
+	case INVTYPE_FEET:
+	case INVTYPE_WRISTS:
+	case INVTYPE_HANDS:
+	case INVTYPE_ROBE:
+		return ITEM_MASK_SUIT;
+
+	//³ÄÒÂ
+	case INVTYPE_BODY:
+		return ITEM_MASK_SHIRT;
+	//Õ½ÅÛ
+	case INVTYPE_TABARD:
+		return ITEM_MASK_TABARD;
+
+	//Ë«ÊÖ ¹­ åó Ç¹
+	case INVTYPE_2HWEAPON:
+	case INVTYPE_RANGEDRIGHT://²»ÄÜ°üÀ¨Ä§ÕÈ
+	case INVTYPE_RANGED:
+		return ITEM_MASK_2H_WEAPON;
+
+	//µ¥ÊÖ¡¢Ö÷ÊÖ
+	case INVTYPE_WEAPON:
+	case INVTYPE_WEAPONMAINHAND:
+		return ITEM_MASK_1H_WEAPON;
+	//¶Ü¡¢¸±ÊÖ
+	case INVTYPE_SHIELD:
+	case INVTYPE_WEAPONOFFHAND:
+		return ITEM_MASK_OFFHAND;
+	//Ô¶³Ì
+	case INVTYPE_THROWN://°üÀ¨Ä§ÕÈ
+	case INVTYPE_RELIC:
+		return ITEM_MASK_RANGED;
+
+	case INVTYPE_BAG:
+	case INVTYPE_HOLDABLE:
+	case INVTYPE_AMMO:
+	case INVTYPE_QUIVER:
+		return ITEM_MASK_NONE;
+	}
+
+	return ITEM_MASK_NONE;
+}
+
+bool ItemMod::CanApply(uint32 mask, Item* item, ITEM_ENCHANT_TYPES type)
+{
+	ItemTemplate const* proto = item->GetTemplate();
+	
+	if (!proto)
+		return false;
+
+	switch (type)
+	{
+	case ITEM_ENCHANT_UPGRADE:
+		return (mask & GetItemMask(item->GetEntry())) != 0;
+	case ITEM_ENCHANT_WEAPON_PERM:
+		return (mask & ITEM_MASK_WEAPON_PERM) != 0;
+	case ITEM_ENCHANT_SIGIL:
+		return (mask & ITEM_MASK_SIGIL) != 0;
+	default:
+		return false;
+	}
+}
+
+bool ItemMod::CheckClass(Player* player, uint32 classMask)
+{
+	return (classMask & player->getClassMask()) != 0;
+}
+
+bool ItemMod::IsUpgradeSetted(Player* player, Item* item, ITEM_ENCHANT_TYPES type)
+{
+	uint32 itemMask = GetItemMask(item->GetEntry());
+	uint32 len = UpgradeVec.size();
+
+	switch (type)
+	{
+	case ITEM_ENCHANT_UPGRADE:
+		for (size_t i = 0; i < len; i++)
+			if (UpgradeVec[i].prevEnchantId == 0 && (UpgradeVec[i].itemMask & itemMask) != 0 && (UpgradeVec[i].classMask & player->getClassMask()) != 0)
+				return true;
+		break;
+	case ITEM_ENCHANT_WEAPON_PERM:
+		for (size_t i = 0; i < len; i++)
+			if (UpgradeVec[i].prevEnchantId == 0 && (UpgradeVec[i].itemMask & ITEM_MASK_WEAPON_PERM) != 0 && (UpgradeVec[i].classMask & player->getClassMask()) != 0)
+				return true;
+		break;
+	case ITEM_ENCHANT_SIGIL:
+		for (size_t i = 0; i < len; i++)
+			if (UpgradeVec[i].prevEnchantId == 0 && (UpgradeVec[i].itemMask & ITEM_MASK_SIGIL) != 0 && (UpgradeVec[i].classMask & player->getClassMask()) != 0)
+				return true;
+		break;
+	default:
+		return false;
+	}
+	
+	return false;
+}
+
+bool ItemMod::AddItemEnchantMenu(Player* player, Item* item)
+{
+	bool flag = false;
+
+	if ((item->GetTemplate()->Class == ITEM_CLASS_ARMOR || item->GetTemplate()->Class == ITEM_CLASS_WEAPON) && IsUpgradeSetted(player,item))
+	{
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sString->GetText(CORE_STR_TYPES(STR_ITEM_ENCHANT)), GOSSIP_SENDER_MAIN, ACTION_ITEM_ENCHANT_CURR_MENU_SHOW);
+		flag = true;
+	}
+
+	if (item->GetTemplate()->Class == ITEM_CLASS_WEAPON && IsUpgradeSetted(player, item, ITEM_ENCHANT_WEAPON_PERM))
+	{
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sString->GetText(CORE_STR_TYPES(STR_WEAPON_PERM)), GOSSIP_SENDER_MAIN, ACTION_WEAPON_PERMENCHANT_CURR_MENU_SHOW);
+		flag = true;
+	}
+		
+	return flag;
+}
+void ItemMod::AddItemCurrEnchantList(Player* player, Item* item, ITEM_ENCHANT_TYPES type)
+{
+	setEnchantMask(item);
+
+	switch (type)
+	{
+	case ITEM_ENCHANT_UPGRADE:
+	{
+		for (uint8 slot = GetEnchantStartSlot(GetItemMask(item->GetEntry())); slot < MAX_ENCHANTMENT_SLOT; slot++)
+		{
+			std::ostringstream oss;
+			uint32 currEnchantId = item->GetEnchantmentId(EnchantmentSlot(slot));
+			oss << GetItemEnchantDescription(player, currEnchantId);
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss.str(), senderValue(slot, currEnchantId), ACTION_ITEM_ENCHANT_NEXT_MENU_SHOW);
+		}
+	}
+	break;
+	case ITEM_ENCHANT_SIGIL:
+	{
+		for (uint8 slot = GetEnchantStartSlot(ITEM_MASK_SIGIL); slot < MAX_ENCHANTMENT_SLOT; slot++)
+		{
+			std::ostringstream oss;
+			uint32 currEnchantId = item->GetEnchantmentId(EnchantmentSlot(slot));
+			//oss << "[µ±Ç°£º" << GetItemEnchantDescription(item, currEnchantId) << "]";
+			oss << GetItemEnchantDescription(player, currEnchantId);
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss.str(), senderValue(slot, currEnchantId), ACTION_SIGIL_ENCHANT_NEXT_MENU_SHOW);
+		}
+	}
+	break;
+	default:
+		break;
+	}
+
+	if (SIGIL_OWN_ENCHANT && type != ITEM_ENCHANT_SIGIL)
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<< ·µ»Ø >>", GOSSIP_SENDER_MAIN, ACTION_MAINMENU_BACK);
+	player->PlayerTalkClass->GetGossipMenu().SetMenuId(MENU_ID);
+	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+}
+
+void ItemMod::AddItemNextEnchantList(Player* player, Item* item, uint32 sender, ITEM_ENCHANT_TYPES type)
+{
+	item->enchantType = type;
+
+	uint32 currEnchantId = getEnchant(sender);
+
+	//·ûÓ¡ÖÐ ÓÐÁ½ÐÐÊÇ¹Ì¶¨Öµ µã»÷ÏÔÊ¾µ±Ç°²Ëµ¥
+	if (SIGIL_OWN_ENCHANT && (currEnchantId == SIGIL_OWN_ENCHANT_TITLE_0 || currEnchantId == SIGIL_OWN_ENCHANT_TITLE_1))
+	{
+		AddItemCurrEnchantList(player, player->playerItem, ITEM_ENCHANT_SIGIL);
+		return;
+	}
+
+	bool undefineEnchant = true;
+	uint8 slot = getSlot(sender);
+	SetFilterVec(player, item, type, currEnchantId);
+	uint32 len = FilterVec.size();
+
+	if (SIGIL_OWN_ENCHANT && type != ITEM_ENCHANT_SIGIL)
+	{
+		for (uint32 i = 0; i < len; i++)
+		{
+			if (currEnchantId == FilterVec[i].enchantId)
+			{
+				if (currEnchantId != 0)
+				{
+					std::ostringstream oss1;
+					std::ostringstream oss2;
+					oss1 << "ÒÆ³ý" << GetItemEnchantDescription(player, currEnchantId);
+					oss2 << "\nÒÆ³ý\n" << GetEnchantDescription(item, currEnchantId);
+					player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, oss1.str(), senderValue(slot, currEnchantId), ACTION_ITEM_REMOVE_ENCHANT, oss2.str().c_str(), 0, 0);
+					undefineEnchant = false;
+					break;
+				}
+			}
+		}
+
+		if (undefineEnchant && currEnchantId != 0)
+		{
+			std::ostringstream oss1;
+			std::ostringstream oss2;
+			oss1 << "|cFFFF0000ÒÆ³ý ¡ª> " << GetItemEnchantDescription(player, currEnchantId) << "|r";
+			oss2 << sCF->GetItemLink(item->GetEntry()) << "\n\nÒÆ³ý ¡ª> " << GetEnchantDescription(item, currEnchantId);
+			player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, oss1.str(), senderValue(slot, currEnchantId), ACTION_ITEM_REMOVE_ENCHANT, oss2.str().c_str(), DEFAULT_REMOVE_ENCHANT_GOLDS * GOLD, 0);
+		}
+	}
+	
+	//·ÀÖ¹å´»ú
+	if(len > 30)
+		len = 30;
+
+	for (uint32 i = 0; i < len; i++)
+		player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, ENCHANT_ACTION_STRING + " ¡ª> " + GetItemEnchantDescription(player, FilterVec[i].enchantId), senderValue(slot, FilterVec[i].enchantId), ACTION_ITEM_ENCHANT, sReq->Notice(player, FilterVec[i].enchantReqId, sCF->GetItemLink(item->GetEntry()), "\n\n" + ENCHANT_ACTION_STRING + " ¡ª> " + GetItemEnchantDescription(player, FilterVec[i].enchantId), 1, FilterVec[i].chance, VIP_RATE_ITEM_STRENGTHEN, HR_RATE_ITEM_STRENGTHEN), sReq->Golds(FilterVec[i].enchantReqId), 0);
+
+	if (SIGIL_OWN_ENCHANT && type != ITEM_ENCHANT_SIGIL)
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<< ·µ»Ø >>", GOSSIP_SENDER_MAIN, ACTION_ITEM_ENCHANT_CURR_MENU_SHOW);
+
+	player->PlayerTalkClass->GetGossipMenu().SetMenuId(MENU_ID);
+	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+}
+
+void ItemMod::SetFilterVec(Player* player, Item* item, ITEM_ENCHANT_TYPES type, uint32 currEnchantId)
+{
+	FilterVec.clear();
+
+	uint32 len = UpgradeVec.size();
+
+	for (uint32 i = 0; i < len; i++)
+	{
+		if (currEnchantId == UpgradeVec[i].prevEnchantId && sItemMod->CanApply(UpgradeVec[i].itemMask, item, type) && sItemMod->CheckClass(player, UpgradeVec[i].classMask))
+		{
+			SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(UpgradeVec[i].enchantId);
+			if (enchantEntry)
+				if (hasEnchantByMask(item, UpgradeVec[i].enchantId) || UpgradeVec[i].prevEnchantId != 0)
+				{
+					FilterTemplate temp;
+					temp.enchantId = UpgradeVec[i].enchantId;
+					temp.prevEnchantId = UpgradeVec[i].prevEnchantId;
+					/*HasEnchant(player, UpgradeVec[i].enchantId) ? temp.enchantReqId = 0 : */temp.enchantReqId = UpgradeVec[i].enchantReqId;
+					temp.removeEnchantRewId = UpgradeVec[i].removeEnchantRewId;
+					temp.description = UpgradeVec[i].description;
+					temp.chance = UpgradeVec[i].chance;
+					temp.itemMask = UpgradeVec[i].itemMask;
+					temp.enchantMask = UpgradeVec[i].enchantMask;
+					temp.classMask = UpgradeVec[i].classMask;
+					FilterVec.push_back(temp);
+				}
+		}
+	}
+}
+
+
+void ItemMod::EnchantItem(Player* player, Item* item, uint8 slot, uint32 enchantId)
+{
+	uint32 len = UpgradeVec.size();
+	for (uint32 i = 0; i < len; i++)
+	{
+		if (enchantId == UpgradeVec[i].enchantId)
+		{
+
+			if (sReq->Check(player, UpgradeVec[i].enchantReqId))
+			{
+				uint32 rate = 0;
+				
+				if (item->enchantType == ITEM_ENCHANT_SIGIL)
+				{
+					rate = UpgradeVec[i].chance + sVIP->GetRate(player, VIP_RATE_SIGIL) + sHR->GetRate(player, HR_RATE_SIGIL);
+					
+					if (rate < 100)
+						rate += GetRateAndDes(player, RATE_SIGIL);
+				}
+					
+				else
+				{
+					rate = UpgradeVec[i].chance + sVIP->GetRate(player, VIP_RATE_ITEM_STRENGTHEN) + sHR->GetRate(player, HR_RATE_ITEM_STRENGTHEN) + GetRateAndDes(player, RATE_ITEM_STRENGTHEN);
+					
+					if (rate < 100)
+						rate += GetRateAndDes(player, RATE_SIGIL);
+				}
+				
+				
+				if (urand(1, 100) > rate)
+				{
+					sReq->Des(player, UpgradeVec[i].enchantReqId);
+					std::string noticetext = ENCHANT_ACTION_STRING + "Ê§°Ü";
+					player->GetSession()->SendAreaTriggerMessage(noticetext.c_str());
+					player->CLOSE_GOSSIP_MENU();
+					return;
+				}
+
+				if (item->enchantType == ITEM_ENCHANT_SIGIL)
+					player->_ApplyItemModsCustom(item, 0, false);
+
+				player->ApplyEnchantment(item, EnchantmentSlot(slot), false);
+				item->SetEnchantment(EnchantmentSlot(slot), enchantId, 0, 0);
+				player->ApplyEnchantment(item, EnchantmentSlot(slot), true);
+				player->CastSpell(player, VISUAL_SPELL_ID, true, NULL, NULL, player->GetGUID());
+
+				if (SpellItemEnchantmentEntry const* info = sSpellItemEnchantmentStore.LookupEntry(enchantId))
+				{
+					std::string noticetext = ENCHANT_ACTION_STRING + info->description[4] + "³É¹¦";
+					player->GetSession()->SendAreaTriggerMessage(noticetext.c_str());
+				}
+				
+				//AddEnchant(player, enchantId);
+
+				sReq->Des(player, UpgradeVec[i].enchantReqId);
+
+				if (item->enchantType == ITEM_ENCHANT_SIGIL)
+					player->_ApplyItemModsCustom(item, 0, true);
+
+				AddItemCurrEnchantList(player, item);
+				return;
+			}
+		}
+	}
+	player->CLOSE_GOSSIP_MENU();
+}
+
+//ÎïÆ·½â°ó
+void ItemMod::RemoveBind(Player* player, Item* item)
+{
+	uint32 len = ItemUnbindCostInfo.size();
+	for (uint32 i = 0; i < len; i++)
+	{
+		if (item->GetEntry() == ItemUnbindCostInfo[i].entry)
+		{
+			if (sReq->Check(player, ItemUnbindCostInfo[i].reqId, item->GetCount()))
+			{
+				item->ClearEnchantment(PERM_ENCHANTMENT_SLOT);
+				item->UnBinded = true;
+				item->SetBinding(false);
+				item->SetState(ITEM_CHANGED, player);
+				player->CastSpell(player, VISUAL_SPELL_ID, true, NULL, NULL, player->GetGUID());
+				player->GetSession()->SendAreaTriggerMessage("³É¹¦½â³ýÎïÆ·°ó¶¨");
+				sReq->Des(player, ItemUnbindCostInfo[i].reqId, item->GetCount());
+			}
+			player->CLOSE_GOSSIP_MENU();
+			return;
+		}
+	}
+	player->CLOSE_GOSSIP_MENU();
+}
+
+//ÎïÆ·Éý¼¶
+void ItemMod::ExchangeItem(Player* player, Item* item, uint32 update/*0 Éý¼¶ 1Ç¿»¯*/)
+{
+	uint32 len = ItemExchangeInfo.size();
+	for (uint32 i = 0; i < len; i++)
+	{
+		if (update != ItemExchangeInfo[i].flag)
+			continue;
+
+		if (item->GetEntry() == ItemExchangeInfo[i].item)
+		{
+			if (sReq->Check(player, ItemExchangeInfo[i].reqId))
+			{
+				uint32 vipRate		= 0;
+				uint32 hrRate		= 0;
+				uint32 stoneRate	= 0;
+
+				if (update == 0)
+				{
+					vipRate			= sVIP->GetRate(player, VIP_RATE_ITEM_EXCHANGE_0);
+					hrRate			= sHR->GetRate(player, HR_RATE_ITEM_EXCHANGE_0);
+				}
+				else
+				{
+					vipRate			= sVIP->GetRate(player, VIP_RATE_ITEM_EXCHANGE_1);
+					hrRate			= sHR->GetRate(player, HR_RATE_ITEM_EXCHANGE_1);
+				}
+
+				uint32 rate = ItemExchangeInfo[i].chance + vipRate + hrRate;
+
+				if (rate < 100)
+					update == 0 ? rate += GetRateAndDes(player, RATE_ITEM_EXCHANGE_0) : rate += GetRateAndDes(player, RATE_ITEM_EXCHANGE_1);
+
+
+				if (urand(1, 100) > rate)
+				{		
+					uint32 expItemId = item->GetEntry();
+
+					std::ostringstream oss;
+					oss << sCF->GetItemLink(item, player->GetSession());
+					update == 0 ? oss << "Éý¼¶Ê§°Ü" : oss << "Éý¼¶Ê§°Ü";
+
+					if (ItemExchangeInfo[i].destroyOnFail)
+					{
+						player->DestroyItem(item->GetBagSlot(), item->GetSlot(), true);
+						oss << ",±»´Ý»Ù£¡";
+					}
+					
+					player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+
+					if (ItemExchangeInfo[i].destroyOnFail)
+						sReq->Des(player, ItemExchangeInfo[i].reqId, 1, expItemId);
+					else
+						sReq->Des(player, ItemExchangeInfo[i].reqId);
+
+					sRew->Rew(player, ItemExchangeInfo[i].rewIdOnFail);
+					
+					player->CLOSE_GOSSIP_MENU();
+					return;
+				}
+
+				Item* exchangeItem = AddItem(player, ItemExchangeInfo[i].exchangeditem, 1);
+				if (!exchangeItem)
+				{
+					player->CLOSE_GOSSIP_MENU();
+					return;
+				}
+
+				if (ItemExchangeInfo[i].keepEnchant) //±£Áô¸½Ä§Ð§¹û
+				{
+					for (uint8 slot = PERM_ENCHANTMENT_SLOT; slot < MAX_ENCHANTMENT_SLOT; slot++)
+					{
+						uint32 enchantId = item->GetEnchantmentId(EnchantmentSlot(slot));
+
+						if (SpellItemEnchantmentEntry const* info = sSpellItemEnchantmentStore.LookupEntry(enchantId))
+						{
+							player->ApplyEnchantment(exchangeItem, EnchantmentSlot(slot), false);
+							exchangeItem->SetEnchantment(EnchantmentSlot(slot), enchantId, 0, 0);
+							player->ApplyEnchantment(exchangeItem, EnchantmentSlot(slot), true);
+						}
+					}
+				}
+			
+				player->CastSpell(player, VISUAL_SPELL_ID, true, NULL, NULL, player->GetGUID());
+				uint32 expItemId = item->GetEntry();
+				player->DestroyItem(item->GetBagSlot(), item->GetSlot(), true);
+				sReq->Des(player, ItemExchangeInfo[i].reqId, 1, expItemId);
+				update == 0 ? player->GetSession()->SendAreaTriggerMessage("Éý¼¶³É¹¦") : player->GetSession()->SendAreaTriggerMessage("Éý¼¶³É¹¦");
+				player->CLOSE_GOSSIP_MENU();
+				return;
+			}
+		}
+	}
+	player->CLOSE_GOSSIP_MENU();
+}
+Item* ItemMod::AddItem(Player* player, uint32 itemId, uint32 count)
+{
+	uint32 noSpaceForCount = 0;
+	ItemPosCountVec dest;
+	InventoryResult msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, count, &noSpaceForCount);
+	if (msg != EQUIP_ERR_OK)
+		count -= noSpaceForCount;
+
+	if (count == 0 || dest.empty())
+	{
+		if (dest.empty()) player->GetSession()->SendNotification("±³°üÒÑÂú£¬»òÉý¼¶ºóµÄÎïÆ·ÒÑ´æÔÚÇÒÎ¨Ò»£¡");
+		// -- TODO: Send to mailbox if no space
+		//ChatHandler(GetSession()).PSendSysMessage("You don't have any space in your bags.");
+		return NULL;
+	}
+
+	Item* item = player->StoreNewItem(dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId));
+	if (item)
+		player->SendNewItem(item, count, true, false);
+	else
+	{
+		player->GetSession()->SendNotification("Ê§°Ü£¬Çë¼ì²éÊÇ·ñÉý¼¶ºóµÄÎïÆ·´æÔÚÇÒÎ¨Ò»£¡");
+		return NULL;
+	}
+	return item;
+}
+//È¥³ý±¦Ê¯
+void ItemMod::AddGemList(Player* player, Item* item)
+{
+	bool gemExsit = false;
+
+	uint32 len = RemoveGemInfo.size();
+	for (uint32 i = 0; i < len; i++) {
+		for (uint8 slot = SOCK_ENCHANTMENT_SLOT; slot < SOCK_ENCHANTMENT_SLOT + MAX_GEM_SOCKETS; slot++)
+		{
+			std::string gemName = GetGemName(item, slot);
+			uint32 gemId = getGemId(item, slot);
+			if (gemId != 0 && gemId == RemoveGemInfo[i].entry)
+			{
+				gemExsit = true;
+				player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, gemName.c_str(), senderValue(slot, gemId), ACTION_ITEM_REMOVEGEM, sReq->Notice(player, RemoveGemInfo[i].reqId, sCF->GetItemLink(gemId), "ÒÆ³ý", 1, RemoveGemInfo[i].chance, VIP_RATE_GEM_REMOVE, HR_RATE_GEM_REMOVE), sReq->Golds(RemoveGemInfo[i].reqId), 0);
+			}
+		}
+	}
+
+	if (!gemExsit)
+	{
+		player->CLOSE_GOSSIP_MENU();
+		return;
+	}
+
+	player->PlayerTalkClass->GetGossipMenu().SetMenuId(MENU_ID);
+	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+}
+
+//¼ø¶¨ºÍ·âÏó
+bool ItemMod::AddIdentifyMenu(Player* player, Item* item)
+{
+	bool flag = false;
+
+	for (uint8 slot = PERM_ENCHANTMENT_SLOT; slot < MAX_ENCHANTMENT_SLOT; slot++)
+	{
+		if (GetIdentifyGroupId(item->GetEntry(), EnchantmentSlot(slot)) != 0)
+		{
+			uint32 reqId = 0;
+			std::string gossipText = "";
+			bool slotHasEnchant = false;
+
+			GetIdentifyInfo(item->GetEntry(), EnchantmentSlot(slot), reqId, gossipText, slotHasEnchant);
+
+			SpellItemEnchantmentEntry const* info = sSpellItemEnchantmentStore.LookupEntry(item->GetEnchantmentId(EnchantmentSlot(slot)));
+
+			if (slotHasEnchant && !info)
+				continue;
+
+			flag = true;
+
+			std::ostringstream oss;
+
+			if (info)
+			{
+				std::string str = info->description[4];
+				sDBCCreate->RepStr(str, "|cFF00FF00", "");
+				sDBCCreate->RepStr(str, "|r", "");
+				oss << sString->GetText(CORE_STR_TYPES(STR_IDENTIFY)) << str;
+			}
+			else
+				oss << sString->GetText(CORE_STR_TYPES(STR_IDENTIFY)) << "»ñµÃÐÂµÄÊôÐÔ";
+
+			if (!gossipText.empty())
+				oss << "\n" << gossipText;
+
+			player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, oss.str(), slot, ACTION_ITEM_IDENTIFY, sReq->Notice(player, reqId, "ÖØÐÂÁ¶»¯", sCF->GetItemLink(item->GetEntry())), sReq->Golds(reqId), 0);
+		}
+	}
+
+	return flag;
+}
+
+void ItemMod::RemoveGem(Player* player, Item* item, uint32 sender)
+{
+	uint32 gemId = getGemId(sender);
+	uint8 slot = getSlot(sender);
+	uint32 len = RemoveGemInfo.size();
+	for (uint32 i = 0; i < len; i++)
+	{
+		if (gemId == RemoveGemInfo[i].entry)
+		{
+			if (sReq->Check(player, RemoveGemInfo[i].reqId))
+			{
+
+				uint32 rate = RemoveGemInfo[i].chance + sVIP->GetRate(player, VIP_RATE_GEM_REMOVE) + sHR->GetRate(player, HR_RATE_GEM_REMOVE);
+
+				if (rate < 100)
+					rate += GetRateAndDes(player, RATE_GEM_REMOVE);
+
+				if (urand(1, 100) > rate)
+				{
+					sReq->Des(player, RemoveGemInfo[i].reqId);
+					player->GetSession()->SendAreaTriggerMessage("ÒÆ³ýÊ§°Ü");
+					AddGemList(player, player->playerItem);
+					return;
+				}
+
+				player->ApplyEnchantment(item, EnchantmentSlot(slot), false);
+				item->ClearEnchantment(EnchantmentSlot(slot));
+				player->CastSpell(player, VISUAL_SPELL_ID, true, NULL, NULL, player->GetGUID());
+				player->AddItem(gemId, 1);
+				player->GetSession()->SendAreaTriggerMessage("ÒÆ³ý³É¹¦");
+				sReq->Des(player, RemoveGemInfo[i].reqId);
+				player->CastSpell(player, VISUAL_SPELL_ID, true, NULL, NULL, player->GetGUID());
+				AddGemList(player, player->playerItem);
+				return;
+			}
+		}
+	}
+	player->CLOSE_GOSSIP_MENU();
+}
+
+void ItemMod::RemoveItemEnchant(Player* player, Item* item, uint8 slot, uint32 enchantId)
+{
+	SpellItemEnchantmentEntry const* info = sSpellItemEnchantmentStore.LookupEntry(enchantId);
+
+	if (!info)
+		player->CLOSE_GOSSIP_MENU();
+
+	for (uint32 i = 0; i < UpgradeVec.size(); i++)
+		if (enchantId == UpgradeVec[i].enchantId)
+			sRew->Rew(player, UpgradeVec[i].removeEnchantRewId);
+		
+	player->ApplyEnchantment(item, EnchantmentSlot(slot), false);
+	item->ClearEnchantment(EnchantmentSlot(slot));
+	player->CastSpell(player, VISUAL_SPELL_ID, true, NULL, NULL, player->GetGUID());
+	std::string text = "ÒÆ³ý" + ENCHANT_NAME_STRING + info->description[4];
+	player->GetSession()->SendAreaTriggerMessage(text.c_str());
+	AddItemCurrEnchantList(player, item);
+}
+
+void ItemMod::RemoveUndefinEnchant(Player* player, Item* item, uint8 slot, uint32 enchantId)
+{
+	if (!player->HasEnoughMoney(100 * GOLD))
+	{
+		player->GetSession()->SendNotification("ÄãÃ»ÓÐ×ã¹»µÄ½ðÇ®");
+		return;
+	}
+	player->ApplyEnchantment(item, EnchantmentSlot(slot), false);
+	item->ClearEnchantment(EnchantmentSlot(slot));
+	player->CastSpell(player, VISUAL_SPELL_ID, true, NULL, NULL, player->GetGUID());
+	player->GetSession()->SendAreaTriggerMessage("ÒÆ³ý¸½Ä§");
+	player->CLOSE_GOSSIP_MENU();
+	return;
+}
+
+void ItemMod::RefreshItem(Player* player, Item* item, EnchantmentSlot slot)
+{
+	uint32 enchantId = GetIdentifyEnchantId(item->GetEntry(), slot);
+	uint32 reqId = 0;
+	std::string gossipText = "";
+	bool slotHasEnchant = false;
+
+	GetIdentifyInfo(item->GetEntry(), slot, reqId, gossipText, slotHasEnchant);
+
+	uint32 enchant_id = item->GetEnchantmentId(slot);
+
+	//if (enchant_id != 8004 && slot == PROP_ENCHANTMENT_SLOT_0 || enchant_id != 8005 && slot == PROP_ENCHANTMENT_SLOT_1)
+	//{
+	//	player->CLOSE_GOSSIP_MENU();
+	//	player->GetSession()->SendNotification("¸Ã×°±¸Ö»ÄÜ¼ø¶¨»ò´ãÁ¶Ò»´Î£¡");
+	//	return;
+	//}
+		
+	if (sReq->Check(player, reqId))
+	{
+		player->ApplyEnchantment(item, slot, false);
+		item->SetEnchantment(slot, enchantId, 0, 0, 0, true);
+		player->ApplyEnchantment(item, slot, true);
+
+		item->SetBinding(true);
+		item->SetNotRefundable(player);
+
+		WorldPacket data(SMSG_ITEM_REFUND_INFO_RESPONSE, 8 + 4 + 4 + 4 + 4 * 4 + 4 * 4 + 4 + 4);
+		data << uint64(item->GetGUID()); // item guid
+		data << uint32(0);               // money cost
+		data << uint32(0);               // honor point cost
+		data << uint32(0);               // arena point cost
+		for (uint8 i = 0; i < MAX_ITEM_EXTENDED_COST_REQUIREMENTS; ++i)// item cost data
+		{
+			data << uint32(0);
+			data << uint32(0);
+		}
+		data << uint32(0);
+		data << uint32(0);
+		player->GetSession()->SendPacket(&data);
+
+		sReq->Des(player, reqId);
+		player->CastSpell(player, VISUAL_SPELL_ID, true, NULL, NULL, player->GetGUID());
+		if (SpellItemEnchantmentEntry const* info = sSpellItemEnchantmentStore.LookupEntry(enchantId))
+			player->GetSession()->SendAreaTriggerMessage("%s|cFF00FF00»ñµÃ|r%s", sCF->GetItemLink(item->GetEntry()).c_str(), info->description[4]);;
+	}
+
+	//<< ·µ»Ø >>¼ÀÁ¶²Ëµ¥
+	AddCastMenu(player, item);
+}
+
+class spell_item_mod : public SpellScriptLoader
+{
+public:
+	spell_item_mod() : SpellScriptLoader("spell_item_mod") { }
+
+	class spell_item_mod_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_item_mod_SpellScript);
+		void HandleAfterCast()
+		{
+			Player* player = GetCaster()->ToPlayer();
+			if (!player)
+				return;
+
+
+			Item* item = GetExplTargetItem();
+			if (!item)
+				return;
+
+			if (item->GetOwner() != player)
+			{
+				ChatHandler(player->GetSession()).PSendSysMessage("Äã²»ÓµÓÐÕâ¼þ×°±¸£¡");
+				return;
+			}
+
+			player->playerItem = item;
+
+			sItemMod->AddCastMenu(player, item);
+		}
+
+		void Register() override
+		{
+			AfterCast += SpellCastFn(spell_item_mod_SpellScript::HandleAfterCast);
+		}
+	};
+
+	SpellScript* GetSpellScript() const override
+	{
+		return new spell_item_mod_SpellScript();
+	}
+};
+
+class item_mod_playerscript : public PlayerScript
+{
+public:
+	item_mod_playerscript() : PlayerScript("item_mod_playerscript") {}
+
+	void OnGossipSelect(Player* player, uint32 menu_id, uint32 sender, uint32 action) override
+	{
+
+		if (menu_id != MENU_ID || !player->playerItem || !player->playerItem->IsInWorld())
+		{
+			player->playerItem = NULL;
+			player->CLOSE_GOSSIP_MENU();
+			return;
+		}
+
+		player->PlayerTalkClass->ClearMenus();
+
+		switch (action)
+		{
+		case ACTION_MAINMENU_BACK:
+			sItemMod->AddCastMenu(player, player->playerItem);
+			break;
+			//ÎïÆ·¸½Ä§
+		case ACTION_ITEM_ENCHANT_CURR_MENU_SHOW:
+			sItemMod->AddItemCurrEnchantList(player, player->playerItem);
+			break;
+		case ACTION_ITEM_ENCHANT_NEXT_MENU_SHOW:
+			sItemMod->AddItemNextEnchantList(player, player->playerItem, sender);
+			break;
+		case ACTION_WEAPON_PERMENCHANT_CURR_MENU_SHOW:
+			player->flag_i = 0;
+			player->rowId = 0;
+			player->pageId = 1;
+			sItemMod->AddWeaponPermList(player, player->playerItem);
+			break;
+		case ACTION_WEAPON_PERMENCHANT_NEXT_MENU_SHOW:
+			player->pageId += 1;
+			sItemMod->AddWeaponPermList(player, player->playerItem);
+			break;	
+		case ACTION_PREV_PAGE:
+			player->pageId -= 1;
+			player->flag_i -= 2 * MAX_ROWS_COUNT;
+			sItemMod->AddWeaponPermList(player, player->playerItem);
+			break;
+		case ACTION_WEAPON_LOOKUPANDBUY_SHOW:
+			sItemMod->LookupOrBuyWeaponPermEnchant(player,player->playerItem,sender);
+			break;
+		case ACTION_WEAPONPERM_LOOKUP:
+			sItemMod->LookupWeaponPermEnchant(player, player->playerItem, sender);
+			break;
+		case ACTION_WEAPONPERM_BUY:
+			sItemMod->BuyWeaponPermEnchant(player, player->playerItem, sender);
+			player->SaveToDB(false, false);
+			break;
+		case ACTION_SIGIL_ENCHANT_NEXT_MENU_SHOW:
+			sItemMod->AddItemNextEnchantList(player, player->playerItem, sender, ITEM_ENCHANT_SIGIL);
+			break;
+		case ACTION_ITEM_ENCHANT:
+			sItemMod->EnchantItem(player, player->playerItem, sItemMod->getSlot(sender), sItemMod->getEnchant(sender));
+			player->SaveToDB(false, false);
+			break;
+		case ACTION_ITEM_REMOVE_ENCHANT:
+			sItemMod->RemoveItemEnchant(player, player->playerItem, sItemMod->getSlot(sender), sItemMod->getEnchant(sender));
+			player->SaveToDB(false, false);
+			break;
+
+			//ÒÆ³ýÎ´¶¨Òå¸½Ä§
+		case ACTION_REMOVE_ENCHANT_UNDEFINE:
+			sItemMod->RemoveUndefinEnchant(player, player->playerItem, sItemMod->getSlot(sender), sItemMod->getEnchant(sender));
+			player->SaveToDB(false, false);
+			break;
+			//ÒÆ³ý±¦Ê¯
+		case ACTION_GEM_MENU_SHOW:
+			sItemMod->AddGemList(player, player->playerItem);
+			break;
+		case ACTION_ITEM_REMOVEGEM:
+			sItemMod->RemoveGem(player, player->playerItem, sender);
+			player->SaveToDB(false, false);
+			break;
+			//ÎïÆ·Éý¼¶
+		case ACTION_ITEM_EXCHANGE:
+			if (player->playerItem->IsNoPatch())
+				sNoPatchItem->LevelUp(player, player->playerItem);
+			else
+				sItemMod->ExchangeItem(player, player->playerItem,sender);
+			player->SaveToDB(false, false);
+			break;
+		case ACTION_ITEM_NO_PATCH_COMPOUND:
+			sNoPatchItem->Compound(player, player->playerItem);
+			player->CLOSE_GOSSIP_MENU();
+			player->SaveToDB(false, false);
+			break;
+			//ÎïÆ·½â°ó
+		case ACTION_ITEM_REMOVEBIND:
+			sItemMod->RemoveBind(player, player->playerItem);
+			break;
+		case ACTION_ITEM_IDENTIFY:
+			sItemMod->RefreshItem(player, player->playerItem, EnchantmentSlot(sender));
+			player->SaveToDB(false, false);
+			break;
+		default:
+			break;
+		}
+	}
+
+	void OnLogout(Player* player) override
+	{
+		sItemMod->RecoverWeaponPermEnchant(player);
+	}
+
+	void OnLogin(Player* player) override
+	{
+		//Ö÷±³°ü
+		for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
+			if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+				for (uint32 k = 0; k < HiddenItemInfo.size(); k++)
+					if (item->GetEntry() == HiddenItemInfo[k].entry)
+						player->_ApplyItemModsCustom(item, 0, true);
+
+		//¶îÍâÈý¸ö±³°ü
+		for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+			if (Bag* pBag = player->GetBagByPos(i))
+				for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+					if (Item* item = player->GetItemByPos(i, j))
+						for (uint32 k = 0; k < HiddenItemInfo.size(); k++)
+							if (item->GetEntry() == HiddenItemInfo[k].entry)
+								player->_ApplyItemModsCustom(item, 0, true);
+
+		//ÒøÐÐ
+		for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
+			if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+				for (uint32 k = 0; k < HiddenItemInfo.size(); k++)
+					if (item->GetEntry() == HiddenItemInfo[k].entry)
+						player->_ApplyItemModsCustom(item, 0, true);
+		//ÒøÐÐ±³°ü
+		for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+			if (Bag* pBag = player->GetBagByPos(i))
+				for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+					if (Item* item = player->GetItemByPos(i, j))
+						for (uint32 k = 0; k < HiddenItemInfo.size(); k++)
+							if (item->GetEntry() == HiddenItemInfo[k].entry)
+								player->_ApplyItemModsCustom(item, 0, true);
+
+
+		player->InitDayLimitItem();
+
+		//sItemMod->LoadEnchant(player);
+
+		sNoPatchItem->UpdateAuras(player);
+	}
+
+	void OnUpdateZone(Player* player, uint32 /*newZone*/, uint32 /*newArea*/) 
+	{ 
+		//sItemMod->UnApplyEquipments(player);
+	}
+};
+
+//·ûÓ¡
+class sigil_item_upgrade : public ItemScript
+{
+public:
+	sigil_item_upgrade() : ItemScript("sigil_item_upgrade") { }
+
+	bool OnUse(Player* player, Item* item, SpellCastTargets const& targets) override
+	{
+		player->PlayerTalkClass->ClearMenus();
+		if (!item || !sItemMod->IsUpgradeSetted(player, item, ITEM_ENCHANT_SIGIL) || !item->IsInWorld())
+		{
+			player->CLOSE_GOSSIP_MENU();
+			return false;
+		}
+
+		if (SIGIL_OWN_ENCHANT)
+		{
+			bool hasInitEnchant = false;
+
+			for (uint32 slot = PERM_ENCHANTMENT_SLOT; slot < MAX_ENCHANTMENT_SLOT; ++slot)
+				if (uint32 enchantId = item->GetEnchantmentId(EnchantmentSlot(slot)))
+				{
+					hasInitEnchant = true;
+					break;
+				}
+
+			if (!hasInitEnchant)
+			{
+				for (uint32 slot = MAX_ENCHANTMENT_SLOT - COUNT_SIGIL; slot < MAX_ENCHANTMENT_SLOT; ++slot)
+				{
+					uint32 enchantId = slot + SIGIL_OWN_ENCHANT_ID_START - (MAX_ENCHANTMENT_SLOT - COUNT_SIGIL);
+					player->ApplyEnchantment(item, EnchantmentSlot(slot), false);
+					item->SetEnchantment(EnchantmentSlot(slot), enchantId, 0, 0);
+					player->ApplyEnchantment(item, EnchantmentSlot(slot), true);
+					player->SaveToDB(false, false);
+				}
+			}
+		}
+		
+		player->playerItem = item;
+		sItemMod->setEnchantMask(item);
+		sItemMod->AddItemCurrEnchantList(player, player->playerItem, ITEM_ENCHANT_SIGIL);
+		return true;
+	}
+};
+
+
+void AddSC_ITEM_MOD()
+{
+	new item_mod_playerscript();
+	new spell_item_mod();
+	new sigil_item_upgrade();
+}
+
+
+
+//¼¸ÂÊ±¦Ê¯
+
+uint32 ItemMod::GetRate(Player* player, RateStoneTypes type)
+{
+	for (std::vector<RateStoneTemplate>::iterator itr = RateStoneVec.begin(); itr != RateStoneVec.end(); ++itr)
+		if (type == itr->type)
+			if (player->HasItemCount(itr->entry, 1))
+				return itr->rate;
+
+	return 0;
+}
+
+uint32 ItemMod::GetRateAndDes(Player* player, RateStoneTypes type)
+{
+	for (std::vector<RateStoneTemplate>::iterator itr = RateStoneVec.begin(); itr != RateStoneVec.end(); ++itr)
+		if (type == itr->type)
+			if (player->HasItemCount(itr->entry, 1))
+			{
+				player->DestroyItemCount(itr->entry, 1, true);
+				return itr->rate;
+			}
+	return 0;
+}
+
+bool ItemMod::HasTransFlag(Item* item)
+{
+	bool flag = false;
+
+	for (uint8 slot = PROP_ENCHANTMENT_SLOT_0; slot < MAX_ENCHANTMENT_SLOT; slot++)
+	{
+		uint32 enchantId = item->GetEnchantmentId(EnchantmentSlot(slot));
+		if (enchantId == TRANS_FLAG_ENCHANT_ID)
+			flag = true;
+	}
+	
+	return flag;
+}
+
+void ItemMod::ApplyHiddenItem(Player* player, Item* item, bool apply)
+{
+	for (std::vector<HiddenItemTemplate>::iterator i = HiddenItemInfo.begin(); i != HiddenItemInfo.end(); ++i)
+		if (item->GetEntry() == i->entry)
+		{
+			player->_ApplyItemModsCustom(item, 0, apply);
+			sGS->UpdateGS(player, item->GetEntry(), GS_TYPE_ITEM_HIDDEN, apply);
+			return;
+		}
+}
+
+bool ItemMod::IsCurrencyLike(uint32 itemid)
+{
+	if (std::find(CurrencyLikeItemVec.begin(), CurrencyLikeItemVec.end(), itemid) != CurrencyLikeItemVec.end())
+		return true;
+
+	return false;
+}
+
+void ItemMod::ResetDayLimitItem()
+{
+	SessionMap const& smap = sWorld->GetAllSessions();
+	for (SessionMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+		if (Player* player = iter->second->GetPlayer())
+			player->PDayLimitItemMap.clear();
+
+	CharacterDatabase.Execute(CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_DAY));
+}
+
+std::string ItemMod::GetDayLimitDes(Player* player, uint32 entry)
+{
+	std::ostringstream oss;
+	uint32 limit = 0;
+	uint32 count = 0;
+
+	
+	auto itr = DayLimitItemMap.find(entry);
+	if (itr != DayLimitItemMap.end())
+		limit = itr->second;
+	else
+		return "";
+
+	itr = player->PDayLimitItemMap.find(entry);
+	if (itr != player->PDayLimitItemMap.end())
+		count = itr->second;
+
+	if (count > limit)
+		count = limit;
+
+	oss << "|cFF00FF00¡¸Ã¿ÈÕÉÏÏÞ |cFFFFCC00" << count << "/" << limit << "|r |cFF00FF00¡¹|r\n";
+
+	return oss.str();
+}
+
+
+std::string ItemMod::GetUseDes(uint32 entry)
+{
+	std::ostringstream oss;
+	uint32 reqId = 0;
+
+	uint32 len = ItemUseVec.size();
+
+	for (size_t i = 0; i < len; i++)
+	{
+		if (entry == ItemUseVec[i].entry)
+		{
+			reqId = ItemUseVec[i].reqId;
+			break;
+		}
+	}
+
+	if (reqId != 0)
+	{
+		oss << "|cFF00FF00¡¸Ê¹ÓÃÐèÒªÂú×ã¡¹|r\n";
+		oss << sReq->GetExtraDes(reqId);
+	}
+
+	return oss.str();
+}
+
+std::string ItemMod::GetEquipDes(uint32 entry)
+{
+	std::ostringstream oss;
+
+	uint32 reqId = GetEquipInfo(entry);
+
+	if (reqId != 0)
+	{
+		oss << "|cFF00FF00¡¸×°±¸ÐèÒªÂú×ã¡¹|r\n";
+		oss << sReq->GetExtraDes(reqId);
+	}
+	return oss.str();
+}
+
+std::string ItemMod::GetBuyDes(uint32 entry)
+{
+	std::ostringstream oss;
+	uint32 reqId = 0;
+
+	uint32 len = ItemBuyVec.size();
+
+	for (size_t i = 0; i < len; i++)
+	{
+		if (entry == ItemBuyVec[i].entry)
+		{
+			reqId = ItemBuyVec[i].reqId;
+			
+			break;
+		}
+	}
+
+	if (reqId != 0)
+	{
+		oss << "|cFF00FF00¡¸¹ºÂòÐèÒªÂú×ã¡¹|r\n";
+		oss << sReq->GetExtraDes(reqId);
+	}
+	
+	return oss.str();
+}
+
+void ItemMod::GetDes(uint32 entry, std::string &description, std::string &heroText)
+{
+	auto iter = ItemDesMap.find(entry);
+
+	if (iter != ItemDesMap.end())
+	{
+		description = iter->second.description;
+		heroText = iter->second.heroText;
+	}
+}
+
+void ItemMod::AddCategoryItem(Player* player, Player* target, uint32 categoryId)
+{
+	uint32 len = ItemAddVec.size();
+
+	for (size_t i = 0; i < len; i++)
+	{
+		if (categoryId == ItemAddVec[i].categoryId)
+		{
+			if (ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(ItemAddVec[i].entry))
+			{
+				if (AddItem(target, ItemAddVec[i].entry, ItemAddVec[i].count))
+					ChatHandler(player->GetSession()).PSendSysMessage("%s»ñµÃ%s X %u", target->GetName().c_str(), pProto->Name1.c_str(), ItemAddVec[i].count);
+				else
+					ChatHandler(player->GetSession()).PSendSysMessage("Ìí¼Ó%sÊ§°Ü", pProto->Name1.c_str());
+			}
+		}
+	}
+}
+
+void ItemMod::UnApplyEquipments(Player* player)
+{
+	for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+	{
+		if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+		{
+			ItemTemplate const* pProto = pItem->GetTemplate();
+
+			if (!pProto)
+				continue;
+
+			bool valid = true;
+
+			std::unordered_map<uint32/*entry*/, uint32/*reqId*/>::iterator iter = ItemEquipMap.find(pItem->GetEntry());
+			if (iter != ItemEquipMap.end())
+				if(!sReq->Check(player, iter->second))
+					valid = false;
+
+			if (valid)
+				continue;
+
+			if (pProto && pProto->ItemSet)
+				RemoveItemsSetItem(player, pProto);
+
+			player->_ApplyItemMods(pItem, slot, false);
+
+			if (slot < EQUIPMENT_SLOT_END)
+			{
+				player->RemoveItemDependentAurasAndCasts(pItem);
+				switch (slot)
+				{
+				case EQUIPMENT_SLOT_MAINHAND:
+				case EQUIPMENT_SLOT_OFFHAND:
+				case EQUIPMENT_SLOT_RANGED:
+					player->RecalculateRating(CR_ARMOR_PENETRATION);
+				default:
+					break;
+				}
+
+				if (slot == EQUIPMENT_SLOT_MAINHAND)
+					player->UpdateExpertise(BASE_ATTACK);
+				else if (slot == EQUIPMENT_SLOT_OFFHAND)
+					player->UpdateExpertise(OFF_ATTACK);
+			}
+
+			ChatHandler(player->GetSession()).PSendSysMessage("Ð¶ÔØ%sÊôÐÔ", sCF->GetItemLink(pItem, player->GetSession()).c_str());
+		}
+	}
+}
+
+/*
+void ItemMod::AddEnchant(Player* player, uint32 enchantId)
+{
+	if (HasEnchant(player, enchantId))
+		return;
+
+	player->RuneVec.push_back(enchantId);
+
+	//¸üÐÂÊý¾Ý¿â
+	PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_RUNE);
+	stmt->setUInt32(0, player->GetGUIDLow());
+	stmt->setUInt32(1, enchantId);
+	CharacterDatabase.Execute(stmt);
+}
+void ItemMod::LoadEnchant(Player* player)
+{
+	player->RuneVec.clear();
+	QueryResult result = CharacterDatabase.PQuery("SELECT enchantId from character_rune where guid = '%u'", player->GetGUIDLow());
+
+	if (result)
+	{
+		do
+		{
+			player->RuneVec.push_back(result->Fetch()[0].GetUInt32());
+		} while (result->NextRow());
+	}
+}
+bool ItemMod::HasEnchant(Player* player, uint32 enchantId)
+{
+	if (player->RuneVec.empty())
+		return false;
+
+	return std::find(player->RuneVec.begin(), player->RuneVec.end(), enchantId) != player->RuneVec.end();
+}
+*/
+
+bool ItemMod::IsGemLimited(Player* player)
+{
+	bool flag = false;
+
+	for (auto itr = GetmCountLimitMap.begin(); itr != GetmCountLimitMap.end(); itr++)
+	{
+		int32 count = 0;
+		for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
+			if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+				count += pItem->GetGemCountWithID(itr->first);
+		
+		if (count >= itr->second)
+			flag = true;
+	}
+
+	return flag;
+}
+
+int32 ItemMod::GetGemCount(Item* pItem, uint32 gemEntry)
+{
+	if (!pItem)
+		return 0;
+
+	int32 count = 0;
+
+	for (uint8 slot = SOCK_ENCHANTMENT_SLOT; slot <= SOCK_ENCHANTMENT_SLOT_3; slot++)
+	{
+		uint32 enchant_id = pItem->GetEnchantmentId(EnchantmentSlot(slot));
+
+		if (SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id))
+			if (const ItemTemplate * itemProto = sObjectMgr->GetItemTemplate(pEnchant->GemID))
+				if (gemEntry == pEnchant->GemID)
+					count++;
+	}
+
+	return count;
+}
+
+bool ItemMod::IsGemLimited(Player* player, Item* pItem1, Item* pItem2)
+{
+	for (auto itr = GetmCountLimitMap.begin(); itr != GetmCountLimitMap.end(); itr++)
+	{
+		int32 count = 0;
+		for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
+			if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+				count += pItem->GetGemCountWithID(itr->first);
+
+		if (count + GetGemCount(pItem2, itr->first) - GetGemCount(pItem1, itr->first) >= itr->second)
+			return true;
+	}
+
+	return false;
+}
+
+void ItemMod::SendData(Player* player)
+{
+	if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, INVENTORY_SLOT_ITEM_START))
+	{
+		uint32 itemId = item->GetEntry();
+
+		std::ostringstream oss;
+		oss << itemId << "#";
+		oss << item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << "*";
+		//oss << getGemId(item, SOCK_ENCHANTMENT_SLOT) << "*";
+		//oss << getGemId(item, SOCK_ENCHANTMENT_SLOT_2) << "*";
+		//oss << getGemId(item, SOCK_ENCHANTMENT_SLOT_3) << "*";
+		oss << item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT) << "*";
+		oss << item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_2) << "*";
+		oss << item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_3) << "*";
+		oss << item->GetEnchantmentId(BONUS_ENCHANTMENT_SLOT) << "*";
+		oss << item->GetItemRandomPropertyId() << "*";
+
+		for (size_t i = PROP_ENCHANTMENT_SLOT_0; i < MAX_ENCHANTMENT_SLOT; i++)
+			oss << GetUIEnchantDescription(item, EnchantmentSlot(i)) << "*";
+
+		sGCAddon->SendPacketTo(player, "GC_S_ITEMDATA", oss.str());
+
+		sLog->outString(oss.str().c_str());
+	}
+}
+
+std::string ItemMod::GetUIEnchantDescription(Item* item, EnchantmentSlot slot)
+{
+	uint32 enchantId = item->GetEnchantmentId(slot);
+	SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchantId);
+	if (!enchantEntry)
+		return "0";
+
+	for (uint8 i = 0; i < 16; ++i)
+		if (strlen(enchantEntry->description[i]))
+			return enchantEntry->description[i];
+
+	return "0";
+}
+
+void ItemMod::InitUIItemEntryData()
+{
+	UIItemEntryMap.clear(); 
+
+	//des heroText
+	for (auto iter = ItemDesMap.begin(); iter != ItemDesMap.end(); iter++)
+	{
+		auto it = UIItemEntryMap.find(iter->first);
+		if (it != UIItemEntryMap.end())
+		{
+			it->second.des = iter->second.description;
+			it->second.heroText = iter->second.heroText;
+		}		
+		else
+		{
+			UIItemEntryTemplate temp;
+			temp.des = iter->second.description;
+			temp.heroText = iter->second.heroText;
+			temp.daylimit = 0;
+			temp.maxGems = 0;
+			temp.exchange1 = 0;
+			temp.exchangeReqId1 = 0;
+			temp.exchange2 = 0;
+			temp.exchangeReqId2 = 0;
+			temp.unbindReqId = 0;
+			temp.useReqId = 0;
+			temp.equipReqId = 0;
+			temp.buyReqId = 0;
+			temp.sellRewId = 0;
+			temp.recoveryRewId = 0;
+			temp.gs = 0;
+			UIItemEntryMap.insert(std::make_pair(iter->first, temp));
+		}
+	}
+
+	//daylimit
+	for (auto iter = DayLimitItemMap.begin(); iter != DayLimitItemMap.end(); iter++)
+	{
+		auto it = UIItemEntryMap.find(iter->first);
+		if (it != UIItemEntryMap.end())
+			it->second.daylimit = iter->second;
+		else
+		{
+			UIItemEntryTemplate temp;
+			temp.des = "";
+			temp.heroText = "";
+			temp.daylimit = iter->second;
+			temp.maxGems = 0;
+			temp.exchange1 = 0;
+			temp.exchangeReqId1 = 0;
+			temp.exchange2 = 0;
+			temp.exchangeReqId2 = 0;
+			temp.unbindReqId = 0;
+			temp.useReqId = 0;
+			temp.equipReqId = 0;
+			temp.buyReqId = 0;
+			temp.sellRewId = 0;
+			temp.recoveryRewId = 0;
+			temp.gs = 0;
+			UIItemEntryMap.insert(std::make_pair(iter->first, temp));
+		}
+	}
+
+	//maxGems
+	for (auto iter = GemCountLimitInfo.begin(); iter != GemCountLimitInfo.end(); iter++)
+	{
+		auto it = UIItemEntryMap.find(iter->entry);
+		if (it != UIItemEntryMap.end())
+			it->second.maxGems = iter->limitCount;
+		else
+		{
+			UIItemEntryTemplate temp;
+			temp.des = "";
+			temp.heroText = "";
+			temp.daylimit = 0;
+			temp.maxGems = iter->limitCount;
+			temp.exchange1 = 0;
+			temp.exchangeReqId1 = 0;
+			temp.exchange2 = 0;
+			temp.exchangeReqId2 = 0;
+			temp.unbindReqId = 0;
+			temp.useReqId = 0;
+			temp.equipReqId = 0;
+			temp.buyReqId = 0;
+			temp.sellRewId = 0;
+			temp.recoveryRewId = 0;
+			temp.gs = 0;
+			UIItemEntryMap.insert(std::make_pair(iter->entry, temp));
+		}
+	}
+
+	//exchange
+	for (auto iter = ItemExchangeInfo.begin(); iter != ItemExchangeInfo.end(); iter++)
+	{
+		auto it = UIItemEntryMap.find(iter->item);
+		if (it != UIItemEntryMap.end())
+		{
+			if (iter->flag == 0)
+			{
+				it->second.exchange1 = iter->exchangeditem;
+				it->second.exchangeReqId1 = iter->reqId;
+			}
+			else
+			{
+				it->second.exchange2 = iter->exchangeditem;
+				it->second.exchangeReqId2 = iter->reqId;
+			}
+		}
+		else
+		{
+			UIItemEntryTemplate temp;
+			temp.des = "";
+			temp.heroText = "";
+			temp.daylimit = 0;
+			temp.maxGems = 0;
+
+			if (iter->flag == 0)
+			{
+				temp.exchange1 = iter->exchangeditem;
+				temp.exchangeReqId1 = iter->reqId;
+				temp.exchange2 = 0;
+				temp.exchangeReqId2 = 0;
+			}
+			else
+			{
+				temp.exchange1 = 0;
+				temp.exchangeReqId1 = 0;
+				temp.exchange2 = iter->exchangeditem;
+				temp.exchangeReqId2 = iter->reqId;
+			}
+			temp.unbindReqId = 0;
+			temp.useReqId = 0;
+			temp.equipReqId = 0;
+			temp.buyReqId = 0;
+			temp.sellRewId = 0;
+			temp.recoveryRewId = 0;
+			temp.gs = 0;
+			UIItemEntryMap.insert(std::make_pair(iter->item, temp));
+		}
+	}
+
+	//unbind
+	for (auto iter = ItemUnbindCostInfo.begin(); iter != ItemUnbindCostInfo.end(); iter++)
+	{
+		auto it = UIItemEntryMap.find(iter->entry);
+		if (it != UIItemEntryMap.end())
+			it->second.unbindReqId = iter->reqId;
+		else
+		{
+			UIItemEntryTemplate temp;
+			temp.des = "";
+			temp.heroText = "";
+			temp.daylimit = 0;
+			temp.maxGems = 0;
+			temp.exchange1 = 0;
+			temp.exchangeReqId1 = 0;
+			temp.exchange2 = 0;
+			temp.exchangeReqId2 = 0;
+			temp.unbindReqId = iter->reqId;
+			temp.useReqId = 0;
+			temp.equipReqId = 0;
+			temp.buyReqId = 0;
+			temp.sellRewId = 0;
+			temp.recoveryRewId = 0;
+			temp.gs = 0;
+			UIItemEntryMap.insert(std::make_pair(iter->entry, temp));
+		}
+	}
+
+	//use
+	for (auto iter = ItemUseVec.begin(); iter != ItemUseVec.end(); iter++)
+	{
+		auto it = UIItemEntryMap.find(iter->entry);
+		if (it != UIItemEntryMap.end())
+			it->second.useReqId = iter->reqId;
+		else
+		{
+			UIItemEntryTemplate temp;
+			temp.des = "";
+			temp.heroText = "";
+			temp.daylimit = 0;
+			temp.maxGems = 0;
+			temp.exchange1 = 0;
+			temp.exchangeReqId1 = 0;
+			temp.exchange2 = 0;
+			temp.exchangeReqId2 = 0;
+			temp.unbindReqId = 0;
+			temp.useReqId = iter->reqId;
+			temp.equipReqId = 0;
+			temp.buyReqId = 0;
+			temp.sellRewId = 0;
+			temp.recoveryRewId = 0;
+			temp.gs = 0;
+			UIItemEntryMap.insert(std::make_pair(iter->entry, temp));
+		}
+	}
+
+	//equip
+	for (auto iter = ItemEquipMap.begin(); iter != ItemEquipMap.end(); iter++)
+	{
+		auto it = UIItemEntryMap.find(iter->first);
+		if (it != UIItemEntryMap.end())
+			it->second.equipReqId = iter->second;
+		else
+		{
+			UIItemEntryTemplate temp;
+			temp.des = "";
+			temp.heroText = "";
+			temp.daylimit = 0;
+			temp.maxGems = 0;
+			temp.exchange1 = 0;
+			temp.exchangeReqId1 = 0;
+			temp.exchange2 = 0;
+			temp.exchangeReqId2 = 0;
+			temp.unbindReqId = 0;
+			temp.useReqId = 0;
+			temp.equipReqId = iter->second;
+			temp.buyReqId = 0;
+			temp.sellRewId = 0;
+			temp.recoveryRewId = 0;
+			temp.gs = 0;
+			UIItemEntryMap.insert(std::make_pair(iter->first, temp));
+		}
+	}
+
+	//buy
+	for (auto iter = ItemBuyVec.begin(); iter != ItemBuyVec.end(); iter++)
+	{
+		auto it = UIItemEntryMap.find(iter->entry);
+		if (it != UIItemEntryMap.end())
+			it->second.buyReqId = iter->reqId;
+		else
+		{
+			UIItemEntryTemplate temp;
+			temp.des = "";
+			temp.heroText = "";
+			temp.daylimit = 0;
+			temp.maxGems = 0;
+			temp.exchange1 = 0;
+			temp.exchangeReqId1 = 0;
+			temp.exchange2 = 0;
+			temp.exchangeReqId2 = 0;
+			temp.unbindReqId = 0;
+			temp.useReqId = 0;
+			temp.equipReqId = 0;
+			temp.buyReqId = iter->reqId;
+			temp.sellRewId = 0;
+			temp.recoveryRewId = 0;
+			temp.gs = 0;
+			UIItemEntryMap.insert(std::make_pair(iter->entry, temp));
+		}
+	}
+
+	//sell
+	for (auto iter = ItemSaleVec.begin(); iter != ItemSaleVec.end(); iter++)
+	{
+		auto it = UIItemEntryMap.find(iter->entry);
+		if (it != UIItemEntryMap.end())
+			it->second.sellRewId = iter->rewId;
+		else
+		{
+			UIItemEntryTemplate temp;
+			temp.des = "";
+			temp.heroText = "";
+			temp.daylimit = 0;
+			temp.maxGems = 0;
+			temp.exchange1 = 0;
+			temp.exchangeReqId1 = 0;
+			temp.exchange2 = 0;
+			temp.exchangeReqId2 = 0;
+			temp.unbindReqId = 0;
+			temp.useReqId = 0;
+			temp.equipReqId = 0;
+			temp.buyReqId = 0;
+			temp.sellRewId = iter->rewId;
+			temp.recoveryRewId = 0;
+			temp.gs = 0;
+			UIItemEntryMap.insert(std::make_pair(iter->entry, temp));
+		}
+	}
+
+	//recovery
+	for (auto iter = RecoveryMap.begin(); iter != RecoveryMap.end(); iter++)
+	{
+		auto it = UIItemEntryMap.find(iter->first);
+		if (it != UIItemEntryMap.end())
+			it->second.recoveryRewId = iter->first;
+		else
+		{
+			UIItemEntryTemplate temp;
+			temp.des = "";
+			temp.heroText = "";
+			temp.daylimit = 0;
+			temp.maxGems = 0;
+			temp.exchange1 = 0;
+			temp.exchangeReqId1 = 0;
+			temp.exchange2 = 0;
+			temp.exchangeReqId2 = 0;
+			temp.unbindReqId = 0;
+			temp.useReqId = 0;
+			temp.equipReqId = 0;
+			temp.buyReqId = 0;
+			temp.sellRewId = 0;
+			temp.recoveryRewId = iter->first;
+			temp.gs = 0;
+			UIItemEntryMap.insert(std::make_pair(iter->first, temp));
+		}
+	}
+
+	//gs
+
+	//recovery
+	for (auto iter = GSVec.begin(); iter != GSVec.end(); iter++)
+	{
+		if (iter->type == GS_TYPE_ITEM_EQUIP || iter->type == GS_TYPE_ITEM_HIDDEN)
+		{
+			auto it = UIItemEntryMap.find(iter->id);
+			if (it != UIItemEntryMap.end())
+				it->second.gs = iter->gs;
+			else
+			{
+				UIItemEntryTemplate temp;
+				temp.des = "";
+				temp.heroText = "";
+				temp.daylimit = 0;
+				temp.maxGems = 0;
+				temp.exchange1 = 0;
+				temp.exchangeReqId1 = 0;
+				temp.exchange2 = 0;
+				temp.exchangeReqId2 = 0;
+				temp.unbindReqId = 0;
+				temp.useReqId = 0;
+				temp.equipReqId = 0;
+				temp.buyReqId = 0;
+				temp.sellRewId = 0;
+				temp.recoveryRewId = 0;
+				temp.gs = iter->gs;
+				UIItemEntryMap.insert(std::make_pair(iter->id, temp));
+			}
+		}
+	}
+}
diff --git a/src/server/scripts/Custom/ItemMod/ItemMod.h b/src/server/scripts/Custom/ItemMod/ItemMod.h
new file mode 100644
index 0000000..8a6e66d
--- /dev/null
+++ b/src/server/scripts/Custom/ItemMod/ItemMod.h
@@ -0,0 +1,479 @@
+/*
+classMask							itemMask
+1			Õ½Ê¿						1			°Ë¼þÌ×
+2			ÆïÊ¿						2			ÊÎÆ·¡¢½äÖ¸¡¢Åû·ç¡¢ÏîÁ´
+4			ÁÔÈË						4			Ë«ÊÖ¡¢¹­¡¢Ç¹¡¢åó
+8			µÁÔô						8			Ö÷ÊÖ¡¢µ¥ÊÖ
+16			ÄÁÊ¦						16			¸±ÊÖ
+32			ËÀÍöÆïÊ¿					32			Ô¶³Ì¡¢Ä§ÕÈ
+64			ÈøÂú						64			³ÄÒÂ
+128			·¨Ê¦						128			Õ½ÅÛ
+256			ÊõÊ¿						256			´ø¹âÐ§µÄÎäÆ÷FM
+1024		µÂÂ³ÒÁ					512			·ûÓ¡
+
+È«Ö°Òµ		classMask	1535		
+´¿ÎïÀí		classMask	45
+´¿·¨Ïµ		classMask	400
+»ìºÏÖ°Òµ		classMask	1090
+flagMsk
+Í¬Ò»¸ömask Ö»ÄÜ³öÏÖÇ¿»¯ÆäÖÐÒ»¸ö
+
+*/
+
+#define TRANS_FLAG_ENCHANT_ID 6000000
+
+//Ç¿»¯Î»ÖÃÊýÁ¿
+
+#define COUNT_SUIT							2
+#define COUNT_ORNAMENT						2
+#define COUNT_2H_WEAPON						3
+#define COUNT_1H_WEAPON						3
+#define COUNT_OFFHAND						3
+#define COUNT_RANGED						3
+#define COUNT_SHIRT							2
+#define COUNT_TABARD						2
+#define COUNT_SIGIL							10
+
+//±£ÁôÇ¿»¯Ð§¹û¿ª¹Ø
+#define KEEP_ENCHANT_SUIT					true
+#define KEEP_ENCHANT_ORNAMENT				true
+#define KEEP_ENCHANT_2H_WEAPON				true
+#define KEEP_ENCHANT_1H_WEAPON				true
+#define KEEP_ENCHANT_OFFHAND				true
+#define KEEP_ENCHANT_RANGED					true
+#define KEEP_ENCHANT_SHIRT					true
+#define KEEP_ENCHANT_TABARD					true
+
+//FMµÈ¶¯×÷·¢ÉúÊ±Ê©·¨µÄÊÓ¾õÐ§¹û¼¼ÄÜID
+#define VISUAL_SPELL_ID						61456
+
+// ²é¿´¹âÐ§FMÊ±¼ä
+#define LOOKUP_WEAPON_PERM_SECONDS			8
+
+//Ã¿Ò³ÏÔÊ¾×î´óFMÐÐÊý
+#define MAX_ROWS_COUNT						25
+
+//·ûÓ¡ÊÇ·ñ×Ô´øFM£¬ÉèÖÃ³õÊ¼ID SIGIL_OWN_ENCHANT_ID_START£¨end = start + COUNT_SIGIL£©
+//SIGIL_OWN_ENCHANT_TITLE_0,SIGIL_OWN_ENCHANT_TITLE_1 ·ûÓ¡¿É×Ô´ø±êÌâ µã»÷»Øµ½µ±Ç°Ò³ Èç¹û²»ÓÃ ¿ÉÉèÖÃÎª -1
+#define SIGIL_OWN_ENCHANT					true
+#define SIGIL_OWN_ENCHANT_ID_START			220000 
+#define SIGIL_OWN_ENCHANT_TITLE_0			220000
+#define SIGIL_OWN_ENCHANT_TITLE_1			220006
+
+
+//¼ø¶¨ºÍ²·ØÔreqId
+#define ITEM_IDENTIFY_REQID					2000
+#define ITEM_ASTROLOGY_REQID				2001
+
+//Ä¬ÈÏÒÆ³ýFM ½ð±ÒÊýÁ¿
+#define DEFAULT_REMOVE_ENCHANT_GOLDS		0
+
+
+
+#define MENU_ID 7890
+#define ACTION_MAINMENU_BACK						1001
+#define ACTION_ITEM_ENCHANT_CURR_MENU_SHOW			1002
+#define ACTION_WEAPON_PERMENCHANT_CURR_MENU_SHOW	1003
+#define ACTION_ITEM_ENCHANT_NEXT_MENU_SHOW			1004
+#define ACTION_WEAPON_PERMENCHANT_NEXT_MENU_SHOW	1005
+#define ACTION_SIGIL_ENCHANT_NEXT_MENU_SHOW			1006
+#define ACTION_ITEM_ENCHANT							1007
+#define ACTION_ITEM_REMOVE_ENCHANT					1008
+#define ACTION_REMOVE_ENCHANT_UNDEFINE				1009
+#define ACTION_ITEM_EXCHANGE						1010
+#define ACTION_ITEM_NO_PATCH_COMPOUND				1015
+#define ACTION_GEM_MENU_SHOW						1011
+#define ACTION_ITEM_REMOVEBIND						1012
+#define ACTION_ITEM_REMOVEGEM						1013
+#define ACTION_ITEM_IDENTIFY						1014
+
+#define ACTION_PREV_PAGE							1016
+
+#define ACTION_WEAPON_LOOKUPANDBUY_SHOW				1017
+#define ACTION_WEAPONPERM_LOOKUP					1028
+#define ACTION_WEAPONPERM_BUY						1029
+#define ACTION_TRANS								1030
+
+const std::string ENCHANT_ACTION_STRING = "ÏâÇ¶";
+const std::string ENCHANT_NAME_STRING	= "·ûÎÄ";
+
+
+
+struct UIItemEntryTemplate
+{
+	std::string des;
+	std::string heroText;
+	uint32 daylimit;
+	uint32 maxGems;
+	uint32 exchange1;
+	uint32 exchangeReqId1;
+	uint32 exchange2;
+	uint32 exchangeReqId2;
+	uint32 unbindReqId;
+	uint32 useReqId;
+	uint32 equipReqId;
+	uint32 buyReqId;
+	uint32 sellRewId;
+	uint32 recoveryRewId;
+	uint32 gs;
+};
+
+extern std::unordered_map<uint32/*entry*/, UIItemEntryTemplate> UIItemEntryMap;
+
+//item buy  equip sale use 
+
+struct ItemBuyTemplate
+{
+	uint32 entry;
+	uint32 reqId;
+};
+extern std::vector<ItemBuyTemplate> ItemBuyVec;
+
+struct ItemVendorBuyTemplate
+{
+	uint32 item;
+	uint32 reqId;
+	uint32 vendor;
+	uint8 clientSlot;
+	uint32 buyMaxCount;
+};
+extern std::vector<ItemVendorBuyTemplate> ItemVendorBuyVec;
+
+extern std::unordered_map<uint32/*entry*/,uint32/*reqId*/> ItemEquipMap;
+
+struct ItemSaleTemplate
+{
+	uint32 entry;
+	uint32 rewId;
+	uint32 rewChance;
+	std::string command;
+};
+extern std::vector<ItemSaleTemplate> ItemSaleVec;
+
+struct ItemUseTemplate
+{
+	uint32 entry;
+	uint32 reqId;
+	uint32 rewId;
+	uint32 rewChance;
+	std::string command;
+	uint32 spellId1;
+	uint32 spellId2;
+	uint32 spellId3;
+};
+extern std::vector<ItemUseTemplate> ItemUseVec;
+
+struct ItemDesTemplate
+{
+	std::string description;
+	std::string heroText;
+};
+
+extern std::unordered_map<uint32, ItemDesTemplate> ItemDesMap;
+
+//Òþ²ØÎïÆ·
+struct HiddenItemTemplate
+{
+	uint32 entry;
+};
+extern std::vector<HiddenItemTemplate> HiddenItemInfo;
+
+//item Mod
+struct ItemModTemplate
+{
+	uint32 entry;
+	uint32 src_entry;
+	float stat_muilt;
+	float mindmg_muilt;
+	float maxdmg_muilt;
+};
+extern std::vector<ItemModTemplate> ItemModVec;
+
+//ItemUnbindCost
+struct ItemUnbindCostTemplate
+{
+	uint32 entry;
+	uint32 reqId;
+};
+extern std::vector<ItemUnbindCostTemplate> ItemUnbindCostInfo;
+
+////È¥³ý±¦Ê¯////
+struct RemoveGemTemplate
+{
+	uint32 entry;
+	uint32 reqId;
+	uint32 chance;
+};
+extern std::vector<RemoveGemTemplate> RemoveGemInfo;
+
+////×°±¸Éý¼¶////
+
+/*
+ALTER TABLE _itemmod_exchange_item ADD destroyOnFail BOOL DEFAULT FALSE AFTER chance;
+ALTER TABLE _itemmod_exchange_item ADD rewIdOnFail INT UNSIGNED DEFAULT 0 AFTER destroy;
+ALTER TABLE _itemmod_exchange_item ADD keepEnchant BOOL DEFAULT TRUE AFTER exchangedItem;
+*/
+
+struct ItemExchangeTemplate
+{
+	uint32 item;
+	uint32 exchangeditem;
+	uint32 reqId;
+	uint32 chance;
+	uint32 flag;//0 ºÏ³É//Ç¿»¯
+	uint32 rewIdOnFail;
+	bool destroyOnFail;
+	bool keepEnchant;
+};
+extern std::vector<ItemExchangeTemplate> ItemExchangeInfo;
+
+////×°±¸Ç¿»¯////
+struct ItemUpgradeTemplate
+{
+	uint32 enchantId;
+	uint32 prevEnchantId;
+	uint32 enchantReqId;
+	uint32 removeEnchantRewId;
+	std::string description;
+	uint32 chance;
+
+	uint32 itemMask;
+	uint32 enchantMask;
+	uint32 classMask;
+};
+extern std::vector<ItemUpgradeTemplate> UpgradeVec;
+
+struct FilterTemplate
+{
+	uint32 enchantId;
+	uint32 prevEnchantId;
+	uint32 enchantReqId;
+	uint32 removeEnchantRewId;
+	std::string description;
+	uint32 chance;
+
+	uint32 itemMask;
+	uint32 enchantMask;
+	uint32 classMask;
+};
+extern std::vector<FilterTemplate> FilterVec;
+
+//±¦Ê¯ÉÏÏÞ
+struct GemCountLimitTemplate
+{
+	uint32 entry;
+	uint32 limitCount;
+};
+extern std::vector<GemCountLimitTemplate> GemCountLimitInfo;
+
+extern std::unordered_map<uint32/*entry*/, uint32/*count*/> GetmCountLimitMap;
+
+//¼ø¶¨ºÍØÔÏó
+struct IdentifyTemplate
+{
+	uint32 entry;
+	uint32 groupId;
+	uint32 reqId;
+	uint32 slot;
+	std::string gossipText;
+	bool slotHasEnchant;
+};
+extern std::vector<IdentifyTemplate> IdentifyVec;
+
+
+struct CreateEnchantTemplate
+{
+	uint32 entry;
+	uint32 groupId;
+	uint8 slot;
+	float chance;
+};
+extern std::vector<CreateEnchantTemplate> CreateEnchantVec;
+
+struct EnchantGroupTemplate
+{
+	uint32 groupId;
+	uint32 enchantId;
+	float chance;
+};
+extern std::vector<EnchantGroupTemplate> EnchantGroupVec;
+extern std::list<uint32> GCAddonEnchantGroupVec;
+
+//×°±¸×é
+struct ItemAddTemplate
+{
+	uint32 categoryId;
+	uint32 entry;
+	uint32 count;
+};
+extern std::vector<ItemAddTemplate> ItemAddVec;
+
+enum ITEM_ENCHANT_TYPES
+{
+	ITEM_ENCHANT_UPGRADE,
+	ITEM_ENCHANT_WEAPON_PERM,
+	ITEM_ENCHANT_SIGIL,
+};
+
+enum ITEM_MASK
+{
+	ITEM_MASK_NONE			=	0,
+	ITEM_MASK_SUIT			=	1,
+	ITEM_MASK_ORNAMENT		=	2,
+	ITEM_MASK_2H_WEAPON		=	4,
+	ITEM_MASK_1H_WEAPON		=	8,
+	ITEM_MASK_OFFHAND		=	16,
+	ITEM_MASK_RANGED		=	32,
+	ITEM_MASK_SHIRT			=	64,
+	ITEM_MASK_TABARD		=	128,
+	ITEM_MASK_WEAPON_PERM	=	256,
+	ITEM_MASK_SIGIL			=	512,
+};
+
+enum RateStoneTypes
+{
+	RATE_ITEM_EXCHANGE_0 = 1,
+	RATE_ITEM_EXCHANGE_1,
+	RATE_ITEM_STRENGTHEN,
+	RATE_SIGIL,
+	RATE_GEM_REMOVE,
+};
+
+struct RateStoneTemplate
+{
+	uint32 entry;
+	RateStoneTypes type;
+	uint32 rate;
+};
+
+extern std::vector<RateStoneTemplate> RateStoneVec;
+
+extern std::vector<uint32 /*itemid*/> CurrencyLikeItemVec;
+
+extern std::unordered_map<uint32, uint32> DayLimitItemMap;
+
+class ItemMod
+{
+public:
+	static ItemMod* instance()
+	{
+		static ItemMod instance;
+		return &instance;
+	}
+
+	void Load();
+	void LoadBuyEquipSaleUse();
+	std::string GetExDes(uint32 entry, uint32 flag = 0);
+	std::string GetUnbindDes(uint32 entry);
+	std::string GetMaxGemDes(uint32 entry);
+
+	uint32 GetBuyReqId(uint32 entry, uint32 vendor, uint8 slot);
+	uint32 GetBuyMaxCount(uint32 entry, uint32 vendor, uint8 slot);
+	uint32 GetEquipInfo(uint32 entry);
+	void GetSaleInfo(uint32 entry, uint32 &rewId, uint32 &rewChance, std::string &command);
+	void GetUseInfo(uint32 entry, uint32 &reqId, uint32 &rewId, uint32 &rewChance, std::string &command, uint32 &spellId1, uint32 &spellId2, uint32 &spellId3);
+
+	uint8 getSlot(uint32 sender); 
+	uint32 getEnchant(uint32 sender);
+	uint32 getGemId(uint32 sender);
+	uint32 senderValue(uint8 slot, uint32 id);
+	std::string GetEnchantDescription(Item* item, uint32 enchantId);
+	std::string GetItemEnchantDescription(Player* player, uint32 enchantId);
+	std::string GetGemName(Item* item, uint8 slot);
+	uint32 getGemId(Item* item, uint8 slot);
+
+	void ExchangeItem(Player* player, Item* item, uint32 update = 0/*0 ºÏ³É 1Ç¿»¯*/);
+	void RemoveBind(Player* player, Item* item);
+	Item* AddItem(Player* player, uint32 itemId, uint32 count);
+	void AddGemList(Player* player, Item* item);
+	void RemoveGem(Player* player, Item* item, uint32 sender);
+	void RemoveItemEnchant(Player* player, Item* item, uint8 slot, uint32 enchantId);
+	void RemoveUndefinEnchant(Player* player, Item* item, uint8 slot, uint32 enchantId);
+
+	uint32 GetItemMask(uint32 entry);
+	bool CanApply(uint32 mask, Item* item, ITEM_ENCHANT_TYPES type = ITEM_ENCHANT_UPGRADE);
+	bool CheckClass(Player* player, uint32 classMask);
+
+	bool hasEnchantByMask(Item* item, uint32 enchantId);
+	void setEnchantMask(Item* item);
+
+	void AddCastMenu(Player* player, Item* item);
+	bool AddItemExchangeMenu(Player* player, Item* item, uint32 update = 0/*0 ºÏ³É 1Ç¿»¯ 2NoPatchItem*/);
+	bool AddItemRemovBindMenu(Player* player, Item* item);
+	bool AddRemoveGemMenu(Player* player, Item* item);
+
+	bool AddItemEnchantMenu(Player* player, Item* item);
+	void AddItemCurrEnchantList(Player* player, Item* item, ITEM_ENCHANT_TYPES type = ITEM_ENCHANT_UPGRADE);
+	void AddItemNextEnchantList(Player* player, Item* item, uint32 sender, ITEM_ENCHANT_TYPES type = ITEM_ENCHANT_UPGRADE);
+	void EnchantItem(Player* player, Item* item, uint8 slot, uint32 enchantId);
+
+	uint8 GetEnchantStartSlot(uint32 itemMask);
+
+	bool IsUpgradeSetted(Player* player, Item* item, ITEM_ENCHANT_TYPES type = ITEM_ENCHANT_UPGRADE);
+
+	//¼ø¶¨ºÍ·âÏó
+	uint32 GetIdentifyGroupId(uint32 entry, EnchantmentSlot slot);
+	uint32 GetIdentifyEnchantId(uint32 entry, EnchantmentSlot slot);
+	void GetIdentifyInfo(uint32 entry, EnchantmentSlot slot, uint32 &reqId, std::string &gossipText, bool &slotHasEnchant);
+	bool AddIdentifyMenu(Player* player, Item* item);
+	
+
+	void RefreshItem(Player* player, Item* item, EnchantmentSlot slot);
+
+
+	void SetFilterVec(Player* player, Item* item, ITEM_ENCHANT_TYPES type, uint32 currEnchantId);
+
+	void LookupOrBuyWeaponPermEnchant(Player* player, Item* item, uint32 sender);
+	void LookupWeaponPermEnchant(Player* player, Item* item, uint32 enchantId);
+	void BuyWeaponPermEnchant(Player* player, Item* item, uint32 enchantId);
+	void AddWeaponPermList(Player* player, Item* item);
+	void RecoverWeaponPermEnchant(Player* player);
+
+	//¼¸ÂÊ±¦Ê¯
+	uint32 GetRate(Player* player, RateStoneTypes type);
+	uint32 GetRateAndDes(Player* player, RateStoneTypes type);
+	//×Ô´øFM
+	uint32 GenerateEnchantId(uint32 entry,uint8 slot);
+
+	//ÏîÁ´³É³¤
+	void NeckUp(Player* player, bool isPVP);
+
+	//»Ã»¯
+	bool HasTransFlag(Item* item);
+
+	void ApplyHiddenItem(Player* player, Item* item, bool apply);
+
+	bool IsCurrencyLike(uint32 itemid);
+
+	void ResetDayLimitItem();
+	std::string GetDayLimitDes(Player* player, uint32 entry);
+
+	std::string GetUseDes(uint32 entry);
+	std::string GetEquipDes(uint32 entry);
+	std::string GetBuyDes(uint32 entry);
+	void GetDes(uint32 entry, std::string &description, std::string &heroText);
+
+	void AddCategoryItem(Player* player, Player* target, uint32 categoryId);
+	
+
+	void UnApplyEquipments(Player* player);
+
+	//void AddEnchant(Player* player, uint32 enchantId);
+	//void LoadEnchant(Player* player);
+	//bool HasEnchant(Player* player, uint32 enchantId);
+
+	bool IsGemLimited(Player* player);
+
+	int32 GetGemCount(Item* pItem, uint32 gemEntry);
+	bool IsGemLimited(Player* player, Item* pItem1, Item* pItem2);
+
+	void SendData(Player* player);
+	std::string GetUIEnchantDescription(Item* item, EnchantmentSlot slot);
+
+
+	void InitUIItemEntryData();
+
+private:
+
+};
+#define sItemMod ItemMod::instance()
diff --git a/src/server/scripts/Custom/ItemMod/NeckUp.cpp b/src/server/scripts/Custom/ItemMod/NeckUp.cpp
new file mode 100644
index 0000000..0fe73e5
--- /dev/null
+++ b/src/server/scripts/Custom/ItemMod/NeckUp.cpp
@@ -0,0 +1,57 @@
+#include "ItemMod.h"
+#include "../GCAddon/GCAddon.h"
+
+#define AT_ID_START 100001
+#define AT_ID_END	110000
+#define SP_ID_START	110001
+#define SP_ID_END	120000
+
+#define AT_ITEM_ENTRY 3
+#define SP_ITEM_ENTRY 38662
+
+
+void ItemMod::NeckUp(Player* player, bool isPVP)
+{
+	if (!isPVP && urand(0, 100) > 30)
+		return;
+
+	Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_NECK);
+
+	if (!item)
+		return;
+	uint32 itemEntry = item->GetEntry();
+
+	if (itemEntry != AT_ITEM_ENTRY && itemEntry != SP_ITEM_ENTRY)
+		return;
+
+	uint32 enchantId = item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT);
+
+	uint32 id_start = 0;
+	uint32 id_end = 0;
+
+	if (itemEntry == AT_ITEM_ENTRY)
+	{
+		id_start = AT_ID_START;
+		id_end = AT_ID_END;
+	}
+	else
+	{
+		id_start = SP_ID_START;
+		id_end = SP_ID_END;
+	}
+
+	if (enchantId < id_start)
+		enchantId = id_start;
+	else
+		enchantId++;
+
+	if (enchantId > id_end)
+		return;
+
+	player->ApplyEnchantment(item, PERM_ENCHANTMENT_SLOT, false);
+	item->SetEnchantment(PERM_ENCHANTMENT_SLOT, enchantId, 0, 0);
+	player->ApplyEnchantment(item, PERM_ENCHANTMENT_SLOT, true);
+
+	//save to db ÐèÒª²âÊÔÒ»ÏÂ
+	//player->SaveToDB(false, false);
+}
diff --git a/src/server/scripts/Custom/ItemMod/NoPatchItem.cpp b/src/server/scripts/Custom/ItemMod/NoPatchItem.cpp
new file mode 100644
index 0000000..03a3dea
--- /dev/null
+++ b/src/server/scripts/Custom/ItemMod/NoPatchItem.cpp
@@ -0,0 +1,1930 @@
+#pragma execution_character_set("utf-8")
+#include "NoPatchItem.h"
+#include "ItemMod.h"
+#include "../GCAddon/GCAddon.h"
+#include "../Requirement/Requirement.h"
+#include "../Reward/Reward.h"
+
+std::unordered_map<uint32, Item*> ItemQueryMap;
+std::unordered_map < uint32, NpTemplate> NpMap;
+std::unordered_map<uint32, std::string> NpPrefixMap;
+std::vector<NpStatTemplate> NpStatVec;
+std::vector<NpSpellTemplate> NpSpellVec;
+std::vector<NpSrcTemplate> NpSrcVec;
+std::vector<_NpItemLevel> NpLevelVec;
+
+std::vector<MapNpTemplate> MapNpVector;
+std::unordered_map<uint32, MapNpTempTemplate> MapNpTempMap;
+std::vector<MapNpStatModTemplate> MapNpStatModVector;
+std::vector<MapNpEnchantTemplate> MapNpEnchantVector;
+std::vector<MapNpWeaponTemplate> MapNpWeaponVector;
+std::vector<_NpItemLevelStatModTemplate> NpLevelStatModVec;
+std::vector<NpAuraTemplate> NpAuraVector;
+std::unordered_map<uint32, NpToLevelTemplate> NpToLevelMap;
+std::vector<NpSameTemplate> NpSameTempIndexVector;
+
+void NoPatchItem::Load()
+{
+	NpMap.clear();
+	NpPrefixMap.clear();
+	NpSrcVec.clear();
+	NpStatVec.clear();
+	NpSpellVec.clear();
+	NpLevelVec.clear();
+	NpLevelStatModVec.clear();
+	NpAuraVector.clear();
+	NpSameTempIndexVector.clear();
+
+	QueryResult result;
+	
+	if (result = WorldDatabase.PQuery("SELECT SrcIndex, SrcEntry, SrcChance From _itemmod_nopatch_src"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			NpSrcTemplate Temp;
+			Temp.SrcIndex = fields[0].GetUInt32();
+			Temp.SrcEntry = fields[1].GetUInt32();
+			Temp.SrcChance = fields[2].GetFloat();
+			NpSrcVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery("SELECT SpellIndex, SpellId, SpellTrigger, SpellCharges, SpellPPMRate, SpellCooldown, SpellCategory, SpellCategoryCooldown,SpellChance "
+		"From _itemmod_nopatch_spell"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			NpSpellTemplate Temp;
+			Temp.SpellIndex						= fields[0].GetUInt32();
+			Temp.Spell.SpellId					= fields[1].GetUInt32();
+			Temp.Spell.SpellTrigger				= fields[2].GetUInt32();
+			Temp.Spell.SpellCharges				= fields[3].GetUInt32();
+			Temp.Spell.SpellPPMRate				= fields[4].GetFloat();
+			Temp.Spell.SpellCooldown			= fields[5].GetInt32();
+			Temp.Spell.SpellCategory			= fields[6].GetUInt32();
+			Temp.Spell.SpellCategoryCooldown	= fields[7].GetInt32();
+			Temp.SpellChance					= fields[8].GetFloat();
+			NpSpellVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery("SELECT StatIndex, ItemStatType, ItemStatMinValue, ItemStatMaxValue,StatChance From _itemmod_nopatch_stat"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			NpStatTemplate Temp;
+			Temp.StatIndex				= fields[0].GetUInt32();
+			Temp.Stat.ItemStatType		= fields[1].GetUInt32();
+			Temp.Stat.ItemStatMinValue	= fields[2].GetUInt32();
+			Temp.Stat.ItemStatMaxValue	= fields[3].GetUInt32();
+			Temp.StatChance				= fields[4].GetUInt32();
+			NpStatVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery("SELECT Entry, StatCount, SpellCount,"
+		"MinDamageMin,MinDamageMax,MaxDamageMin,MaxDamageMax,MinDelay,MaxDelay,SrcIndex,SpellIndex,StatIndex,LevelIndex,Quality,ItemLevel,Suffix From _itemmod_nopatch"))
+	{
+		do
+		{
+			Field* fields				= result->Fetch();
+			uint32 Entry				= fields[0].GetUInt32();
+			NpTemplate Temp;
+			Temp.StatCount				= fields[1].GetUInt32();
+			if (Temp.StatCount > MAX_ITEM_PROTO_STATS)
+				Temp.StatCount = MAX_ITEM_PROTO_STATS;
+			Temp.SpellCount				= fields[2].GetUInt32();
+			if (Temp.SpellCount > MAX_ITEM_PROTO_SPELLS)
+				Temp.SpellCount = MAX_ITEM_PROTO_SPELLS;
+			Temp.Damage.MinDamageMin	= fields[3].GetUInt32();
+			Temp.Damage.MinDamageMax	= fields[4].GetUInt32();
+			Temp.Damage.MaxDamageMin	= fields[5].GetUInt32();
+			Temp.Damage.MaxDamageMax	= fields[6].GetUInt32();
+			Temp.Delay.MinDelay			= fields[7].GetUInt32();
+			Temp.Delay.MaxDelay			= fields[8].GetUInt32();
+			Temp.SrcIndex				= fields[9].GetUInt32();
+			Temp.SpellIndex				= fields[10].GetUInt32();
+			Temp.StatIndex				= fields[11].GetUInt32();			
+			Temp.LevelIndex				= fields[12].GetUInt32();
+			Temp.Quality	= fields[13].GetInt32();
+			Temp.ItemLevel	= fields[14].GetUInt32();
+			Temp.Suffix		= fields[15].GetString();
+
+			NpMap.insert(std::make_pair(Entry, Temp));
+
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery("SELECT ItemStatType, Prefix From _itemmod_nopatch_stat_prefix"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			NpPrefixMap.insert(std::make_pair(fields[0].GetUInt32(), fields[1].GetString()));
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery("SELECT Level, ReqId, Chance, SpellIndex,AddSpellCount,StatIndex,AddStatCount,LevelStatModIndex,DamageLevelType,DamageValue,"
+		"Suffix,ItemLevel,Quality,LevelIndex,EnchantIndex From _itemmod_nopatch_level"))
+	{
+		do
+		{
+			Field* f = result->Fetch();
+			_NpItemLevel Temp;
+			Temp.Level				= f[0].GetUInt8();
+			Temp.ReqId				= f[1].GetUInt32();
+			Temp.Chance				= f[2].GetFloat();
+			Temp.SpellIndex			= f[3].GetUInt32();
+			Temp.AddSpellCount		= f[4].GetUInt32();
+			Temp.StatIndex			= f[5].GetUInt32();
+			Temp.AddStatCount		= f[6].GetUInt32();
+			Temp.LevelStatModIndex	= f[7].GetUInt8();
+
+			if (strcmp("¼ÓÖµ", f[8].GetCString()) == 0)
+				Temp.DamageLevelType = TYPE_ADD_VALUE;
+			else
+				Temp.DamageLevelType = TYPE_MUI_VALUE;
+			Temp.DamageValue		= f[9].GetFloat();
+
+			Temp.Suffix				= f[10].GetString();
+			Temp.ItemLevel			= f[11].GetUInt32();
+			Temp.Quality			= f[12].GetUInt32();
+			Temp.LevelIndex			= f[13].GetUInt32();
+			Temp.EnchantIndex		= f[14].GetUInt32();
+			NpLevelVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery("SELECT LevelStatModIndex, StatType, ModType, StatValue From _itemmod_nopatch_level_statmod"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			_NpItemLevelStatModTemplate Temp;
+			Temp.LevelStatModIndex = fields[0].GetUInt32();
+			Temp.StatType = fields[1].GetUInt32();
+
+
+			if (strcmp("¼ÓÖµ", fields[2].GetCString()) == 0)
+				Temp.ModType = TYPE_ADD_VALUE;
+			else
+				Temp.ModType = TYPE_MUI_VALUE;
+
+			Temp.StatValue = fields[3].GetFloat();
+			NpLevelStatModVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery("SELECT LevelIndex, Level, Count, RewId, Aura1, Aura2, Aura3, Aura4, Aura5 From _itemmod_nopatch_aura"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			NpAuraTemplate Temp;
+			Temp.LevelIndex = fields[0].GetUInt32();
+			Temp.Level		= fields[1].GetUInt32();
+			Temp.Count		= fields[2].GetUInt32();
+			Temp.RewId		= fields[3].GetUInt32();
+			for (size_t i = 0; i < 5; i++)
+				Temp.Auras[i] = fields[4 + i].GetUInt32();
+			NpAuraVector.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery("SELECT Entry, Level, Chance From _itemmod_nopatch_tolevel"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 Entry = fields[0].GetUInt32();
+			NpToLevelTemplate Temp;
+			Temp.level = fields[1].GetUInt32();
+			Temp.chance = fields[2].GetFloat();
+			NpToLevelMap.insert(std::make_pair(Entry, Temp));
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery("SELECT SrcTempIndex, TargetTempIndex, MeetLevel, RewId From _itemmod_nopatch_compound"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 SrcTempIndex = fields[0].GetUInt32();
+			NpSameTemplate Temp;
+			Temp.SrcTempIndex		= fields[0].GetUInt32();
+			Temp.TargetTempIndex	= fields[1].GetUInt32();
+			Temp.MeetLevel			= fields[2].GetUInt32();
+			Temp.RewId				= fields[3].GetUInt32();
+			NpSameTempIndexVector.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	LoadMap();
+}
+
+void NoPatchItem::LoadMap()
+{
+	MapNpVector.clear();
+	MapNpTempMap.clear();
+	MapNpStatModVector.clear();
+	MapNpEnchantVector.clear();
+	MapNpWeaponVector.clear();
+
+	QueryResult result;
+	//											0		1		2		3			4
+	if (result = WorldDatabase.PQuery("SELECT MapId, Diff, ChallengeLv,TempIndex,TempChance From _itemmod_nopatch_map"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			MapNpTemplate Temp;
+			Temp.MapId			= fields[0].GetUInt32();
+			Temp.Diff			= Difficulty(fields[1].GetUInt8());
+			Temp.ChallengeLv	= fields[2].GetUInt32();
+			Temp.TempIndex		= fields[3].GetUInt32();
+			Temp.Chance			= fields[4].GetFloat();
+			MapNpVector.push_back(Temp);
+
+		} while (result->NextRow());
+	}
+
+	//											0			1		2		3			4			5	
+	if (result = WorldDatabase.PQuery("SELECT TempIndex,Quality,ItemLevel,EnchantIndex,Suffix,LeveIndex,"
+		//		6		7				8		9		10			11			12	
+		"StatModIndex,StatAddData,StatOverData,SpellIndex,SpellCount, WeaponIndex,SellRewId,Prefix From _itemmod_nopatch_map_temp"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 TempIndex = fields[0].GetUInt32();
+			MapNpTempTemplate Temp;
+			Temp.Quality		= fields[1].GetUInt32();
+			Temp.ItemLevel		= fields[2].GetUInt32();
+			Temp.EnchantIndex	= fields[3].GetUInt32();
+			Temp.Suffix			= fields[4].GetString();
+			Temp.LevelIndex		= fields[5].GetUInt32();
+			Temp.StatModIndex	= fields[6].GetUInt32();
+
+			Tokenizer StatAdd(fields[7].GetString(), '#');
+			for (Tokenizer::const_iterator itr = StatAdd.begin(); itr != StatAdd.end(); ++itr)
+			{
+				Tokenizer data(*itr, ',');
+				if (data.size() > 1)
+					Temp.StatAddMap.insert(std::make_pair(atoi(data[0]), atoi(data[1])));
+			}
+
+			Tokenizer StatOver(fields[8].GetString(), '#');
+			for (Tokenizer::const_iterator itr = StatOver.begin(); itr != StatOver.end(); ++itr)
+			{
+				Tokenizer data(*itr, ',');
+				if (data.size() > 1)
+					Temp.StatOverMap.insert(std::make_pair(atoi(data[0]), atoi(data[1])));
+			}
+
+			Temp.SpellIndex		= fields[9].GetInt32();
+			Temp.SpellCount		= fields[10].GetUInt32();
+			if (Temp.SpellCount > MAX_ITEM_PROTO_SPELLS)
+				Temp.SpellCount = MAX_ITEM_PROTO_SPELLS;
+			Temp.WeaponIndex	= fields[11].GetUInt32();
+			Temp.SellRewId		= fields[12].GetUInt32();
+			Temp.Prefix			= fields[13].GetString();
+			MapNpTempMap.insert(std::make_pair(TempIndex, Temp));
+
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery("SELECT StatModIndex, StatType, ModStatMin, ModStatMax From _itemmod_nopatch_map_statmod"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			MapNpStatModTemplate Temp;
+			Temp.StatModIndex	= fields[0].GetUInt32();
+			Temp.StatType		= fields[1].GetUInt32();
+			Temp.ModStatMin		= fields[2].GetFloat();
+			Temp.ModStatMax		= fields[3].GetFloat();
+			MapNpStatModVector.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery("SELECT EnchantIndex, Slot, EnchantGroupId From _itemmod_nopatch_map_enchant"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			MapNpEnchantTemplate Temp;
+			Temp.EnchantIndex	= fields[0].GetUInt32();
+			Temp.Slot			= fields[1].GetUInt8();
+			Temp.EnchantGroupId = fields[2].GetUInt32();
+			MapNpEnchantVector.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	if (result = WorldDatabase.PQuery("SELECT WeaponIndex, SubClass, MinDamageMod, MaxDamageMod, MinDamageMin,MinDamageMax,MaxDamageMin,MaxDamageMax,MinDelay,MaxDelay From _itemmod_nopatch_map_weapon"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			MapNpWeaponTemplate Temp;
+			Temp.WeaponIndex			= fields[0].GetUInt32();
+			Temp.SubClass				= fields[1].GetUInt32();
+			Temp.MinDamageMod			= fields[2].GetFloat();
+			Temp.MaxDamageMod			= fields[3].GetFloat();
+			if (Temp.MaxDamageMod < Temp.MinDamageMod)
+				Temp.MaxDamageMod = Temp.MinDamageMod;
+			Temp.Damage.MinDamageMin	= fields[4].GetUInt32();
+			Temp.Damage.MinDamageMax	= fields[5].GetUInt32();
+			if (Temp.Damage.MinDamageMax < Temp.Damage.MinDamageMin)
+				Temp.Damage.MinDamageMax = Temp.Damage.MinDamageMin;
+			Temp.Damage.MaxDamageMin	= fields[6].GetUInt32();
+			Temp.Damage.MaxDamageMax	= fields[7].GetUInt32();
+			if (Temp.Damage.MaxDamageMax < Temp.Damage.MaxDamageMin)
+				Temp.Damage.MaxDamageMax = Temp.Damage.MaxDamageMin;
+			Temp.Delay.MinDelay			= fields[8].GetUInt32();
+			Temp.Delay.MaxDelay			= fields[9].GetUInt32();
+			if (Temp.Delay.MaxDelay	 < Temp.Delay.MinDelay)
+				Temp.Delay.MaxDelay = Temp.Delay.MinDelay;
+			MapNpWeaponVector.push_back(Temp);
+		} while (result->NextRow());
+	}
+}
+
+bool NoPatchItem::CalBase(uint32 entry, uint32 &SrcIndex, uint32 &SpellIndex, uint32 &SpellCount, uint32 &StatIndex, uint32 &StatCount, 
+	uint32 &minDamage, uint32 &maxDamage, uint32 &delay, std::string &Suffix, uint32 &ItemLvel, int32 &Quality)
+
+{
+	std::unordered_map < uint32, NpTemplate>::iterator itr = NpMap.find(entry);
+
+	if (itr != NpMap.end())
+	{
+		SrcIndex = itr->second.SrcIndex;
+		SpellIndex = itr->second.SpellIndex;
+		SpellCount = itr->second.SpellCount;
+		StatIndex = itr->second.StatIndex;
+		StatCount = itr->second.StatCount;
+		minDamage = urand(itr->second.Damage.MinDamageMin, itr->second.Damage.MinDamageMax);
+		maxDamage = urand(itr->second.Damage.MaxDamageMin, itr->second.Damage.MaxDamageMax);
+		delay = urand(itr->second.Delay.MinDelay, itr->second.Delay.MaxDelay);
+		Suffix = itr->second.Suffix;
+		Quality = itr->second.Quality;
+		ItemLvel = itr->second.ItemLevel;
+		return true;
+	}
+	return false;
+}
+
+bool NoPatchItem::CalLevel(Item* item, uint32 &L_ReqId, float &L_Chance,
+	uint32 &L_SpellIndex, uint32 &L_AddSpellCount, uint32 &L_StatIndex, uint32 &L_AddStatCount,
+	uint8 &L_LevelStatModIndex, NpLevelTypes &L_DamageLevelType, float &L_DamageValue,
+	std::string &L_Suffix, uint32 &L_ItemLvel, uint32 &L_Quality, uint32 &L_EnchantIndex)
+
+{
+	if (item->MapData > 0)
+	{
+		auto itr = MapNpTempMap.find(item->TempIndex);
+
+		if (itr != MapNpTempMap.end())
+		{
+			for (auto i = NpLevelVec.begin(); i != NpLevelVec.end(); i++)
+			{
+				if (itr->second.LevelIndex == i->LevelIndex && GetMapLevelNow(item->MapData) == i->Level)
+				{
+					L_ReqId = i->ReqId;
+					L_Chance = i->Chance;
+					L_SpellIndex = i->SpellIndex;
+					L_AddSpellCount = i->AddSpellCount;
+					L_StatIndex = i->StatIndex;
+					L_AddStatCount = i->AddStatCount;
+					L_LevelStatModIndex = i->LevelStatModIndex;
+					L_DamageLevelType = i->DamageLevelType;
+					L_DamageValue = i->DamageValue;
+					L_Suffix = i->Suffix;
+					L_ItemLvel = i->ItemLevel;
+					L_Quality = i->Quality;
+					L_EnchantIndex = i->EnchantIndex;
+					return true;
+				}
+			}
+		}
+	}
+
+	if (item->LevelData > 0 && item->MapData == 0)
+	{
+		uint64 LevelData = item->LevelData;
+		uint32 LevelEntry = GetLevelEntry(LevelData);
+		uint8 LevelNow = GetLevelNow(LevelData);
+
+		auto iter = NpMap.find(LevelEntry);
+
+		if (iter != NpMap.end())
+		{
+			for (auto i = NpLevelVec.begin(); i != NpLevelVec.end(); i++)
+			{
+				if (LevelNow == i->Level && iter->second.LevelIndex == i->LevelIndex)
+				{
+					L_ReqId = i->ReqId;
+					L_Chance = i->Chance;
+					L_SpellIndex = i->SpellIndex;
+					L_AddSpellCount = i->AddSpellCount;
+					L_StatIndex = i->StatIndex;
+					L_AddStatCount = i->AddStatCount;
+					L_LevelStatModIndex = i->LevelStatModIndex;
+					L_DamageLevelType = i->DamageLevelType;
+					L_DamageValue = i->DamageValue;
+					L_Suffix = i->Suffix;
+					L_ItemLvel = i->ItemLevel;
+					L_Quality = i->Quality;
+					L_EnchantIndex = i->EnchantIndex;
+					return true;
+				}
+			}
+		}
+	}
+
+	return false;
+}
+
+bool NoPatchItem::GetExchange(Item* item, uint32 &L_ReqId, float &L_Chance)
+{
+	if (item->MapData > 0)
+	{
+		auto itr = MapNpTempMap.find(item->TempIndex);
+
+		if (itr != MapNpTempMap.end())
+		{
+			for (auto i = NpLevelVec.begin(); i != NpLevelVec.end(); i++)
+			{
+				if (itr->second.LevelIndex == i->LevelIndex && GetMapLevelNow(item->MapData) == i->Level)
+				{
+					L_ReqId = i->ReqId;
+					L_Chance = i->Chance;
+					return true;
+				}
+			}
+		}
+	}
+	
+	if (item->LevelData > 0 && item->MapData == 0)
+	{
+		uint64 LevelData = item->LevelData;
+		uint32 LevelEntry = GetLevelEntry(LevelData);
+		uint8 LevelNow = GetLevelNow(LevelData);
+
+		auto iter = NpMap.find(LevelEntry);
+
+		if (iter != NpMap.end())
+		{
+			for (auto i = NpLevelVec.begin(); i != NpLevelVec.end(); i++)
+			{
+				if (LevelNow == i->Level && iter->second.LevelIndex == i->LevelIndex)
+				{
+					L_ReqId = i->ReqId;
+					L_Chance = i->Chance;
+					return true;
+				}
+			}
+		}
+	}
+	
+	return false;
+}
+
+uint32 NoPatchItem::GetSellRewId(Item* item)
+{
+	auto iter = MapNpTempMap.find(item->TempIndex);
+	if (iter != MapNpTempMap.end())
+		return iter->second.SellRewId;
+
+	return 0;
+}
+
+std::string NoPatchItem::GetPrefix(Item* item)
+{
+	uint32 ItemStatType = MAX_ITEM_MOD;
+	uint32 max = 0;
+
+	for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+		if (item->Stats[i].ItemStatValue > max)
+			max = item->Stats[i].ItemStatValue;
+
+	for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+		if (item->Stats[i].ItemStatValue == max && item->Stats[i].ItemStatValue != 0)
+			ItemStatType = item->Stats[i].ItemStatType;
+
+	std::unordered_map<uint32, std::string>::iterator itr = NpPrefixMap.find(ItemStatType);
+
+	if (itr != NpPrefixMap.end())
+		return itr->second;
+
+	return "";
+}
+
+bool SrcSort(const NpSrcTemplate &a, const NpSrcTemplate &b){
+	return a.SrcChance < b.SrcChance;
+}
+
+bool StatSort(const NpStatTemplate &a, const NpStatTemplate &b){
+	return a.StatChance < b.StatChance;
+}
+
+bool SpellSort(const NpSpellTemplate &a, const NpSpellTemplate &b){
+	return a.SpellChance <  b.SpellChance;
+	;
+}
+
+uint32 NoPatchItem::GetRandomSrcEntry(uint32 SrcIndex)
+{
+	if (NpSrcVec.empty())
+		return 0;
+
+	uint32 srcEntry = 0;
+
+	std::vector<NpSrcTemplate> vtMap;
+
+	for (size_t i = 0; i < NpSrcVec.size(); i++)
+		if (SrcIndex == NpSrcVec[i].SrcIndex)
+			vtMap.push_back(NpSrcVec[i]);
+
+	if (vtMap.empty())
+		return srcEntry;
+
+
+	sort(vtMap.begin(), vtMap.end(), SrcSort);
+
+
+	float sum = 0;
+
+	for (auto it = vtMap.begin(); it != vtMap.end(); it++)
+		sum += it->SrcChance;
+
+	float rand = frand(0, sum);
+
+	sum = 0;
+
+	for (auto it = vtMap.begin(); it != vtMap.end(); it++)
+	{
+		sum += it->SrcChance;
+		if (rand < sum)
+		{
+			srcEntry = it->SrcEntry;
+			break;
+		}
+	}
+
+	return srcEntry;
+}
+
+uint32 NoPatchItem::GetRandomTempIndex(uint32 MapId, Difficulty Diff, uint32 ChallengeLv)
+{
+	if (MapNpVector.empty())
+		return 0;
+
+
+	uint32 TempIndex = 0;
+
+	std::vector<std::pair<int, float>> vtMap;
+
+	for (auto it = MapNpVector.begin(); it != MapNpVector.end(); it++)
+		if (it->MapId == MapId && it->Diff == Diff && it->ChallengeLv == ChallengeLv)
+			vtMap.push_back(std::make_pair(it->TempIndex, it->Chance));
+
+	sort(vtMap.begin(), vtMap.end(),
+		[](const std::pair<int, float> &x, const std::pair<int, float> &y) -> int {
+		return x.second < y.second;
+	});
+
+	float sum = 0;
+
+	for (auto it = vtMap.begin(); it != vtMap.end(); it++)
+		sum += it->second;
+
+	float rand = frand(0, sum);
+
+	sum = 0;
+
+	for (auto it = vtMap.begin(); it != vtMap.end(); it++)
+	{
+		sum += it->second;
+		if (rand <= sum)
+		{
+			TempIndex = it->first;
+			break;
+		}
+	}
+
+	return TempIndex;
+}
+
+_Spell NoPatchItem::GetRandomSpell(_Spell Spells[MAX_ITEM_PROTO_SPELLS], uint32 SpellIndex)
+{
+	_Spell Spell;
+	Spell.SpellCategory = 0;
+	Spell.SpellCategoryCooldown = -1;
+	Spell.SpellCharges = 0;
+	Spell.SpellCooldown = -1;
+	Spell.SpellId = 0;
+	Spell.SpellPPMRate = 0;
+	Spell.SpellTrigger = 0;
+
+	if (NpSpellVec.empty())
+		return Spell;
+
+	
+	std::vector<NpSpellTemplate> vtMap;
+
+	for (size_t i = 0; i < NpSpellVec.size(); i++)
+		if (SpellIndex == NpSpellVec[i].SpellIndex)
+		{
+			bool exsit = false;
+			for (size_t j = 0; j < MAX_ITEM_PROTO_SPELLS; j++)
+				if (NpSpellVec[i].Spell.SpellId == Spells[j].SpellId)
+					exsit = true;
+
+			if (!exsit)
+				vtMap.push_back(NpSpellVec[i]);
+		}
+			
+
+	if (vtMap.empty())
+		return Spell;
+
+	sort(vtMap.begin(), vtMap.end(), SpellSort);
+
+	
+	float total = 0;
+	for (auto it = vtMap.begin(); it != vtMap.end(); it++)
+		total += it->SpellChance;
+
+	float rand = frand(0, total);
+
+	float sum = 0;
+	
+	for (auto it = vtMap.begin(); it != vtMap.end();++it)
+	{
+		sum += it->SpellChance;
+	
+		if (rand < sum)
+			return it->Spell;
+	}
+	
+	return Spell;
+}
+
+_ItemStat NoPatchItem::GetRandomStat(uint32 StatIndex)
+{
+	_ItemStat Stat;
+	Stat.ItemStatType = 0;
+	Stat.ItemStatValue = 0;
+
+	if (NpStatVec.empty())
+		return Stat;
+
+	std::vector<NpStatTemplate> vtMap;
+
+	for (size_t i = 0; i < NpStatVec.size(); i++)
+		if (StatIndex == NpStatVec[i].StatIndex)
+			vtMap.push_back(NpStatVec[i]);
+
+	if (vtMap.empty())
+		return Stat;
+
+
+	sort(vtMap.begin(), vtMap.end(), StatSort);
+
+
+	float sum = 0;
+
+	for (auto it = vtMap.begin(); it != vtMap.end(); it++)
+		sum += it->StatChance;
+
+	float rand = frand(0, sum);
+
+	sum = 0;
+
+	for (auto it = vtMap.begin(); it != vtMap.end(); it++)
+	{
+		sum += it->StatChance;
+		if (rand < sum)
+		{
+			Stat.ItemStatType = it->Stat.ItemStatType;
+			Stat.ItemStatValue = urand(it->Stat.ItemStatMinValue, it->Stat.ItemStatMaxValue);
+			break;
+		}
+	}
+
+	return Stat;
+}
+
+void NoPatchItem::MergeStat(_ItemStat(&Stats)[MAX_ITEM_PROTO_STATS])
+{
+	for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+	{
+		for (size_t j = i + 1; j < MAX_ITEM_PROTO_STATS; j++)
+		{
+			if (Stats[i].ItemStatType == Stats[j].ItemStatType)
+			{
+				Stats[i].ItemStatValue += Stats[j].ItemStatValue;
+				Stats[j].ItemStatType = 0;
+				Stats[j].ItemStatValue = 0;
+			}
+		}
+	}
+}
+
+bool NoPatchItem::Create(Player* owner, Item* item)
+{
+	if (item->IsNoPatch())
+		return false;
+
+	uint32 entry = item->GetEntry();
+
+	uint32 SrcIndex = 0;
+	uint32 SpellIndex = 0;
+	uint32 SpellCount = 0;
+	uint32 StatIndex = 0;
+	uint32 StatCount = 0;
+	uint32 MinDamage = 0;
+	uint32 MaxDamage = 0;
+	uint32 Delay = 0;
+	std::string Suffix = "";
+	int32 Quality = 0;
+	uint32 ItemLevel = 300;
+
+	if (!CalBase(entry, SrcIndex, SpellIndex, SpellCount, StatIndex, StatCount, MinDamage, MaxDamage, Delay, Suffix, ItemLevel, Quality))
+		return false;
+
+	uint32 srcEntry = SrcIndex == 0 ? entry : GetRandomSrcEntry(SrcIndex);
+
+	const ItemTemplate* srcTemp = sObjectMgr->GetItemTemplate(srcEntry);
+
+	if (!srcTemp)
+		return false;
+
+	Item* pItem;
+
+	if (Quality < 0)
+		pItem = owner->AddItemById(entry, 1);
+	else
+		pItem = owner->AddItemById(srcEntry, 1);
+
+	if (!pItem)
+		return false;
+
+	if (Quality < 0)
+	{
+		//ÉèÖÃÐÂÎïÆ·
+		pItem->Name = srcTemp->Name1 + Suffix;
+		pItem->LevelData = GetLevelData(entry, 1, srcTemp->Quality, ItemLevel);
+
+		//²úÉú¼¼ÄÜ
+		_Spell NewSpells[MAX_ITEM_PROTO_SPELLS];
+
+		for (size_t i = 0; i < MAX_ITEM_PROTO_SPELLS; i++)
+			NewSpells[i] = srcTemp->Spells[i];
+
+		uint32 count = 0;
+
+		for (size_t i = 0; i < MAX_ITEM_PROTO_SPELLS; i++)
+		{
+			if (count >= SpellCount)
+				continue;
+
+			if (NewSpells[i].SpellId == 0)
+			{
+				NewSpells[i] = GetRandomSpell(NewSpells, SpellIndex);
+				count++;
+			}
+		}
+
+		for (size_t i = 0; i < MAX_ITEM_PROTO_SPELLS; i++)
+			pItem->Spells[i] = NewSpells[i];
+
+		//²úÉúÊôÐÔ
+		for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+		{
+			pItem->Stats[i] = srcTemp->ItemStat[i];
+			pItem->Stats[i].ItemStatValue = srcTemp->ItemStat[i].ItemStatValue * abs(Quality);
+		}
+		
+
+		//²úÉúÊôÐÔ
+		_ItemStat NewStats[MAX_ITEM_PROTO_STATS];
+
+		for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+		{
+			NewStats[i] = srcTemp->ItemStat[i];
+			NewStats[i].ItemStatValue = srcTemp->ItemStat[i].ItemStatValue * abs(Quality);
+		}
+
+		count = 0;
+
+		for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+		{
+			if (count >= StatCount)
+				continue;
+
+			if (NewStats[i].ItemStatType == 0 && NewStats[i].ItemStatValue == 0)
+			{
+				NewStats[i] = GetRandomStat(StatIndex);
+				count++;
+			}
+		}
+
+		MergeStat(NewStats);
+
+		for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+			pItem->Stats[i] = NewStats[i];
+
+		pItem->Damages[0].DamageMin = srcTemp->Damage[0].DamageMin;// *abs(Quality);
+		pItem->Damages[0].DamageMax = srcTemp->Damage[0].DamageMax;// *abs(Quality);
+		pItem->NpDelay = srcTemp->Delay;
+	}
+	else
+	{
+		//ÉèÖÃÐÂÎïÆ·
+		pItem->Name = srcTemp->Name1 + Suffix;
+		pItem->LevelData = GetLevelData(entry, 1, Quality, ItemLevel);
+
+		//²úÉú¼¼ÄÜ
+		for (size_t i = 0; i < SpellCount; i++)
+			pItem->Spells[i] = GetRandomSpell(pItem->Spells,SpellIndex);
+
+		//²úÉúÊôÐÔ
+		for (size_t i = 0; i < StatCount; i++)
+			pItem->Stats[i] = GetRandomStat(StatIndex);
+
+		//ºÏ²¢ÊôÐÔ
+		MergeStat(pItem->Stats);
+
+		//²úÉúÇ°×º
+		pItem->Name = GetPrefix(pItem) + pItem->Name;
+
+		pItem->Damages[0].DamageMin = MinDamage;
+		pItem->Damages[0].DamageMax = MaxDamage;
+		pItem->NpDelay = Delay;
+	}
+	
+	//ÉèÖÃflag query data
+	pItem->SetUInt32Value(ITEM_FIELD_PROPERTY_SEED, GetQueryId(pItem));
+	//SetItemFlag(pItem);
+	pItem->SetState(ITEM_CHANGED, owner);
+	ItemQueryMap[pItem->GetGUIDLow()] = pItem;
+
+	//´Ý»ÙÔ­ÎïÆ·
+	owner->DestroyItem(item->GetBagSlot(), item->GetSlot(), true);
+
+	return true;
+}
+
+Item* NoPatchItem::GetSameItem(Player* owner, Item* item)
+{
+	uint8 level = GetLevelNow(item->LevelData);
+
+	for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+		if (Item* pItem = owner->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+			if (pItem->IsNoPatch() && pItem->GetGUID() != item->GetGUID() && pItem->GetEntry() == item->GetEntry() && GetLevelNow(pItem->LevelData) == level)
+				return pItem;
+
+	for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
+		if (Item* pItem = owner->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+			if (pItem->IsNoPatch() && pItem->GetGUID() != item->GetGUID() && pItem->GetEntry() == item->GetEntry() && GetLevelNow(pItem->LevelData) == level)
+				return pItem;
+
+	for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+		if (Bag* pBag = owner->GetBagByPos(i))
+			for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+				if (Item* pItem = owner->GetItemByPos(i, j))
+					if (pItem->IsNoPatch() && pItem->GetGUID() != item->GetGUID() && pItem->GetEntry() == item->GetEntry() && GetLevelNow(pItem->LevelData) == level)
+						return pItem;
+
+	return NULL;
+}
+
+bool NoPatchItem::CanCompound(Item* item)
+{
+	if (!item->IsNoPatch())
+		return false;
+
+	uint32 level = GetLevelNow(item->LevelData) - 1;
+
+	for (auto itr = NpSameTempIndexVector.begin(); itr != NpSameTempIndexVector.end(); itr++)
+		if (itr->MeetLevel == level && itr->SrcTempIndex == item->TempIndex)
+			return true;
+	
+	return false;
+}
+
+void NoPatchItem::GetTargetTemp(Item* item, uint32 &TargetTempIndex, uint32 &RewId)
+{
+	if (!item->IsNoPatch())
+		return;
+
+	uint32 level = GetLevelNow(item->LevelData) - 1;
+
+	for (auto itr = NpSameTempIndexVector.begin(); itr != NpSameTempIndexVector.end(); itr++)
+		if (itr->MeetLevel == level && itr->SrcTempIndex == item->TempIndex)
+		{
+			TargetTempIndex = itr->TargetTempIndex;
+			RewId = itr->RewId;
+		}
+}
+
+bool NoPatchItem::Compound(Player* owner, Item* item1)
+{
+	if (!item1->IsNoPatch())
+	{
+		owner->GetSession()->SendNotification("²»ÊÇNoPathItem");
+		return false;
+	}
+	
+	const ItemTemplate* proto = item1->GetTemplate();
+	if (!proto)
+		return false;
+
+	uint32 TempIndex = 0;
+	uint32 RewId = 0;
+
+	GetTargetTemp(item1, TempIndex, RewId);
+
+	if (TempIndex == 0)
+		return false;
+	
+	Item* item2 = GetSameItem(owner, item1);
+
+	if (!item2)
+	{
+		owner->GetSession()->SendNotification("Î´ÕÒµ½ÍêÈ«ÏàÍ¬µÄÁ½¼þÎïÆ·");
+		return false;
+	}
+
+	auto itr = MapNpTempMap.find(TempIndex);
+
+	if (itr != MapNpTempMap.end())
+	{
+		Item* item = owner->AddItemById(item1->GetEntry(), item1->GetCount());
+
+		if (!item)
+			return false;
+
+		item->Name = proto->Name1 + itr->second.Suffix;
+
+		if (itr->second.Quality > 0)
+			item->LevelData = GetLevelData(item->GetEntry(), 1, itr->second.Quality, itr->second.ItemLevel);
+		else
+			item->LevelData = GetLevelData(item->GetEntry(), 1, proto->Quality, itr->second.ItemLevel);
+
+		item->MapData = GetMapData(1, 1, 0, 0);
+
+		//²úÉú¼¼ÄÜ
+		//¸½¼Ó¶îÍâ¼¼ÄÜ
+		if (itr->second.SpellIndex > 0)
+		{
+			_Spell NewSpells[MAX_ITEM_PROTO_SPELLS];
+
+			for (size_t i = 0; i < MAX_ITEM_PROTO_SPELLS; i++)
+				NewSpells[i] = proto->Spells[i];
+
+			uint32 count = 0;
+
+			for (size_t i = 0; i < MAX_ITEM_PROTO_SPELLS; i++)
+			{
+				if (count >= itr->second.SpellCount)
+					continue;
+
+				if (NewSpells[i].SpellId == 0)
+				{
+					NewSpells[i] = GetRandomSpell(NewSpells, itr->second.SpellIndex);
+					count++;
+				}
+			}
+
+			for (size_t i = 0; i < MAX_ITEM_PROTO_SPELLS; i++)
+				item->Spells[i] = NewSpells[i];
+		}
+		//¶îÍâ¼¼ÄÜ
+		else if (itr->second.SpellIndex < 0)
+		{
+			//²úÉú¼¼ÄÜ
+			for (size_t i = 0; i < itr->second.SpellCount; i++)
+				item->Spells[i] = GetRandomSpell(item->Spells, abs(itr->second.SpellIndex));
+		}
+		else
+		{
+			for (size_t i = 0; i < MAX_ITEM_PROTO_SPELLS; i++)
+				item->Spells[i] = proto->Spells[i];
+		}
+
+		//Ô­ÊôÐÔ·­±¶
+		for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+			item->Stats[i] = proto->ItemStat[i];
+
+		for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+		{
+			uint32 StatType = item->Stats[i].ItemStatType;
+
+			for (auto it = MapNpStatModVector.begin(); it != MapNpStatModVector.end(); it++)
+			{
+				if (it->StatModIndex == itr->second.StatModIndex && it->StatType == StatType && item->Stats[i].ItemStatValue > 0)
+				{
+					float mod = frand(it->ModStatMin, it->ModStatMax);
+					item->Stats[i].ItemStatValue *= mod;
+					break;
+				}
+			}
+		}
+
+		//¸½¼Ó¶îÍâÊôÐÔ
+		if (itr->second.StatOverMap.empty())
+		{
+			_ItemStat NewStats[MAX_ITEM_PROTO_STATS];
+			for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+				NewStats[i] = item->Stats[i];
+
+			uint32 total = 0;
+
+			for (auto it = itr->second.StatAddMap.begin(); it != itr->second.StatAddMap.end(); it++)
+			{
+				if (total >= MAX_ITEM_PROTO_STATS)
+					continue;
+
+				uint32 count = 0;
+
+				for (size_t i = total; i < MAX_ITEM_PROTO_STATS; i++)
+				{
+					if (count >= it->second)
+						continue;
+
+					if (NewStats[i].ItemStatType == 0 && NewStats[i].ItemStatValue == 0)
+					{
+						NewStats[i] = GetRandomStat(it->first);
+						count++;
+						total++;
+					}
+				}
+			}
+
+			MergeStat(NewStats);
+
+			for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+				item->Stats[i] = NewStats[i];
+		}
+		else
+		{
+			for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+			{
+				item->Stats[i].ItemStatType = 0;
+				item->Stats[i].ItemStatValue = 0;
+			}
+
+			_ItemStat NewStats[MAX_ITEM_PROTO_STATS];
+
+			for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+			{
+				NewStats[i].ItemStatType = 0;
+				NewStats[i].ItemStatValue = 0;
+			}
+
+			uint32 total = 0;
+
+			for (auto it = itr->second.StatOverMap.begin(); it != itr->second.StatOverMap.end(); it++)
+			{
+				if (total >= MAX_ITEM_PROTO_STATS)
+					continue;
+
+				uint32 count = 0;
+
+				for (size_t i = total; i < MAX_ITEM_PROTO_STATS; i++)
+				{
+					if (count >= it->second)
+						continue;
+
+					if (NewStats[i].ItemStatType == 0 && NewStats[i].ItemStatValue == 0)
+					{
+						NewStats[i] = GetRandomStat(it->first);
+						count++;
+						total++;
+					}
+				}
+			}
+
+			MergeStat(NewStats);
+
+			for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+				item->Stats[i] = NewStats[i];
+		}
+
+		//²úÉúËæ»úFM
+		for (uint8 slot = PROP_ENCHANTMENT_SLOT_0; slot < MAX_ENCHANTMENT_SLOT; slot++)
+		{
+			uint32 enchant_id = GetCreateEnchantId(itr->second.EnchantIndex, slot - 6);
+
+			if (enchant_id == 0)
+				continue;
+
+			if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id))
+				item->SetEnchantment(EnchantmentSlot(slot), enchant_id, 0, 0);
+		}
+
+		item->Damages[0].DamageMin = proto->Damage[0].DamageMin;
+		item->Damages[0].DamageMax = proto->Damage[0].DamageMax;
+		item->NpDelay = proto->Delay;
+
+		if (proto->Class == ITEM_CLASS_WEAPON)
+		{
+			for (auto i = MapNpWeaponVector.begin(); i != MapNpWeaponVector.end(); i++)
+			{
+				if (itr->second.WeaponIndex == i->WeaponIndex && proto->SubClass == i->SubClass)
+				{
+					item->Damages[0].DamageMin *= i->MinDamageMod;
+					item->Damages[0].DamageMax *= i->MaxDamageMod;
+
+					uint32 min = urand(i->Damage.MinDamageMin, i->Damage.MinDamageMax);
+					uint32 max = urand(i->Damage.MaxDamageMin, i->Damage.MaxDamageMax);
+
+					if (min != 0 && max != 0)
+					{
+						if (max < min)
+							max = min;
+
+						item->Damages[0].DamageMin = min;
+						item->Damages[0].DamageMax = max;
+					}
+
+					uint32 delay = urand(i->Delay.MinDelay, i->Delay.MaxDelay);
+
+					if (delay != 0)
+						item->NpDelay = delay;
+					else
+						item->NpDelay = proto->Delay;
+
+					break;
+				}
+			}
+		}
+
+		item->TempIndex = TempIndex;
+		//ÉèÖÃflag query data
+		item->SetUInt32Value(ITEM_FIELD_PROPERTY_SEED, GetQueryId(item));
+		//SetItemFlag(item);
+		ItemQueryMap[item->GetGUIDLow()] = item;
+		if (Player* owner = item->GetOwner())
+			item->SetState(ITEM_CHANGED, owner);
+
+		owner->DestroyItem(item1->GetBagSlot(), item1->GetSlot(), true);
+		owner->DestroyItem(item2->GetBagSlot(), item2->GetSlot(), true);
+		sRew->Rew(owner, RewId);
+
+		return true;
+	}
+
+	return false;
+}
+
+bool NoPatchItem::Create(Map* map, Item* item)
+{
+	if (!map || !item)
+		return false;
+
+	if (item->IsNoPatch())
+		return false;
+
+	const ItemTemplate* proto = item->GetTemplate();
+	if (!proto)
+		return false;
+
+	if (proto->Class != ITEM_CLASS_WEAPON && proto->Class != ITEM_CLASS_ARMOR && proto->Class != ITEM_CLASS_CONTAINER)
+		return false;
+
+	uint32 TempIndex = GetRandomTempIndex(map->GetId(), map->GetDifficulty(), map->challengeLv);
+
+	auto itr = MapNpTempMap.find(TempIndex);
+
+	if (itr != MapNpTempMap.end())
+	{
+		item->Name = proto->Name1 + itr->second.Suffix;
+
+		if (itr->second.Quality > 0)
+			item->LevelData = GetLevelData(item->GetEntry(), 1, itr->second.Quality, itr->second.ItemLevel);
+		else
+			item->LevelData = GetLevelData(item->GetEntry(), 1, proto->Quality, itr->second.ItemLevel);
+
+		item->MapData = GetMapData(map->GetId(), 1, map->GetDifficulty(), map->challengeLv);
+
+		//²úÉú¼¼ÄÜ
+		//¸½¼Ó¶îÍâ¼¼ÄÜ
+		if (itr->second.SpellIndex > 0)
+		{
+			_Spell NewSpells[MAX_ITEM_PROTO_SPELLS];
+
+			for (size_t i = 0; i < MAX_ITEM_PROTO_SPELLS; i++)
+				NewSpells[i] = proto->Spells[i];
+
+			uint32 count = 0;
+
+			for (size_t i = 0; i < MAX_ITEM_PROTO_SPELLS; i++)
+			{
+				if (count >= itr->second.SpellCount)
+					continue;
+
+				if (NewSpells[i].SpellId == 0)
+				{
+					NewSpells[i] = GetRandomSpell(NewSpells, itr->second.SpellIndex);
+					count++;
+				}
+			}
+
+			for (size_t i = 0; i < MAX_ITEM_PROTO_SPELLS; i++)
+				item->Spells[i] = NewSpells[i];
+		}
+		//¶îÍâ¼¼ÄÜ
+		else if (itr->second.SpellIndex < 0)
+		{
+			//²úÉú¼¼ÄÜ
+			for (size_t i = 0; i < itr->second.SpellCount; i++)
+				item->Spells[i] = GetRandomSpell(item->Spells, abs(itr->second.SpellIndex));
+		}
+		else
+		{
+			for (size_t i = 0; i < MAX_ITEM_PROTO_SPELLS; i++)
+				item->Spells[i] = proto->Spells[i];
+		}
+
+		//Ô­ÊôÐÔ·­±¶
+		for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+			item->Stats[i] = proto->ItemStat[i];
+
+		for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+		{
+			uint32 StatType = item->Stats[i].ItemStatType;
+
+			for (auto it = MapNpStatModVector.begin(); it != MapNpStatModVector.end(); it++)
+			{
+				if (it->StatModIndex == itr->second.StatModIndex && it->StatType == StatType && item->Stats[i].ItemStatValue > 0)
+				{
+					float mod = frand(it->ModStatMin, it->ModStatMax);
+					item->Stats[i].ItemStatValue *= mod;
+					break;
+				}
+			}
+		}
+
+		//¸½¼Ó¶îÍâÊôÐÔ
+		if (itr->second.StatOverMap.empty())
+		{
+			_ItemStat NewStats[MAX_ITEM_PROTO_STATS];
+			for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+				NewStats[i] = item->Stats[i];
+
+			uint32 total = 0;
+
+			for (auto it = itr->second.StatAddMap.begin(); it != itr->second.StatAddMap.end(); it++)
+			{
+				if (total >= MAX_ITEM_PROTO_STATS)
+					continue;
+
+				uint32 count = 0;
+
+				for (size_t i = total; i < MAX_ITEM_PROTO_STATS; i++)
+				{
+					if (count >= it->second)
+						continue;
+
+					if (NewStats[i].ItemStatType == 0 && NewStats[i].ItemStatValue == 0)
+					{
+						NewStats[i] = GetRandomStat(it->first);
+						count++;
+						total++;
+					}
+				}
+			}
+
+			MergeStat(NewStats);
+
+			for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+				item->Stats[i] = NewStats[i];
+		}
+		else
+		{
+			for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+			{
+				item->Stats[i].ItemStatType = 0;
+				item->Stats[i].ItemStatValue = 0;
+			}
+
+			_ItemStat NewStats[MAX_ITEM_PROTO_STATS];
+
+			for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+			{
+				NewStats[i].ItemStatType = 0;
+				NewStats[i].ItemStatValue = 0;
+			}
+
+			uint32 total = 0;
+
+			for (auto it = itr->second.StatOverMap.begin(); it != itr->second.StatOverMap.end(); it++)
+			{
+				if (total >= MAX_ITEM_PROTO_STATS)
+					continue;
+
+				uint32 count = 0;
+
+				for (size_t i = total; i < MAX_ITEM_PROTO_STATS; i++)
+				{
+					if (count >= it->second)
+						continue;
+
+					if (NewStats[i].ItemStatType == 0 && NewStats[i].ItemStatValue == 0)
+					{
+						NewStats[i] = GetRandomStat(it->first);
+						count++;
+						total++;
+					}
+				}
+			}
+
+			MergeStat(NewStats);
+
+			for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+				item->Stats[i] = NewStats[i];				
+		}
+
+		//²úÉúËæ»úFM
+		for (uint8 slot = PROP_ENCHANTMENT_SLOT_0; slot < MAX_ENCHANTMENT_SLOT; slot++)
+		{
+			uint32 enchant_id = GetCreateEnchantId(itr->second.EnchantIndex, slot - 6);
+
+			if (enchant_id == 0)
+				continue;
+
+			if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id))
+				item->SetEnchantment(EnchantmentSlot(slot), enchant_id, 0, 0);
+		}
+
+		item->Damages[0].DamageMin = proto->Damage[0].DamageMin;
+		item->Damages[0].DamageMax = proto->Damage[0].DamageMax;
+		item->NpDelay = proto->Delay;
+
+		if (proto->Class == ITEM_CLASS_WEAPON)
+		{
+			for (auto i = MapNpWeaponVector.begin(); i != MapNpWeaponVector.end(); i++)
+			{
+				if (itr->second.WeaponIndex == i->WeaponIndex && proto->SubClass == i->SubClass)
+				{
+					item->Damages[0].DamageMin *= i->MinDamageMod;
+					item->Damages[0].DamageMax *= i->MaxDamageMod;
+
+					uint32 min = urand(i->Damage.MinDamageMin, i->Damage.MinDamageMax);
+					uint32 max = urand(i->Damage.MaxDamageMin, i->Damage.MaxDamageMax);
+
+					if (min != 0 && max != 0)
+					{
+						if (max < min)
+							max = min;
+
+						item->Damages[0].DamageMin = min;
+						item->Damages[0].DamageMax = max;
+					}
+
+					uint32 delay = urand(i->Delay.MinDelay, i->Delay.MaxDelay);
+
+					if (delay != 0)
+						item->NpDelay = delay;
+					else
+						item->NpDelay = proto->Delay;
+
+					break;
+				}
+			}
+		}
+
+		item->TempIndex = TempIndex;
+		//ÉèÖÃflag query data
+		item->SetUInt32Value(ITEM_FIELD_PROPERTY_SEED, GetQueryId(item));
+		//SetItemFlag(item);
+		ItemQueryMap[item->GetGUIDLow()] = item;
+		if (Player* owner = item->GetOwner())
+			item->SetState(ITEM_CHANGED, owner);
+
+		return true;
+	}
+
+	return false;
+}
+
+uint32 NoPatchItem::GetCreateEnchantId(uint32 EnchantIndex, uint8 Slot)
+{
+	uint32 EnchantGroupId = 0;
+
+	for (auto itr = MapNpEnchantVector.begin(); itr != MapNpEnchantVector.end(); itr++)
+		if (itr->EnchantIndex == EnchantIndex && itr->Slot == Slot)
+			EnchantGroupId = itr->EnchantGroupId;
+
+	if (EnchantGroupId == 0)
+		return 0;
+
+	uint32 len_group = EnchantGroupVec.size();
+
+	std::unordered_map<uint32, float> EnchantIdMap;
+
+	for (size_t i = 0; i < len_group; i++)
+		if (EnchantGroupId == EnchantGroupVec[i].groupId)
+			EnchantIdMap.insert(std::make_pair(EnchantGroupVec[i].enchantId, EnchantGroupVec[i].chance));
+
+	std::vector<std::pair<int, float>> vtMap;
+	for (auto it = EnchantIdMap.begin(); it != EnchantIdMap.end(); it++)
+		vtMap.push_back(std::make_pair(it->first, it->second));
+
+	sort(vtMap.begin(), vtMap.end(),
+		[](const std::pair<int, float> &x, const std::pair<int, float> &y) -> int {
+		return x.second < y.second;
+	});
+
+
+	float sum = 0;
+
+	for (auto it = vtMap.begin(); it != vtMap.end(); it++)
+		sum += it->second;
+
+	float rand = frand(0, sum);
+
+	sum = 0;
+
+	for (auto it = vtMap.begin(); it != vtMap.end(); it++)
+	{
+		sum += it->second;
+		if (rand <= sum)
+			return it->first;
+	}
+
+	return 0;
+}
+
+void NoPatchItem::GetMapPrefixSuffix(Item* item, std::string &prefix, std::string &suffix)
+{
+	auto iter = MapNpTempMap.find(item->TempIndex);
+	if (iter != MapNpTempMap.end())
+	{
+		prefix = iter->second.Prefix;
+		suffix = iter->second.Suffix;
+	}
+}
+
+int32 NoPatchItem::GetLevelStat(uint32 LevelStatModIndex, uint32 type, int32 value)
+{
+	for (auto itr = NpLevelStatModVec.begin(); itr != NpLevelStatModVec.end(); itr++)
+	{
+		if (LevelStatModIndex == itr->LevelStatModIndex && type == itr->StatType)
+		{
+			if (itr->ModType == TYPE_MUI_VALUE)
+				return value * itr->StatValue;
+			else
+				return value + itr->StatValue;
+		}
+	}
+
+	return value;
+}
+
+bool NoPatchItem::LevelUp(Player* owner, Item* item)
+{
+	uint32 L_ReqId = 0;
+	float L_Chance = 0;
+	uint32 L_SpellIndex = 0;
+	uint32 L_AddSpellCount = 0;
+	uint32 L_StatIndex = 0;
+	uint32 L_AddStatCount = 0;
+	uint8 L_LevelStatModIndex = 0;
+	NpLevelTypes L_DamageLevelType = TYPE_ADD_VALUE;
+	float L_DamageValue = 0;
+	std::string L_Suffix = "";
+	uint32 L_ItemLvel = 0;
+	uint32 L_Quality = 0;
+	uint32 L_EnchantIndex = 0;
+
+	if (!CalLevel(item, L_ReqId, L_Chance, L_SpellIndex, L_AddSpellCount, L_StatIndex, L_AddStatCount, L_LevelStatModIndex, L_DamageLevelType, L_DamageValue, L_Suffix, L_ItemLvel, L_Quality, L_EnchantIndex))
+		return false;
+
+	if (!sReq->Check(owner, L_ReqId))
+		return false;
+
+	if (frand(0, 100.0f) > L_Chance)
+	{
+		sReq->Des(owner, L_ReqId);
+		owner->GetSession()->SendNotification("Éý¼¶Ê§°Ü");
+		return false;
+	}
+
+	Item* pItem = item->CloneItem(item->GetCount(), owner);
+
+	if (!pItem)
+		return false;
+
+	//ÉèÖÃÐÂÎïÆ·
+	std::string prefix = "";
+	std::string suffix = "";
+	GetMapPrefixSuffix(item, prefix, suffix);
+	pItem->Name = prefix + item->GetTemplate()->Name1 + suffix + L_Suffix;
+	pItem->TempIndex = item->TempIndex;
+
+
+	if (L_Quality > 0)
+		pItem->LevelData = GetLevelData(GetLevelEntry(item->LevelData), GetLevelNow(item->LevelData) + 1, L_Quality, L_ItemLvel);
+	else
+		pItem->LevelData = GetLevelData(GetLevelEntry(item->LevelData), GetLevelNow(item->LevelData) + 1, GetQuality(item->LevelData), L_ItemLvel);
+
+	
+	if (item->MapData > 0)
+		pItem->MapData = GetMapData(GetMapId(item->MapData), GetMapLevelNow(item->MapData) + 1, GetDifficulty(item->MapData), GetChallegeLv(item->MapData));
+
+	//²úÉú¼¼ÄÜ
+	_Spell NewSpells[MAX_ITEM_PROTO_SPELLS];
+
+	for (size_t i = 0; i < MAX_ITEM_PROTO_SPELLS; i++)
+		NewSpells[i] = item->Spells[i];
+
+	uint32 count = 0;
+
+	for (size_t i = 0; i < MAX_ITEM_PROTO_SPELLS; i++)
+	{
+		if (count >= L_AddSpellCount)
+			continue;
+
+		if (NewSpells[i].SpellId == 0)
+		{
+			NewSpells[i] = GetRandomSpell(NewSpells, L_SpellIndex);
+			count++;
+		}
+	}
+
+	for (size_t i = 0; i < MAX_ITEM_PROTO_SPELLS; i++)
+		pItem->Spells[i] = NewSpells[i];
+
+	//²úÉúÊôÐÔ
+	_ItemStat NewStats[MAX_ITEM_PROTO_STATS];
+
+	for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+		NewStats[i] = item->Stats[i];
+
+	for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+	{
+		if (NewStats[i].ItemStatType == 0 && NewStats[i].ItemStatValue == 0)
+			continue;
+
+		NewStats[i].ItemStatValue = GetLevelStat(L_LevelStatModIndex, NewStats[i].ItemStatType, NewStats[i].ItemStatValue);
+
+		//NewStats[i].ItemStatValue = L_StatLevelType == TYPE_ADD_VALUE ? NewStats[i].ItemStatValue + int32(L_StatValue) : NewStats[i].ItemStatValue * L_StatValue;
+	}
+	
+	count = 0;
+
+	for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+	{
+		if (count >= L_AddStatCount)
+			continue;
+
+		if (NewStats[i].ItemStatType == 0 && NewStats[i].ItemStatValue == 0)
+		{
+			NewStats[i] = GetRandomStat(L_StatIndex);
+			count++;
+		}
+	}
+
+	MergeStat(NewStats);
+
+	for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+		pItem->Stats[i] = NewStats[i];
+
+	//²úÉúÇ°×º
+	pItem->Name = GetPrefix(pItem) + pItem->Name;
+
+	pItem->Damages[0].DamageMin = L_DamageLevelType == TYPE_ADD_VALUE ? item->Damages[0].DamageMin + L_DamageValue : item->Damages[0].DamageMin * L_DamageValue;
+	pItem->Damages[0].DamageMax = L_DamageLevelType == TYPE_ADD_VALUE ? item->Damages[0].DamageMax + L_DamageValue : item->Damages[0].DamageMax * L_DamageValue;;
+
+	pItem->NpDelay = item->NpDelay;
+
+	//±£ÁôFMÐ§¹û
+	for (uint8 slot = PERM_ENCHANTMENT_SLOT; slot < MAX_ENCHANTMENT_SLOT; slot++)
+	{
+		uint32 x = GetCreateEnchantId(L_EnchantIndex, slot - 6);
+
+		uint32 enchantId = x > 0 ? x : item->GetEnchantmentId(EnchantmentSlot(slot));
+
+		if (SpellItemEnchantmentEntry const* info = sSpellItemEnchantmentStore.LookupEntry(enchantId))
+		{
+			owner->ApplyEnchantment(pItem, EnchantmentSlot(slot), false);
+			pItem->SetEnchantment(EnchantmentSlot(slot), enchantId, 0, 0);
+			owner->ApplyEnchantment(pItem, EnchantmentSlot(slot), true);
+		}
+	}
+
+	//ÉèÖÃflag query data
+	pItem->SetUInt32Value(ITEM_FIELD_PROPERTY_SEED, GetQueryId(pItem));
+	//SetItemFlag(pItem);
+	pItem->SetState(ITEM_CHANGED, owner);
+	ItemQueryMap[pItem->GetGUIDLow()] = pItem;
+
+	//¿Û¼õÏûºÄ´Ý»ÙÔ­ÎïÆ·
+	sReq->Des(owner, L_ReqId);
+	owner->DestroyItem(item->GetBagSlot(), item->GetSlot(), true);
+
+	ItemPosCountVec sDest;
+	InventoryResult msg = owner->CanStoreItem(NULL_BAG, NULL_SLOT, sDest, pItem, false);
+	if (msg == EQUIP_ERR_OK)
+		owner->StoreItem(sDest, pItem, true);
+	else
+		owner->SendEquipError(msg, pItem, NULL);
+
+	owner->CLOSE_GOSSIP_MENU();
+
+
+	UpdateAuras(owner);
+
+	return true;
+}
+
+uint8 NoPatchItem::GetInsert(ItemTemplate temp)
+{
+	uint8 insert = 0;
+	//Ãû×Ö
+	insert++;
+
+	sLog->outString("-->%d->>>>Ãû×Ö", insert);
+
+	//Ó¢ÐÛÄ£Ê½
+	if ((temp.Flags & ITEM_FLAG_HEROIC_TOOLTIP) != 0)
+	{
+		insert++;
+		sLog->outString("-->%d->>>>Ó¢ÐÛÄ£Ê½", insert);
+	}
+
+	//°ó¶¨ ÕËºÅ°ó¶¨ ×°±¸°ó¶¨...
+	if (temp.Bonding != NO_BIND || (temp.Flags & ITEM_FLAG_IS_BOUND_TO_ACCOUNT) != 0 || temp.Quality == 7)
+	{
+		insert++;
+		sLog->outString("-->%d->>>>°ó¶¨", insert);
+	}
+
+	//Ä§·¨ÖÆ×÷µÄÎïÆ·
+	if ((temp.Flags & ITEM_FLAG_CONJURED) != 0)
+		insert++;
+
+	//Î¨Ò» ×î´óÊýÁ¿ ×°±¸Î¨Ò»...
+	if (temp.MaxCount != 0 || (temp.Flags & ITEM_FLAG_UNIQUE_EQUIPPABLE) != 0)
+	{
+		insert++;
+		sLog->outString("-->%d->>>>×î´óÊýÁ¿", insert);
+	}
+
+	//¿¹ÐÔ
+	if (temp.HolyRes != 0)
+		insert++;
+	if (temp.FireRes != 0)
+		insert++;
+	if (temp.NatureRes != 0)
+		insert++;
+	if (temp.FrostRes != 0)
+		insert++;
+	if (temp.ShadowRes != 0)
+		insert++;
+	if (temp.ArcaneRes != 0)
+		insert++;
+
+	//»¤¼×
+	if (temp.Armor > 0)
+	{
+		insert++;
+		sLog->outString("-->%d->>>>»¤¼×", insert);
+	}
+
+	//Ë«ÊÖ »¤¼×...
+	if (temp.InventoryType != 0 && (temp.Class == ITEM_CLASS_WEAPON || temp.Class == ITEM_CLASS_ARMOR))
+	{
+		insert++;
+		sLog->outString("-->%d->>>>Î»ÖÃ", insert);
+	}
+
+	//ÉËº¦
+	if (temp.Damage[0].DamageMin > 0 || temp.Damage[0].DamageMax > 0)
+	{
+		insert++;
+		sLog->outString("-->%d->>>>ÉËº¦", insert);
+	}
+	if (temp.Damage[1].DamageMin > 0 || temp.Damage[1].DamageMax > 0)
+	{
+		insert++;
+		sLog->outString("-->%d->>>>ÉËº¦", insert);
+	}
+
+
+	//ÃëÉË
+	if (temp.Damage[0].DamageMin > 0 && temp.Damage[0].DamageMax > 0 && temp.Delay > 0)
+	{
+		insert++;
+		sLog->outString("-->%d->>>>ÃëÉË", insert);
+	}
+
+	//ÊôÐÔ
+	for (uint8 i = 0; i < temp.StatsCount; ++i)
+		if ((temp.ItemStat[i].ItemStatType == 0
+			|| temp.ItemStat[i].ItemStatType == 1
+			|| temp.ItemStat[i].ItemStatType == 3
+			|| temp.ItemStat[i].ItemStatType == 4
+			|| temp.ItemStat[i].ItemStatType == 5
+			|| temp.ItemStat[i].ItemStatType == 6
+			|| temp.ItemStat[i].ItemStatType == 7
+			) && temp.ItemStat[i].ItemStatValue != 0)
+		{
+			insert++;
+			sLog->outString("-->%d->>>>ItemStatType:%d", insert, temp.ItemStat[i].ItemStatType);
+		}
+
+
+	//±¦Ê¯
+	for (size_t i = 0; i < MAX_ITEM_PROTO_SOCKETS; i++)
+		if (temp.Socket[i].Color != 0)
+		{
+			insert++;
+			sLog->outString("-->%d->>>>±¦Ê¯", insert);
+		}
+
+	//Ê¹ÓÃÇøÓò
+	if (temp.Area != 0)
+		insert++;
+
+	if (temp.Map != 0)
+		insert++;
+
+	return insert;
+}
+
+uint32 NoPatchItem::GetItemFlag(Item* item)
+{
+	//uint32 insert = GetInsert(*(item->GetTemplate()));
+	uint32 ReqId = 0;
+	float Chance = 0;
+	uint32 SellRewId = GetSellRewId(item);
+	GetExchange(item, ReqId, Chance);
+
+
+	std::ostringstream oss;
+	oss << item->IsSoulBound() ? 1 : 0;
+	char buffer[128];
+	sprintf(buffer, "%03u", SellRewId);
+	oss << buffer;
+	sprintf(buffer, "%04u", ReqId);
+	oss << buffer;
+
+	sprintf(buffer, "%01u", CanCompound(item) ? 1 : 0);
+	oss << buffer;
+
+	//sprintf(buffer, "%02u", insert);
+	//oss << buffer;
+
+	//sLog->outString("SellRewId:%u", SellRewId);
+	//sLog->outString("ReqId:%u", ReqId);
+	//sLog->outString("insert:%u", insert);
+	uint32 flag = atoi(oss.str().c_str());
+
+	//sLog->outString("flag:%u", flag);
+
+	//ChatHandler(item->GetOwner()->GetSession()).PSendSysMessage("PROPERTIES_ID %u", flag);
+
+	return flag + 2000;
+}
+
+void NoPatchItem::SetItemFlag(Item* item)
+{
+	if (!item->IsNoPatch())
+		return;
+
+	item->SetUInt32Value(ITEM_FIELD_RANDOM_PROPERTIES_ID, GetItemFlag(item));
+
+	if (Player* owner = item->GetOwner())
+		sGCAddon->SendItemEnchantData(item->GetOwner(), item);
+
+	//ChatHandler(item->GetOwner()->GetSession()).PSendSysMessage("ITEM_FIELD_RANDOM_PROPERTIES_ID %u", item->GetUInt32Value(ITEM_FIELD_RANDOM_PROPERTIES_ID));
+}
+
+bool NoPatchItem::ItemQuery(Player* player, uint32 item)
+{
+	if (uint32 guid = GetGUID(item))
+	{
+		auto itr = ItemQueryMap.find(guid);
+
+		if (itr != ItemQueryMap.end())
+		{
+			Item * pItem = itr->second;
+
+			if (!pItem || !pItem->IsNoPatch())
+				return false;
+
+			if (const ItemTemplate* srcTemp = pItem->GetTemplate())
+			{
+				ItemTemplate sendTemp;
+
+				sendTemp = *srcTemp;
+				sendTemp.ItemId = GetQueryId(pItem);
+				sendTemp.Name1 = pItem->Name;
+				sendTemp.ItemLevel = GetItemLevel(pItem->LevelData);
+				sendTemp.Quality = GetQuality(pItem->LevelData);
+				sendTemp.StatsCount = MAX_ITEM_PROTO_STATS;
+				for (size_t i = 0; i < MAX_ITEM_PROTO_SPELLS; i++)
+					sendTemp.Spells[i] = pItem->Spells[i];
+				for (size_t i = 0; i < MAX_ITEM_PROTO_STATS; i++)
+					sendTemp.ItemStat[i] = pItem->Stats[i];
+				for (size_t i = 0; i < MAX_ITEM_PROTO_DAMAGES; i++)
+					sendTemp.Damage[i] = pItem->Damages[i];
+				sendTemp.Delay = pItem->NpDelay;
+				sendTemp.InitializeQueryData();
+
+				player->GetSession()->SendPacket(&sendTemp.queryData);
+				return true;
+			}
+		}
+	}
+
+	return false;
+}
+
+bool NoPatchItem::CanOpenItem(Player* player)
+{
+	if (!player)
+		return true;
+
+	Map* map = player->GetMap();
+
+	if (!map)
+		return true;
+
+	for (auto itr = MapNpVector.begin(); itr != MapNpVector.end(); itr++)
+		if (map->GetId() == itr->MapId && map->GetDifficulty() == itr->Diff && map->challengeLv == itr->ChallengeLv)
+			return false;
+
+	return true;
+}
+
+uint32 NoPatchItem::GetLevelIndex(Item* item)
+{
+	if (item->MapData > 0)
+	{
+		auto itr = MapNpTempMap.find(item->TempIndex);
+		if (itr != MapNpTempMap.end())
+			return itr->second.LevelIndex;
+	}
+
+	if (item->LevelData > 0 && item->MapData == 0)
+	{
+		uint32 LevelEntry = GetLevelEntry(item->LevelData);
+		auto iter = NpMap.find(LevelEntry);
+		if (iter != NpMap.end())
+			return iter->second.LevelIndex;
+	}
+
+	return 0;
+}
+
+void NoPatchItem::UpdateAuras(Player* pl)
+{
+	for (auto itr = NpAuraVector.begin(); itr != NpAuraVector.end(); itr++)
+		for (size_t i = 0; i < 5; i++)
+			pl->RemoveAura(itr->Auras[i]);
+
+	std::vector<NpAuraData>v;
+
+	for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+	{
+		if (Item* item = pl->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+		{
+			if (!item->IsNoPatch())
+				continue;
+
+			NpAuraData data;
+			data.LevelIndex = GetLevelIndex(item);
+			data.Level = GetLevelNow(item->LevelData) - 1;
+			v.push_back(data);
+		}
+	}
+
+	for (auto itr = NpAuraVector.begin(); itr != NpAuraVector.end(); itr++)
+	{
+		uint32 count = 0;
+		uint32 LevelIndex = itr->LevelIndex;
+		uint32 Level = itr->Level;
+
+		for (auto i = v.begin(); i != v.end(); i++)
+			if (LevelIndex == i->LevelIndex && Level == i->Level)
+				count++;
+
+		if (count >= itr->Count)
+		{
+			for (size_t i = 0; i < 5; i++)
+				if (itr->Auras[i])
+					pl->AddAura(itr->Auras[i], pl);
+
+			sRew->Rew(pl, itr->RewId);
+		}		
+	}
+}
diff --git a/src/server/scripts/Custom/ItemMod/NoPatchItem.h b/src/server/scripts/Custom/ItemMod/NoPatchItem.h
new file mode 100644
index 0000000..a5a42f5
--- /dev/null
+++ b/src/server/scripts/Custom/ItemMod/NoPatchItem.h
@@ -0,0 +1,268 @@
+struct _NpItemStat
+{
+	uint32  ItemStatType;
+	int32   ItemStatMinValue;
+	int32	ItemStatMaxValue;
+};
+
+struct _NpItemDamage
+{
+	uint32 MinDamageMin;
+	uint32 MinDamageMax;
+	uint32 MaxDamageMin;
+	uint32 MaxDamageMax;
+};
+
+struct _NpItemDelay
+{
+	uint32 MinDelay;
+	uint32 MaxDelay;
+};
+
+enum NpLevelTypes
+{
+	TYPE_MUI_VALUE,
+	TYPE_ADD_VALUE,
+};
+
+struct _NpItemLevel
+{
+	uint8 LevelIndex;
+	uint32 Level;
+	uint32 ReqId;
+	float Chance;
+
+	uint32 SpellIndex;
+	uint32 AddSpellCount;
+
+	uint32 StatIndex;
+	uint32 AddStatCount;
+
+	uint8 LevelStatModIndex;
+
+	NpLevelTypes DamageLevelType;
+	float DamageValue;
+
+	std::string Suffix;
+	uint32 ItemLevel;
+	uint32 Quality;
+
+	uint32 EnchantIndex;
+};
+
+struct _NpItemLevelStatModTemplate
+{
+	uint8 LevelStatModIndex;
+	NpLevelTypes ModType;
+	uint32 StatType;
+	float StatValue;
+};
+
+struct NpTemplate
+{
+	uint32 SpellIndex;
+	uint32 StatIndex;
+	uint32 StatCount;
+	uint32 SpellCount;
+	uint32 SrcIndex;
+	uint32 LevelIndex;
+	_NpItemDamage Damage;
+	_NpItemDelay Delay;
+	std::string Suffix;
+	uint32 ItemLevel;
+	int32 Quality;
+};
+
+struct NpSrcTemplate
+{
+	uint32 SrcIndex;
+	uint32 SrcEntry;
+	float SrcChance;
+};
+
+struct NpStatTemplate
+{
+	uint32 StatIndex;
+	_NpItemStat Stat;
+	float StatChance;
+};
+
+struct NpSpellTemplate
+{
+	uint32 SpellIndex;
+	_Spell Spell;
+	float SpellChance;
+};
+
+extern std::unordered_map<uint32/*entry*/, NpTemplate> NpMap;
+extern std::vector<NpSrcTemplate> NpSrcVec;
+extern std::vector<NpStatTemplate> NpStatVec;
+extern std::vector<NpSpellTemplate> NpSpellVec;
+extern std::vector<_NpItemLevel> NpLevelVec;
+extern std::unordered_map<uint32, std::string> NpPrefixMap;
+extern std::unordered_map<uint32, Item*> ItemQueryMap;
+extern std::vector<_NpItemLevelStatModTemplate> NpLevelStatModVec;
+
+struct NpToLevelTemplate
+{
+	float chance;
+	uint32 level;
+};
+
+extern std::unordered_map<uint32, NpToLevelTemplate> NpToLevelMap;
+
+struct MapNpTemplate
+{
+	uint32 MapId;
+	Difficulty Diff;
+	uint32 ChallengeLv;
+	uint32 TempIndex;
+	float Chance;
+};
+
+struct MapNpTempTemplate
+{
+	uint32 Quality;
+	uint32 ItemLevel;
+	std::string Suffix;
+	std::string Prefix;
+	uint32 LevelIndex;
+	uint32 EnchantIndex;
+	uint32 StatModIndex;
+	std::unordered_map<uint32, uint32>StatAddMap;
+	std::unordered_map<uint32, uint32>StatOverMap;
+	int32 SpellIndex;
+	uint32 SpellCount;
+	uint32 WeaponIndex;
+	uint32 SellRewId;
+};
+
+struct MapNpStatModTemplate
+{
+	uint32 StatModIndex;
+	uint32 StatType;
+	float ModStatMin;
+	float ModStatMax;
+};
+
+
+struct MapNpEnchantTemplate
+{
+	uint32 EnchantIndex;
+	uint8 Slot;
+	uint32 EnchantGroupId;
+};
+
+struct MapNpWeaponTemplate
+{
+	uint32 WeaponIndex;
+	uint8 SubClass;
+	float MinDamageMod;
+	float MaxDamageMod;
+	_NpItemDamage Damage;
+	_NpItemDelay Delay;
+};
+
+struct NpAuraData
+{
+	uint32 LevelIndex;
+	uint32 Level;
+};
+
+struct NpAuraTemplate
+{
+	uint32 LevelIndex;
+	uint32 Level;
+	uint32 Count;
+	uint32 Auras[5];
+	uint32 RewId;
+};
+
+struct NpSameTemplate
+{
+	uint32 SrcTempIndex;
+	uint32 TargetTempIndex;
+	uint32 MeetLevel;
+	uint32 RewId;
+};
+
+extern std::vector<MapNpTemplate> MapNpVector;
+extern std::unordered_map<uint32, MapNpTempTemplate> MapNpTempMap;
+extern std::vector<MapNpStatModTemplate> MapNpStatModVector;
+extern std::vector<MapNpEnchantTemplate> MapNpEnchantVector;
+extern std::vector<MapNpWeaponTemplate> MapNpWeaponVector;
+extern std::vector<NpAuraTemplate> NpAuraVector;
+extern std::vector<NpSameTemplate> NpSameTempIndexVector;
+
+class NoPatchItem
+{
+public:
+	static NoPatchItem* instance()
+	{
+		static NoPatchItem instance;
+		return &instance;
+	}
+	void Load();
+	void LoadMap();
+
+	bool CalBase(uint32 entry, uint32 &SrcIndex, uint32 &SpellIndex, uint32 &SpellCount, uint32 &StatIndex, uint32 &StatCount, 
+		uint32 &minDamage, uint32 &maxDamage, uint32 &delay, std::string &Suffix, uint32 &ItemLvel, int32 &Quality);
+	bool CalLevel(Item* item, uint32 &L_ReqId, float &L_Chance,
+		uint32 &L_SpellIndex, uint32 &L_AddSpellCount, uint32 &L_StatIndex, uint32 &L_AddStatCount,
+		uint8 &L_LevelStatModIndex, NpLevelTypes &L_DamageLevelType, float &L_DamageValue,
+		std::string &L_Suffix, uint32 &L_ItemLvel, uint32 &L_Quality, uint32 &L_EnchantIndex);
+	int32 GetLevelStat(uint32 LevelStatModIndex, uint32 type, int32 value);
+	bool GetExchange(Item* item, uint32 &L_ReqId, float &L_Chance);
+	uint32 GetSellRewId(Item* item);
+	std::string GetPrefix(Item* item);
+	uint32 GetRandomSrcEntry(uint32 SrcIndex);
+	_Spell GetRandomSpell(_Spell Spells[MAX_ITEM_PROTO_SPELLS], uint32 SpellIndex);
+	_ItemStat GetRandomStat(uint32 StatIndex);
+
+	uint32 GetItemLevel(uint64 LevelData)   { return uint32((LevelData & 0x000000000000FFFF)); }
+	uint32 GetQuality(uint64 LevelData)		{ return uint32((LevelData & 0x0000000000FF0000) >> 16); }
+	uint8 GetLevelNow(uint64 LevelData)		{ return uint8((LevelData & 0x00000000FF000000) >> 24); }
+	uint32 GetLevelEntry(uint64 LevelData)	{ return uint32((LevelData & 0xFFFFFFFF00000000) >> 32); }
+	uint64 GetLevelData(uint32 entry, uint8 LevelNow, uint32 Quality, uint32 ItemLvel){ return (uint64)entry << 32 | (uint64)LevelNow << 24 | (uint64)Quality << 16 | (uint64)ItemLvel; }
+
+	uint64 GetMapData(uint32 mapId, uint8 levelNow, uint8 Difficulty, uint32 ChallengeLv)
+	{
+		return (uint64)mapId << 32 | (uint64)levelNow << 24 | (uint64)Difficulty << 16 | (uint64)ChallengeLv;
+	}
+
+	uint32 GetChallegeLv(uint64 MapData){ return uint32((MapData & 0x000000000000FFFF)); }
+	uint8 GetDifficulty(uint64 MapData){ return uint8((MapData & 0x0000000000FF0000) >> 16); }
+	uint8 GetMapLevelNow(uint64 MapData){ return uint8((MapData & 0x00000000FF000000) >> 24); }
+	uint32 GetMapId(uint64 MapData)	{ return uint32((MapData & 0xFFFFFFFF00000000) >> 32); }
+
+	void MergeStat(_ItemStat(&Stats)[MAX_ITEM_PROTO_STATS]);
+
+	bool Create(Player* owner, Item* item);
+	bool Create(Map* map, Item* item);
+	bool CanCompound(Item* item);
+	void GetTargetTemp(Item* item, uint32 &TargetTempIndex, uint32 &RewId);
+	bool Compound(Player* owner, Item* item);
+	Item* GetSameItem(Player* owner, Item* item);
+	uint32 GetRandomTempIndex(uint32 MapId, Difficulty Diff, uint32 ChallengeLv);
+	uint32 GetCreateEnchantId(uint32 EnchantIndex, uint8 Slot);
+
+	bool LevelUp(Player* owner, Item* item);
+
+	uint32 GetQueryId(Item* item){ return item->GetGUIDLow() + 1000000; }
+	uint32 GetGUID(uint32 queryid){ return queryid - 1000000; }
+	uint8 GetInsert(ItemTemplate temp);
+	uint32 GetItemFlag(Item* item);
+	void SetItemFlag(Item* item);
+
+	bool ItemQuery(Player* player, uint32 item);
+
+	bool CanOpenItem(Player* player);
+	void GetMapPrefixSuffix(Item* item, std::string &prefix, std::string &suffix);
+
+	uint32 GetLevelIndex(Item* item);
+	void UpdateAuras(Player* pl);
+	
+private:
+
+};
+#define sNoPatchItem NoPatchItem::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/ItemMod/WeaponPermEnchant.cpp b/src/server/scripts/Custom/ItemMod/WeaponPermEnchant.cpp
new file mode 100644
index 0000000..d7231bf
--- /dev/null
+++ b/src/server/scripts/Custom/ItemMod/WeaponPermEnchant.cpp
@@ -0,0 +1,203 @@
+#pragma execution_character_set("utf-8")
+#include "../PrecompiledHeaders/ScriptPCH.h"
+#include "../DataLoader/DataLoader.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../Requirement/Requirement.h"
+#include "../Reward/Reward.h"
+#include "ItemMod.h"
+#include "Object.h"
+#include "../VIP/VIP.h"
+#include "../HonorRank/HonorRank.h"
+
+void ItemMod::RecoverWeaponPermEnchant(Player* player)
+{
+	uint32 len = player->WeaponVec.size();
+
+	for (size_t i = 0; i < len; i++)
+	{
+		Item* item = player->WeaponVec[i].item;
+
+		if (item)
+		{
+
+			uint32 enchantId = player->WeaponVec[i].enchantId;
+			player->ApplyEnchantment(item, PERM_ENCHANTMENT_SLOT, false);
+			item->SetEnchantment(PERM_ENCHANTMENT_SLOT, enchantId, 0, 0);
+			player->ApplyEnchantment(item, PERM_ENCHANTMENT_SLOT, true);
+			//player->SaveToDB(false, false);
+		}
+	}
+
+	player->WeaponVec.clear();
+}
+
+
+void ItemMod::AddWeaponPermList(Player* player, Item* item)
+{
+	uint32 currEnchantId = item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT);
+	
+	//RemoveTempPermEnchant(player, item);
+	//RecoverWeaponPermEnchant(player);
+
+	SetFilterVec(player, item, ITEM_ENCHANT_WEAPON_PERM, 0);
+
+	uint32 len = FilterVec.size();
+	bool undefineEnchant = true;
+	
+
+	for (uint32 i = 0; i < len; i++)
+		if (currEnchantId && currEnchantId == FilterVec[i].enchantId)
+		{
+			undefineEnchant = false;
+			break;
+		}
+
+	std::ostringstream ossCurrEnchant;
+	
+	if (currEnchantId)
+		ossCurrEnchant << "[µ±Ç°£º" << GetItemEnchantDescription(player, currEnchantId) << "]";
+		
+	if (undefineEnchant && currEnchantId)
+		player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, ossCurrEnchant.str(), senderValue(PERM_ENCHANTMENT_SLOT, currEnchantId), ACTION_REMOVE_ENCHANT_UNDEFINE, "ÒÆ³ý¹âÐ§", DEFAULT_REMOVE_ENCHANT_GOLDS * GOLD, 0);
+
+	if (!undefineEnchant && currEnchantId)
+		for (uint32 i = 0; i < len; i++)
+			if (currEnchantId == FilterVec[i].enchantId)
+			{
+				player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, ossCurrEnchant.str(), senderValue(PERM_ENCHANTMENT_SLOT, currEnchantId), ACTION_ITEM_REMOVE_ENCHANT, "ÒÆ³ý¹âÐ§" + sCF->GetItemLink(item->GetEntry()), 0, 0);
+				break;
+			}
+
+	for (uint32 i = player->flag_i; i < len; i++)
+	{
+		if(currEnchantId != FilterVec[i].enchantId)
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GetItemEnchantDescription(player, FilterVec[i].enchantId), FilterVec[i].enchantId, ACTION_WEAPON_LOOKUPANDBUY_SHOW);
+		player->flag_i++;
+		player->rowId++;
+		if (player->rowId >= MAX_ROWS_COUNT)
+		{
+			player->rowId = 0;
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "ÏÂÒ³", GOSSIP_SENDER_MAIN, ACTION_WEAPON_PERMENCHANT_NEXT_MENU_SHOW);
+			if (player->pageId >= 2)
+				player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "ÉÏÒ³", GOSSIP_SENDER_MAIN, ACTION_PREV_PAGE);
+			break;
+		}
+	}
+
+	if (player->rowId < MAX_ROWS_COUNT && player->rowId != 0 && player->pageId != 1)
+	{
+		player->flag_i = player->flag_i + MAX_ROWS_COUNT - player->rowId;
+		player->rowId = 0;
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "ÉÏÒ³", GOSSIP_SENDER_MAIN, ACTION_PREV_PAGE);
+	}
+
+	player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "·µ»Ø", GOSSIP_SENDER_MAIN, ACTION_MAINMENU_BACK);
+	player->PlayerTalkClass->GetGossipMenu().SetMenuId(MENU_ID);
+	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+}
+
+void ItemMod::LookupOrBuyWeaponPermEnchant(Player* player, Item* item, uint32 sender)
+{
+	uint32 reqId = 0;
+
+	uint32 len = FilterVec.size();
+
+	for (size_t i = 0; i < len; i++)
+		if (sender == FilterVec[i].enchantId)
+		{
+			reqId = FilterVec[i].enchantReqId;
+			break;
+		}
+
+	player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "¹ºÂò", sender, ACTION_WEAPONPERM_BUY, sReq->Notice(player, reqId, sCF->GetItemLink(item->GetEntry()), "¸½¼Ó¹âÐ§"), sReq->Golds(reqId), 0);
+	//HasPermEchant(item) ? player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "²é¿´", sender, ACTION_WEAPONPERM_LOOKUP, "½«»áÒÆ³ýµ±Ç°ÎäÆ÷¹âÐ§£¬È·¶¨Âð£¿", 0, 0) : 
+	player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "²é¿´", sender, ACTION_WEAPONPERM_LOOKUP);
+	player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "·µ»Ø", GOSSIP_SENDER_MAIN, ACTION_WEAPON_PERMENCHANT_CURR_MENU_SHOW);
+	player->PlayerTalkClass->GetGossipMenu().SetMenuId(MENU_ID);
+	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+}
+
+
+
+void ItemMod::LookupWeaponPermEnchant(Player* player, Item* item, uint32 enchantId)
+{
+	if (!item->IsEquipped())
+	{
+		ChatHandler(player->GetSession()).PSendSysMessage("ÇëÏÈ×°±¸Õâ¼þÎäÆ÷!");
+		return;
+	}
+
+	uint32 len = FilterVec.size();
+
+	uint32 reqId = 0;
+	for (size_t i = 0; i < len; i++)
+		if (enchantId == FilterVec[i].enchantId)
+		{
+			reqId = FilterVec[i].enchantReqId;
+			break;
+		}
+	player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "¹ºÂò", enchantId, ACTION_WEAPONPERM_BUY, sReq->Notice(player, reqId, sCF->GetItemLink(item->GetEntry()), "¸½¼Ó¹âÐ§"), sReq->Golds(reqId), 0);
+	//HasPermEchant(item) ? player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "²é¿´", enchantId, ACTION_WEAPONPERM_LOOKUP, "½«»áÒÆ³ýµ±Ç°ÎäÆ÷¹âÐ§£¬È·¶¨Âð£¿", 0, 0) : 
+	player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "²é¿´", enchantId, ACTION_WEAPONPERM_LOOKUP);
+	player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "·µ»Ø", GOSSIP_SENDER_MAIN, ACTION_WEAPON_PERMENCHANT_CURR_MENU_SHOW);
+	player->PlayerTalkClass->GetGossipMenu().SetMenuId(MENU_ID);
+	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+
+	bool invec = false;
+	for (size_t i = 0; i < player->WeaponVec.size(); i++)
+		if (item == player->WeaponVec[i].item)
+			invec = true;
+	
+	if (!invec)
+	{
+		uint32 currEnchantId = item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT);
+		weapontemplate temp;
+		temp.enchantId = currEnchantId;
+		temp.item = item;
+		player->WeaponVec.push_back(temp);
+
+		ChatHandler(player->GetSession()).PSendSysMessage("pushback <------- item:%d -- currEnchantId:%d", item->GetEntry(), currEnchantId);
+	}
+	
+	player->ApplyEnchantment(item, PERM_ENCHANTMENT_SLOT, false);
+	item->SetEnchantment(PERM_ENCHANTMENT_SLOT, enchantId, LOOKUP_WEAPON_PERM_SECONDS * IN_MILLISECONDS, 0);
+	player->ApplyEnchantment(item, PERM_ENCHANTMENT_SLOT, true);
+	ChatHandler(player->GetSession()).PSendSysMessage("¹âÐ§½«ÔÚ%dºó»òÖØÐÂ´ò¿ª²Ëµ¥Ê±ÏûÊ§£¡", LOOKUP_WEAPON_PERM_SECONDS);
+
+	player->isInLookupPermEnchant = true;
+	player->lookupPermEnchantTimer = 0;
+}
+
+void ItemMod::BuyWeaponPermEnchant(Player* player, Item* item, uint32 enchantId)
+{
+	uint32 reqId = 0;
+
+	uint32 len = FilterVec.size();
+
+	for (size_t i = 0; i < len; i++)
+		if (enchantId == FilterVec[i].enchantId)
+		{
+			reqId = FilterVec[i].enchantReqId;
+			break;
+		}
+
+	if (sReq->Check(player, reqId))
+	{
+		player->ApplyEnchantment(item, PERM_ENCHANTMENT_SLOT, false);
+		item->SetEnchantment(PERM_ENCHANTMENT_SLOT, enchantId, 0, 0);
+		player->ApplyEnchantment(item, PERM_ENCHANTMENT_SLOT, true);
+		player->CastSpell(player, VISUAL_SPELL_ID, true, NULL, NULL, player->GetGUID());
+		sReq->Des(player, reqId);
+		player->CLOSE_GOSSIP_MENU();
+		
+		//¹ºÂò¹ýFMµÄ item ½«´ÓvecÖÐÉ¾³ý£¬ÕâÑùµÈ²é¿´½áÊøºó½«²»»áÉ¾³ýFMÐ§¹û
+		for (std::vector<weapontemplate>::iterator itr = player->WeaponVec.begin(); itr != player->WeaponVec.end();)
+		{
+			if (itr->item == item)
+				itr = player->WeaponVec.erase(itr);
+			else
+				++itr;
+		}
+	}
+}
+
diff --git a/src/server/scripts/Custom/ItemSet/ItemSet.cpp b/src/server/scripts/Custom/ItemSet/ItemSet.cpp
new file mode 100644
index 0000000..f800fbf
--- /dev/null
+++ b/src/server/scripts/Custom/ItemSet/ItemSet.cpp
@@ -0,0 +1,228 @@
+#include "ItemSet.h"
+
+std::vector<ItemSetTemplate> ItemSetVec;
+std::vector<ItemSetItemsTemplate> ItemSetItemsVec;
+
+
+bool ItemSetSort(ItemSetTemplate a, ItemSetTemplate b) { return (a.counts < b.counts); }
+
+void ItemSet::Load()
+{
+	return;
+	ItemSetVec.clear();
+	QueryResult result1 = WorldDatabase.PQuery("SELECT ID,counts,spell1,spell2,spell3,description from _itemmod_set");
+	if (result1)
+	{
+		do
+		{
+			Field* fields = result1->Fetch();
+			ItemSetTemplate Temp;
+			Temp.ID				= fields[0].GetUInt32();
+			Temp.counts			= fields[1].GetUInt32();
+			Temp.spell1			= fields[2].GetUInt32();
+			Temp.spell2			= fields[3].GetUInt32();
+			Temp.spell3			= fields[4].GetUInt32();
+			Temp.description	= fields[5].GetString();
+			ItemSetVec.push_back(Temp);
+		} while (result1->NextRow());
+	}
+
+	ItemSetItemsVec.clear();
+	QueryResult result2 = WorldDatabase.PQuery("SELECT ID,entry from _itemmod_set_items");
+	if (result2)
+	{
+		do
+		{
+			Field* fields = result2->Fetch();
+			ItemSetItemsTemplate Temp;
+			Temp.ID		= fields[0].GetUInt32();
+			Temp.entry	= fields[1].GetUInt32();
+			ItemSetItemsVec.push_back(Temp);
+		} while (result2->NextRow());
+	}
+}
+
+std::string ItemSet::GetDes(uint32 entry)
+{
+	uint32 ID = 0;
+
+	std::vector<ItemSetItemsTemplate>::iterator itr1;
+	for (itr1 = ItemSetItemsVec.begin(); itr1 != ItemSetItemsVec.end(); itr1++)
+		if (itr1->entry == entry)
+		{
+			ID = itr1->ID;
+			break;
+		}
+
+	if (ID == 0)
+		return "";
+	
+	std::ostringstream oss;
+
+	std::sort(ItemSetVec.begin(), ItemSetVec.end(), ItemSetSort);
+	std::vector<ItemSetTemplate>::iterator itr2;
+	for (itr2 = ItemSetVec.begin(); itr2 != ItemSetVec.end(); itr2++)
+		if (ID == itr2->ID)
+		{
+			oss << itr2->description << "\n";
+		}
+
+	return oss.str();
+}
+
+uint32 ItemSet::GetID(uint32 entry)
+{
+	uint32 ID = 0;
+
+	std::vector<ItemSetItemsTemplate>::iterator itr;
+	for (itr = ItemSetItemsVec.begin(); itr != ItemSetItemsVec.end(); itr++)
+		if (itr->entry == entry)
+		{
+			ID = itr->ID;
+			break;
+		}
+
+	return ID;
+}
+
+void ItemSet::AddAllSpell(Player* player)
+{
+	player->InvSetVec.clear();
+
+	for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
+		if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+		{
+			uint32 ID = GetID(item->GetEntry());
+			if (ID != 0)
+				player->InvSetVec.push_back(ID);
+		}
+
+	//Ñ§Ï°ÐÂµÄÌ××°¼¼ÄÜ
+	std::vector<uint32 /*spell*/> spellVec;
+
+	for (std::vector<uint32>::iterator itr = player->InvSetVec.begin(); itr != player->InvSetVec.end(); itr++)
+	{
+		uint32 ID = *itr;
+		uint32 counts = std::count(player->InvSetVec.begin(), player->InvSetVec.end(), ID);
+
+		for (std::vector<ItemSetTemplate>::iterator i = ItemSetVec.begin(); i != ItemSetVec.end(); i++)
+			if (ID == i->ID && counts >= i->counts)
+			{
+				if (SpellInfo const* spellEntry1 = sSpellMgr->GetSpellInfo(i->spell1))
+					if (std::find(spellVec.begin(), spellVec.end(), i->spell1) == spellVec.end())
+						spellVec.push_back(i->spell1);
+				if (SpellInfo const* spellEntry2 = sSpellMgr->GetSpellInfo(i->spell2))
+					if (std::find(spellVec.begin(), spellVec.end(), i->spell2) == spellVec.end())
+						spellVec.push_back(i->spell2);
+				if (SpellInfo const* spellEntry3 = sSpellMgr->GetSpellInfo(i->spell3))
+					if (std::find(spellVec.begin(), spellVec.end(), i->spell3) == spellVec.end())
+						spellVec.push_back(i->spell3);
+			}
+	}
+
+	for (std::vector<uint32 /*spell*/>::iterator i = spellVec.begin(); i != spellVec.end(); i++)
+		if (!player->HasSpell(*i))
+			player->learnSpell(*i);
+}
+
+void ItemSet::UpdateSpell(Player* player, uint32 addEntry, uint32 remEntry)
+{
+	player->InvSetVec.clear();
+
+	for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
+		if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+		{
+			uint32 ID = GetID(item->GetEntry());
+			if (ID != 0)
+				player->InvSetVec.push_back(ID);
+		}
+
+	uint32 remID = GetID(remEntry);
+	uint32 addID = GetID(addEntry);
+
+	if (remID == addID)
+		return;
+
+	//ÐèÒªÒÆ³ý¼¼ÄÜVEC
+
+	std::vector<uint32 /*spell*/> remVec;
+
+	for (std::vector<ItemSetTemplate>::iterator it = ItemSetVec.begin(); it != ItemSetVec.end(); it++)
+	{
+		if (remID == it->ID)
+		{
+			uint32 counts = std::count(player->InvSetVec.begin(), player->InvSetVec.end(), remID);
+			if (counts >= it->counts)
+				continue;
+
+			if (SpellInfo const* spellEntry1 = sSpellMgr->GetSpellInfo(it->spell1))
+				if (std::find(remVec.begin(), remVec.end(), it->spell1) == remVec.end())
+					remVec.push_back(it->spell1);
+			if (SpellInfo const* spellEntry2 = sSpellMgr->GetSpellInfo(it->spell2))
+				if (std::find(remVec.begin(), remVec.end(), it->spell2) == remVec.end())
+					remVec.push_back(it->spell2);
+			if (SpellInfo const* spellEntry3 = sSpellMgr->GetSpellInfo(it->spell3))
+				if (std::find(remVec.begin(), remVec.end(), it->spell3) == remVec.end())
+					remVec.push_back(it->spell3);
+		}		
+	}
+
+	//ÐÂÌ××°¼¼ÄÜVEC
+
+	std::vector<uint32 /*spell*/> addVec;
+
+	for (std::vector<uint32>::iterator itr = player->InvSetVec.begin(); itr != player->InvSetVec.end(); itr++)
+	{
+		uint32 ID = *itr;
+		uint32 counts = std::count(player->InvSetVec.begin(), player->InvSetVec.end(), ID);
+
+		for (std::vector<ItemSetTemplate>::iterator i = ItemSetVec.begin(); i != ItemSetVec.end(); i++)
+			if (ID == i->ID && counts >= i->counts)
+			{
+				if (SpellInfo const* spellEntry1 = sSpellMgr->GetSpellInfo(i->spell1))
+					if (std::find(addVec.begin(), addVec.end(), i->spell1) == addVec.end())
+						addVec.push_back(i->spell1);
+				if (SpellInfo const* spellEntry2 = sSpellMgr->GetSpellInfo(i->spell2))
+					if (std::find(addVec.begin(), addVec.end(), i->spell2) == addVec.end())
+						addVec.push_back(i->spell2);
+				if (SpellInfo const* spellEntry3 = sSpellMgr->GetSpellInfo(i->spell3))
+					if (std::find(addVec.begin(), addVec.end(), i->spell3) == addVec.end())
+						addVec.push_back(i->spell3);
+			}
+	}
+
+	//È¥ÖØ
+	for (std::vector<uint32 /*spell*/>::iterator i = remVec.begin(); i != remVec.end();)
+	{		
+		if (std::find(addVec.begin(), addVec.end(), *i) != addVec.end())
+			i = remVec.erase(i);
+		else
+			++i;
+	}	
+
+	//ÒÆ³ý¼¼ÄÜ
+	for (std::vector<uint32 /*spell*/>::iterator i = remVec.begin(); i != remVec.end(); i++)
+		if (player->HasSpell(*i))
+			player->removeSpell(*i, SPEC_MASK_ALL, false);
+
+	//Ñ§Ï°¼¼ÄÜ
+	for (std::vector<uint32 /*spell*/>::iterator i = addVec.begin(); i != addVec.end(); i++)
+		if (!player->HasSpell(*i))
+			player->learnSpell(*i);
+}
+
+
+class ItemSetPlayerScript : PlayerScript
+{
+public:
+	ItemSetPlayerScript() : PlayerScript("ItemSetPlayerScript") {}
+
+	void OnLogin(Player* player)
+	{
+		sItemSet->AddAllSpell(player);
+	}
+};
+void AddSC_ItemSet()
+{
+	new ItemSetPlayerScript();
+}
diff --git a/src/server/scripts/Custom/ItemSet/ItemSet.h b/src/server/scripts/Custom/ItemSet/ItemSet.h
new file mode 100644
index 0000000..1e128d6
--- /dev/null
+++ b/src/server/scripts/Custom/ItemSet/ItemSet.h
@@ -0,0 +1,37 @@
+struct ItemSetTemplate
+{
+	uint32 ID;
+	uint32 counts;
+	uint32 spell1;
+	uint32 spell2;
+	uint32 spell3;
+	std::string description;
+};
+
+extern std::vector<ItemSetTemplate> ItemSetVec;
+
+struct ItemSetItemsTemplate
+{
+	uint32 ID;
+	uint32 entry;
+};
+
+extern std::vector<ItemSetItemsTemplate> ItemSetItemsVec;
+
+class ItemSet
+{
+public:
+	static ItemSet* instance()
+	{
+		static ItemSet instance;
+		return &instance;
+	}
+	void Load();
+	std::string GetDes(uint32 entry);
+	uint32 GetID(uint32 entry);
+	void AddAllSpell(Player* player);
+	void UpdateSpell(Player* player, uint32 addEntry, uint32 remEntry);
+private:
+
+};
+#define sItemSet ItemSet::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/LeaderReward/LeaderReward.cpp b/src/server/scripts/Custom/LeaderReward/LeaderReward.cpp
new file mode 100644
index 0000000..2b556f2
--- /dev/null
+++ b/src/server/scripts/Custom/LeaderReward/LeaderReward.cpp
@@ -0,0 +1,283 @@
+#pragma execution_character_set("utf-8")
+#include "LeaderReward.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "Group.h"
+#include "../Reward/Reward.h"
+
+std::vector<LeaderRewardTemplate> LeaderRewardVec;
+std::vector<LearderDataTemplate> LeaderDataVec;
+
+void LeaderReward::Load()
+{
+	return;
+	LeaderRewardVec.clear();
+	QueryResult result = WorldDatabase.PQuery("SELECT mapIdOrZoneId,isInstance,bossInfo,rewId,distance,nearbyPlayers,rewType,diff,ipMaxCount FROM _leader_reward");
+	if (!result) return;
+	do
+	{
+		Field* fields = result->Fetch();
+		LeaderRewardTemplate Temp;
+		Temp.mapIdOrZoneId	= fields[0].GetUInt32();
+		Temp.isInstance		= fields[1].GetBool();
+
+		std::string bossInfo = fields[2].GetString();
+		std::vector<std::string> strBossInfo = sCF->SplitStr(bossInfo, "|");
+		for (size_t j = 0; j < strBossInfo.size(); j++)
+			Temp.bossInfo.push_back(atoi(strBossInfo[j].c_str()));
+
+		Temp.rewId			= fields[3].GetUInt32();
+		Temp.range			= fields[4].GetUInt32();
+		Temp.nearbyPlayers	= fields[5].GetUInt32();
+		Temp.rewType		= fields[6].GetUInt32();
+		Temp.diff			= fields[7].GetUInt8();
+		Temp.ipMaxCount		= fields[8].GetUInt32();
+		LeaderRewardVec.push_back(Temp);
+	} while (result->NextRow());
+}
+
+void LeaderReward::GetLeaderInfo(uint32 entry,uint32 mapIdOrZoneId, bool isInstance, uint8 diff, std::vector<uint32/*bossId*/> &bossVec, uint32 &rewId, uint32 &range, uint32 &nearbyPlayers, uint32 &rewType, uint32 &ipMaxCount)
+{
+	uint32 len = LeaderRewardVec.size();
+	for (size_t i = 0; i < len; i++)
+	{
+		if (mapIdOrZoneId == LeaderRewardVec[i].mapIdOrZoneId && isInstance == LeaderRewardVec[i].isInstance && diff == LeaderRewardVec[i].diff)
+		{
+			bossVec = LeaderRewardVec[i].bossInfo;
+
+			if (std::find(bossVec.begin(), bossVec.end(), entry) == bossVec.end())
+			{
+				bossVec.clear();
+				continue;
+			}
+
+			rewId = LeaderRewardVec[i].rewId;
+			range = LeaderRewardVec[i].range;
+			nearbyPlayers = LeaderRewardVec[i].nearbyPlayers;
+			rewType = LeaderRewardVec[i].rewType;
+			ipMaxCount = LeaderRewardVec[i].ipMaxCount;
+
+			return;
+		}
+	}
+}
+
+uint32 LeaderReward::GetNearbyPlayers(Player* leader, float range)
+{
+	Group* group = leader->GetGroup();
+
+	if (!group)
+		return 0;
+
+	uint32 count = 0;
+
+	for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+		if (Player* member = itr->GetSource())
+			if (member->GetDistance2d(leader) <= range)
+				count += 1;
+	
+	return count - 1;
+}
+
+uint32 LeaderReward::GetSameIpCount(Player* leader)
+{
+	Group* group = leader->GetGroup();
+
+	if (!group)
+		return 1;
+
+	std::vector<std::string> ipVec;
+
+	for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+		if (Player* member = itr->GetSource())
+		{
+			std::string ipAdress = member->GetSession()->GetRemoteAddress();
+				ipVec.push_back(ipAdress);
+		}
+
+	uint32 max = 0;
+
+	for (std::vector<std::string>::iterator iter = ipVec.begin(); iter != ipVec.end(); ++iter)
+	{
+		uint32 count = std::count(ipVec.begin(), ipVec.end(), (*iter));
+
+		if (count > max)
+			max = count;
+	}
+
+	return max;
+}
+
+void LeaderReward::GetBossInfoVec(uint32 mapIdOrZoneId,bool isInstance,uint8 diff, uint32 entry, std::vector<uint32> &bossinfovec)
+{
+	for (std::vector<LeaderRewardTemplate>::iterator iLeaderRewardVec = LeaderRewardVec.begin(); iLeaderRewardVec != LeaderRewardVec.end(); ++iLeaderRewardVec)
+	{
+		if (mapIdOrZoneId != iLeaderRewardVec->mapIdOrZoneId || isInstance != iLeaderRewardVec->isInstance || diff != iLeaderRewardVec->diff)
+			continue;
+
+		for (std::vector<uint32>::iterator ii = iLeaderRewardVec->bossInfo.begin(); ii != iLeaderRewardVec->bossInfo.end(); ++ii)
+			if (entry == (*ii))
+			{
+				bossinfovec = iLeaderRewardVec->bossInfo;
+				break;
+			}
+	}
+		
+}
+
+void LeaderReward::GetPlayerBossIdVec(uint32 guid, bool isInstance, uint8 diff, uint32 mapIdOrZoneId, std::vector<uint32> &playerbossidvec)
+{
+	for (std::vector<LearderDataTemplate>::iterator i = LeaderDataVec.begin(); i != LeaderDataVec.end(); ++i)
+	{
+		if (guid == i->guid && diff == i->diff && isInstance == i->isInstance)
+		{
+			playerbossidvec.push_back(i->bossId);
+		}
+	}
+}
+
+bool LeaderReward::CheckLeaderData(Player* killer, Creature* boss)
+{
+	bool isInstance = killer->GetMap()->Instanceable();
+	uint8 diff = killer->GetMap()->GetDifficulty();
+	uint32 mapIdOrZoneId = 0;
+
+	if (isInstance)
+		mapIdOrZoneId = killer->GetMapId();
+	else
+		mapIdOrZoneId = killer->GetZoneId();
+
+
+	Group* group = killer->GetGroup();
+
+	uint32 entry = boss->GetEntry();
+
+	Player* leader;
+
+	if (group)
+		leader = ObjectAccessor::FindPlayerInOrOutOfWorld(group->GetLeaderGUID());
+	else
+		leader = killer;
+
+
+	std::vector<uint32/*bossId*/> bossVec;
+	uint32 rewId = 0;
+	uint32 range = 0;
+	uint32 nearbyPlayers = 0;
+	uint32 rewType = 0;
+	uint32 ipMaxCount = 0;
+
+	GetLeaderInfo(entry,mapIdOrZoneId, isInstance, diff, bossVec, rewId, range, nearbyPlayers, rewType, ipMaxCount);
+	
+	//¸ÃµØÍ¼»òÇøÓò²»ÔÚ±íÖÐ
+	if (bossVec.empty() || rewId == 0)
+		return false;
+
+	bool isLegalBoss = false;
+
+	for (std::vector<uint32>::iterator i = bossVec.begin(); i != bossVec.end(); ++i)
+		if (entry == (*i))
+			isLegalBoss = true;
+
+	if (!isLegalBoss)
+		return false;
+
+	uint32 count = GetNearbyPlayers(leader, range);
+	uint32 ipCount = GetSameIpCount(leader);
+
+	if (count < nearbyPlayers && group)
+	{
+		ChatHandler(leader->GetSession()).PSendSysMessage("¹²ÓÐ %d ÈËÔÚ %d Âë·¶Î§ÄÚ£¬ÐèÒª %d ÈË£¬½«ÎÞ·¨»ñµÃ½±Àø", count, range, nearbyPlayers);
+		return false;
+	}
+
+	if (ipCount > ipMaxCount && group)
+	{
+		ChatHandler(leader->GetSession()).PSendSysMessage("¹²ÓÐ %d ÈËÍ¬Ò»IP£¬³¬¹ýÏÞÖÆ %d£¬½«ÎÞ·¨»ñµÃ½±Àø", ipCount, ipMaxCount);
+		return false;
+	}
+
+	std::vector<uint32> bossinfovec;
+	GetBossInfoVec(mapIdOrZoneId, isInstance, diff, entry, bossinfovec);
+	std::vector<uint32> playerbossidvec;
+	GetPlayerBossIdVec(leader->GetGUIDLow(), isInstance, diff, mapIdOrZoneId, playerbossidvec);
+
+	bool exsist = false;
+
+	for (std::vector<uint32>::iterator iter = playerbossidvec.begin(); iter != playerbossidvec.end(); ++iter)
+		if (entry == (*iter))
+			exsist = true;
+
+	if (!exsist)
+	{
+		LearderDataTemplate Temp;
+		Temp.guid = leader->GetGUIDLow();
+		Temp.mapIdOrZoneId = mapIdOrZoneId;
+		Temp.isInstance = isInstance;
+		Temp.diff = diff;
+		Temp.bossId = entry;
+		LeaderDataVec.push_back(Temp);
+	}	
+
+	GetPlayerBossIdVec(leader->GetGUIDLow(), isInstance, diff, mapIdOrZoneId, playerbossidvec);
+
+	bool allKillFlag = true;
+
+	for (std::vector<uint32>::iterator iter = bossinfovec.begin(); iter != bossinfovec.end(); ++iter)
+	{
+		
+		if (std::find(playerbossidvec.begin(), playerbossidvec.end(), (*iter)) == playerbossidvec.end())
+		{
+			allKillFlag = false;
+			break;
+		}
+			
+	}
+
+
+	if (!allKillFlag)
+		return false;
+
+	if (rewType == 0)
+		sRew->Rew(leader, rewId);
+	else
+	{
+		if (group)
+			for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+				if (Player* member = itr->GetSource())
+					sRew->Rew(member, rewId);
+	}
+
+	//½±ÀøÖ®ºóÇå¿Õ
+	for (std::vector<LearderDataTemplate>::iterator iter = LeaderDataVec.begin(); iter != LeaderDataVec.end(); ++iter)
+	{
+		if (leader->GetGUIDLow() == iter->guid && mapIdOrZoneId == iter->mapIdOrZoneId && isInstance == iter->isInstance && diff == iter->diff)
+		{
+			if (std::find(bossinfovec.begin(), bossinfovec.end(), iter->bossId) != bossinfovec.end())
+				iter->bossId = 0;
+		}
+	}
+
+
+	for (std::vector<LearderDataTemplate>::iterator iter = LeaderDataVec.begin(); iter != LeaderDataVec.end();)
+		if (iter->bossId == 0)
+			iter = LeaderDataVec.erase(iter);
+		else
+			++iter;
+
+	return true;
+}
+
+class LeaderRewardPlayerScript : PlayerScript
+{
+public:
+	LeaderRewardPlayerScript() : PlayerScript("LeaderRewardPlayerScript") {}
+
+	void OnCreatureKill(Player* killer, Creature* boss) override
+	{
+		sLeaderReward->CheckLeaderData(killer, boss);
+	}
+};
+void AddSC_LeaderReward()
+{
+	//new LeaderRewardPlayerScript();
+}
diff --git a/src/server/scripts/Custom/LeaderReward/LeaderReward.h b/src/server/scripts/Custom/LeaderReward/LeaderReward.h
new file mode 100644
index 0000000..97190ab
--- /dev/null
+++ b/src/server/scripts/Custom/LeaderReward/LeaderReward.h
@@ -0,0 +1,47 @@
+//¸±±¾ÐÅÏ¢
+struct LeaderRewardTemplate
+{
+	uint32 mapIdOrZoneId;
+	bool isInstance;
+	uint8 diff;
+	std::vector<uint32 /*bossid*/> bossInfo;
+	uint32 rewId;
+	uint32 range;
+	uint32 nearbyPlayers;
+	uint32 rewType;
+	uint32 ipMaxCount;
+};
+
+extern std::vector<LeaderRewardTemplate> LeaderRewardVec;
+
+//Íæ¼ÒÐÅÏ¢
+struct LearderDataTemplate
+{
+	uint32 guid;
+	bool isInstance;/*ÊÇ·ñÊÇ¸±±¾*/
+	uint8 diff;
+	uint32 mapIdOrZoneId;/*¸±±¾Ê¹ÓÃmapId,·Ç¸±±¾Ê¹ÓÃzoneId*/
+	//std::vector<uint32/*bossId*/> BossIdVec;/*»÷É±ºóÈç¹ûÈÝÆ÷ÒÑÓÐ´Ë¹ÖÎïÐÅÏ¢ÔòÏÈÇå¿ÕÈÝÆ÷ºóÑ¹Èë£¬Èç¹ûÃ»ÓÐÔòÖ±½ÓÑ¹Èë*/
+	uint32 bossId;
+};
+
+extern std::vector<LearderDataTemplate> LeaderDataVec;
+
+class LeaderReward
+{
+public:
+	static LeaderReward* instance()
+	{
+		static LeaderReward instance;
+		return &instance;
+	}
+
+	void Load();
+	void GetLeaderInfo(uint32 entry, uint32 mapIdOrZoneId, bool isInstance, uint8 diff, std::vector<uint32/*bossId*/> &bossVec, uint32 &rewId, uint32 &range, uint32 &nearbyPlayers, uint32 &rewType, uint32 &ipMaxCount);
+	bool CheckLeaderData(Player* killer, Creature* boss);
+	uint32 GetNearbyPlayers(Player* leader,float range);
+	uint32 GetSameIpCount(Player* leader);
+	void GetBossInfoVec(uint32 mapIdOrZoneId,bool isInstance,uint8 diff, uint32 entry, std::vector<uint32> &bossinfovec);
+	void GetPlayerBossIdVec(uint32 guid, bool isInstance, uint8 diff, uint32 mapIdOrZoneId, std::vector<uint32> &playerbossidvec);
+};
+#define sLeaderReward LeaderReward::instance()
diff --git a/src/server/scripts/Custom/LoginCode/LoginCode.cpp b/src/server/scripts/Custom/LoginCode/LoginCode.cpp
new file mode 100644
index 0000000..6021d1f
--- /dev/null
+++ b/src/server/scripts/Custom/LoginCode/LoginCode.cpp
@@ -0,0 +1,178 @@
+#pragma execution_character_set("utf-8")
+#include "LoginCode.h"
+#include <cstring>
+#include "openssl/hmac.h"
+#include "openssl/evp.h"
+int base32_decode(const char* encoded, char* result, int bufSize)
+{
+    // Base32 implementation
+    // Copyright 2010 Google Inc.
+    // Author: Markus Gutschke
+    // Licensed under the Apache License, Version 2.0
+    int buffer = 0;
+    int bitsLeft = 0;
+    int count = 0;
+    for (const char* ptr = encoded; count < bufSize && *ptr; ++ptr)
+    {
+        char ch = *ptr;
+        if (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n' || ch == '-')
+            continue;
+        buffer <<= 5;
+        // Deal with commonly mistyped characters
+        if (ch == '0')
+            ch = 'O';
+        else if (ch == '1')
+            ch = 'L';
+        else if (ch == '8')
+            ch = 'B';
+        // Look up one base32 digit
+        if ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'))
+            ch = (ch & 0x1F) - 1;
+        else if (ch >= '2' && ch <= '7')
+            ch -= '2' - 26;
+        else
+            return -1;
+        buffer |= ch;
+        bitsLeft += 5;
+        if (bitsLeft >= 8)
+        {
+            result[count++] = buffer >> (bitsLeft - 8);
+            bitsLeft -= 8;
+        }
+    }
+    if (count < bufSize)
+        result[count] = '\000';
+    return count;
+}
+
+#define HMAC_RES_SIZE 20
+
+int GenerateToken(const char* b32key)
+{
+    size_t keySize = strlen(b32key);
+    int bufsize = (keySize + 7) / 8 * 5;
+    char* encoded = new char[bufsize];
+    memset(encoded, 0, bufsize);
+    unsigned int hmacResSize = HMAC_RES_SIZE;
+    unsigned char hmacRes[HMAC_RES_SIZE];
+    unsigned long timestamp = time(nullptr) / 30;
+    unsigned char challenge[8];
+    for (int i = 8; i--; timestamp >>= 8)
+        challenge[i] = timestamp;
+    base32_decode(b32key, encoded, bufsize);
+    HMAC(EVP_sha1(), encoded, bufsize, challenge, 8, hmacRes, &hmacResSize);
+    unsigned int offset = hmacRes[19] & 0xF;
+    unsigned int truncHash = (hmacRes[offset] << 24) | (hmacRes[offset + 1] << 16) | (hmacRes[offset + 2] << 8) | (hmacRes[offset + 3]);
+    truncHash &= 0x7FFFFFFF;
+    delete[] encoded;
+    return truncHash % 1000000;
+}
+
+#define LETTER_SIZE 24
+
+const std::string letter[LETTER_SIZE] = { "A", "B", "C", "D", "E", "F", "G", "H", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" };
+
+void LoginCode::GenerateCode(Player* player)
+{
+	std::string code = "";
+
+	for (size_t i = 0; i < 16; i++)
+		code += letter[urand(0, LETTER_SIZE - 1)];
+
+	player->temp_token_key = code;
+}
+
+void LoginCode::AddGossip(Player* player, Object* obj)
+{
+	player->PlayerTalkClass->ClearMenus();
+
+	if (player->token_key.empty())
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Ê¹ÓÃ¶¯Ì¬¿ÚÁîµÇÂ¼¿ÉÒÔÈÃÕËºÅ¸ü¼Ó°²È«\n\n²Ù×÷²½Öè\n1.ÏÂÔØ¹È¸èÁîÅÆAPP\n2.µã»÷²úÉúÒ»¸ö16Î»µÄÃÜÔ¿\n3.´ò¿ªAPPÑ¡ÔñÊäÈëÌá¹©µÄÃÜÔ¿£¬½«ÕËºÅºÍÃÜÔ¿ÊäÈë£¬½«ÃÜÔ¿ÓëAPP°ó¶¨\n\n¡¸µã»÷²úÉúÃÜÔ¿¡¹", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
+	else
+		player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "½â³ý¶¯Ì¬¿ÚÁîµÇÂ¼", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF, "", 0, true);
+	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+}
+
+void LoginCode::Action(Player*player, uint32 action, Object*obj)
+{
+	player->PlayerTalkClass->ClearMenus();
+
+	switch (action)
+	{
+	case GOSSIP_ACTION_INFO_DEF:
+		GenerateCode(player);
+		player->ADD_GOSSIP_ITEM_EXTENDED(0, "½«ÏÂÁÐÃÜÔ¿°ó¶¨ÔÚ¹È¸èÁîÅÆAPP\n\n|cFFFF0000¡¸|r" + player->temp_token_key + "|cFFFF0000¡¹|r\n\n¡¸µã»÷Ìí¼Ó¶¯Ì¬¿ÚÁîµÇÂ¼¡¹", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1, "\nµã»÷È·ÈÏºó·þÎñÆ÷½«±£´æÄãµÄÃÜÔ¿\n\n|cFFFF0000¡¸|r" + player->temp_token_key + "|cFFFF0000¡¹|r\n\nÇëÈ·ÈÏÄãÒÑ¾­ÏÂÔØ¹È¸èÁîÅÆAPPÇÒÒÑ¾­°ó¶¨¸ÃÃÜÔ¿\n", 0, false);
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+		break;
+	case GOSSIP_ACTION_INFO_DEF + 1:	
+		player->token_key = player->temp_token_key;
+		LoginDatabase.DirectPExecute("UPDATE account SET token_key = '%s' WHERE id = '%u'", player->token_key.c_str(), player->GetSession()->GetAccountId());
+		ChatHandler(player->GetSession()).PSendSysMessage("|cFFFF0000¡¸|r%s|cFFFF0000¡¹|rÒÑ¾­´æ´¢£¬Çë¼°Ê±°ó¶¨¹È¸èÁîÅÆAPP", player->token_key.c_str());
+		player->CLOSE_GOSSIP_MENU();
+		break;
+	}
+}
+
+
+class LoginCodePlayerScript : PlayerScript
+{
+public:
+	LoginCodePlayerScript() : PlayerScript("LoginCodePlayerScript") {}
+
+	void OnLogin(Player* player)
+	{
+		QueryResult result = LoginDatabase.PQuery("SELECT token_key FROM account WHERE id = '%u'", player->GetSession()->GetAccountId());
+
+		if (!result) 
+			return;
+
+		player->token_key = result->Fetch()[0].GetString();
+	}
+};
+
+class LoginCodeCreatureScript : public CreatureScript
+{
+public:
+	LoginCodeCreatureScript() : CreatureScript("LoginCodeCreatureScript") { }
+
+
+	bool OnGossipHello(Player* player, Creature* creature) override
+	{
+		sLoginCode->AddGossip(player, creature);
+		return true;
+	}
+
+	bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action) override
+	{
+		sLoginCode->Action(player, action, creature);
+		return true;
+	}
+
+	bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, const char* code) override
+	{
+		if (!*code)
+			return false;
+
+		int inputToken = atoi(code);
+		int validToken = GenerateToken(player->token_key.c_str());
+
+		if (validToken != inputToken)
+		{
+			player->GetSession()->SendNotification("ÄãÊäÈëµÄ¶¯Ì¬¿ÚÁîÃÜÂëÎÞ·¨Í¨¹ýÑéÖ¤£¡");
+			player->CLOSE_GOSSIP_MENU();
+			return false;
+		}
+
+		LoginDatabase.DirectPExecute("UPDATE account SET token_key = '' WHERE id = '%u'", player->GetSession()->GetAccountId());
+		player->token_key = "";
+		ChatHandler(player->GetSession()).PSendSysMessage("ÒÑ¾­½â³ý¶¯Ì¬¿ÚÁîµÇÂ¼£¡");
+		player->CLOSE_GOSSIP_MENU();
+		return true;
+	}
+};
+
+void AddSC_LoginCodeScript()
+{
+	new LoginCodePlayerScript();
+	new LoginCodeCreatureScript();
+}
diff --git a/src/server/scripts/Custom/LoginCode/LoginCode.h b/src/server/scripts/Custom/LoginCode/LoginCode.h
new file mode 100644
index 0000000..45e04e8
--- /dev/null
+++ b/src/server/scripts/Custom/LoginCode/LoginCode.h
@@ -0,0 +1,15 @@
+class LoginCode
+{
+public:
+	static LoginCode* instance()
+	{
+		static LoginCode instance;
+		return &instance;
+	}
+	void AddGossip(Player* player, Object* obj);
+	void Action(Player*player, uint32 action, Object*obj);
+	void GenerateCode(Player* player);
+private:
+
+};
+#define sLoginCode LoginCode::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Lottery/Lottery.cpp b/src/server/scripts/Custom/Lottery/Lottery.cpp
new file mode 100644
index 0000000..0d8e897
--- /dev/null
+++ b/src/server/scripts/Custom/Lottery/Lottery.cpp
@@ -0,0 +1,404 @@
+#pragma execution_character_set("utf-8")
+#include "Lottery.h"
+#include "../Switch/Switch.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../String/myString.h"
+
+std::vector<LotteryTemplate> LotteryInfo;
+std::vector<LotterySetTemplate> LotteryVec;
+
+void Lottery::Load()
+{
+	LotteryVec.clear();
+
+	if (!sSwitch->GetOnOff(ST_LOTTERY))
+		return;
+
+	QueryResult result = WorldDatabase.PQuery(
+		sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+		//			0			1		2			3			4			5		6		7
+		"SELECT ¹ºÂò×Ü»ý·ÖÉÏÏÞ,¿ª½±¼ä¸ô,¿ª±ª×Ó·­±¶Êý,¿ª´ó·­±¶Êý,¿ªÐ¡·­±¶Êý,¿ª±ª×Ó¼¸ÂÊ,¿ª´ó¼¸ÂÊ,¿ªÐ¡¼¸ÂÊ FROM __²ÊÆ±" :
+		//			0			1		2			3		4		5		6			7
+		"SELECT tokenLimit,intervals,aaa_muil,max_muil,min_muil,aaa_chance,max_chance,min_chance FROM _lottery");
+	if (!result) return;
+
+	Field* fields = result->Fetch();
+	LotterySetTemplate LotteryTemp;
+	LotteryTemp.tokenLimit	= fields[0].GetUInt32();
+	LotteryTemp.interval	= fields[1].GetUInt32();
+	LotteryTemp.aaa_muil	= fields[2].GetUInt32();
+	LotteryTemp.max_muil	= fields[3].GetUInt32();
+	LotteryTemp.min_muil	= fields[4].GetUInt32();
+	LotteryTemp.aaa_chance	= fields[5].GetUInt32();
+	LotteryTemp.max_chance	= fields[6].GetUInt32();
+	LotteryTemp.min_chance	= fields[7].GetUInt32();
+	LotteryVec.push_back(LotteryTemp);
+
+	if (!LotteryVec.empty())
+		SetLotteryAmountLimit(LotteryVec[0].tokenLimit);
+}
+
+void Lottery::LoadLotterData()
+{
+	LotteryInfo.clear();
+	QueryResult result = CharacterDatabase.PQuery("SELECT guidLow,lotteryType,lotteryAmount FROM character_lottery");
+	if (!result) return;
+	do
+	{
+		Field* fields = result->Fetch();
+		LotteryTemplate LotteryTemp;
+		LotteryTemp.guidLow			= fields[0].GetUInt32();
+		LotteryTemp.lotteryType		= LotteryType(fields[1].GetUInt32());
+		LotteryTemp.lotteryAmount	= fields[2].GetUInt32();
+		LotteryInfo.push_back(LotteryTemp);
+	} while (result->NextRow());
+}
+
+uint32 Lottery::GetMuilByType(LotteryType type)
+{
+	if (LotteryVec.empty())
+		return 0;
+
+	switch (type)
+	{
+	case LOTTERY_TYPE_AAA:
+		return LotteryVec[0].aaa_muil;
+	case LOTTERY_TYPE_MAX:
+		return LotteryVec[0].max_muil;
+	case LOTTERY_TYPE_MIN:
+		return LotteryVec[0].min_muil;
+	default:
+		return 0;
+	}
+}
+
+uint32 Lottery::GetRewardTokenAmountByType(LotteryType type)
+{
+	uint32 AAA_Amount = 0;
+	uint32 MAX_Amount = 0;
+	uint32 MIN_Amount = 0;
+
+	for (size_t i = 0; i < LotteryInfo.size(); i++)
+	{
+		if (type != LotteryInfo[i].lotteryType)
+			continue;
+
+		switch (type)
+		{
+		case LOTTERY_TYPE_AAA:
+			AAA_Amount += LotteryInfo[i].lotteryAmount;
+			break;
+		case LOTTERY_TYPE_MAX:
+			MAX_Amount += LotteryInfo[i].lotteryAmount;
+			break;
+		case LOTTERY_TYPE_MIN:
+			MIN_Amount += LotteryInfo[i].lotteryAmount;
+			break;
+		default:
+			break;
+		}
+	}
+
+	switch (type)
+	{
+	case LOTTERY_TYPE_AAA:
+		return AAA_Amount * GetMuilByType(LOTTERY_TYPE_AAA);
+	case LOTTERY_TYPE_MAX:
+		return MAX_Amount * GetMuilByType(LOTTERY_TYPE_MAX);
+	case LOTTERY_TYPE_MIN:
+		return MIN_Amount * GetMuilByType(LOTTERY_TYPE_MIN);
+	default:
+		return 0;
+	}
+}
+
+void Lottery::GenerateLotteryType()
+{
+	LotteryType type;
+
+	if (LotteryVec[0].aaa_chance == 0 && LotteryVec[0].max_chance == 0 && LotteryVec[0].min_chance == 0)
+	{
+		uint32 aaa = GetRewardTokenAmountByType(LOTTERY_TYPE_AAA);
+		uint32 max = GetRewardTokenAmountByType(LOTTERY_TYPE_MAX);
+		uint32 min = GetRewardTokenAmountByType(LOTTERY_TYPE_MIN);
+		
+		uint32 min_ammount = 0;
+		
+		if (aaa >= max)
+		{
+			min_ammount = max;
+			type = LOTTERY_TYPE_MAX;
+		}
+		else
+		{
+			min_ammount = aaa;
+			type = LOTTERY_TYPE_AAA;
+		}
+
+		if (min_ammount >= min)
+			type = LOTTERY_TYPE_MIN;
+
+		if (aaa == max && aaa < min)
+			type = (urand(0, 1) == 0 ? LOTTERY_TYPE_MAX : LOTTERY_TYPE_AAA);
+
+		if (aaa == min && aaa < max)
+			type = (urand(0, 1) == 0 ? LOTTERY_TYPE_MIN : LOTTERY_TYPE_AAA);
+
+		if (max == min && max < aaa)
+			type = (urand(0, 1) == 0 ? LOTTERY_TYPE_MIN : LOTTERY_TYPE_MAX);
+
+		if (max == min && max == aaa)
+		{
+			switch (urand(0,2))
+			{
+			case 0:
+				type = LOTTERY_TYPE_AAA;
+				break;
+			case 1:
+				type = LOTTERY_TYPE_MAX;
+				break;
+			case 2:
+				type = LOTTERY_TYPE_MIN;
+				break;
+			}
+		}
+
+	}
+	else
+	{
+		uint32 all = LotteryVec[0].aaa_chance + LotteryVec[0].max_chance + LotteryVec[0].min_chance;
+		uint32 minmax = LotteryVec[0].max_chance + LotteryVec[0].min_chance;
+
+		uint32 m = LotteryVec[0].max_chance < LotteryVec[0].min_chance ? LotteryVec[0].max_chance : LotteryVec[0].min_chance;
+
+		if (urand(0, all) < LotteryVec[0].aaa_chance)
+			type = LOTTERY_TYPE_AAA;
+		else if (urand(0, minmax) < m)
+			type = LotteryVec[0].max_chance < LotteryVec[0].min_chance ? LOTTERY_TYPE_MAX : LOTTERY_TYPE_MIN;
+		else
+			type = LotteryVec[0].max_chance < LotteryVec[0].min_chance ? LOTTERY_TYPE_MIN : LOTTERY_TYPE_MAX;
+	}
+	
+
+	SetLotteryType(type);
+}
+
+void Lottery::LotteryRunNotice()
+{
+	std::ostringstream oss;
+
+	switch (GetLotteryType())
+	{
+		case LOTTERY_TYPE_AAA:
+			oss << "[²ÊÆ±]£º¿ª³ö[|cFFFF1717±ª×Ó|r]£¬|cFFFF1717" << GetMuilByType(LOTTERY_TYPE_AAA) << "|r±¶½±Àø...";
+			break;
+		case LOTTERY_TYPE_MAX:
+			oss << "[²ÊÆ±]£º¿ª³ö[|cFFFF1717´ó|r]£¬|cFFFF1717" << GetMuilByType(LOTTERY_TYPE_MAX) << "|r±¶½±Àø...";
+			break;
+		case LOTTERY_TYPE_MIN:
+			oss << "[²ÊÆ±]£º¿ª³ö[|cFFFF1717Ð¡|r]£¬|cFFFF1717" << GetMuilByType(LOTTERY_TYPE_MIN) << "|r±¶½±Àø...";
+			break;
+		default:
+			break;
+	}
+	sWorld->SendScreenMessage(oss.str().c_str());
+}
+
+void Lottery::LotteryEnd()
+{
+	//¿ª½±
+	GenerateLotteryType();
+	//¿ª½±ÐÅÏ¢
+	LotteryRunNotice();
+	//½±ÀøÖÐ½±Íæ¼Ò
+	RewardPlayer(GetLotteryType());
+	//Çå¿Õ²ÊÆ±ÈÝÆ÷
+	LotteryInfo.clear();
+	//Çå¿ÕÊý¾Ý±í
+	CharacterDatabase.DirectPExecute("truncate table character_lottery");
+}
+
+bool Lottery::PlayerBuyLottery(Player* player, LotteryType type,uint32 lotteryAmount)
+{
+	bool flag = true;
+
+	if (lotteryAmount == 0)
+	{
+		player->GetSession()->SendNotification("Ñ¹×¢Ê§°Ü£¬ÇëÊäÈëÕýÈ·¸ñÊ½µÄ¹ºÂò²ÊÆ±µÄÊýÁ¿£¡");
+		flag = false;
+	}
+
+	if (type != LOTTERY_TYPE_AAA && type != LOTTERY_TYPE_MIN && type != LOTTERY_TYPE_MAX)
+		flag = false;
+
+	uint32 count = sCF->GetTokenAmount(player);
+
+	if (lotteryAmount > count)
+	{
+		std::ostringstream oss;
+		oss << "Ñ¹×¢Ê§°Ü£¬" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "²»×ã£¡";
+		player->GetSession()->SendNotification(oss.str().c_str());
+		flag = false;
+	}
+
+	if (!flag)
+		return false;
+
+	if (PlayerCanBuy(player, lotteryAmount))
+	{
+		CharacterDatabase.DirectPExecute("INSERT INTO character_lottery VALUES('%u', '%u', '%u')", player->GetGUIDLow(), uint32(type), lotteryAmount);
+		uint32	accountId = sObjectMgr->GetPlayerAccountIdByGUID(MAKE_NEW_GUID(player->GetGUIDLow(), 0, HIGHGUID_PLAYER));
+		sCF->UpdateTokenAmount(player, lotteryAmount, false, "¹ºÂò²ÊÆ±");
+		LotteryTemplate LotteryTemp;
+		LotteryTemp.guidLow			= player->GetGUIDLow();
+		LotteryTemp.lotteryType		= type;
+		LotteryTemp.lotteryAmount	= lotteryAmount;
+		LotteryInfo.push_back(LotteryTemp);
+
+		std::ostringstream oss;
+		oss << "ÄãÑ¹";
+		switch (type)
+		{
+		case LOTTERY_TYPE_AAA:
+			oss << "[|cFFFF1717±ª×Ó|r]";
+			break;
+		case LOTTERY_TYPE_MAX:
+			oss << "[|cFFFF1717´ó|r]";
+			break;
+		case LOTTERY_TYPE_MIN:
+			oss << "[|cFFFF1717Ð¡|r]";
+			break;
+		default:
+			break;
+		}
+
+		oss << " X |cFFFF1717";
+		oss << lotteryAmount;
+		oss << "|r×¢£¬³É¹¦£¡";
+		player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+	}
+
+	player->CLOSE_GOSSIP_MENU();
+	return true;
+}
+
+
+bool Lottery::PlayerCanBuy(Player* player,uint32 lotteryAmount)
+{
+	if (GetPlayerLotteryAmount(player) + lotteryAmount > GetLotterAmountLimit())
+	{
+		std::ostringstream oss;
+		oss << "ÏÞÖÆ¹ºÂò²ÊÆ±×Ü¼Æ" << GetLotterAmountLimit();
+		oss << ",ÄãÒÑÀÛ¼Æ¹ºÂò²ÊÆ±" << GetPlayerLotteryAmount(player);
+		oss << "\n±¾´Î¹ºÂòÊýÁ¿½«²»µÃ³¬¹ý" << GetLotterAmountLimit() - GetPlayerLotteryAmount(player);
+		player->GetSession()->SendNotification(oss.str().c_str());
+
+		return false;
+	}
+	return true;
+}
+
+uint32 Lottery::GetPlayerLotteryAmount(Player* player)
+{
+	uint32 amount = 0;
+
+	for (size_t i = 0; i < LotteryInfo.size(); i++)
+		if (player->GetGUIDLow() == LotteryInfo[i].guidLow)
+			amount += LotteryInfo[i].lotteryAmount;
+
+	return amount;
+}
+
+std::string Lottery::GetLotteryName(LotteryType type)
+{
+	switch (type)
+	{
+	case LOTTERY_TYPE_AAA:
+		return "[|cFFFF1717±ª×Ó|r]";
+	case LOTTERY_TYPE_MAX:
+		return "[|cFFFF1717´ó|r]";
+	case LOTTERY_TYPE_MIN:
+		return "[|cFFFF1717Ð¡|r]";
+	default:
+		return "";
+		break;
+	}
+}
+
+void Lottery::RewardPlayer(LotteryType type)
+{
+	for (size_t i = 0; i < LotteryInfo.size(); i++)
+		if (type == LotteryInfo[i].lotteryType)
+		{
+			uint32 lotteryTokenAmount = LotteryInfo[i].lotteryAmount * GetMuilByType(type);
+
+			Player* player = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(LotteryInfo[i].guidLow, 0, HIGHGUID_PLAYER));
+
+			if (player)
+			{
+				std::ostringstream oss;
+				oss << "[²ÊÆ±]£ºÄãÖÐÁË|cFFFF1717" << LotteryInfo[i].lotteryAmount << "|r×¢" << GetLotteryName(type) << "£¬»ñµÃ" << lotteryTokenAmount << sString->GetText(CORE_STR_TYPES(STR_TOKEN));
+				player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+				ChatHandler(player->GetSession()).PSendSysMessage(oss.str().c_str());
+				sCF->UpdateTokenAmount(player, lotteryTokenAmount, true, "²ÊÆ±ÖÐ½±");
+			}
+			else
+			{
+				uint32	accountId = sObjectMgr->GetPlayerAccountIdByGUID(MAKE_NEW_GUID(LotteryInfo[i].guidLow, 0, HIGHGUID_PLAYER));
+				LoginDatabase.DirectPExecute("UPDATE account SET tokenAmount = tokenAmount + '%u' WHERE id = '%u'", lotteryTokenAmount, accountId);
+			}
+		}
+}
+
+void Lottery::AddLotteryGossip(Player* player, Object* obj)
+{
+	player->PlayerTalkClass->ClearMenus();
+	player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "Ñ¹±ª×Ó", LOTTERY_TYPE_AAA, GOSSIP_ACTION_INFO_DEF, "", 0, true);
+	player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "Ñ¹´ó", LOTTERY_TYPE_MAX, GOSSIP_ACTION_INFO_DEF, "", 0, true);
+	player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "Ñ¹Ð¡", LOTTERY_TYPE_MIN, GOSSIP_ACTION_INFO_DEF, "", 0, true);
+	if (obj->ToCreature())
+		player->SEND_GOSSIP_MENU(obj->GetEntry(), obj->GetGUID());
+	else
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+
+	ChatHandler(player->GetSession()).PSendSysMessage("[²ÊÆ±]£ºÇëµã»÷ÄãÒªÑ¹×¢µÄ²ÊÆ±ÀàÐÍ£¬²¢ÊäÈëÄãÒªÑ¹×¢µÄÊýÁ¿");
+	ChatHandler(player->GetSession()).PSendSysMessage("[²ÊÆ±]£º1×¢µÈÓÚ1%s£¬Ñ¹×¢ÕýÈ·½±Àø·­±¶£¡", sString->GetText(CORE_STR_TYPES(STR_TOKEN)));
+}
+
+class Lottery_WorldScript : public WorldScript
+{
+public:
+	Lottery_WorldScript() : WorldScript("Lottery_WorldScript") {}
+
+	uint32 Timer = 0;
+	bool remind = false;
+
+	void OnStartup() override
+	{
+		sLottery->LoadLotterData();
+	}
+
+	void OnUpdate(uint32 diff) override
+	{
+		if (LotteryVec.empty())
+			return;
+
+		Timer += diff;
+		if (Timer > (LotteryVec[0].interval * MINUTE * IN_MILLISECONDS - 10 * IN_MILLISECONDS) && !remind)
+		{
+			remind = true;
+			sWorld->SendScreenMessage("10ÃëÖÓºó¿ª½±...");
+		}
+		else if (Timer > LotteryVec[0].interval * MINUTE * IN_MILLISECONDS)
+		{
+			Timer = 0;
+			remind = false;
+			sLottery->LotteryEnd();
+		}
+	}
+};
+
+void AddSC_LOTTERY()
+{
+	new Lottery_WorldScript();
+}
diff --git a/src/server/scripts/Custom/Lottery/Lottery.h b/src/server/scripts/Custom/Lottery/Lottery.h
new file mode 100644
index 0000000..8cc5c32
--- /dev/null
+++ b/src/server/scripts/Custom/Lottery/Lottery.h
@@ -0,0 +1,65 @@
+enum LotteryType
+{
+	LOTTERY_TYPE_AAA = 0,
+	LOTTERY_TYPE_MAX = 1,
+	LOTTERY_TYPE_MIN = 2
+};
+
+struct LotteryTemplate
+{
+	uint32 guidLow;
+	LotteryType lotteryType;
+	uint32 lotteryAmount;
+};
+
+struct LotterySetTemplate
+{
+	uint32 tokenLimit;
+	uint32 interval;
+	uint32 aaa_muil;
+	uint32 max_muil;
+	uint32 min_muil;
+
+	uint32 aaa_chance;
+	uint32 max_chance;
+	uint32 min_chance;
+};
+extern std::vector<LotterySetTemplate> LotteryVec;
+
+class Lottery
+{
+public:
+	static Lottery* instance()
+	{
+		static Lottery instance;
+		return &instance;
+	}
+	void Load();
+
+	LotteryType GetLotteryType(){ return m_type; }
+	void SetLotteryType(LotteryType type){ m_type = type; }
+
+	uint32 GetRewardTokenAmountByType(LotteryType type);
+	void GenerateLotteryType();
+	uint32 GetMuilByType(LotteryType type);
+	std::string GetLotteryName(LotteryType type);
+
+	void LotteryRunNotice();
+	void LotteryEnd();
+	void LoadLotterData();
+
+	bool PlayerBuyLottery(Player*, LotteryType type, uint32 lotteryAmount);
+	uint32 GetPlayerLotteryAmount(Player* player);
+	bool PlayerCanBuy(Player* player, uint32 lotteryAmount);
+	void RewardPlayer(LotteryType type);
+
+	void SetLotteryAmountLimit(uint32 lotteryAmountLimit){ m_lotteryAmountLimit = lotteryAmountLimit; }
+	uint32 GetLotterAmountLimit(){ return m_lotteryAmountLimit; }
+
+	void AddLotteryGossip(Player* player, Object* obj);
+private:
+	LotteryType m_type;
+	uint32 m_lotteryAmountLimit;
+
+};
+#define sLottery Lottery::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/LuckDraw/LuckDraw.cpp b/src/server/scripts/Custom/LuckDraw/LuckDraw.cpp
new file mode 100644
index 0000000..92c141b
--- /dev/null
+++ b/src/server/scripts/Custom/LuckDraw/LuckDraw.cpp
@@ -0,0 +1,193 @@
+#pragma execution_character_set("utf-8")
+#include "LuckDraw.h"
+#include "../GCAddon/GCAddon.h"
+#include "../Requirement/Requirement.h"
+#include "../Talisman/Talisman.h"
+#include "../Switch/Switch.h"
+#include "../CommonFunc/CommonFunc.h"
+
+std::unordered_map<uint32, LuckDrawTemplate> LuckDrawMap;
+
+void LuckDraw::Load()
+{
+	LuckDrawMap.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÎïÆ·ID,¼¸ÂÊ,ÎïÆ·ÊýÁ¿ FROM __³é½±" :
+		"SELECT itemId,chance,itemCount FROM _luckdraw");
+	if (!result)
+		return;
+	do
+	{
+		Field* fields = result->Fetch();
+		uint32 itemId = fields[0].GetUInt32();
+
+		LuckDrawTemplate Temp;
+		Temp.chance = fields[1].GetFloat();
+		Temp.count = fields[2].GetInt32();
+		LuckDrawMap.insert(std::make_pair(itemId, Temp));
+	} while (result->NextRow());
+}
+
+int32 LuckDraw::GetCount(uint32 itemId)
+{
+	std::unordered_map<uint32, LuckDrawTemplate>::iterator iter = LuckDrawMap.find(itemId);
+
+	if (iter != LuckDrawMap.end())
+		return iter->second.count;
+
+	return 1;
+}
+
+void LuckDraw::SendCheckInfo(Player* player)
+{
+
+	bool check1 = sReq->Check(player, atoi(sSwitch->GetFlagByIndex(ST_LUCKDRAW, 1).c_str()), 1, false);
+	bool check10 = sReq->Check(player, atoi(sSwitch->GetFlagByIndex(ST_LUCKDRAW, 2).c_str()), 1, false);
+
+	std::ostringstream oss;
+
+	oss << "CHECK#";
+
+	if (check10)
+		oss << "2";
+	else if (check1)
+		oss << "1";
+	else
+		oss << "0";
+
+	sGCAddon->SendPacketTo(player, "GC_S_LUCKDRAW_V3", oss.str());
+
+}
+
+void LuckDraw::OpenPanel(Player* player)
+{
+	uint32 reqId = atoi(sSwitch->GetFlagByIndex(ST_LUCKDRAW, 1).c_str());
+
+	SendCheckInfo(player);
+
+	std::ostringstream oss;
+	
+	oss << "SHOW#";
+
+	for (std::unordered_map<uint32, LuckDrawTemplate>::iterator iter = LuckDrawMap.begin(); iter != LuckDrawMap.end(); iter++)
+		oss << iter->first << "-" << sTalisman->GetIcon(iter->first) << "-" << abs(iter->second.count) << ":";
+
+	sGCAddon->SendPacketTo(player, "GC_S_LUCKDRAW_V3", oss.str());
+}
+
+void LuckDraw::Stop(Player* player)
+{
+	SendCheckInfo(player);
+
+	uint32 itemId = 0;
+
+	std::vector<std::pair<int, float>> vtMap;
+	for (auto it = LuckDrawMap.begin(); it != LuckDrawMap.end(); it++)
+		vtMap.push_back(std::make_pair(it->first, it->second.chance));
+
+	sort(vtMap.begin(), vtMap.end(),
+		[](const std::pair<int, float> &x, const std::pair<int, float> &y) -> int {
+		return x.second < y.second;
+	});
+
+	float sum = 0;
+
+	for (auto it = vtMap.begin(); it != vtMap.end(); it++)
+		sum += it->second;
+
+	float rand = frand(0, sum);
+
+	sum = 0;
+
+	for (auto it = vtMap.begin(); it != vtMap.end(); it++)
+	{
+		sum += it->second;
+		if (rand <= sum)
+		{
+			itemId = it->first;
+			break;
+		}
+	}
+
+	std::ostringstream oss;
+	oss << "STOP#" << itemId;
+	sGCAddon->SendPacketTo(player, "GC_S_LUCKDRAW_V3", oss.str());
+
+	int32 count = GetCount(itemId);
+
+	player->AddItem(itemId, abs(count));
+
+	if (count < 0)
+	{
+		std::ostringstream oss1;
+		oss1 << "[ÐÒÔË³é½±]" << sCF->GetNameLink(player) << "³éµ½ÁË" << sCF->GetItemLink(itemId) << " X " << abs(count);
+		sWorld->SendScreenMessage(oss1.str().c_str());
+	}
+}
+
+void LuckDraw::SendData(Player* player)
+{
+	std::ostringstream oss;
+	for (std::unordered_map<uint32, LuckDrawTemplate>::iterator iter = LuckDrawMap.begin(); iter != LuckDrawMap.end(); iter++)
+	{
+		if (ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(iter->first))
+			player->GetSession()->SendPacket(&pProto->queryData);
+		oss << iter->first << "-" << iter->second.count << " ";
+	}
+		
+
+	sGCAddon->SendPacketTo(player, "GC_S_LUCKDRAW", oss.str());
+}
+
+void LuckDraw::SendUpdateData(Player* player)
+{
+	sGCAddon->SendPacketTo(player, "GC_S_LUCKDRAW_UPDATE", " ");
+}
+
+void LuckDraw::Rew(Player* player, uint32 rewCount)
+{
+	uint32 itemId = 0;
+
+	std::vector<std::pair<int, float>> vtMap;
+	for (auto it = LuckDrawMap.begin(); it != LuckDrawMap.end(); it++)
+		vtMap.push_back(std::make_pair(it->first, it->second.chance));
+
+	sort(vtMap.begin(), vtMap.end(),
+		[](const std::pair<int, float> &x, const std::pair<int, float> &y) -> int {
+		return x.second < y.second;
+	});
+
+	float sum = 0;
+
+	for (auto it = vtMap.begin(); it != vtMap.end(); it++)
+		sum += it->second;
+
+	float rand = frand(0, sum);
+
+	sum = 0;
+
+	for (auto it = vtMap.begin(); it != vtMap.end(); it++)
+	{
+		sum += it->second;
+		if (rand <= sum)
+		{
+			itemId = it->first;
+			break;
+		}
+	}
+
+	int32 count = GetCount(itemId);
+
+	player->AddItem(itemId, abs(count));
+
+	std::ostringstream oss;
+	oss << itemId << " " << count << " " << rewCount;
+	sGCAddon->SendPacketTo(player, "GC_S_LUCKDRAW_REW", oss.str());
+
+	if (count < 0)
+	{
+		std::ostringstream oss;
+		oss << "[ÐÒÔË³é½±]" << sCF->GetNameLink(player) << "³éµ½ÁË" << sCF->GetItemLink(itemId) << " X " << abs(count);
+		sWorld->SendScreenMessage(oss.str().c_str());
+	}
+}
diff --git a/src/server/scripts/Custom/LuckDraw/LuckDraw.h b/src/server/scripts/Custom/LuckDraw/LuckDraw.h
new file mode 100644
index 0000000..ddd8807
--- /dev/null
+++ b/src/server/scripts/Custom/LuckDraw/LuckDraw.h
@@ -0,0 +1,33 @@
+struct LuckDrawTemplate
+{
+	float chance;
+	int32 count;
+};
+
+extern std::unordered_map<uint32, LuckDrawTemplate> LuckDrawMap;
+
+class LuckDraw
+{
+public:
+	static LuckDraw* instance()
+	{
+		static LuckDraw instance;
+		return &instance;
+	}
+	
+	void Load();
+	void Stop(Player* player);
+	
+	void SendCheckInfo(Player* player);
+	void OpenPanel(Player* player);
+
+	int32 GetCount(uint32 itemId);
+
+
+	void SendData(Player* player);
+	void SendUpdateData(Player* player);
+	void Rew(Player* player, uint32 rewCount);
+private:
+
+};
+#define sLuckDraw LuckDraw::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/MainFunc/MainFunc.cpp b/src/server/scripts/Custom/MainFunc/MainFunc.cpp
new file mode 100644
index 0000000..e0a2112
--- /dev/null
+++ b/src/server/scripts/Custom/MainFunc/MainFunc.cpp
@@ -0,0 +1,747 @@
+#pragma execution_character_set("utf-8")
+#include "MainFunc.h"
+#include "../FunctionCollection/FunctionCollection.h"
+#include "../Custom/HonorRank/HonorRank.h"
+#include "../Lottery/Lottery.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../Recruit/Recruit.h"
+#include "../CustomEvent/Event.h"
+#include "Guild.h"
+#include "../Requirement/Requirement.h"
+#include "../Reward/Reward.h"
+#include "../Quest/QuestMod.h"
+#include "../VIP/VIP.h"
+#include "Group.h"
+#include "MapManager.h"
+#include "../ResetInstance/ResetInstance.h"
+#include "../Switch/Switch.h"
+#include "../Skill/Skill.h"
+#include "../Rank/Rank.h"
+#include "../Faction/Faction.h"
+#include "../Morph/Morph.h"
+#include "../GCAddon/GCAddon.h"
+#include "../LuckDraw/LuckDraw.h"
+#include "../SignIn/SignIn.h"
+#include "../Recovery/Recovery.h"
+#include "../StatPoints/StatPoints.h"
+#include "../Command/CustomCommand.h"
+#include "../Reincarnation/Reincarnation.h"
+#include "../String/myString.h"
+#include "../UnitMod/CharMod/CharMod.h"
+#include "../Talisman/Talisman.h"
+#include "../AuthCheck/AuthCheck.h"
+#include "../CDK/CDK.h"
+
+//ALTER TABLE _function ADD PopText TEXT	DEFAULT NULL AFTER MenuText;
+
+std::vector<MainFuncTemplate> MainFuncVec;
+bool GreaterSort(MainFuncTemplate a, MainFuncTemplate b) { return (a.CurMenu <b.CurMenu); }
+
+void MainFunc::Load()
+{
+	MainFuncVec.clear();
+	
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//			0				1       2
+		"SELECT ÉúÎïÎïÆ·»òÎïÌåID, ²Ëµ¥ID, ÉÏ¼¶²Ëµ¥ID, "
+		//3			4			5			6			7		8		9				10			11	12		13		14
+		"GMÃüÁî×é, ÐèÇóÄ£°åID, ½±ÀøÄ£°åID, Ð¡Í¼±êID, ´óÍ¼±ê, ²Ëµ¥ÎÄ±¾, ÁªÃË´«ËÍ×ø±êID, ²¿Âä´«ËÍ×ø±êID, ÀàÐÍ, ÕóÓª, ¹¦ÄÜÑ¡Ôñ,µ¯´°ÎÄ±¾ FROM __Ö÷¹¦ÄÜÅäÖÃ" :
+		//			0     1       2
+		"SELECT Entry, MenuId, PreMenuId, "
+		//3        4		5		6			7		8		9		10		11		12		13		14
+		"Command, ReqId, RewId, SmallIcon, BigIcon, MenuText, Pos_A, Pos_H, AgentType,TeamId, FuncType,PopText FROM _function");
+
+	if (!result) 
+		return;
+	do
+	{
+		Field* fields = result->Fetch();
+		MainFuncTemplate Temp;
+
+		Temp.Entry		= fields[0].GetUInt32();
+		Temp.CurMenu	= fields[1].GetUInt32();
+		Temp.PreMenu	= fields[2].GetUInt32();
+		Temp.Command	= fields[3].GetString();
+		Temp.ReqId		= fields[4].GetUInt32();
+		Temp.RewId		= fields[5].GetUInt32();
+		Temp.SmallIcon	= fields[6].GetUInt8();
+		Temp.BigIcon	= fields[7].GetString();
+		Temp.Text		= fields[8].GetString();
+		Temp.Pos_A		= fields[9].GetUInt32();
+		Temp.Pos_H		= fields[10].GetUInt32();
+		Temp.PopText	= fields[14].GetString();
+
+		const char*  str = fields[11].GetCString();
+
+		if (strcmp("Item", str) == 0)
+			Temp.AgentType = MF_TYPE_ITEM;
+		else if (strcmp("NPC", str) == 0)
+			Temp.AgentType = MF_TYPE_CREATURE;
+		else if (strcmp("GameObject", str) == 0)
+			Temp.AgentType = MF_TYPE_GAMEOBJECT;
+		else
+			Temp.AgentType = MF_TYPE_NONE;
+
+
+		str = fields[12].GetCString();
+
+		if (strcmp("ÁªÃË", str) == 0)
+			Temp.TeamId = TEAM_ALLIANCE;
+		else if (strcmp("²¿Âä", str) == 0)
+			Temp.TeamId = TEAM_HORDE;
+		else
+			Temp.TeamId = TEAM_NEUTRAL;
+
+
+		str = fields[13].GetCString();
+
+		if (strcmp("·µ»ØÖ÷²Ëµ¥", str) == 0)
+			Temp.FuncType = MF_MAIN_MENU;
+		else if (strcmp("·µ»ØÉÏ¼¶²Ëµ¥", str) == 0)
+			Temp.FuncType = MF_BACK_MENU;
+		else if (strcmp("½ÇÉ«ÐÞ¸ÄÃû×Ö", str) == 0)
+			Temp.FuncType = MF_MOD_CHAR_NAME;
+		else if (strcmp("½ÇÉ«ÐÞ¸ÄÖÖ×å", str) == 0)
+			Temp.FuncType = MF_MOD_CHAR_RACE;
+		else if (strcmp("½ÇÉ«ÐÞ¸ÄÕóÓª", str) == 0)
+			Temp.FuncType = MF_MOD_CHAR_FACTION;
+		else if (strcmp("½ÇÉ«ÐÞ¸ÄÍâ¹Û", str) == 0)
+			Temp.FuncType = MF_MOD_CHAR_CUSTOMIZE;
+		else if (strcmp("½ÇÉ«ÖØÖÃÌì¸³", str) == 0)
+			Temp.FuncType = MF_RESET_TALENTS;
+		else if (strcmp("½ÇÉ«ÎäÆ÷¼¼ÄÜÈ«Âú", str) == 0)
+			Temp.FuncType = MF_UPGRADE_WEAPON_SKILLS;
+		else if (strcmp("»ý·Ö²éÑ¯", str) == 0)
+			Temp.FuncType = MF_QUERY_TOKEN;
+		else if (strcmp("ÍÑÀëÕ½¶·", str) == 0)
+			Temp.FuncType = MF_COMBATE_STOP;
+		else if (strcmp("ÅÝµã", str) == 0)
+			Temp.FuncType = MF_ABTAIN_TIME_REWARD;
+		else if (strcmp("²ÊÆ±", str) == 0)
+			Temp.FuncType = MF_BUY_LOTTERY;
+		else if (strcmp("¶Ò»»Âë", str) == 0)
+			Temp.FuncType = MF_CDK;
+		else if (strcmp("»î¶¯ÁÐ±í", str) == 0)
+			Temp.FuncType = MF_SHOW_ACTIVE_EVENTS;
+		else if (strcmp("¾üÏÎ", str) == 0)
+			Temp.FuncType = MF_UPGRADE_HR;
+		else if (strcmp("ÕÐÄ¼", str) == 0)
+			Temp.FuncType = MF_RECRUIT;
+		else if (strcmp("ÈÎÎñ´«ËÍ", str) == 0)
+			Temp.FuncType = MF_QUEST_TELE;
+		else if (strcmp("»áÔ±", str) == 0)
+			Temp.FuncType = MF_UPGRADE_VIP;
+		else if (strcmp("×ªÉú", str) == 0)
+			Temp.FuncType = MF_REINCARNATION;
+		else if (strcmp("ÖØÖÃÌØ¶¨¸±±¾", str) == 0)
+			Temp.FuncType = MF_RESET_INSTANCE;
+		else if (strcmp("×Ô¶¨ÒåÉÌÒµ¼¼ÄÜ", str) == 0)
+			Temp.FuncType = MF_CUSTOM_SKILL;
+		else if (strcmp("×Ô¶¨ÒåµÈ¼¶", str) == 0)
+			Temp.FuncType = MF_RANK;
+		else if (strcmp("×Ô¶¨ÒåÕóÓª", str) == 0)
+			Temp.FuncType = MF_FACTION;
+		else if (strcmp("ÖØÖÃÈÕ³£ÈÎÎñ", str) == 0)
+			Temp.FuncType = MF_RESET_DAILY_QUEST;
+		else if (strcmp("³é½±", str) == 0)
+			Temp.FuncType = MF_LUCKDRAW;
+		else if (strcmp("ÎïÆ·»ØÊÕ", str) == 0)
+			Temp.FuncType = MF_RECOVERY;
+		else if (strcmp("·¨±¦", str) == 0)
+			Temp.FuncType = MF_TALISMAN;
+		else if (strcmp("¶·Æø", str) == 0)
+			Temp.FuncType = MF_STATPOINTS;
+		else if (strcmp("Ëæ»úÈÎÎñ", str) == 0)
+			Temp.FuncType = MF_RANDOM_QUEST;
+		else if (strcmp("ÖØÖÃËùÓÐ¸±±¾", str) == 0)
+			Temp.FuncType = MF_RESET_INSTANCE_ALL;
+		else if (strcmp("°ó¶¨Â¯Ê¯µã", str) == 0)
+			Temp.FuncType = MF_HOME_BIND;
+		else if (strcmp("´«ËÍÂ¯Ê¯µã", str) == 0)
+			Temp.FuncType = MF_HOME_TELE;
+		else if (strcmp("ÐÞÀí", str) == 0)
+			Temp.FuncType = MF_REPAIR;
+		else if (strcmp("ÒøÐÐ", str) == 0)
+			Temp.FuncType = MF_BANK;
+		else if (strcmp("ÓÊÏä", str) == 0)
+			Temp.FuncType = MF_MAIL;
+		else if (strcmp("×ªÖ°", str) == 0)
+			Temp.FuncType = MF_ALT_CLASS;
+		else
+			Temp.FuncType = MF_NONE;
+
+		MainFuncVec.push_back(Temp);
+	} while (result->NextRow());
+
+	sort(MainFuncVec.begin(), MainFuncVec.end(), GreaterSort);//ÉýÐòÅÅÁÐ
+}
+
+bool MainFunc::Pop(uint32 ReqId)
+{
+	auto  itr = ReqMap.find(ReqId);
+	if (itr != ReqMap.end())
+		return true;
+
+	return false;
+}
+
+void MainFunc::ClearMenu(Player* pl)
+{
+	pl->PlayerTalkClass->ClearMenus();
+}
+
+void MainFunc::CloseMenu(Player* pl)
+{
+	pl->CLOSE_GOSSIP_MENU();
+}
+
+bool MainFunc::CheckTeamId(Player*  pl, TeamId teamId)
+{
+	if (teamId == TEAM_NEUTRAL || pl->GetTeamId() == teamId)
+		return true;
+
+	return false;
+}
+
+void MainFunc::TelePort(Player* pl, uint32 PosId)
+{
+	if (PosId == 0)
+		return;
+
+	auto itr = PosMap.find(PosId);
+
+	if (itr != PosMap.end())
+		pl->TeleportTo(itr->second.map, itr->second.x, itr->second.y, itr->second.z, itr->second.o);
+}
+
+MFAgentTypes MainFunc::GetAgentType(Object* obj)
+{
+	switch (obj->GetTypeId())
+	{
+	case TYPEID_ITEM:
+		return MF_TYPE_ITEM;
+	case TYPEID_UNIT:
+		return MF_TYPE_CREATURE;
+	case TYPEID_GAMEOBJECT:
+		return MF_TYPE_GAMEOBJECT;
+	}
+
+	return MF_TYPE_NONE;
+}
+
+
+void MainFunc::GetExtraData(Player* pl, Object* obj, uint32 CurMenu, uint32 PreMenu, uint32 &RewId, std::string &Command, uint32 &PosId)
+{
+	MFAgentTypes AgentType = GetAgentType(obj);
+	uint32 Entry = obj->GetEntry();
+
+	for (auto itr = MainFuncVec.begin(); itr != MainFuncVec.end(); itr++)
+		if (AgentType == itr->AgentType && Entry == itr->Entry && itr->CurMenu == CurMenu && itr->PreMenu == PreMenu)
+		{
+			RewId = itr->RewId;
+			Command = itr->Command;
+			if (pl->GetTeamId() == TEAM_ALLIANCE)
+				PosId = itr->Pos_A;
+			else
+				PosId = itr->Pos_H;
+			break;
+		}		
+}
+
+uint32 MainFunc::GetPreMenu(Object* obj, uint32 CurMenu)
+{
+	MFAgentTypes AgentType = GetAgentType(obj);
+	uint32 Entry = obj->GetEntry();
+
+	for (auto itr = MainFuncVec.begin(); itr != MainFuncVec.end(); itr++)
+		if (AgentType == itr->AgentType && Entry == itr->Entry && itr->CurMenu == CurMenu)
+			return itr->PreMenu;
+
+	return 0;
+}
+
+bool MainFunc::HasNextMenu(Object* obj, uint32 Menu)
+{
+	MFAgentTypes AgentType = GetAgentType(obj);
+	uint32 Entry = obj->GetEntry();
+
+	for (auto itr = MainFuncVec.begin(); itr != MainFuncVec.end(); itr++)
+		if (AgentType == itr->AgentType && Entry == itr->Entry && itr->PreMenu == Menu)
+			return true;
+
+	return false;
+}
+
+void MainFunc::AddGossip(Player* pl, Object* obj, uint32 PreMenu)
+{
+	ClearMenu(pl);
+
+	uint32 Entry = obj->GetEntry();
+	MFAgentTypes AgentType = GetAgentType(obj);
+	
+	for (auto itr = MainFuncVec.begin(); itr != MainFuncVec.end(); itr++)
+	{
+		if (AgentType == itr->AgentType && Entry == itr->Entry && itr->PreMenu == PreMenu && CheckTeamId(pl, itr->TeamId))
+		{
+			uint32 ReqId = itr->ReqId;
+			uint32 sender = HL(itr->PreMenu, itr->CurMenu);
+			uint32 action = HL(itr->FuncType, ReqId);
+
+			std::string text = itr->BigIcon.empty() ? itr->Text : "|TInterface/ICONS/" + itr->BigIcon + ":30:30:0:0|t" + itr->Text;
+
+			if (Pop(itr->ReqId))
+				pl->ADD_GOSSIP_ITEM_EXTENDED(itr->SmallIcon, text, sender, action, sReq->Notice(pl, ReqId, itr->Text, ""), sReq->Golds(ReqId), false);
+			else if (!itr->PopText.empty())
+				pl->ADD_GOSSIP_ITEM_EXTENDED(itr->SmallIcon, text, sender, action, itr->PopText, 0, false);
+			else
+				pl->ADD_GOSSIP_ITEM(itr->SmallIcon, text, sender, action);
+		}
+	}
+
+	if (obj->ToCreature())
+		pl->SEND_GOSSIP_MENU(obj->GetEntry(), obj->GetGUID());
+	else
+		pl->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+}
+
+void MainFunc::DoAction(Player* pl, Object* obj, uint32 sender, uint32 action)
+{
+	ClearMenu(pl);
+
+	switch (sender)
+	{
+	case SENDER_HR_MENU:
+		sHR->AddNextHRMenu(pl, obj);
+		return;
+	case SENDER_HR_UP:
+		sHR->SetHRTitle(pl, action);
+		CloseMenu(pl);
+		return;
+	case SENDER_VIP_CURR:
+		sVIP->AddGossip(pl, obj);
+		return;
+	case SENDER_VIP_UP:
+		sVIP->Up(pl);
+		CloseMenu(pl);
+		return;
+	case SENDER_QUEST_TELE:
+		sQuestMod->Tele(pl, action);
+		CloseMenu(pl);
+		return;
+	case SENDER_RESET_INS:
+		sResetIns->Action(pl, action);
+		CloseMenu(pl);
+		return;
+	case SENDER_REINCARNATION:
+		sReincarnation->DoAction(pl, obj, action);
+		return;
+	case SENDER_CUSTOM_EVENT_ACTIVE:
+		sEvent->AcceptInvitation(pl, action + 1000000);
+		CloseMenu(pl);
+		return;
+	case SENDER_CUSTOM_EVENT_DEACTIVE:
+		sEvent->AddEventList(pl, obj);
+		return;
+	case SENDER_CUSTOM_SKILL:
+		sCustomSkill->Action(pl, action, obj);
+		return;
+	case SENDER_RANK:
+		sRank->Action(pl, action, obj);
+		return;
+	case SENDER_FACTION:
+		sFaction->Action(pl, action, obj);
+		return;
+	case SENDER_ALT_CLASS:
+		sCharMod->ModClass(pl, action);
+		CloseMenu(pl);
+		return;
+	}
+
+	uint32 PreMenu = H(sender);
+	uint32 CurMenu = L(sender);
+	MFTypes FuncType = MFTypes(H(action));
+	uint32 ReqId = L(action);
+
+	//ÐèÇó¼ì²â
+	if (!sReq->Check(pl, ReqId))
+	{
+		//ÏÔÊ¾µ±Ç°²Ëµ¥
+		AddGossip(pl, obj, PreMenu);
+		return;
+	}
+	sReq->Des(pl, ReqId);
+
+	//½±Àø ÃüÁî ´«ËÍ
+	uint32 RewId = 0;
+	std::string Command = "";
+	uint32 PosId = 0;
+	GetExtraData(pl, obj, CurMenu, PreMenu, RewId, Command, PosId);
+	sRew->Rew(pl, RewId);
+	TelePort(pl, PosId);
+
+	//if (!Command.empty())
+		//return;
+
+	//Ìí¼ÓÏÂ¼¶²Ëµ¥
+	AddGossip(pl, obj, CurMenu);
+
+	//Ö´ÐÐ¹¦ÄÜ
+	switch (FuncType)
+	{
+	case MF_NONE:
+		//ÈôÃ»ÓÐÏÂ¼¶²Ëµ¥£¬ÏÔÊ¾µ±Ç°²Ëµ¥
+		if (!HasNextMenu(obj, CurMenu))
+			AddGossip(pl, obj, PreMenu);
+		break;
+	case MF_MAIN_MENU:
+		AddGossip(pl, obj, 0);
+		break;
+	case MF_BACK_MENU:
+		//·µ»ØÉÏ¼¶²Ëµ¥
+		AddGossip(pl, obj, GetPreMenu(obj, PreMenu));
+		return;
+	case MF_MOD_CHAR_NAME:
+		pl->SetAtLoginFlag(AT_LOGIN_RENAME);
+		pl->GetSession()->SendAreaTriggerMessage("ÖØÐÂÉÏÏßÒÔ¸ü¸Ä[Ãû×Ö]");
+		CloseMenu(pl);
+		break;
+	case MF_MOD_CHAR_RACE:
+	{
+		pl->SetAtLoginFlag(AT_LOGIN_CHANGE_RACE);
+		pl->GetSession()->SendAreaTriggerMessage("ÖØÐÂÉÏÏßÒÔ¸ü¸Ä[ÖÖ×å]");
+		if (Guild* guild = pl->GetGuild())
+			guild->HandleLeaveMember(pl->GetSession());
+		CloseMenu(pl);
+	}
+		break;
+	case MF_MOD_CHAR_FACTION:
+	{
+		pl->SetAtLoginFlag(AT_LOGIN_CHANGE_FACTION);
+		pl->GetSession()->SendAreaTriggerMessage("ÖØÐÂÉÏÏßÒÔ¸ü¸Ä[ÕóÓª]");
+		if (Guild* guild = pl->GetGuild())
+			guild->HandleLeaveMember(pl->GetSession());
+		CloseMenu(pl);
+	}
+		break;
+	case MF_MOD_CHAR_CUSTOMIZE:
+	{
+		pl->SetAtLoginFlag(AT_LOGIN_CUSTOMIZE);
+		pl->GetSession()->SendAreaTriggerMessage("ÖØÐÂÉÏÏßÒÔ¸ü¸Ä[Íâ¹Û]");
+		if (Guild* guild = pl->GetGuild())
+			guild->HandleLeaveMember(pl->GetSession());
+		CloseMenu(pl);
+	}
+		break;
+	case MF_RESET_TALENTS:
+		pl->resetTalents(true);
+		pl->SendTalentsInfoData(false);
+		pl->GetSession()->SendAreaTriggerMessage("ÒÑÖØÖÃ½ÇÉ«Ìì¸³");
+		CloseMenu(pl);
+		break;
+	case MF_UPGRADE_WEAPON_SKILLS:
+		pl->UpdateSkillsToMaxSkillsForLevel();
+		pl->GetSession()->SendAreaTriggerMessage("ÎäÆ÷¼¼ÄÜÒÑÌáÉýÖÁ×î´óÖµ");
+		CloseMenu(pl);
+		break;
+	case MF_QUERY_TOKEN:
+	{
+		std::ostringstream oss;
+		oss << "Äãµ±Ç°µÄ" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "ÊýÁ¿£º" << sCF->GetTokenAmount(pl);
+		pl->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+		ChatHandler(pl->GetSession()).PSendSysMessage(oss.str().c_str());
+		CloseMenu(pl);
+	}
+		break;
+	case MF_COMBATE_STOP:
+	{
+		if (!pl->canStopCombat && sSwitch->GetValue(ST_STOP_COMBAT_CD) != 0)
+		{
+			uint32 cd = pl->stopCombatCD / IN_MILLISECONDS;
+			std::ostringstream oss;
+			oss << "ÍÑÕ½¹¦ÄÜ½«ÔÚ" << cd << "ÃëºóÀäÈ´£¡";
+			pl->GetSession()->SendNotification(oss.str().c_str());
+		}
+		else
+		{
+			pl->ClearInCombat();
+			pl->GetSession()->SendAreaTriggerMessage("ÒÑÇå³ýÕ½¶·×´Ì¬");
+			pl->canStopCombat = false;
+			pl->stopCombatCD = sSwitch->GetValue(ST_STOP_COMBAT_CD) * IN_MILLISECONDS;
+		}
+		CloseMenu(pl);
+	}
+		break;
+	case MF_ABTAIN_TIME_REWARD:
+	{
+		if (PlayerTimeRewType != 1)
+		{
+			if (PlayerTimeRewType != 2)
+				pl->GetSession()->SendNotification("ÅÝµã½±ÀøÒÑ¹Ø±Õ£¡");
+			else
+				pl->GetSession()->SendNotification("ÁìÈ¡ÅÝµãÒÑ¹Ø±Õ£¬Çë±£³ÖÔÚÏß£¬µÈ´ýÏµÍ³·¢·Å½±Àø");
+		}
+		else
+		{
+			int32 unRewardNum = pl->GetTotalPlayedTime() / 3600 - pl->onlineRewardedCount;
+			if (unRewardNum <= 0)
+			{
+				uint32 minu = pl->GetTotalPlayedTime() > 3600 ? uint32(60 - (float(pl->GetTotalPlayedTime()) / 3600 - pl->GetTotalPlayedTime() / 3600) * 60) : (60 - pl->GetTotalPlayedTime() / 60);
+				std::ostringstream oss;
+				oss << minu << "·ÖÖÓºó¿ÉÁìÈ¡ÅÝµã";
+				pl->GetSession()->SendNotification(oss.str().c_str());
+				ChatHandler(pl->GetSession()).PSendSysMessage(oss.str().c_str());
+			}
+			else
+			{
+				sCF->SetOnlineRewardedCount(pl, unRewardNum + pl->onlineRewardedCount);
+				for (int32 i = 0; i < unRewardNum; i++)
+					sRew->Rew(pl, pl->timeRewId);
+			}		
+		}
+		CloseMenu(pl);
+	}
+		break;
+	case MF_BUY_LOTTERY:
+		sLottery->AddLotteryGossip(pl, obj);
+		break;
+	case MF_CDK:
+		sCDK->AddGossip(pl, obj);
+		break;
+	case MF_SHOW_ACTIVE_EVENTS:
+		sEvent->AddEventList(pl, obj);
+		break;
+	case MF_UPGRADE_HR:
+		sHR->AddNextHRMenu(pl, obj);
+		break;
+	case MF_RECRUIT:
+		sRecruit->AddMainMenu(pl, obj);
+		break;
+	case MF_QUEST_TELE:
+		sQuestMod->AddTeleGossip(pl, obj);
+		break;
+	case MF_UPGRADE_VIP:
+		sVIP->AddGossip(pl, obj);
+		break;
+	case MF_REINCARNATION:
+		sReincarnation->AddGossip(pl, obj);
+		break;
+	case MF_RESET_INSTANCE:
+		sResetIns->AddGossip(pl, obj);
+		break;
+	case MF_CUSTOM_SKILL:
+		sCustomSkill->AddGossip(pl, obj);
+		break;
+	case MF_RANK:
+		sRank->AddGossip(pl, obj);
+		break;
+	case MF_FACTION:
+		sFaction->AddGossip(pl, obj);
+		break;
+	case MF_RESET_DAILY_QUEST:
+		pl->ResetDailyQuestStatus();
+		CloseMenu(pl);
+		break;
+	case MF_LUCKDRAW:
+		sLuckDraw->OpenPanel(pl);
+		CloseMenu(pl);
+		break;
+	case MF_TALISMAN:
+		sTalisman->SendPacket(pl);
+		CloseMenu(pl);
+		break;
+	case MF_RECOVERY:
+		sRecovery->OpenPanel(pl);
+		CloseMenu(pl);
+		break;
+	case MF_STATPOINTS:
+		sStatPoints->OpenPanel(pl);
+		CloseMenu(pl);
+		break;
+	case MF_RANDOM_QUEST:
+		sQuestMod->AddAllRandomQuest(pl);
+		CloseMenu(pl);
+		break;
+	case MF_RESET_INSTANCE_ALL:
+		sCustomCommand->DoCommand(pl, ".instance unbind all");
+		CloseMenu(pl);
+		break;
+	case MF_HOME_BIND:
+		if (AreaTableEntry const* areaEntry = GetAreaEntryByAreaID(pl->GetAreaId()))
+		{
+			if (pl->GetMap()->Instanceable())
+				ChatHandler(pl->GetSession()).PSendSysMessage("Äã´¦ÔÚ¸±±¾¡¢¾º¼¼³¡»òÕ½³¡ÖÐ£¬Â¯Ê¯µã²»ÄÜ°ó¶¨µ½µ±Ç°Î»ÖÃ£º%s", areaEntry->area_name[4]);
+			else
+			{
+				pl->SetHomebind(pl->GetWorldLocation(), pl->GetAreaId());
+				ChatHandler(pl->GetSession()).PSendSysMessage("Â¯Ê¯µãÒÑ¾­°ó¶¨µ½µ±Ç°Î»ÖÃ£º%s", areaEntry->area_name[4]);
+			}
+		}
+		CloseMenu(pl);
+		break;
+	case MF_HOME_TELE:
+		pl->TeleportTo(pl->m_homebindMapId, pl->m_homebindX, pl->m_homebindY, pl->m_homebindZ, pl->GetOrientation());
+		CloseMenu(pl);
+		break;
+	case MF_REPAIR:
+		pl->DurabilityRepairAll(false, 0, false);
+		pl->GetSession()->SendAreaTriggerMessage("ÐÞÀíÍê³É");
+		CloseMenu(pl);
+		break;
+	case MF_BANK:
+		pl->GetSession()->SendShowBank(pl->GetGUID());
+		CloseMenu(pl);
+		break;
+	case MF_MAIL:
+		if (!pl->HasSpellCooldown(54710))
+		{
+			pl->CastSpell(pl, 54710, true);
+			pl->AddSpellCooldown(54710, 0, 90 * IN_MILLISECONDS);
+		}
+		else
+			pl->GetSession()->SendNotification("ÓÊÏä¹¦ÄÜÀäÈ´Ê£ÓàÊ±¼ä%dÃë", pl->GetSpellCooldownDelay(54710) / IN_MILLISECONDS);
+		CloseMenu(pl);
+		break;
+	case MF_ALT_CLASS:
+		sCharMod->AddGossip(pl, obj);
+		break;
+	}
+
+	sCustomCommand->DoCommand(pl, Command);
+}
+
+
+class Func_ItemScript : public ItemScript
+{
+public:
+	Func_ItemScript() : ItemScript("Func_ItemScript") { }
+
+	bool OnUse(Player* player, Item* item, SpellCastTargets const& targets) override
+	{
+		sMF->AddGossip(player, item, 0);
+		return true;
+	}
+
+	void OnGossipSelect(Player* player, Item* item, uint32 sender, uint32 action) override
+	{
+		if (sRecruit->AddSubMenuOrDoAction(player, item, sender, action))
+			return;
+
+		sMF->DoAction(player, item, sender, action);
+	}
+
+	void OnGossipSelectCode(Player* player, Item* item, uint32 sender, uint32 action, const char* code) override
+	{
+		player->PlayerTalkClass->ClearMenus();
+
+		if (!*code)
+			return;
+
+		if (sCDK->Redeem(player, sender, action, code))
+			return;
+
+		if (sRecruit->RecruitFriend(player, sender, code))
+			return;
+
+		if (sLottery->PlayerBuyLottery(player, LotteryType(sender), (uint32)atoi(code)))
+			return;
+	}
+
+};
+
+class Func_CreatureScript : public CreatureScript
+{
+public:
+	Func_CreatureScript() : CreatureScript("Func_CreatureScript") { }
+
+
+	bool OnGossipHello(Player* player, Creature* creature) override
+	{
+		sMF->AddGossip(player, creature, 0);
+		return true;
+	}
+
+	bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action) override
+	{
+		if (sRecruit->AddSubMenuOrDoAction(player, creature, sender, action))
+			return true;
+		
+		sMF->DoAction(player, creature, sender, action);
+
+		return true;
+	}
+
+	bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, const char* code) override
+	{
+		player->PlayerTalkClass->ClearMenus();
+
+		if (!*code)
+			return false;
+
+		if (sCDK->Redeem(player, sender, action, code))
+			return true;
+
+		if (sRecruit->RecruitFriend(player, sender, code))
+			return true;
+
+		if (sLottery->PlayerBuyLottery(player, LotteryType(sender), (uint32)atoi(code)))
+			return true;
+		return false;
+	}
+};
+
+class Func_GameObjectScript :public GameObjectScript
+{
+public:
+	Func_GameObjectScript() : GameObjectScript("Func_GameObjectScript") { }
+
+	bool OnGossipHello(Player* player, GameObject* go) override
+	{
+		sMF->AddGossip(player, go, 0);
+		return true;
+	}
+
+	bool OnGossipSelect(Player* player, GameObject* go, uint32 sender, uint32 action) override
+	{
+		if (sRecruit->AddSubMenuOrDoAction(player, go, sender, action))
+			return true;
+
+		sMF->DoAction(player, go, sender, action);
+		return true;
+	}
+
+	bool OnGossipSelectCode(Player* player, GameObject* go, uint32 sender, uint32 action, const char* code) override
+	{
+		player->PlayerTalkClass->ClearMenus();
+
+		if (!*code)
+			return false;
+
+		if (sCDK->Redeem(player, sender, action, code))
+			return true;
+
+		if (sRecruit->RecruitFriend(player, sender, code))
+			return true;
+
+		if (sLottery->PlayerBuyLottery(player, LotteryType(sender), (uint32)atoi(code)))
+			return true;
+		return false;
+	}
+};
+
+class Func_PlayerScript : PlayerScript
+{
+public:
+	Func_PlayerScript() : PlayerScript("Func_PlayerScript") {}
+	void OnLogin(Player* player)
+	{
+		sCF->SetCommercePoints(player);
+	}
+};
+
+void AddSC_MainFunc()
+{
+	new Func_PlayerScript();
+	new Func_ItemScript();
+	new Func_CreatureScript();
+	new Func_GameObjectScript();
+}
diff --git a/src/server/scripts/Custom/MainFunc/MainFunc.h b/src/server/scripts/Custom/MainFunc/MainFunc.h
new file mode 100644
index 0000000..c1a9eaa
--- /dev/null
+++ b/src/server/scripts/Custom/MainFunc/MainFunc.h
@@ -0,0 +1,100 @@
+enum MFAgentTypes
+{
+	MF_TYPE_NONE,
+	MF_TYPE_ITEM,
+	MF_TYPE_GAMEOBJECT,
+	MF_TYPE_CREATURE,
+};
+
+enum MFTypes
+{
+	MF_NONE,
+	MF_MAIN_MENU,				//ä¸»èå
+	MF_BACK_MENU,				//è¿å
+	MF_MOD_CHAR_NAME,			//å§å
+	MF_MOD_CHAR_RACE,			//ç§æ
+	MF_MOD_CHAR_FACTION,		//éµè¥
+	MF_MOD_CHAR_CUSTOMIZE,		//å¤å½¢
+	MF_RESET_TALENTS,			//éç½®å¤©èµ
+	MF_UPGRADE_WEAPON_SKILLS,	//æ­¦å¨æè½å¨æ»¡
+	MF_QUERY_TOKEN,				//ç§¯åæ¥è¯¢
+	MF_COMBATE_STOP,			//è±æ
+	MF_ABTAIN_TIME_REWARD,		//æ³¡ç¹
+	MF_BUY_LOTTERY,				//å½©ç¥¨
+	MF_SHOW_ACTIVE_EVENTS,		//æ´»å¨åè¡¨
+	MF_UPGRADE_HR,				//åè¡èå
+	MF_RECRUIT,					//æå
+	MF_QUEST_TELE,				//ä»»å¡ä¼ é
+	MF_UPGRADE_VIP,				//VIPèå
+	MF_REINCARNATION,			//è½¬ç
+	MF_RESET_INSTANCE,			//éç½®ç¹å®å¯æ¬
+	MF_CUSTOM_SKILL,			//èªå®ä¹åä¸æè½
+	MF_RANK,					//èªå®ä¹ç­çº§
+	MF_FACTION,					//èªå®ä¹éµè¥
+	MF_RESET_DAILY_QUEST,		//éç½®æ¥å¸¸ä»»å¡
+	MF_LUCKDRAW,				//å¹¸è¿æ½å¥
+	MF_TALISMAN,				//æ³å®
+	MF_RECOVERY,				//ç©ååæ¶
+	MF_STATPOINTS,				//ææ°
+	MF_RANDOM_QUEST,			//éæºä»»å¡
+	MF_RESET_INSTANCE_ALL,		//éç½®ææå¯æ¬
+	MF_HOME_BIND,				//ç»å®çç³ç¹
+	MF_HOME_TELE,				//ä¼ éçç³ç¹
+	MF_REPAIR,					//ä¿®ç
+	MF_BANK,					//é¶è¡
+	MF_MAIL,					//é®ç®±
+	MF_ALT_CLASS,				//è½¬è
+	MF_CDK,						//åæ¢ç 
+};
+
+struct MainFuncTemplate
+{
+	MFAgentTypes AgentType;
+	uint32 Entry;
+	uint32 CurMenu;
+	uint32 PreMenu;
+	TeamId TeamId;
+	MFTypes FuncType;
+	std::string Command;
+	uint32 ReqId;
+	uint32 RewId;
+	uint8 SmallIcon;
+	std::string BigIcon;
+	std::string Text;
+	uint32 Pos_A;
+	uint32 Pos_H;
+	std::string PopText;
+};
+
+extern std::vector<MainFuncTemplate> MainFuncVec;
+
+class MainFunc
+{
+public:
+	static MainFunc* instance()
+	{
+		static MainFunc instance;
+		return &instance;
+	}
+
+	void Load();
+
+	
+	uint32 HL(uint16 h, uint16 l){ return (uint32)((h << 16) | (l & 0xFFFF)); }
+	uint32 H(uint32 HL){ return (uint32)(HL >> 16); }
+	uint32 L(uint32 HL){ return (uint32)(HL & 0xFFFF); }
+	bool Pop(uint32 ReqId);
+	void ClearMenu(Player* pl);
+	void CloseMenu(Player* pl);
+	bool CheckTeamId(Player*  pl, TeamId teamId);
+	MFAgentTypes GetAgentType(Object* obj);
+	void GetExtraData(Player* pl, Object* obj, uint32 CurMenu, uint32 PreMenu, uint32 &RewId, std::string &Command, uint32 &PosId);
+	void TelePort(Player* pl, uint32 PosId);
+	uint32 GetPreMenu(Object* obj, uint32 Menu);
+	bool HasNextMenu(Object* obj, uint32 Menu);
+	void AddGossip(Player* pl, Object* obj, uint32 PreMenu);
+	void DoAction(Player* pl, Object* obj, uint32 sender, uint32 action);
+private:
+
+};
+#define sMF MainFunc::instance()
diff --git a/src/server/scripts/Custom/MapMod/MapMod.cpp b/src/server/scripts/Custom/MapMod/MapMod.cpp
new file mode 100644
index 0000000..75320f1
--- /dev/null
+++ b/src/server/scripts/Custom/MapMod/MapMod.cpp
@@ -0,0 +1,538 @@
+#pragma execution_character_set("utf-8")
+#include "MapMod.h"
+#include "../Requirement/Requirement.h"
+#include "../EquipmentManager/EquipmentManager.h"
+#include "../CommonFunc/CommonFunc.h"
+#include <random>
+#include <algorithm>
+#include <vector>
+
+std::vector<MapModTemplate> MapModVec;
+std::unordered_map<uint32, std::unordered_map<uint8, bool>> MapItemMap;
+std::vector<MapModPlayerTemplate> MapModPlayerVec;
+void MapMod::Load()
+{
+	MapModVec.clear();
+    MapItemMap.clear();
+    EquipmentVec.clear();
+    QueryResult result;
+    if (result = WorldDatabase.PQuery(
+        //		0	 1	   2	3	4	 5	  6	   7	8	9	10	 11	 12	  13   14  15	16	 17	 18		19
+        "SELECT Í·²¿,¾±²¿,¼ç²¿,³ÄÒÂ,ÐØ²¿,Ñü²¿,ÍÈ²¿,Ñ¥×Ó,ÊÖÍó,ÊÖ²¿,½äÖ¸,½äÖ¸,ÊÎÆ·,ÊÎÆ·,±³²¿,Ö÷ÊÖ,¸±ÊÖ,Ô¶³Ì,Õ½ÅÛ,µØÍ¼ID FROM _µØÍ¼×°±¸¿ØÖÆ"))
+    {
+        do
+        {
+            Field* fields = result->Fetch();
+            std::unordered_map<uint8, bool> slots;
+
+            for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
+                slots.insert(std::make_pair(i, fields[i].GetBool()));
+
+            MapItemMap.insert(std::make_pair(fields[19].GetUInt32(), slots));
+
+        } while (result->NextRow());
+    }
+
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+
+		//		0		1		2		3			4		5				6		7		8			9			10				11		12		13
+		"SELECT µØÍ¼ID,µØÓòID,ÇøÓòID,½øÈëÐèÇóÄ£°åID,¸±±¾ÄÑ¶È,¹ÖÎïÀàÐÍ,µÈ¼¶,ÉúÃüÖµ,ÎïÀíÉËº¦Öµ»ò±¶ÂÊ,·¨ÊõÉËº¦±¶ÂÊ,ÖÎÁÆÐ§¹û±¶ÂÊ,¼õÉË°Ù·Ö±È,¿¹ÐÔÖµ,»÷É±½±ÀøÄ£°åID,"
+		//14			15				16		17		18			19			20						21				
+		"»÷É±½±Àø¼¸ÂÊ,»÷É±ÊÇ·ñÈ«·þÌáÊ¾,»¤¼×Öµ,¸±±¾ÌôÕ½µÈ¼¶,¹¥»÷¼ä¸ô,»÷É±½±Àø·¨±¦Öµ,»÷É±½±Àø×Ô¶¨ÒåµÈ¼¶Öµ,Àë¿ª¸±±¾ºóÊÇ·ñÖØÖÃ,"
+		//	22    23		24		25		26	 27		28			29				30		  31				32				33				34
+		"µôÂäID1,µôÂäID2,µôÂäID3,µôÂäID4,µôÂäID5,¹â»·×é,Ëæ»ú¹â»·Êý,ÉúÃüÖµ±¶ÂÊ,¶ÓÎé»÷É±½±ÀøÄ£°åID,¶ÓÎé»÷É±½±Àø¼¸ÂÊ,»÷É±ÕÙ»½ÎïÌåID,ÊÇ·ñ¼ÓÔØÔ­µôÂä,Ëæ»ú¼¼ÄÜ×éÄ£°åID FROM _ÊôÐÔµ÷Õû_µØÍ¼" :
+
+		//		0	1	2		3	4		5		6	7		8			9		10		11			12			13
+		"SELECT Map,Area,Zone,ReqId,Diff,ModType,Level,Health,MeleeDmg,SpellDmgMod,HealMod,ReduceDmgPct,Resistance,KillRewId,"
+		//		14		15			16		17			18			19				20				21					
+		"KillRewChance,KillAnnounce,Armor,ChallengeLv,AttackTime,AddTalismanValue,AddRankValue,ResetOnLeave,"
+		//	22		23		24		25			26			27		28			29			30		31					32					33				34	
+		"LootId_1,LootId_2,LootId_3,LootId_4,LootId_5,AuraData,RandomAuraCount,HpMod,KillGroupRewId,KillGroupRewChance,KillRewGameObject,SrcLoot,RandSpellGroupId FROM _map");
+
+	if (!result) 
+		return;
+
+	do
+	{
+		Field* fields = result->Fetch();
+		MapModTemplate MapModTemp;
+		MapModTemp.Map				= fields[0].GetUInt32();
+		MapModTemp.Area				= fields[1].GetUInt32();
+		MapModTemp.Zone				= fields[2].GetUInt32();
+		MapModTemp.ReqId			= fields[3].GetUInt32();
+		MapModTemp.Diff				= fields[4].GetUInt32();
+		MapModTemp.ModType			= fields[5].GetUInt32();
+		MapModTemp.Level			= fields[6].GetUInt8();
+		MapModTemp.Health			= fields[7].GetUInt32();
+		MapModTemp.MeleeDmg			= fields[8].GetFloat();
+		MapModTemp.SpellDmgMod		= fields[9].GetFloat();
+		MapModTemp.HealMod			= fields[10].GetFloat();
+		MapModTemp.ReduceDmgPct		= fields[11].GetFloat();
+		MapModTemp.Resistance		= fields[12].GetInt32();
+		MapModTemp.KillRewId		= fields[13].GetUInt32();
+		MapModTemp.KillRewChance	= fields[14].GetFloat();
+		MapModTemp.KillAnnounce		= fields[15].GetBool();
+		MapModTemp.Armor			= fields[16].GetInt32();
+		MapModTemp.ChallengeLv		= fields[17].GetUInt32();
+		MapModTemp.AttackTime		= fields[18].GetUInt32();
+		MapModTemp.AddTalismanValue = fields[19].GetInt32();
+		MapModTemp.AddRankValue		= fields[20].GetInt32();
+		MapModTemp.ResetOnLeave		= fields[21].GetBool();
+
+		for (size_t i = 0; i < MAX_CUSTOM_LOOT_COUNT; i++)
+			MapModTemp.LootId[i] = fields[22 + i].GetUInt32();
+
+		Tokenizer auraData(fields[27].GetString(), '#');
+		for (Tokenizer::const_iterator itr = auraData.begin(); itr != auraData.end(); ++itr)
+			if (SpellInfo const*  spellInfo = sSpellMgr->GetSpellInfo(abs(atoi(*itr))))
+				MapModTemp.AuraVec.push_back(atoi(*itr));
+			
+		MapModTemp.RandomAuraCount = fields[28].GetUInt32();
+
+		MapModTemp.HpMod				= fields[29].GetFloat();
+		MapModTemp.KillGroupRewId		= fields[30].GetUInt32();
+		MapModTemp.KillGroupRewChance	= fields[31].GetFloat();
+		MapModTemp.KillRewGameObject	= fields[32].GetUInt32();
+		MapModTemp.SrcLoot				= fields[33].GetBool();
+		MapModTemp.RandSpellGroupId		= fields[34].GetUInt32();
+		MapModVec.push_back(MapModTemp);
+	} while (result->NextRow());
+
+
+		//EQUIPMENT_SLOT_HEAD = 0,
+		//EQUIPMENT_SLOT_NECK = 1,
+		//EQUIPMENT_SLOT_SHOULDERS = 2,
+		//EQUIPMENT_SLOT_BODY = 3,
+		//EQUIPMENT_SLOT_CHEST = 4,
+		//EQUIPMENT_SLOT_WAIST = 5,
+		//EQUIPMENT_SLOT_LEGS = 6,
+		//EQUIPMENT_SLOT_FEET = 7,
+		//EQUIPMENT_SLOT_WRISTS = 8,
+		//EQUIPMENT_SLOT_HANDS = 9,
+		//EQUIPMENT_SLOT_FINGER1 = 10,
+		//EQUIPMENT_SLOT_FINGER2 = 11,
+		//EQUIPMENT_SLOT_TRINKET1 = 12,
+		//EQUIPMENT_SLOT_TRINKET2 = 13,
+		//EQUIPMENT_SLOT_BACK = 14,
+		//EQUIPMENT_SLOT_MAINHAND = 15,
+		//EQUIPMENT_SLOT_OFFHAND = 16,
+		//EQUIPMENT_SLOT_RANGED = 17,
+		//EQUIPMENT_SLOT_TABARD = 18,
+
+
+	MapModPlayerVec.clear();
+	if (result = WorldDatabase.PQuery("SELECT µØÍ¼ID, ¸±±¾ÄÑ¶È, ¸±±¾ÌôÕ½µÈ¼¶, »ñµÃ¹â»·×é FROM _ÊôÐÔµ÷Õû_µØÍ¼_Íæ¼Ò"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			MapModPlayerTemplate Temp;
+			Temp.Map = fields[0].GetUInt32();
+			Temp.Diff = fields[1].GetUInt8();
+			Temp.ChallengeLv = fields[2].GetUInt32();
+
+			Tokenizer data1(fields[3].GetString(), ' ');
+			for (Tokenizer::const_iterator itr = data1.begin(); itr != data1.end(); ++itr)
+				Temp.AuraVec.push_back(uint32(atol(*itr)));
+
+			MapModPlayerVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+}
+
+void MapMod::ReApplyMapAura(Player* player)
+{
+	for (auto itr = MapModPlayerVec.begin(); itr != MapModPlayerVec.end(); itr++)
+		for (auto i = itr->AuraVec.begin(); i != itr->AuraVec.end(); i++)
+			if (player->HasAura(*i))
+				player->RemoveAurasDueToSpell(*i);
+
+	for (auto itr = MapModPlayerVec.begin(); itr != MapModPlayerVec.end(); itr++)
+		if (player->GetMapId() == itr->Map && player->GetMap()->challengeLv == itr->ChallengeLv && player->GetMap()->GetDifficulty() == itr->Diff)
+			for (auto i = itr->AuraVec.begin(); i != itr->AuraVec.end(); i++)
+				if (!player->HasAura(*i))
+					player->AddAura(*i, player);
+}
+
+void MapMod::RemoveItem(Player* player)
+{
+	auto itr = MapItemMap.find(player->GetMapId());
+
+	if (itr == MapItemMap.end())
+		return;
+
+	SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+	std::list<Item*> mailItems;
+
+	for (size_t i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
+	{
+		auto x = itr->second.find(i);
+		if (x == itr->second.end())
+			continue;
+
+		if (x->second)
+			continue;
+
+		if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+		{
+			ItemPosCountVec dest;
+			uint8 msg = player->CanStoreItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
+			if (msg == EQUIP_ERR_OK)
+			{
+				player->RemoveItem(INVENTORY_SLOT_BAG_0, i, true);
+				player->StoreItem(dest, pItem, true);
+			}
+			else
+			{
+				player->MoveItemFromInventory(INVENTORY_SLOT_BAG_0, i, true);
+				SQLTransaction trans = CharacterDatabase.BeginTransaction();
+				pItem->DeleteFromInventoryDB(trans);
+				pItem->SaveToDB(trans);
+				mailItems.push_back(pItem);
+			}
+		}
+	}
+
+	while (!mailItems.empty())
+	{
+		MailDraft draft("ÒÅÊ§µÄÎïÆ·", "ÇëÊÕºÃÄãµÄÎïÆ·");
+		for (uint8 i = 0; !mailItems.empty() && i < MAX_MAIL_ITEMS; ++i)
+		{
+			draft.AddItem(mailItems.front());
+			mailItems.pop_front();
+		}
+
+		draft.SendMailTo(trans, player, MailSender(player, MAIL_STATIONERY_GM), MAIL_CHECK_MASK_COPIED);
+	}
+
+	player->UpdateTitansGrip();
+
+	CharacterDatabase.CommitTransaction(trans);
+}
+
+bool MapMod::CanEquipItem(Player* player, uint8 slot, uint32 itemId)
+{
+	if (slot >= EQUIPMENT_SLOT_END)
+		return true;
+
+	auto itr = MapItemMap.find(player->GetMapId());
+
+	if (itr == MapItemMap.end())
+		return true;
+
+	if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+		if (proto->Map == player->GetMapId())
+			return true;
+
+	auto x = itr->second.find(slot);
+	if (x->second)
+		return true;
+
+	return false;
+}
+
+bool MapMod::OnEnterMap(Player* player)
+{
+	uint32 map = player->GetMapId();
+	uint32 diff = player->GetMap()->GetDifficulty();
+	uint32 ChallengeLv = player->GetMap()->challengeLv;
+
+	for (auto itr = MapModVec.begin(); itr != MapModVec.end(); itr++)
+	{
+		if (diff != itr->Diff || ChallengeLv != itr->ChallengeLv || itr->Zone != 0 || itr->Area != 0)
+			continue;
+
+		if (map != itr->Map)
+			continue;
+
+		if (sReq->Check(player, itr->ReqId))
+		{
+			sReq->Des(player, itr->ReqId);
+			return true;
+		}
+		else
+		{
+			player->GetSession()->SendNotification("ÄãÃ»ÓÐ×Ê¸ñ½øÈë¸ÃµØÍ¼£¡");
+			player->TeleportTo(player->m_homebindMapId, player->m_homebindX, player->m_homebindY, player->m_homebindZ, player->GetOrientation());
+			return false;
+		}
+	}
+
+	return true;
+}
+
+bool MapMod::OnEnterZone(Player* player, uint32 zone)
+{
+	uint32 diff = player->GetMap()->GetDifficulty();
+	uint32 ChallengeLv = player->GetMap()->challengeLv;
+
+	for (auto itr = MapModVec.begin(); itr != MapModVec.end(); itr++)
+	{
+		if (diff != itr->Diff || ChallengeLv != itr->ChallengeLv || itr->Area != 0)
+			continue;
+
+		if (zone != itr->Zone)
+			continue;
+
+		if (sReq->Check(player, itr->ReqId))
+		{
+			sReq->Des(player, itr->ReqId);
+			return true;
+		}
+		else
+		{
+			player->GetSession()->SendNotification("ÄãÃ»ÓÐ×Ê¸ñ½øÈë¸ÃµØÓò£¡");
+			player->TeleportTo(player->m_homebindMapId, player->m_homebindX, player->m_homebindY, player->m_homebindZ, player->GetOrientation());
+			return false;
+		}
+	}
+
+	return true;
+}
+
+bool MapMod::OnEnterArea(Player* player, uint32 area)
+{
+	uint32 diff = player->GetMap()->GetDifficulty();
+	uint32 ChallengeLv = player->GetMap()->challengeLv;
+
+	for (auto itr = MapModVec.begin(); itr != MapModVec.end(); itr++)
+	{
+		if (diff != itr->Diff || ChallengeLv != itr->ChallengeLv)
+			continue;
+
+		if (area != itr->Area)
+			continue;
+
+		if (sReq->Check(player, itr->ReqId))
+		{
+			sReq->Des(player, itr->ReqId);
+			return true;
+		}
+		else
+		{
+			player->GetSession()->SendNotification("ÄãÃ»ÓÐ×Ê¸ñ½øÈë¸ÃÇøÓò£¡");
+			player->TeleportTo(player->m_homebindMapId, player->m_homebindX, player->m_homebindY, player->m_homebindZ, player->GetOrientation());
+			return false;
+		}
+	}
+
+	return true;
+}
+
+void MapMod::SetMod(Creature* creature)
+{
+	if (creature->GetEntry() == 1964 || creature->IsGuardian() || creature->IsHunterPet() || creature->IsTotem())
+		return;
+		
+	////Ð¡¶¯ÎïÖ®Àà
+	//if (creature->IsCivilian())
+	//	return;
+
+	uint32 map	= creature->GetMapId();
+	uint32 zone = creature->GetZoneId();
+	uint32 area = creature->GetAreaId();
+	uint32 diff = creature->GetMap()->GetDifficulty();
+	uint32 ChallengeLv = creature->GetMap()->challengeLv;
+
+	uint32 ModType = 0;
+
+	if (creature->IsDungeonBoss() || creature->isWorldBoss())
+		ModType = 1;
+
+	uint32 len = MapModVec.size();
+
+	for (size_t i = 0; i < len; i++)
+	{
+		if (ChallengeLv == MapModVec[i].ChallengeLv && diff == MapModVec[i].Diff && (map == MapModVec[i].Map && MapModVec[i].Zone == 0 && MapModVec[i].Area == 0 || map == MapModVec[i].Map && zone == MapModVec[i].Zone && MapModVec[i].Area == 0 || map == MapModVec[i].Map && zone == MapModVec[i].Zone && area == MapModVec[i].Area))
+		{
+			if (ModType == 0 && (MapModVec[i].ModType != 0 && MapModVec[i].ModType != 2))
+				continue;
+
+			if (ModType == 1 && (MapModVec[i].ModType != 1 && MapModVec[i].ModType != 2))
+				continue;
+
+			creature->C_Level			= MapModVec[i].Level;
+			creature->C_Health			= MapModVec[i].Health;
+			creature->C_HpMod			= MapModVec[i].HpMod;
+			creature->C_MeleeDmg		= MapModVec[i].MeleeDmg;
+			creature->C_SpellDmgMod		= MapModVec[i].SpellDmgMod;
+			creature->C_HealMod			= MapModVec[i].HealMod;
+			creature->C_ReduceDmgPct	= MapModVec[i].ReduceDmgPct;
+			creature->C_Resistance		= MapModVec[i].Resistance;
+			creature->C_SrcLoot			= MapModVec[i].SrcLoot;
+
+			for (size_t j = 0; j < MAX_CUSTOM_LOOT_COUNT; j++)
+				creature->C_LootId[j] = MapModVec[i].LootId[j];
+
+			std::vector<uint32> RandomAuraVec;
+
+			for (auto itr = MapModVec[i].AuraVec.begin(); itr != MapModVec[i].AuraVec.end(); itr++)
+			{
+				if (*itr > 0)
+					creature->C_AuraVec.push_back(*itr);
+				else
+					RandomAuraVec.push_back(abs(*itr));
+			}
+			
+			if (!RandomAuraVec.empty())
+			{
+				int32 delcount = RandomAuraVec.size() - MapModVec[i].RandomAuraCount;
+
+				for (size_t i = 0; i < delcount; i++)
+				{
+					if (RandomAuraVec.empty())
+						break;
+
+                    std::default_random_engine generator{ std::random_device{}() };
+                    std::shuffle(std::begin(RandomAuraVec), std::end(RandomAuraVec), generator);
+
+					RandomAuraVec.erase(RandomAuraVec.begin());
+				}
+			}
+
+			if (!RandomAuraVec.empty())
+				for (size_t i = 0; i < RandomAuraVec.size(); i++)
+					creature->C_AuraVec.push_back(RandomAuraVec[i]);
+			
+			creature->C_KillRewId			= MapModVec[i].KillRewId;
+			creature->C_KillRewChance		= MapModVec[i].KillRewChance;
+			creature->C_KillGroupRewId		= MapModVec[i].KillGroupRewId;
+			creature->C_KillGroupRewChance	= MapModVec[i].KillGroupRewChance;
+			creature->C_KillAnnounce		= MapModVec[i].KillAnnounce;
+			creature->C_Armor				= MapModVec[i].Armor;
+			creature->C_AttackTime			= MapModVec[i].AttackTime;
+			creature->C_AddTalismanValue	= MapModVec[i].AddTalismanValue;
+			creature->C_AddAddRankValue		= MapModVec[i].AddRankValue;
+			creature->C_KillRewGameObject	= MapModVec[i].KillRewGameObject;
+			creature->RandSpellGroupId		= MapModVec[i].RandSpellGroupId;
+			break;
+		}
+	}
+}
+
+void MapMod::ResetInstance(Player* player, Difficulty diff, uint32 mapId)
+{
+	if (MapEntry const* mapEntry = sMapStore.LookupEntry(mapId))
+	{
+		std::string text = mapEntry->name[4];
+
+		switch (diff)
+		{
+		case 0:
+			break;
+		case 1:
+			mapEntry->IsRaid() ? text += "[25]" : text += "[5H]";
+			break;
+		case 2:
+			text += "[10H]";
+			break;
+		case 3:
+			text += "[25H]";
+			break;
+		default:
+			break;
+		}
+
+		text += " ÒÑ±»ÖØÖÃ";
+
+		for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
+		{
+			BoundInstancesMap const& m_boundInstances = sInstanceSaveMgr->PlayerGetBoundInstances(player->GetGUIDLow(), Difficulty(i));
+			for (BoundInstancesMap::const_iterator itr = m_boundInstances.begin(); itr != m_boundInstances.end();)
+			{
+				InstanceSave* save = itr->second.save;
+				MapEntry const* mapEntry = sMapStore.LookupEntry(itr->first);
+				if (mapEntry && itr->first != player->GetMapId() && (!mapId || mapId == itr->first) && (diff == -1 || diff == save->GetDifficulty()))
+				{
+					ChatHandler(player->GetSession()).PSendSysMessage(text.c_str());
+					sInstanceSaveMgr->PlayerUnbindInstance(player->GetGUIDLow(), itr->first, diff, true, player);
+					itr = m_boundInstances.begin();
+				}
+				else
+					++itr;
+			}
+		}
+	}
+}
+
+void MapMod::PopOrTele(Player* player, uint32 triggerId)
+{
+    AreaTriggerTeleport const* at = sObjectMgr->GetAreaTriggerTeleport(triggerId);
+	if (!at)
+		return;
+
+	uint32 mapId = at->target_mapId;
+	uint32 len = MapModVec.size();
+	uint32 reqId = 0;
+
+	for (size_t i = 0; i < len; i++)
+		if (mapId == MapModVec[i].Map && MapModVec[i].Zone == 0 && MapModVec[i].Area == 0)
+			if (MapModVec[i].ReqId > 0)
+				reqId = MapModVec[i].ReqId;
+
+	if (reqId == 0)
+		player->TeleportTo(at->target_mapId, at->target_X, at->target_Y, at->target_Z, at->target_Orientation, TELE_TO_NOT_LEAVE_TRANSPORT);
+	else
+	{
+		if (MapEntry const* mapEntry = sMapStore.LookupEntry(mapId))
+		{
+			sCF->SendAcceptOrCancel(player, 994, sReq->Notice(player, reqId, "½øÈë", mapEntry->name[4]));
+			player->enter_map_at = at;
+			player->enter_map_req = reqId;
+		}
+	}
+}
+
+class MapModPlayerScript : public PlayerScript
+{
+public:
+	MapModPlayerScript() : PlayerScript("MapModPlayerScript") {}
+
+	void OnMapChanged(Player* player) override
+	{
+		sMapMod->ReApplyMapAura(player);
+
+		sMapMod->RemoveItem(player);
+
+        if (player->GetMap())
+            player->InitMapTempItems(player->GetMapId());
+
+		//if (!sMapMod->OnEnter(player, 0))
+			//return;
+
+		sEM->Update(player, 0);
+
+		Map* map = player->LastMap;
+
+		if (!map || !map->IsDungeon())
+			return;
+
+		uint32 MapId = map->GetId();
+		uint32 Diff = map->GetDifficulty();
+		uint32 ChallengeLv = map->challengeLv;
+
+		uint32 len = MapModVec.size();
+
+		for (size_t i = 0; i < len; i++)
+		{
+			if (ChallengeLv == MapModVec[i].ChallengeLv && Diff == MapModVec[i].Diff && MapId == MapModVec[i].Map)
+			{
+				if (MapModVec[i].ResetOnLeave)
+				{
+					sMapMod->ResetInstance(player, map->GetDifficulty(), MapId);
+					return;
+				}
+			}
+		}
+	}
+    void OnUpdateZone(Player* player, uint32 /*newZone*/, uint32 newArea)
+    {
+        player->InitAreaTempItems(newArea);
+    }
+};
+
+void AddSC_MapModPlayerScript()
+{
+	new MapModPlayerScript();
+}
diff --git a/src/server/scripts/Custom/MapMod/MapMod.h b/src/server/scripts/Custom/MapMod/MapMod.h
new file mode 100644
index 0000000..a1d0d11
--- /dev/null
+++ b/src/server/scripts/Custom/MapMod/MapMod.h
@@ -0,0 +1,94 @@
+
+/*
+ALTER TABLE _map ADD ResetOnLeave BOOL DEFAULT FALSE AFTER AddRankValue;
+ALTER TABLE _map CHANGE ChallegeLevel ChallengeLv INT UNSIGNED DEFAULT 0;
+ALTER TABLE _map ADD HpMod FLOAT UNSIGNED DEFAULT 1 AFTER Health;
+ALTER TABLE _map ADD Aura3 INT UNSIGNED DEFAULT 0 AFTER ResetOnLeave;
+ALTER TABLE _map ADD Aura2 INT UNSIGNED DEFAULT 0 AFTER ResetOnLeave;
+ALTER TABLE _map ADD Aura1 INT UNSIGNED DEFAULT 0 AFTER ResetOnLeave;
+DROP TABLE _challenge_aura;
+
+ALTER TABLE _map ALTER COLUMN KillRewChance SET DEFAULT 100;
+ALTER TABLE _map ADD KillGroupRewId INT UNSIGNED DEFAULT 0 AFTER KillRewChance;
+ALTER TABLE _map ADD KillGroupRewChance float UNSIGNED DEFAULT 100 AFTER KillGroupRewId;
+ALTER TABLE _attribute_creature ALTER COLUMN KillRewChance SET DEFAULT 100;
+ALTER TABLE _attribute_creature ADD KillGroupRewId INT UNSIGNED DEFAULT 0 AFTER KillRewChance;
+ALTER TABLE _attribute_creature ADD KillGroupRewChance float UNSIGNED DEFAULT 100 AFTER KillGroupRewId;
+ALTER TABLE _attribute_creature ADD AddRankValue int DEFAULT 0 AFTER AddTalismanValue;
+
+
+*/
+struct MapModTemplate
+{
+	uint32 Map;
+	uint32 Diff;
+	uint32 Area;
+	uint32 Zone;
+	uint32 ReqId;
+	uint32 ModType;										//0æ®éæªç© 1BOSS 2æ®éæªç©+BOSS
+	uint8 Level;										//ç­çº§
+	uint32 Health;										//çå½å¼
+	float HpMod;										//çå½å¼åç
+	int32 Armor;										//æ¤ç²-1 creature_templateè¡¨ç¡®å®
+	float MeleeDmg;									//ç©çä¼¤å®³
+	float SpellDmgMod;									//æ³æ¯ä¼¤å®³åç
+	float HealMod;										//æ²»çåç
+	float ReduceDmgPct;									//åä¼¤ç¾åæ¯
+	int32 Resistance;									//ææ§-1 creature_templateè¡¨ç¡®å®
+	uint32	LootId[MAX_CUSTOM_LOOT_COUNT];				//æè½ creaute_loot_template
+	bool  SrcLoot;
+	uint32 KillRewId;									//å»æèè·å¾å¥å±
+	float KillRewChance;								//å»æèè·å¾å¥å±å ç
+	uint32 KillGroupRewId;								//å»æèéä¼è·å¾å¥å±
+	float KillGroupRewChance;							//å»æèéä¼è·å¾å¥å±å ç
+	bool KillAnnounce;									//å»ææ¶å¹¿æ­åå®¹
+	uint32 ChallengeLv;									//ææç­çº§
+	uint32 AttackTime;									//ç©çæ»å»é´é
+	int32 AddTalismanValue;
+	int32 AddRankValue;
+	bool ResetOnLeave;									//ç¦»å¼å¯æ¬åéç½®
+	std::vector<int32> AuraVec;							//åç¯
+	uint32 RandomAuraCount;								//éæºåç¯ä¸ªæ°
+	uint32 KillRewGameObject;							//å»æç®±å­
+	uint32 RandSpellGroupId;
+};
+extern std::vector<MapModTemplate> MapModVec;
+extern std::unordered_map<uint32, std::unordered_map<uint8, bool>> MapItemMap;
+
+struct MapModPlayerTemplate
+{
+	uint32 Map;
+	uint32 Diff;
+	uint32 ChallengeLv;
+	std::vector<uint32> AuraVec;
+};
+extern std::vector<MapModPlayerTemplate> MapModPlayerVec;
+
+class MapMod
+{
+public:
+	static MapMod* instance()
+	{
+		static MapMod instance;
+		return &instance;
+	}
+
+	void Load();
+	bool OnEnterMap(Player* player);
+
+	bool OnEnterZone(Player* player, uint32 zone);
+	bool OnEnterArea(Player* player, uint32 area);
+
+	void SetMod(Creature* creature);
+	void ResetInstance(Player* player, Difficulty diff, uint32 mapId);
+
+	void PopOrTele(Player* player, uint32 triggerId);
+
+	void RemoveItem(Player* player);
+	bool CanEquipItem(Player* player, uint8 slot, uint32 itemId);
+
+	void ReApplyMapAura(Player* player);
+private:
+
+};
+#define sMapMod MapMod::instance()
diff --git a/src/server/scripts/Custom/Market/Market.cpp b/src/server/scripts/Custom/Market/Market.cpp
new file mode 100644
index 0000000..b2a8c77
--- /dev/null
+++ b/src/server/scripts/Custom/Market/Market.cpp
@@ -0,0 +1,182 @@
+#pragma execution_character_set("utf-8")
+#include "Market.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../GCAddon/GCAddon.h"
+#include "../String/myString.h"
+
+void Market::SetSelection(Player* buyer, uint64 guid)
+{
+	Player* seller = ObjectAccessor::GetPlayer(*buyer, guid);
+
+	if (seller && seller->OnSale)
+		UpdateMaket(buyer, seller);
+}
+
+void Market::InitMarket(Player* player)
+{
+	player->MarketVec.clear();
+	player->OnSale = true;
+}
+
+void Market::ClickItem(Player* player, Item* item)
+{
+	if (player->MarketVec.size() < 6)
+	{
+		MarketTemplate Temp;
+		Temp.item = item;
+		Temp.token = 0;
+		player->MarketVec.push_back(Temp);
+	}
+	else
+		ChatHandler(player->GetSession()).PSendSysMessage("Ã»ÓÐ¶àÓàµÄÀ¸Î»");
+
+	UpdateMaket(player);
+}
+
+void Market::UpdateMaket(Player* player)
+{
+	std::ostringstream oss;
+	oss << "GC_SMSG_OPC_MARKET_UPDATE@";
+
+	for (uint32 slot = 0; slot < player->MarketVec.size(); slot++)
+	{
+		Item* item = player->MarketVec[slot].item;
+		uint32 token = player->MarketVec[slot].token;
+
+		if (!item)
+			continue;
+
+		oss << slot + 1 << "-" << item->GetEntry() << "-" << item->GetCount() << "-" << token << ":";
+	}
+
+	player->OnSale = true;
+	//sGCAddon->SendPacket(player, oss.str());
+}
+
+void Market::UpdateMaket(Player* buyer, Player* seller)
+{
+	std::ostringstream oss;
+	oss << "GC_SMSG_OPC_MARKET_BUYER_UPDATE@";
+
+	for (uint32 slot = 0; slot < seller->MarketVec.size(); slot++)
+	{
+		Item* item = seller->MarketVec[slot].item;
+		uint32 token = seller->MarketVec[slot].token;
+
+		if (!item)
+			continue;
+
+		ItemDisplayInfoEntry const* info = sItemDisplayInfoStore.LookupEntry(item->GetTemplate()->DisplayInfoID);
+
+		if (!info)
+			continue;
+
+		oss << slot + 1 << "-" << item->GetEntry() << "-" << item->GetCount() << "-" << info->inventoryIcon << "-" << token << ":";
+	}
+
+	//sGCAddon->SendPacket(buyer, oss.str());
+}
+
+void Market::SetPrice(Player* player, uint32 slot, uint32 token)
+{
+	for (uint32 slot1 = 0; slot1 < player->MarketVec.size(); slot1++)
+	{
+		if (slot == slot1)
+		{
+			player->MarketVec[slot1].token = token;
+			break;
+		}
+	}
+}
+
+void Market::OffShelve(Player* player, uint32 slot)
+{
+	std::vector<MarketTemplate>::iterator it = player->MarketVec.begin() + slot;
+	player->MarketVec.erase(it);
+
+	UpdateMaket(player);
+}
+
+void Market::OnSell(Player* seller, Player* buyer, uint32 slot)
+{
+	Item* item = NULL;
+	uint32 token = 0;
+
+	for (uint32 i = 0; i < seller->MarketVec.size(); i++)
+		if (i == slot)
+		{
+			item	= seller->MarketVec[i].item;
+			token	= seller->MarketVec[i].token;
+			break;
+		}
+
+	if (!item)
+	{
+		ChatHandler(buyer->GetSession()).PSendSysMessage("¸ÃÉÌÆ·²»´æÔÚ");
+		UpdateMaket(buyer, seller);
+		return;
+	}
+		
+	if (buyer->totalTokenAmount < token)
+	{
+		ChatHandler(buyer->GetSession()).PSendSysMessage("%s²»×ãÒÔ¹ºÂò¸ÃÉÌÆ·", sString->GetText(CORE_STR_TYPES(STR_TOKEN)));
+		return;
+	}
+		
+	OffShelve(seller, slot);
+	UpdateMaket(buyer, seller);
+
+
+	buyer->AddItem(item->GetBagSlot(), item->GetCount());
+	ChatHandler(buyer->GetSession()).PSendSysMessage("¹ºÂòÉÌÆ·Íê³É");
+	sCF->UpdateTokenAmount(buyer, token, false, "[°ÚÌ¯]¹ºÂòÎïÆ·");
+
+	sCF->UpdateTokenAmount(seller, token, true, "[°ÚÌ¯]³öÊÛÎïÆ·");
+	seller->DestroyItem(item->GetBagSlot(), item->GetSlot(), true);
+	ChatHandler(seller->GetSession()).PSendSysMessage("³öÊÛÉÌÆ·Íê³É");
+}
+
+
+class spell_market : public SpellScriptLoader
+{
+public:
+	spell_market() : SpellScriptLoader("spell_market") { }
+
+	class spell_market_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_market_SpellScript);
+		void HandleAfterCast()
+		{
+			Player* player = GetCaster()->ToPlayer();
+			if (!player)
+				return;
+
+			Item* item = GetExplTargetItem();
+			if (!item)
+				return;
+
+			if (item->GetOwner() != player)
+			{
+				ChatHandler(player->GetSession()).PSendSysMessage("Äã²»ÓµÓÐÕâ¼þÎïÆ·£¡");
+				return;
+			}
+			
+			sMarket->ClickItem(player, item);
+		}
+
+		void Register() override
+		{
+			AfterCast += SpellCastFn(spell_market_SpellScript::HandleAfterCast);
+		}
+	};
+
+	SpellScript* GetSpellScript() const override
+	{
+		return new spell_market_SpellScript();
+	}
+};
+
+void AddSC_Market()
+{
+	//new spell_market();
+}
diff --git a/src/server/scripts/Custom/Market/Market.h b/src/server/scripts/Custom/Market/Market.h
new file mode 100644
index 0000000..909baf9
--- /dev/null
+++ b/src/server/scripts/Custom/Market/Market.h
@@ -0,0 +1,21 @@
+class Market
+{
+public:
+	static Market* instance()
+	{
+		static Market instance;
+		return &instance;
+	}
+	void InitMarket(Player* player);
+	void ClickItem(Player* player, Item* item);
+	void UpdateMaket(Player* player);
+	void UpdateMaket(Player* buyer, Player* seller);
+	void SetPrice(Player* player, uint32 slot, uint32 token);
+	void OffShelve(Player* player, uint32 slot);
+	void OnSell(Player* seller,Player* buyer, uint32 slot);
+
+	void SetSelection(Player* buyer, uint64 guid);
+private:
+
+};
+#define sMarket Market::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Morph/Morph.cpp b/src/server/scripts/Custom/Morph/Morph.cpp
new file mode 100644
index 0000000..4ee8673
--- /dev/null
+++ b/src/server/scripts/Custom/Morph/Morph.cpp
@@ -0,0 +1,375 @@
+#pragma execution_character_set("utf-8")
+#include "Morph.h"
+#include "../FunctionCollection/FunctionCollection.h"
+
+std::unordered_map<uint32, MorphTemplate> MorphMap;
+std::unordered_map<uint32, CharInfoTemplate> CharInfoMap;
+
+void Morph::Load()
+{
+	MorphMap.clear();
+	QueryResult result = WorldDatabase.PQuery("SELECT id,displayId,description,scale,duration,skin,face,hair,haircolor,facialhair FROM _morph");
+	if (!result)
+		return;
+	do
+	{
+		Field* fields = result->Fetch();	
+		uint32 id = fields[0].GetUInt32();
+
+		if (id == 0)
+			continue;
+
+		MorphTemplate Temp;
+		Temp.displayId		= fields[1].GetUInt32();
+		Temp.description	= fields[2].GetString();
+		Temp.scale			= fields[3].GetUInt32();
+		Temp.duration		= fields[4].GetUInt32();
+		Temp.skin			= fields[5].GetUInt32();
+		Temp.face			= fields[6].GetUInt32();
+		Temp.hair			= fields[7].GetUInt32();
+		Temp.haircolor		= fields[8].GetUInt32();
+		Temp.facialhair		= fields[9].GetUInt32();
+		MorphMap.insert(std::make_pair(id, Temp));
+
+	} while (result->NextRow());
+}
+
+void Morph::UpdateCharInfoMap(Player* player)
+{
+	std::unordered_map<uint32, CharInfoTemplate>::iterator iter = CharInfoMap.find(player->GetGUIDLow());
+
+	if (iter == CharInfoMap.end())
+	{
+		CharInfoTemplate Temp;
+		Temp.skin = player->GetByteValue(PLAYER_BYTES, 0);
+		Temp.face = player->GetByteValue(PLAYER_BYTES, 1);
+		Temp.hair = player->GetByteValue(PLAYER_BYTES, 2);
+		Temp.haircolor = player->GetByteValue(PLAYER_BYTES, 3);
+		Temp.facialhair = player->GetByteValue(PLAYER_BYTES_2, 0);
+		Temp.race = player->getRace();
+		Temp.gender = player->getGender();
+		Temp.displayId = player->GetDisplayId();
+		Temp.morphId = 0;
+		Temp.duration = 0;
+		CharInfoMap.insert(std::make_pair(player->GetGUIDLow(), Temp));
+	}
+	else
+	{
+		iter->second.skin = player->GetByteValue(PLAYER_BYTES, 0);
+		iter->second.face = player->GetByteValue(PLAYER_BYTES, 1);
+		iter->second.hair = player->GetByteValue(PLAYER_BYTES, 2);
+		iter->second.haircolor = player->GetByteValue(PLAYER_BYTES, 3);
+		iter->second.facialhair = player->GetByteValue(PLAYER_BYTES_2, 0);
+		iter->second.race = player->getRace();
+		iter->second.gender = player->getGender();
+		iter->second.displayId = player->GetDisplayId();
+	}
+}
+
+std::string Morph::GetDescription(uint32 morphId)
+{
+	std::unordered_map<uint32, MorphTemplate>::iterator iter = MorphMap.find(morphId);
+
+	if (iter != MorphMap.end())
+		return iter->second.description;
+
+	return "";
+}
+
+uint32 Morph::GetDuration(uint32 morphId)
+{
+	std::unordered_map<uint32, MorphTemplate>::iterator iter = MorphMap.find(morphId);
+
+	if (iter != MorphMap.end())
+		return iter->second.duration * IN_MILLISECONDS;
+
+	return 0;
+}
+
+uint32 Morph::GetMorphId(Player* player)
+{
+	std::unordered_map<uint32, CharInfoTemplate>::iterator iter = CharInfoMap.find(player->GetGUIDLow());
+
+	if (iter != CharInfoMap.end())
+		return iter->second.morphId;
+
+	return 0;
+}
+
+void Morph::SetMorphId(Player* player, uint32 morphId)
+{
+	std::unordered_map<uint32, CharInfoTemplate>::iterator iter = CharInfoMap.find(player->GetGUIDLow());
+
+	if (iter != CharInfoMap.end())
+		iter->second.morphId = morphId;
+}
+
+void Morph::SetMorphDuration(Player* player, uint32 duration)
+{
+	std::unordered_map<uint32, CharInfoTemplate>::iterator iter = CharInfoMap.find(player->GetGUIDLow());
+
+	if (iter != CharInfoMap.end())
+		iter->second.duration = duration;
+}
+
+uint32 Morph::GetMorphDuration(Player* player)
+{
+	std::unordered_map<uint32, CharInfoTemplate>::iterator iter = CharInfoMap.find(player->GetGUIDLow());
+
+	if (iter != CharInfoMap.end())
+		return iter->second.duration;
+
+	return 0;
+}
+
+void Morph::Mor(Player* player)
+{
+	uint32 morphId = GetMorphId(player);
+
+	if (morphId == 0)
+		return;
+	
+	std::unordered_map<uint32, MorphTemplate>::iterator iter = MorphMap.find(morphId);
+
+	if (iter != MorphMap.end())
+	{
+		uint32 displayId		= iter->second.displayId;
+		float scale				= iter->second.scale;
+		uint8 skin				= iter->second.skin;
+		uint8 face				= iter->second.face;
+		uint8 hair				= iter->second.hair;
+		uint8 haircolor			= iter->second.haircolor;
+		uint8 facialhair		= iter->second.facialhair;
+
+		if (displayId == player->GetDisplayId())
+			return;
+
+		player->SetByteValue(PLAYER_BYTES, 0, skin);//skin
+		player->SetByteValue(PLAYER_BYTES, 1, face);//face
+		player->SetByteValue(PLAYER_BYTES, 2, hair); //hair
+		player->SetByteValue(PLAYER_BYTES, 3, haircolor);//haircolor
+		player->SetByteValue(PLAYER_BYTES_2, 0, facialhair);//facialhair
+
+		uint8 race = 0;
+		uint8 gender = 0;
+
+		switch (displayId)
+		{
+		case 49:
+			race = 1;
+			gender = 0;
+			break;
+		case 50:
+			race = 1;
+			gender = 1;
+			break;
+		case 51:
+			race = 2;
+			gender = 0;
+			break;
+		case 52:
+			race = 2;
+			gender = 1;
+			break;
+		case 53:
+			race = 3;
+			gender = 0;
+			break;
+		case 54:
+			race = 3;
+			gender = 1;
+			break;
+		case 55:
+			race = 4;
+			gender = 0;
+			break;
+		case 56:
+			race = 4;
+			gender = 1;
+			break;
+		case 57:
+			race = 5;
+			gender = 0;
+			break;
+		case 58:
+			race = 5;
+			gender = 1;
+			break;
+		case 59:
+			race = 6;
+			gender = 0;
+			break;
+		case 60:
+			race = 6;
+			gender = 1;
+			break;
+		case 1563:
+			race = 7;
+			gender = 0;
+			break;
+		case 1564:
+			race = 7;
+			gender = 1;
+			break;
+		case 1478:
+			race = 8;
+			gender = 0;
+			break;
+		case 1479:
+			race = 8;
+			gender = 1;
+			break;
+		case 15476:
+			race = 10;
+			gender = 0;
+			break;
+		case 15475:
+			race = 10;
+			gender = 1;
+			break;
+		case 16125:
+			race = 11;
+			gender = 0;
+			break;
+		case 16126:
+			race = 11;
+			gender = 1;
+			break;
+		default:
+			break;
+		}
+
+		uint32 bytes0 = 0;
+		bytes0 |= race;										// race
+		bytes0 |= player->getClass() << 8;                  // class
+		bytes0 |= gender << 16;                             // gender
+		player->SetUInt32Value(UNIT_FIELD_BYTES_0, bytes0);
+
+
+		for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+			if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+				player->SetVisibleItemSlot(slot, item);
+
+		player->SetDisplayId(displayId);
+		player->SetNativeDisplayId(displayId);
+		player->SetObjectScale(scale);
+	}
+}
+
+void Morph::DeMor(Player* player)
+{
+	SetMorphId(player, 0);
+	SetMorphDuration(player, 0);
+	player->SetObjectScale(1.0f);
+	Reset(player);
+}
+
+void Morph::Reset(Player* player)
+{
+	std::unordered_map<uint32, CharInfoTemplate>::iterator iter = CharInfoMap.find(player->GetGUIDLow());
+
+	if (iter != CharInfoMap.end())
+	{
+		player->SetByteValue(PLAYER_BYTES, 0, iter->second.skin);//skin
+		player->SetByteValue(PLAYER_BYTES, 1, iter->second.face);//face
+		player->SetByteValue(PLAYER_BYTES, 2, iter->second.hair); //hair
+		player->SetByteValue(PLAYER_BYTES, 3, iter->second.haircolor);//haircolor
+		player->SetByteValue(PLAYER_BYTES_2, 0, iter->second.facialhair);//facialhair
+
+		uint32 bytes0 = 0;
+		bytes0 |= iter->second.race;				// race
+		bytes0 |= player->getClass() << 8;          // class
+		bytes0 |= iter->second.gender << 16;        // gender
+		player->SetUInt32Value(UNIT_FIELD_BYTES_0, bytes0);
+
+		player->SetDisplayId(iter->second.displayId);
+		player->SetNativeDisplayId(iter->second.displayId);
+	}
+}
+
+void Morph::AddGossip(Player* player, Object* obj)
+{
+	player->PlayerTalkClass->ClearMenus();
+
+	for (std::unordered_map<uint32, MorphTemplate>::iterator iter = MorphMap.begin(); iter != MorphMap.end(); iter++)
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, iter->second.description, SENDER_MORPH, iter->first + SENDER_MORPH);
+	
+	if (obj->ToCreature())
+		player->SEND_GOSSIP_MENU(obj->GetEntry(), obj->GetGUID());
+	else
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+}
+
+void Morph::Action(Player*player, uint32 action, Object*obj)
+{
+	player->RemoveAura(MORPH_SPELLID);
+	SetMorphId(player, action - SENDER_MORPH);
+	SetMorphDuration(player, GetDuration(action - SENDER_MORPH));
+	player->CastSpell(player, MORPH_SPELLID);
+	AddGossip(player, obj);
+}
+//
+//class spell_morph : public SpellScriptLoader
+//{
+//public:
+//	spell_morph() : SpellScriptLoader("spell_morph") { }
+//
+//	class spell_morph_AuraScript : public AuraScript
+//	{
+//		PrepareAuraScript(spell_morph_AuraScript);
+//
+//		void OnApply(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*handle*/)
+//		{
+//			Unit* target = GetTarget();
+//
+//			if (!target || target->GetTypeId() != TYPEID_PLAYER)
+//				return;
+//
+//			uint32 duration = sMorph->GetMorphDuration(target->ToPlayer());
+//			SetMaxDuration(duration);
+//			SetDuration(duration);
+//			sMorph->Mor(target->ToPlayer());
+//		}
+//
+//		void OnRemove(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*handle*/)
+//		{
+//			Unit* target = GetTarget();
+//
+//			if (!target || target->GetTypeId() != TYPEID_PLAYER)
+//				return;
+//
+//			if (GetDuration() < 1)
+//				sMorph->DeMor(target->ToPlayer());
+//			else
+//				sMorph->SetMorphDuration(target->ToPlayer(), GetDuration());
+//		}
+//
+//		void Register()
+//		{
+//			OnEffectApply += AuraEffectApplyFn(spell_morph_AuraScript::OnApply, EFFECT_0, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL);
+//			OnEffectRemove += AuraEffectRemoveFn(spell_morph_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL);
+//		}
+//	};
+//
+//	AuraScript* GetAuraScript() const
+//	{
+//		return new spell_morph_AuraScript();
+//	}
+//};
+//
+//class MorPlayerScript : PlayerScript
+//{
+//public:
+//	MorPlayerScript() : PlayerScript("MorPlayerScript") {}
+//
+//	void OnLogin(Player* player, bool /*first*/)
+//	{
+//		//sMorph->UpdateCharInfoMap(player);
+//	}
+//};
+//
+//void AddSC_Morph()
+//{
+//	new spell_morph();
+//	new MorPlayerScript();
+//}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Morph/Morph.h b/src/server/scripts/Custom/Morph/Morph.h
new file mode 100644
index 0000000..2a391a7
--- /dev/null
+++ b/src/server/scripts/Custom/Morph/Morph.h
@@ -0,0 +1,62 @@
+#define MORPH_SPELLID 8
+
+struct MorphTemplate
+{
+	uint32 displayId;
+	std::string description;
+	float scale;
+	uint32 duration;
+	uint8 skin;
+	uint8 face;
+	uint8 hair;
+	uint8 haircolor;
+	uint8 facialhair;
+};
+
+extern std::unordered_map<uint32, MorphTemplate> MorphMap;
+
+struct CharInfoTemplate
+{
+	uint8 skin;
+	uint8 face;
+	uint8 hair;
+	uint8 haircolor;
+	uint8 facialhair;
+	uint8 race;
+	uint8 gender;
+	uint32 displayId;
+	uint32 morphId;
+	uint32 duration;
+};
+
+extern std::unordered_map<uint32, CharInfoTemplate> CharInfoMap;
+class Morph
+{
+public:
+	static Morph* instance()
+	{
+		static Morph instance;
+		return &instance;
+	}
+	void Load();
+	void UpdateCharInfoMap(Player* player);
+
+	uint32 GetMorphId(Player* player);
+	void SetMorphId(Player* player, uint32 morphId);
+	void SetMorphDuration(Player* player, uint32 duration);
+	uint32 GetMorphDuration(Player* player);
+
+	void Reset(Player* player);
+	void Mor(Player* player);
+	void DeMor(Player* player);
+
+	uint32 GetDisplayId(uint32 morphId);
+	std::string GetDescription(uint32 morphId);
+	uint32 GetDuration(uint32 morphId);
+
+	void AddGossip(Player* player, Object* obj);
+	void Action(Player*player, uint32 action, Object*obj);
+private:
+
+};
+//#define sMorph Morph::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/MountVendor/MountVendor.cpp b/src/server/scripts/Custom/MountVendor/MountVendor.cpp
new file mode 100644
index 0000000..7306357
--- /dev/null
+++ b/src/server/scripts/Custom/MountVendor/MountVendor.cpp
@@ -0,0 +1,277 @@
+#pragma execution_character_set("utf-8")
+#include "MountVendor.h"
+#include "../Requirement/Requirement.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../DataLoader/DataLoader.h"
+
+std::vector<MountVendorTemplate> MountVendorVec;
+
+void MountVendor::Load()
+{
+	MountVendorVec.clear();
+
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ×øÆï¼¼ÄÜID,¹ºÂòÐèÇóÄ£°åID,ÊÇ·ñÊÛÂô FROM _×øÆï_Ô¤ÀÀÓëÊÛÂô" :
+		"SELECT mountSpellId,reqId,onSale FROM _mount_vendor");
+	
+	if (!result) 
+		return;
+	do
+	{
+		Field* fields = result->Fetch();
+		MountVendorTemplate MountVendorTemp;
+		MountVendorTemp.spellId = fields[0].GetUInt32();
+		MountVendorTemp.reqId = fields[1].GetUInt32();
+		MountVendorTemp.onSale = fields[2].GetBool();
+		MountVendorVec.push_back(MountVendorTemp);
+	} while (result->NextRow());
+}
+
+class MountVendorScript : public CreatureScript
+{
+public:
+	MountVendorScript() : CreatureScript("MountVendorScript") { }
+
+
+	bool OnGossipHello(Player* player, Creature* creature) override
+	{
+		player->PlayerTalkClass->ClearMenus();
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Â½µØ×øÆï", GOSSIP_SENDER_MAIN + 1, GOSSIP_ACTION_INFO_DEF);
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "·ÉÐÐ×øÆï", GOSSIP_SENDER_MAIN + 2, GOSSIP_ACTION_INFO_DEF);
+		player->SEND_GOSSIP_MENU(creature->GetEntry(), creature->GetGUID());
+		return true;
+	}
+
+	bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action) override
+	{
+		player->PlayerTalkClass->ClearMenus();
+		player->mountReqId = 0;
+		switch (sender)
+		{
+		case GOSSIP_SENDER_MAIN:
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TAXI, "²é¿´", GOSSIP_SENDER_MAIN + 3, action);
+			if (OnSale(action))
+				player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, "¹ºÂò", GOSSIP_SENDER_MAIN + 4, action);
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "·µ»Ø", GOSSIP_SENDER_MAIN + 5, action);
+			player->SEND_GOSSIP_MENU(creature->GetEntry(), creature->GetGUID());
+			break;
+		case GOSSIP_SENDER_MAIN + 1://Â½µØ×øÆïÁÐ±í
+			AddMountList(player, false);
+			player->SEND_GOSSIP_MENU(creature->GetEntry(), creature->GetGUID());
+			break;
+		case GOSSIP_SENDER_MAIN + 2://·ÉÐÐ×øÆïÁÐ±í
+			AddMountList(player, true);
+			player->SEND_GOSSIP_MENU(creature->GetEntry(), creature->GetGUID());
+			break;
+		case GOSSIP_SENDER_MAIN + 3://²é¿´
+		{
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TAXI, "²é¿´", GOSSIP_SENDER_MAIN + 3, action);
+			if (OnSale(action))
+				player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, "¹ºÂò", GOSSIP_SENDER_MAIN + 4, action);
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "·µ»Ø", GOSSIP_SENDER_MAIN + 5, action);
+			player->SEND_GOSSIP_MENU(creature->GetEntry(), creature->GetGUID());
+			if (player->HasAura(action))
+				break;
+			if (player->IsMounted())
+			{
+				player->Dismount();
+				player->RemoveAurasByType(SPELL_AURA_MOUNTED);
+			}
+
+			std::ostringstream oss;
+			oss << "¸Ã×øÆïÐ§¹û½«ÔÚ" << MountTryTime << "SºóÈ¥³ý";
+			player->GetSession()->SendNotification(oss.str().c_str());
+			player->AddAura(action, player);
+			player->mountSpellId = action;
+			player->isTryMount = true;
+			player->mountTimer = 0;
+			ChatHandler(player->GetSession()).PSendSysMessage(GetMountDescription(action).c_str());
+		}
+			break;
+		case GOSSIP_SENDER_MAIN + 4://¹ºÂò
+		{
+			player->mountReqId = GetReqId(action);
+			player->mountSpellId = action;
+			std::string notice = sReq->Notice(player, player->mountReqId, "¹ºÂò\n", GetMountName(action));
+			sCF->SendAcceptOrCancel(player, 997, notice);
+		}		
+			break;
+		case GOSSIP_SENDER_MAIN + 5://·µ»Ø
+			//OnGossipHello(player, creature);
+			if (IsFlyMount(action))
+			{
+				player->PlayerTalkClass->ClearMenus();
+				AddMountList(player, true);
+				player->SEND_GOSSIP_MENU(creature->GetEntry(), creature->GetGUID());
+			}
+			else
+			{
+				player->PlayerTalkClass->ClearMenus();
+				AddMountList(player, false);
+				player->SEND_GOSSIP_MENU(creature->GetEntry(), creature->GetGUID());
+			}
+			break;
+		default:
+			break;
+		}
+
+		return true;
+	}
+
+	void AddMountList(Player* player, bool flymount)
+	{
+		uint32 len = MountVendorVec.size();
+
+		uint32 flycount = 0;
+		uint32 noflycount = 0;
+
+		for (size_t i = 0; i < len; i++)
+		{
+			SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(MountVendorVec[i].spellId);
+			if (!spellInfo)
+				continue;
+			if (player->HasSpell(spellInfo->Id))
+				continue;
+
+			if (flymount)
+			{
+				if (!IsFlyMount(MountVendorVec[i].spellId))
+					continue;
+
+				flycount++;
+
+				if (flycount < 32)
+					player->ADD_GOSSIP_ITEM(GOSSIP_ICON_VENDOR, spellInfo->SpellName[4], GOSSIP_SENDER_MAIN, MountVendorVec[i].spellId);
+			}
+			else
+			{
+				if (IsFlyMount(MountVendorVec[i].spellId))
+					continue;
+
+				noflycount++;
+
+				if (noflycount < 32)
+					player->ADD_GOSSIP_ITEM(GOSSIP_ICON_VENDOR, spellInfo->SpellName[4], GOSSIP_SENDER_MAIN, MountVendorVec[i].spellId);
+			}
+		}
+	}
+
+	bool OnSale(uint32 spellId)
+	{
+		uint32 len = MountVendorVec.size();
+
+		for (size_t i = 0; i < len; i++)
+		{
+			if (spellId == MountVendorVec[i].spellId)
+				return MountVendorVec[i].onSale;
+		}
+
+		return false;
+	}
+
+	bool IsFlyMount(uint32 spellId)
+	{
+		SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+		if (!spellInfo)
+			return false;
+
+		for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+			if (spellInfo->Effects[i].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED)
+				return true;
+
+		return false;
+	}	
+
+	uint32 GetReqId(uint32 spellId)
+	{
+		uint32 len = MountVendorVec.size();
+
+		for (size_t i = 0; i < len; i++)
+		{
+			if (spellId == MountVendorVec[i].spellId)
+				return MountVendorVec[i].reqId;
+		}
+
+		return 0;
+	}
+
+	std::string GetMountName(uint32 spellId)
+	{
+		SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+		if (!spellInfo)
+			return "";
+		return spellInfo->SpellName[4];
+	}
+
+	std::string GetMountDescription(uint32 spellId)
+	{
+		SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+		if (!spellInfo)
+			return "";
+
+		uint32 speed = 0;
+
+		for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+			if (spellInfo->Effects[i].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+				speed = spellInfo->Effects[i].BasePoints + 1;
+
+		for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+			if (spellInfo->Effects[i].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED)
+				speed = spellInfo->Effects[i].BasePoints + 1;
+		
+		std::ostringstream oss;
+		oss << "[|cFFFF1717" << spellInfo->SpellName[4] << "|r]";
+
+		if (IsFlyMount(spellId))
+			oss << " ·ÉÐÐ×øÆï£¬";
+		else
+			oss << " Â½µØ×øÆï£¬";
+
+		oss << "ÒÆ¶¯ËÙ¶ÈÌá¸ß|cFFFF1717" << speed << "|r%%¡£";
+
+		std::unordered_map<uint32, MountAllowedTemplate>::iterator iter = MountAllowedMap.find(spellInfo->Id);
+
+		if (iter != MountAllowedMap.end())
+		{
+			bool ban = false;
+
+			for (size_t i = 0; i < BAN_MAP_MAX; i++)
+			{
+				if (MapEntry const* mapEntry = sMapStore.LookupEntry(iter->second.BanMap[i]))
+				{
+					ban = true;
+					oss << "[|cFFFF1717" << mapEntry->name[4] << "|r]";
+				}
+			}
+					
+			if (!iter->second.indoor)
+			{
+				ban = true;
+				oss << "[" << "|cFFFF1717ÊÒÄÚ|r" << "]";
+			}
+			
+			if (!iter->second.instance)
+			{
+				ban = true;
+				oss << "[" << "|cFFFF1717¸±±¾|r" << "]";
+			}
+				
+
+			if (!iter->second.battleground)
+			{
+				ban = true;
+				oss << "[" << "|cFFFF1717Õ½³¡|r" << "]";
+			}
+
+			if (ban)
+				oss << "ÎÞ·¨Ê¹ÓÃÕâÖÖ×øÆï¡£";
+		}
+
+		return oss.str();
+	}
+};
+
+void AddSC_MountVendor()
+{
+	new MountVendorScript();
+}
diff --git a/src/server/scripts/Custom/MountVendor/MountVendor.h b/src/server/scripts/Custom/MountVendor/MountVendor.h
new file mode 100644
index 0000000..5156e57
--- /dev/null
+++ b/src/server/scripts/Custom/MountVendor/MountVendor.h
@@ -0,0 +1,27 @@
+#define MountTryTime 5
+
+struct MountVendorTemplate
+{
+	uint32 spellId;
+	bool onSale;
+	uint32 reqId;
+};
+
+extern std::vector<MountVendorTemplate> MountVendorVec;
+
+class MountVendor
+{
+public:
+	static MountVendor* instance()
+	{
+		static MountVendor instance;
+		return &instance;
+	}
+
+	void Load();
+	
+
+private:
+
+};
+#define sMountVendor MountVendor::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/NPC/NPC.cpp b/src/server/scripts/Custom/NPC/NPC.cpp
new file mode 100644
index 0000000..bfe44eb
--- /dev/null
+++ b/src/server/scripts/Custom/NPC/NPC.cpp
@@ -0,0 +1,281 @@
+#pragma execution_character_set("utf-8")
+#include "NPC.h"
+#include "../CustomEvent/Event.h"
+
+std::unordered_map<uint32/*entry*/, std::unordered_map<uint32/*index*/, StoryTemplate> > StoryMap;
+
+void Story::Load()
+{
+	StoryMap.clear();
+
+	//QueryResult result = WorldDatabase.PQuery("SELECT entry,id,action,param1,param2 FROM _npc");
+	//
+	//if (!result) 
+	//	return;
+	//do
+	//{
+	//	Field* fields = result->Fetch();
+	//	uint32 entry = fields[0].GetUInt32();
+	//	uint32 index = fields[1].GetUInt32();
+	//	const char*  s = fields[2].GetCString();
+	//
+	//	StoryAction action = STORY_ACTION_NONE;
+	//
+	//	if (strcmp("¿ªÊ¼", s) == 0)
+	//		action = STORY_ACTION_START;
+	//	else if (strcmp("ÒÆ¶¯", s) == 0)
+	//		action = STORY_ACTION_MOVE;
+	//	else if (strcmp("Ëµ»°", s) == 0)
+	//		action = STORY_ACTION_SAY;
+	//	else if (strcmp("´óº°", s) == 0)
+	//		action = STORY_ACTION_YELL;
+	//	else if (strcmp("±íÇé", s) == 0)
+	//		action = STORY_ACTION_EMOTE;
+	//	else if (strcmp("¼¼ÄÜ", s) == 0)
+	//		action = STORY_ACTION_SPELL;
+	//	else if (strcmp("½áÊø", s) == 0)
+	//		action = STORY_ACTION_END;
+	//
+	//	
+	//	std::string param1 = fields[3].GetString();
+	//	std::string param2 = fields[4].GetString();
+	//
+	//	//if (StoryMap.empty())
+	//	//{
+	//	//	std::unordered_map<uint32/*index*/, StoryTemplate> map;
+	//	//	
+	//	//	StoryTemplate Temp;
+	//	//	Temp.action = action;
+	//	//	Temp.param1 = param1;
+	//	//	Temp.param2 = param2;
+	//	//	map.insert(std::make_pair(index, Temp));
+	//	//
+	//	//	StoryMap.insert(std::make_pair(entry, map));
+	//	//}
+	//	//else
+	//	//{
+	//		std::unordered_map<uint32/*entry*/, std::unordered_map<uint32/*index*/, StoryTemplate> >::iterator itr = StoryMap.find(entry);
+	//
+	//		if (itr == StoryMap.end())
+	//		{
+	//			std::unordered_map<uint32/*index*/, StoryTemplate> map;
+	//
+	//			StoryTemplate Temp;
+	//			Temp.action = action;
+	//			Temp.param1 = param1;
+	//			Temp.param2 = param2;
+	//			map.insert(std::make_pair(index, Temp));
+	//
+	//			StoryMap.insert(std::make_pair(entry, map));
+	//		}
+	//		else
+	//		{
+	//
+	//			StoryTemplate Temp;
+	//			Temp.action = action;
+	//			Temp.param1 = param1;
+	//			Temp.param2 = param2;
+	//			itr->second.insert(std::make_pair(index, Temp));
+	//		}
+	//	//}
+	//
+	//
+	//} while (result->NextRow());
+}
+
+void Story::GetParams(uint32 entry, uint32 index, StoryAction &action, std::string &param1, std::string &param2)
+{
+	std::unordered_map<uint32/*entry*/, std::unordered_map<uint32/*index*/, StoryTemplate> >::iterator itr = StoryMap.find(entry);
+
+	if (itr != StoryMap.end())
+	{
+		std::unordered_map<uint32/*index*/, StoryTemplate>::iterator i = itr->second.find(index);
+
+		if (i != itr->second.end())
+		{
+			action = i->second.action;
+			param1 = i->second.param1;
+			param2 = i->second.param2;
+		}
+	}
+}
+
+class StoryNPC : public CreatureScript
+{
+public:
+	StoryNPC() : CreatureScript("StoryNPC") { }
+
+	bool OnGossipHello(Player* player, Creature* creature) override
+	{
+		player->PlayerTalkClass->ClearMenus();
+
+		StoryAction action = STORY_ACTION_NONE;
+		std::string param1 = "";
+		std::string param2 = "";
+		sStory->GetParams(creature->GetEntry(), 1, action, param1, param2);
+
+		std::string text = param1;
+		uint32 questId = atoi(param2.c_str());
+
+		Quest const* quest = sObjectMgr->GetQuestTemplate(questId);
+
+		if (!quest || quest && player->IsActiveQuest(questId))
+		{
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, text.c_str(), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
+			player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+			return true;
+		}
+			
+		player->CLOSE_GOSSIP_MENU();
+		return true;
+	}
+
+	bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action) override
+	{
+		player->CLOSE_GOSSIP_MENU();
+		creature->GetAI()->DoAction(1);
+		return true;
+	}
+
+	struct StoryNPCAI : public ScriptedAI
+	{
+		StoryNPCAI(Creature* creature) : ScriptedAI(creature), Summons(me){}
+		SummonList Summons;
+		EventMap events;
+		uint32 index = 1;
+		bool _start = false;
+		StoryAction action = STORY_ACTION_NONE;
+		std::string param1 = "";
+		std::string param2 = "";
+
+
+		void DoAction(int32 i)
+		{
+			if (i == 1)
+			{
+				_start = true;
+				me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
+				index++;
+				sStory->GetParams(me->GetEntry(), index, action, param1, param2);
+				events.ScheduleEvent(index, IN_MILLISECONDS);
+			}
+		}
+
+		void JustSummoned(Creature* summon) override
+		{
+			Summons.Summon(summon);
+		}
+
+		void Reset() override
+		{
+			_start = false;
+			index = 1;
+			action = STORY_ACTION_NONE;
+			param1 = "";
+			param2 = "";
+			Summons.DespawnAll();
+			me->GetMotionMaster()->MoveTargetedHome();
+			me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
+		}
+
+		void MoveInLineOfSight(Unit* who)
+		{
+		}
+
+		void SummonedCreatureDies(Creature* summon, Unit* killer)  override
+		{
+			
+		}
+
+		void UpdateAI(uint32 diff) override
+		{
+			if (!_start)
+				return;
+
+			events.Update(diff);
+			
+			if (uint32 eventid = events.ExecuteEvent())
+			{
+				switch (action)
+				{
+				case STORY_ACTION_MOVE:
+				{
+					uint32 posId = atoi(param1.c_str());
+
+					std::unordered_map<uint32, PosTemplate>::iterator it = PosMap.find(posId);
+
+					if (it != PosMap.end())
+						me->GetMotionMaster()->MoveCharge(it->second.x, it->second.y, it->second.z, 2.0);
+
+					index++;
+					sStory->GetParams(me->GetEntry(), index, action, param1, param2);
+					events.ScheduleEvent(index, IN_MILLISECONDS * atoi(param2.c_str()));
+				}
+					break;
+				case STORY_ACTION_SAY:
+					me->MonsterSay(param1.c_str(), LANG_UNIVERSAL, NULL);
+					index++;
+					sStory->GetParams(me->GetEntry(), index, action, param1, param2);
+					events.ScheduleEvent(index, IN_MILLISECONDS * atoi(param2.c_str()));
+					break;
+				case STORY_ACTION_YELL:
+					me->MonsterYell(param1.c_str(), LANG_UNIVERSAL, NULL);
+					index++;
+					sStory->GetParams(me->GetEntry(), index, action, param1, param2);
+					events.ScheduleEvent(index, IN_MILLISECONDS * atoi(param2.c_str()));
+					break;
+				case STORY_ACTION_EMOTE:
+					me->HandleEmoteCommand(atoi(param1.c_str()));
+					index++;
+					sStory->GetParams(me->GetEntry(), index, action, param1, param2);
+					events.ScheduleEvent(index, IN_MILLISECONDS * atoi(param2.c_str()));
+					break;
+				case STORY_ACTION_SPELL:
+				{
+					uint32 spellid = atoi(param1.c_str());
+					DoCast(spellid);
+					index++;
+					sStory->GetParams(me->GetEntry(), index, action, param1, param2);
+					events.ScheduleEvent(index, IN_MILLISECONDS * atoi(param2.c_str()));
+				}
+					break;
+				case STORY_ACTION_END:
+				{
+					uint32 questId = atoi(param1.c_str());
+
+					Quest const* quest = sObjectMgr->GetQuestTemplate(questId);
+
+					if (quest)
+					{
+						std::list<Player*> playersNearby;
+						me->GetPlayerListInGrid(playersNearby, 100.0f, true);
+
+						if (!playersNearby.empty())
+							for (std::list<Player*>::iterator iter = playersNearby.begin(); iter != playersNearby.end(); ++iter)
+							{
+								Player* player = *iter;
+
+								if (!player || !player->hasQuest(questId))
+									continue;
+								player->CompleteQuest(questId);
+							}
+					}
+
+					Reset();
+				}
+					return;
+				}
+			}
+		}
+	};
+
+	CreatureAI* GetAI(Creature* creature) const override
+	{
+		return new StoryNPCAI(creature);
+	}
+};
+
+void AddSC_StoryNPC()
+{
+	new StoryNPC();
+}
diff --git a/src/server/scripts/Custom/NPC/NPC.h b/src/server/scripts/Custom/NPC/NPC.h
new file mode 100644
index 0000000..e0afdae
--- /dev/null
+++ b/src/server/scripts/Custom/NPC/NPC.h
@@ -0,0 +1,35 @@
+enum StoryAction
+{
+	STORY_ACTION_NONE,
+	STORY_ACTION_START,
+	STORY_ACTION_MOVE,
+	STORY_ACTION_SAY,
+	STORY_ACTION_YELL,
+	STORY_ACTION_EMOTE,
+	STORY_ACTION_SPELL,
+	STORY_ACTION_END,
+};
+
+struct StoryTemplate
+{
+	StoryAction action;
+	std::string param1;
+	std::string param2;
+};
+
+extern std::unordered_map<uint32/*entry*/, std::unordered_map<uint32/*index*/, StoryTemplate> > StoryMap;
+
+class Story
+{
+public:
+	static Story* instance()
+	{
+		static Story instance;
+		return &instance;
+	}
+
+	void Load();
+
+	void GetParams(uint32 entry, uint32 index, StoryAction &action, std::string &param1, std::string &param2);
+};
+#define sStory Story::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Other/AutoJoinGuild.cpp b/src/server/scripts/Custom/Other/AutoJoinGuild.cpp
new file mode 100644
index 0000000..7c3f960
--- /dev/null
+++ b/src/server/scripts/Custom/Other/AutoJoinGuild.cpp
@@ -0,0 +1,43 @@
+#include "GuildMgr.h"
+#include "../Switch/Switch.h"
+
+class AutoJoinGuild : public PlayerScript
+{
+public:
+	AutoJoinGuild() : PlayerScript("AutoJoinGuild") {}
+	void OnLogin(Player* player)
+	{
+		if (!sSwitch->GetOnOff(ST_AUTO_JOIN_GUILD) || player->HasAtLoginFlag(AT_LOGIN_CHANGE_FACTION) || player->HasAtLoginFlag(AT_LOGIN_CHANGE_RACE)) 
+			return;
+
+		if (player->realTeam == TEAM_ALLIANCE)
+		{
+			uint32 AllyGuild = atoi(sSwitch->GetFlagByIndex(ST_AUTO_JOIN_GUILD, 1).c_str());
+
+			if (player->GetGuildId() != AllyGuild)
+			{
+				Guild* targetGuild = sGuildMgr->GetGuildById(AllyGuild);
+				if (!targetGuild)
+					return;
+				targetGuild->AddMember(player->GetGUID());
+			}
+		}else
+		{
+			uint32 HoderGuild = atoi(sSwitch->GetFlagByIndex(ST_AUTO_JOIN_GUILD, 2).c_str());
+
+			if (player->GetGuildId() != HoderGuild)
+			{
+				Guild* targetGuild = sGuildMgr->GetGuildById(HoderGuild);
+				if (!targetGuild)
+					return;
+				targetGuild->AddMember(player->GetGUID());
+			}
+		}
+	}
+};
+
+
+void AddSC_AutoJoinGuild()
+{
+	new AutoJoinGuild();
+}
diff --git a/src/server/scripts/Custom/Other/CFBG.cpp b/src/server/scripts/Custom/Other/CFBG.cpp
new file mode 100644
index 0000000..69f5b48
--- /dev/null
+++ b/src/server/scripts/Custom/Other/CFBG.cpp
@@ -0,0 +1,61 @@
+#include "CFBG.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../CustomEvent/FixedTimeBG/FixedTimeBG.h"
+
+void CFBG::SetFaction(Player* player)
+{
+	switch (player->getRace())
+	{
+	case 1:
+	case 3:
+	case 4:
+	case 7:
+	case 11:
+		player->setFactionForRace(RACE_ORC);
+	break;
+	case 2:
+	case 5:
+	case 6:
+	case 8:
+	case 10:
+		player->setFactionForRace(RACE_HUMAN);
+	break;
+	}
+}
+
+
+bool CFBG::SendCFBGChat(Player* player, uint32 msgtype, std::string message)
+{
+	float distance = msgtype == CHAT_MSG_SAY ? sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY) : sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_YELL);
+	if (Battleground* pBattleGround = player->GetBattleground())
+	{
+		if (pBattleGround->isArena())
+			return false;
+		
+		if(!sFTB->GetCFFlag(pBattleGround->GetBgTypeID()))
+			return false;
+
+		for (Battleground::BattlegroundPlayerMap::const_iterator itr = pBattleGround->GetPlayers().begin(); itr != pBattleGround->GetPlayers().end(); ++itr)
+		{
+			if (Player* pPlayer = ObjectAccessor::FindPlayer(itr->first))
+			{
+				if (player->GetDistance2d(pPlayer->GetPositionX(), pPlayer->GetPositionY()) <= distance)
+				{
+					WorldPacket data;
+					if (msgtype == CHAT_MSG_SAY || msgtype == CHAT_MSG_BATTLEGROUND || msgtype == CHAT_MSG_YELL)
+					{
+						if (pPlayer->GetTeamId() == player->GetTeamId())
+							ChatHandler::BuildChatPacket(data, CHAT_MSG_SAY, Language(LANG_UNIVERSAL), player, pPlayer, message);
+						else
+							ChatHandler::BuildChatPacket(data, CHAT_MSG_SAY, Language(LANG_TITAN), player, pPlayer, message);
+						pPlayer->GetSession()->SendPacket(&data);
+					}
+				}
+			}
+		}
+		return true;
+	}
+	else
+		return false;
+}
+
diff --git a/src/server/scripts/Custom/Other/CFBG.h b/src/server/scripts/Custom/Other/CFBG.h
new file mode 100644
index 0000000..d5e1e3d
--- /dev/null
+++ b/src/server/scripts/Custom/Other/CFBG.h
@@ -0,0 +1,19 @@
+#include "Player.h"
+#include "BattlegroundQueue.h"
+
+class CFBG
+{
+public:
+	static CFBG* instance()
+	{
+		static CFBG instance;
+		return &instance;
+	}
+	void SetFaction(Player* player);
+
+	bool SendCFBGChat(Player* player, uint32 msgtype, std::string message);
+
+private:
+	
+};
+#define sCFBG CFBG::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Other/CampAttack.cpp b/src/server/scripts/Custom/Other/CampAttack.cpp
new file mode 100644
index 0000000..51107ae
--- /dev/null
+++ b/src/server/scripts/Custom/Other/CampAttack.cpp
@@ -0,0 +1,211 @@
+#pragma execution_character_set("utf-8")
+#include "../PrecompiledHeaders/ScriptPCH.h"
+#include "../CommonFunc/CommonFunc.h"
+enum Events
+{
+	CALL_PORT	= 1,
+	FIRST_WAVE	= 2,
+	SECOND_WAVE	= 3,
+	THIRD_WAVE	= 4,
+	FOURTH_WAVE = 5,
+	CALL_GOB_PORT=6,
+	GROUND_SHAKE =7,
+	CALL_RAGNAROS =8,
+	CALL_FIREKING =9,
+};
+enum NPCS
+{
+	NPC_PORT = 960031,
+	NPC_FIRE_SON = 960032,
+	NPC_BLACK_IRON = 960033,
+	NPC_RAGNAROS = 960034,
+	NPC_FIRE_KING = 960035,
+};
+
+enum GOBS
+{
+	GOB_PORT = 186880,
+};
+static Position PortLocation[] =
+{
+	// ´«ËÍÃÅË¢ÐÂÎ»ÖÃ
+	{ -515.860f, 17.0702f, 49.6485f, 0 }, // 0
+	{ -503.188f, 4.16218f, 51.8489f, 0 }, // 1
+	{ -500.943f, 36.2931f, 50.6729f, 0 }, // 2
+	{ -525.468f, 27.8368f, 48.6491f, 0 }, // 3
+	{ -529.523f, -6.7841f, 53.2613f, 0 }, // 4
+};
+
+
+
+class camp_trigger : public CreatureScript
+{
+public:
+	camp_trigger() : CreatureScript("camp_trigger") { }
+
+	struct camp_triggerAI : public ScriptedAI
+	{
+		camp_triggerAI(Creature* creature) : ScriptedAI(creature), Summons(me){}
+		SummonList Summons;
+
+		void Reset() override
+		{
+			Summons.DespawnAll();
+			bool FirstWaveStared = false;
+			bool SecondWaveStared = false;
+		}
+
+		void JustSummoned(Creature* summoned) override
+		{
+			switch (summoned->GetEntry())
+			{
+			case NPC_PORT:
+				summoned->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+				summoned->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+				break;
+			case NPC_FIRE_SON:
+				//summoned->SetInCombatWithZone();
+				if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0))
+					summoned->AI()->AttackStart(target);
+				summoned->GetMotionMaster()->MoveRandom(20.0f);
+				break;
+			case NPC_BLACK_IRON:
+				if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0))
+					summoned->AI()->AttackStart(target);
+				summoned->GetMotionMaster()->MoveRandom(20.0f);
+				break;
+			case NPC_RAGNAROS:
+				summoned->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+				summoned->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+				summoned->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
+				break;
+			case NPC_FIRE_KING:
+				if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0))
+					summoned->AI()->AttackStart(target);
+				summoned->GetMotionMaster()->MoveRandom(20.0f);
+				break;
+			default:
+				break;
+			}
+
+			Summons.Summon(summoned);
+		}
+
+		void SummonedCreatureDespawn(Creature* summoned) override
+		{
+			Summons.Despawn(summoned);
+		}
+
+		void SummonedCreatureDies(Creature* summon, Unit*)
+		{
+			
+		}
+		void UpdateAI(uint32 diff) override
+		{
+			if (CampAttackStartFlag)
+			{
+				if (me->FindNearestCreature(NPC_FIRE_KING, 1000, true) || me->FindNearestCreature(NPC_FIRE_SON, 1000, true) || me->FindNearestCreature(NPC_BLACK_IRON, 1000, true))
+				{
+					CampAttackStartFlag = false;
+					return;
+				}
+				CampAttackStartFlag = false;
+				_events.ScheduleEvent(CALL_PORT, 1000);
+				sWorld->SendGlobalText("ÐÂ±øÓªµØÕýÔÚ±»¹¥»÷£¡", NULL);
+			}
+			_events.Update(diff);
+
+			while (uint32 eventId = _events.ExecuteEvent())
+			{
+						
+				switch (eventId)
+				{
+				case CALL_PORT:
+					for (uint32 i = 0; i < 5; i++)
+					{
+						me->SummonCreature(NPC_PORT, PortLocation[i], TEMPSUMMON_MANUAL_DESPAWN);
+					}
+					_events.ScheduleEvent(FIRST_WAVE, 5000);
+					_events.ScheduleEvent(FIRST_WAVE, 10000);
+
+					_events.ScheduleEvent(GROUND_SHAKE, 20000);
+
+					break;				
+				case FIRST_WAVE:
+					for (uint32 i = 0; i < 5; i++)
+					{
+						me->SummonCreature(NPC_FIRE_SON, PortLocation[i], TEMPSUMMON_TIMED_DESPAWN, 3 * 60000);
+						me->SummonCreature(NPC_FIRE_SON, PortLocation[i], TEMPSUMMON_TIMED_DESPAWN, 3 * 60000);
+					}
+					break;
+				case GROUND_SHAKE:
+				{
+					//É¾³ý´«ËÍÃÅ
+					std::list<Creature*> NPCPorts;
+					me->GetCreatureListWithEntryInGrid(NPCPorts, NPC_PORT, 300.0f);
+					if (!NPCPorts.empty())
+						for (std::list<Creature*>::iterator itr = NPCPorts.begin(); itr != NPCPorts.end(); ++itr)
+						{
+							if (*itr) (*itr)->RemoveFromWorld();
+						}
+					_events.ScheduleEvent(CALL_GOB_PORT, 4000);	
+				}				
+					break;
+				case CALL_GOB_PORT:
+				{
+
+					for (uint32 i = 0; i < 5; i++)
+					{
+						float x, y, z;
+						PortLocation[i].GetPosition(x, y, z);
+						if (GameObject* gob = me->SummonGameObject(GOB_PORT, x, y, z, 0, 0, 0, 0, 0, 0))
+							gob->Delete();
+
+					}
+					_events.ScheduleEvent(SECOND_WAVE, 5000);
+					_events.ScheduleEvent(CALL_RAGNAROS, 20000);
+				}
+				break;
+				case SECOND_WAVE:
+				{
+					for (uint32 i = 0; i < 5; i++)
+					{
+						me->SummonCreature(NPC_BLACK_IRON, PortLocation[i], TEMPSUMMON_TIMED_DESPAWN, 3*60000);
+						me->SummonCreature(NPC_BLACK_IRON, PortLocation[i], TEMPSUMMON_TIMED_DESPAWN, 3*60000);
+						me->SummonCreature(NPC_BLACK_IRON, PortLocation[i], TEMPSUMMON_TIMED_DESPAWN, 3*60000);
+					}
+				}
+					break;
+				case CALL_RAGNAROS:
+				{
+					Creature* ragnaros = me->SummonCreature(NPC_RAGNAROS, me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(),0, TEMPSUMMON_TIMED_DESPAWN, 15000);
+					if (ragnaros) ragnaros->MonsterYell("ÕâÀï½«ÉÕ³É»Ò½ý£¬É­Â¬¿Ï£¬Ö´ÐÐÎÒµÄÒâÖ¾£¡", LANG_UNIVERSAL, NULL);
+					_events.ScheduleEvent(CALL_FIREKING, 5000);
+				}		
+					break;
+				case CALL_FIREKING:
+				{
+					Creature* fireking = me->SummonCreature(NPC_FIRE_KING, me->m_positionX + 30, me->m_positionY, me->m_positionZ, 0, TEMPSUMMON_TIMED_DESPAWN, 5 * 60000);
+					if (fireking) fireking->MonsterYell("×ñÃü£¬Î°´óµÄÖ÷ÈË£¡", LANG_UNIVERSAL, NULL);
+
+				}
+					break;
+				default:
+					break;
+				}
+			}
+		}
+	private:
+		EventMap _events;
+	};
+	CreatureAI* GetAI(Creature* creature) const
+	{
+		return new camp_triggerAI(creature);
+	}
+};
+
+
+void AddSC_Camp_Attack()
+{
+	new camp_trigger();
+}
diff --git a/src/server/scripts/Custom/Other/FactionBossBattle.cpp b/src/server/scripts/Custom/Other/FactionBossBattle.cpp
new file mode 100644
index 0000000..1959755
--- /dev/null
+++ b/src/server/scripts/Custom/Other/FactionBossBattle.cpp
@@ -0,0 +1,202 @@
+#pragma execution_character_set("utf-8")
+#include "../PrecompiledHeaders/ScriptPCH.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../CustomEvent/Event.h"
+
+//LMÈý¸öBOSSµÄentry
+#define A_A_ENTRY 200000
+#define A_B_ENTRY 200001
+#define A_C_ENTRY 200002
+
+//BLÈý¸öBOSSµÄentry
+#define H_A_ENTRY 200003
+#define H_B_ENTRY 200004
+#define H_C_ENTRY 200005
+
+//ÊÂ¼þID
+#define FACTION_BOSS_BATTLE_EVENTID 100
+
+//»ñÈ¡½±ÀøËùÐèµÄÉËº¦ºÍÖÎÁÆ
+#define DAMAGE_FOR_REWARD 500000
+#define HEAL_FOR_REWARD 500000
+#define KILLS_FOR_REWARD 100
+#define KILLEDS_FOR_REWARD 100
+
+//½±ÀøµÄ±¦ÏäID
+#define FACTION_BOSS_BATTLE_CHESTID 200000
+
+//ÇëÌá¹©ÊÂ¼þ¿ªÊ¼Ê±LMºÍBL×ø±ê
+//ÇëÌá¹©ÊÂ¼þ½áÊøÊ±´«ËÍ×ø±ê
+
+
+
+class FactionBossTrigger : public CreatureScript
+{
+public:
+	FactionBossTrigger() : CreatureScript("FactionBossTrigger") { }
+
+	struct FactionBossTriggerAI : public ScriptedAI
+	{
+		FactionBossTriggerAI(Creature* creature) : ScriptedAI(creature), Summons(me){}
+		SummonList Summons;
+
+		void InitializeAI() override
+		{
+			me->SummonCreatureGroup(1);
+		}
+
+		void Reset() override
+		{
+			Summons.DespawnAll();
+		}
+
+		void JustSummoned(Creature* summoned) override
+		{
+			Summons.Summon(summoned);
+			switch (summoned->GetEntry())
+			{
+			case A_A_ENTRY:
+			case H_A_ENTRY:
+				break;
+			case A_B_ENTRY:
+			case H_B_ENTRY:
+			case A_C_ENTRY:
+			case H_C_ENTRY:
+				//summoned->SetReactState(REACT_PASSIVE);
+				//summoned->SetVisible(false);
+				//summoned->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
+				break;
+			default:
+				break;
+			}
+		}
+
+		void SummonedCreatureDespawn(Creature* summoned) override
+		{
+			Summons.Despawn(summoned);
+		}
+
+		void SummonedCreatureDies(Creature* summon, Unit* killer)
+		{
+			switch (summon->GetEntry())
+			{
+			case A_A_ENTRY:
+				SetCreatureActive(A_B_ENTRY);
+				break;
+			case H_A_ENTRY:
+				SetCreatureActive(H_B_ENTRY);
+				break;
+			case A_B_ENTRY:
+				SetCreatureActive(A_C_ENTRY);
+				break;
+			case H_B_ENTRY:
+				SetCreatureActive(H_C_ENTRY);
+				break;
+			case A_C_ENTRY:
+			case H_C_ENTRY:
+				RewardWinTeam(killer);
+				if (sGameEventMgr->IsActiveEvent(FACTION_BOSS_BATTLE_EVENTID))
+					sGameEventMgr->StopEvent(FACTION_BOSS_BATTLE_EVENTID,true);
+			default:
+				break;
+			}
+		}
+		void UpdateAI(uint32 diff) override
+		{
+		
+			
+		}
+
+		void JustDied(Unit* /*killer*/){}
+
+
+		void SetCreatureActive(uint32 entry)
+		{
+			if (Creature* creature = GetClosestCreatureWithEntry(me, entry, 200))
+			{
+				creature->SetReactState(REACT_AGGRESSIVE);
+				creature->SetVisible(true);
+				creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
+			}
+		}
+
+		void RewardWinTeam(Unit* killer)
+		{
+			Summons.DespawnAll();
+
+			Player * player;
+
+			if (killer->GetTypeId() == TYPEID_PLAYER)
+				player = killer->ToPlayer();
+			else if (killer->GetOwner()->GetTypeId() == TYPEID_PLAYER)
+				player = killer->GetOwner()->ToPlayer();
+
+			if (player)
+			{
+				SessionMap const& smap = sWorld->GetAllSessions();
+				for (SessionMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+					if (Player* pl = iter->second->GetPlayer())
+						if (pl->GetSession())
+						{
+					
+								if (pl->GetTeamId() != player->GetTeamId())
+									continue;
+
+								pl->AddItem(FACTION_BOSS_BATTLE_CHESTID, 1);
+						}
+			}
+		}
+
+	private:
+		EventMap _events;
+	};
+	CreatureAI* GetAI(Creature* creature) const
+	{
+		return new FactionBossTriggerAI(creature);
+	}
+};
+
+
+
+class FactionBossPlayerScript : public PlayerScript
+{
+public:
+	FactionBossPlayerScript() : PlayerScript("FactionBossPlayerScript") {}
+	void OnCreatureKill(Player* killer, Creature* killed) 
+	{
+		if (!sGameEventMgr->IsActiveEvent(FACTION_BOSS_BATTLE_EVENTID) && (killed->GetEntry() != 200000 || killed->GetEntry() != 200001))
+			return;	
+
+		Player * player = killed->GetLootRecipient();
+
+		if (!player)
+			return;	
+		
+		/*
+		if (killer->GetTypeId() == TYPEID_PLAYER)
+			player = killer->ToPlayer();
+		else if (killer->GetOwner()->GetTypeId() == TYPEID_PLAYER)
+			player = killer->GetOwner()->ToPlayer();
+			*/
+		
+		SessionMap const& smap = sWorld->GetAllSessions();
+		for (SessionMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+			if (Player* pl = iter->second->GetPlayer())
+				if (pl->GetSession())
+				{
+					
+						if (pl->GetTeamId() != player->GetTeamId())
+							continue;
+						pl->AddItem(FACTION_BOSS_BATTLE_CHESTID, 1);							
+				}
+
+		sGameEventMgr->StopEvent(FACTION_BOSS_BATTLE_EVENTID, true);
+		sWorld->SendServerMessage(SERVER_MSG_STRING, "ÄÏº£ÕòÕ½ÒÛ½áÊø£¡");
+	}
+};
+
+void AddSC_FactionBOSS_BATTLE()
+{
+	//new FactionBossTrigger();
+	//new FactionBossPlayerScript();
+}
diff --git a/src/server/scripts/Custom/Other/Fountain.cpp b/src/server/scripts/Custom/Other/Fountain.cpp
new file mode 100644
index 0000000..ff8afbd
--- /dev/null
+++ b/src/server/scripts/Custom/Other/Fountain.cpp
@@ -0,0 +1,81 @@
+#define FountainSpellId 92000
+
+class Fountain : public CreatureScript
+{
+public:
+	Fountain() : CreatureScript("Fountain") { }
+	struct FountainAI : public ScriptedAI
+	{
+		FountainAI(Creature* creature) : ScriptedAI(creature), Summons(me)
+		{
+			me->AddAura(FountainSpellId, me);
+		}
+		SummonList Summons;
+		
+		void Reset() override
+		{
+			me->AddAura(FountainSpellId, me);
+		}
+	};
+
+	CreatureAI* GetAI(Creature* creature) const override
+	{
+		return new FountainAI(creature);
+	}
+};
+
+
+class spell_fountain : public SpellScriptLoader
+{
+public:
+	spell_fountain() : SpellScriptLoader("spell_fountain") { }
+
+	class spell_fountain_AuraScript : public AuraScript
+	{
+		PrepareAuraScript(spell_fountain_AuraScript);
+
+		bool CheckAreaTarget(Unit* target)
+		{
+			if (target->GetTypeId() == TYPEID_PLAYER)
+			{
+				if (target->ToPlayer()->duel || !GetCaster()->IsWithinDistInMap(target, 3.0f))
+					return false;
+
+				if (GetCaster()->GetEntry() == 50102 && target->ToPlayer()->GetTeamId() == TEAM_ALLIANCE || GetCaster()->GetEntry() == 50103 && target->ToPlayer()->GetTeamId() == TEAM_HORDE)
+					return true;
+			}
+
+			return false;
+		}
+		void Register()
+		{
+			DoCheckAreaTarget += AuraCheckAreaTargetFn(spell_fountain_AuraScript::CheckAreaTarget);
+		}
+	};
+
+	AuraScript* GetAuraScript() const
+	{
+		return new spell_fountain_AuraScript();
+	}
+};
+
+
+class FountainPlayerScript : public PlayerScript
+{
+public:
+	FountainPlayerScript() : PlayerScript("FountainPlayerScript") {}
+
+	void OnUpdateZone(Player* player, uint32 /*newZone*/, uint32 /*newArea*/) override
+	{
+		if (player->HasAura(FountainSpellId))
+			player->RemoveAura(FountainSpellId);
+	}
+
+};
+
+void AddSC_Fountain()
+{
+	new spell_fountain();
+	new Fountain();
+	new FountainPlayerScript();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Other/JJC.cpp b/src/server/scripts/Custom/Other/JJC.cpp
new file mode 100644
index 0000000..ccbdb6c
--- /dev/null
+++ b/src/server/scripts/Custom/Other/JJC.cpp
@@ -0,0 +1,354 @@
+/*
+The Zxtreme - Dev Core
+*/
+#pragma execution_character_set("utf-8")
+#include <cstring>
+#include <string.h>
+#include "ObjectMgr.h"
+#include "ScriptMgr.h"
+#include "ArenaTeam.h"
+#include "ArenaTeamMgr.h"
+#include "World.h"
+
+enum enus
+{
+    ARENA_MAX_RESULTS = 10,
+    ARENA_2V2_LADDER = GOSSIP_ACTION_INFO_DEF + 1,
+    ARENA_3V3_LADDER = GOSSIP_ACTION_INFO_DEF + 2,
+    ARENA_5V5_LADDER = GOSSIP_ACTION_INFO_DEF + 3,
+    ARENA_GOODBYE = GOSSIP_ACTION_INFO_DEF + 4,
+    ARENA_START_TEAM_LOOKUP = GOSSIP_ACTION_INFO_DEF + 5,
+    ARENA_HELP = GOSSIP_ACTION_INFO_DEF + 9999,
+};
+
+class arena_top_teams : public CreatureScript
+{
+    private:
+    uint32 optionToTeamType(uint32 option) 
+    {
+        uint32 teamType;
+        switch(option)
+        {
+            case ARENA_2V2_LADDER: 
+                teamType = 2;
+            break;
+                    
+            case ARENA_3V3_LADDER:
+                teamType = 3; 
+            break;
+                
+            case ARENA_5V5_LADDER:
+                teamType = 1; 
+            break;
+        }
+        return teamType;
+    }
+        
+    uint32 teamTypeToOption(uint32 teamType) 
+    {
+        uint32 option;
+        switch(teamType) 
+        {
+            case 2: 
+                option = ARENA_2V2_LADDER; 
+            break;
+                    
+            case 3: 
+                option = ARENA_3V3_LADDER; 
+            break;
+                    
+            case 5: 
+                option = ARENA_5V5_LADDER; 
+            break;
+        }
+        return option;
+    }
+        
+    std::string raceToString(uint8 race) 
+    {
+        std::string race_s = "Unknown";
+        switch (race)
+        {
+            case RACE_HUMAN:            
+                race_s = "ÈËÀà";       
+            break;
+                
+            case RACE_ORC:              
+                race_s = "ÊÞÈË";         
+            break;
+                
+            case RACE_DWARF:           
+                race_s = "°«ÈË";       
+            break;
+                
+            case RACE_NIGHTELF:         
+                race_s = "°µÒ¹¾«Áé";   
+            break;
+                
+            case RACE_UNDEAD_PLAYER:   
+                race_s = "ÍöÁé";      
+            break;
+                
+            case RACE_TAUREN:          
+                race_s = "Å£Í·ÈË";      
+            break;
+                
+            case RACE_GNOME:            
+                race_s = "Gnome";       
+            break;
+                
+            case RACE_TROLL:            
+                race_s = "¾ÞÄ§";       
+            break;
+                
+            case RACE_BLOODELF:         
+                race_s = "Ñª¾«Áé";   
+            break;
+                
+            case RACE_DRAENEI:          
+                race_s = "µÂÀ³Äá";     
+            break;
+        }
+        return race_s;
+    }
+        
+    std::string classToString(uint8 Class) 
+    {
+        std::string Class_s = "Unknown";
+        switch (Class)
+        {
+            case CLASS_WARRIOR:         
+                Class_s = "Õ½Ê¿";        
+            break;
+                
+            case CLASS_PALADIN:        
+                Class_s = "Ê¥ÆïÊ¿";       
+            break;
+                
+            case CLASS_HUNTER:         
+                Class_s = "ÁÔÈË";        
+            break;
+                
+            case CLASS_ROGUE:          
+                Class_s = "µÁÔô";          
+            break;
+                
+            case CLASS_PRIEST:
+                Class_s = "ÄÁÊ¦";
+            break;
+                
+            case CLASS_DEATH_KNIGHT:
+                Class_s = "ËÀÍöÆïÊ¿";
+            break;
+                
+            case CLASS_SHAMAN: 
+                Class_s = "ÈøÂú";       
+            break;
+                
+            case CLASS_MAGE: 
+                Class_s = "·¨Ê¦";          
+            break;
+                
+            case CLASS_WARLOCK: 
+                Class_s = "ÊõÊ¿";       
+            break;
+                
+            case CLASS_DRUID:          
+                Class_s = "µÂÂ³ÒÁ";          
+            break;
+        }
+        return Class_s;
+    }
+        
+    std::string getWinPercent(uint32 wins, uint32 losses)
+    {
+        uint32 totalGames = wins + losses;
+        if (totalGames == 0)
+            return "0%";
+            
+        std::stringstream buf;
+        uint32 percentage = (wins * 100) / totalGames;
+        buf << percentage << "%";
+        return buf.str();
+    }
+
+    public:
+        arena_top_teams() : CreatureScript("arena_top_teams"){}
+        
+    bool OnGossipHello(Player *player, Creature *creature)
+    {
+        player->ADD_GOSSIP_ITEM(4,"|cff00ff00|TInterface\\icons\\spell_chargepositive:26|t|r ¾º¼¼³¡ÅÅÃû?", GOSSIP_SENDER_MAIN, ARENA_HELP);
+        player->ADD_GOSSIP_ITEM(4,"|cff00ff00|TInterface\\icons\\Achievement_Arena_2v2_7:26|t|r ¾º¼¼³¡2v2", GOSSIP_SENDER_MAIN, ARENA_2V2_LADDER);
+        player->ADD_GOSSIP_ITEM(4,"|cff00ff00|TInterface\\icons\\Achievement_Arena_3v3_7:26|t|r ¾º¼¼³¡3v3", GOSSIP_SENDER_MAIN, ARENA_3V3_LADDER);
+        player->ADD_GOSSIP_ITEM(4,"|cff00ff00|TInterface\\icons\\Achievement_Arena_5v5_7:26|t|r ¾º¼¼³¡1v1", GOSSIP_SENDER_MAIN, ARENA_5V5_LADDER);
+        player->ADD_GOSSIP_ITEM(4,"|cff00ff00|TInterface\\icons\\spell_chargenegative:26|t|r ·µ»Ø", GOSSIP_SENDER_MAIN, ARENA_GOODBYE);
+        player->SEND_GOSSIP_MENU(90085, creature->GetGUID());
+        return true;
+    }
+        
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 /*uiSender*/, uint32 uiAction) 
+    {
+        player->PlayerTalkClass->ClearMenus();
+        switch(uiAction) 
+        {
+            case ARENA_GOODBYE:
+            {
+                player->PlayerTalkClass->SendCloseGossip();
+                break;
+            }
+
+            case ARENA_HELP:
+            {
+				ChatHandler(player->GetSession()).PSendSysMessage("|cffff6060[Information]:|r Õâ¸öNPCÏÔÊ¾·þÎñÆ÷µÄ½Ç¶·Ê¿ (Top 10).¼òµ¥µÄµã»÷ÍÅ¶ÓÃû³ÆºÍ¿´µ½ÍÅ¶ÓÏ¸½Ú");
+																		  
+				break;
+
+			}
+
+			case ARENA_2V2_LADDER:
+			case ARENA_5V5_LADDER:
+			case ARENA_3V3_LADDER:
+            {
+                uint32 teamType = optionToTeamType(uiAction);
+                QueryResult result = CharacterDatabase.PQuery("SELECT arenaTeamId, name, rating FROM arena_team WHERE type = '%u' ORDER BY rating DESC LIMIT %u;", teamType, ARENA_MAX_RESULTS);
+                    
+                if(!result) 
+                {
+                    player->ADD_GOSSIP_ITEM(7, "·µ»Ø", GOSSIP_SENDER_MAIN, ARENA_GOODBYE);
+                    player->SEND_GOSSIP_MENU(1, creature->GetGUID());
+                } 
+                else
+                {
+                    std::string name;
+                    uint32 teamId, rating, rank = 1;
+                    player->ADD_GOSSIP_ITEM(0,"¶¥¼¶¾º¼¼³¡Ãûµ¥ - ½Ç¶·Ê¿:", GOSSIP_SENDER_MAIN, ARENA_GOODBYE);
+                    do 
+                    {
+                        Field *fields = result->Fetch();
+                        teamId = fields[0].GetUInt32();
+                        name = fields[1].GetString();
+                        rating = fields[2].GetUInt32();
+                            
+                        std::stringstream buffer;
+                        buffer << rank << ". " << name;
+                        buffer << ": " << "|cFF1E90FF" << rating << "|r" << " ÆÀ¼¶!";
+                        player->ADD_GOSSIP_ITEM(4, buffer.str(), GOSSIP_SENDER_MAIN, ARENA_START_TEAM_LOOKUP + teamId);
+                            
+                        rank++;
+                    } 
+                    while(result->NextRow());
+                    player->ADD_GOSSIP_ITEM(7, "·µ»Ø", GOSSIP_SENDER_MAIN, ARENA_GOODBYE);
+                    player->SEND_GOSSIP_MENU(90086, creature->GetGUID());
+                }
+                break;
+            }
+            
+            default:
+            {
+                if (uiAction > ARENA_START_TEAM_LOOKUP) 
+                {
+                    uint32 teamId = uiAction - ARENA_START_TEAM_LOOKUP;
+					QueryResult result = CharacterDatabase.PQuery("SELECT name, rating, seasonWins, seasonGames - seasonWins, weekWins, weekGames - weekWins, rank, captainGuid , type FROM arena_team WHERE arenaTeamId = '%u'", teamId);
+                        
+                    if(!result) 
+                    {
+                        player->GetSession()->SendNotification("¾º¼¼³¡¶ÓÎ´ÕÒµ½...");
+                        player->PlayerTalkClass->SendCloseGossip();
+                        return true;
+                    }
+                        
+                    Field *fields = result->Fetch();
+                    std::string name = fields[0].GetString();
+                    uint32 rating = fields[1].GetUInt32();
+                    uint32 seasonWins = fields[2].GetUInt32();
+                    uint32 seasonLosses = fields[3].GetUInt32();
+                    uint32 weekWins = fields[4].GetUInt32();
+                    uint32 weekLosses = fields[5].GetUInt32();
+                    uint32 rank = fields[6].GetUInt32();
+                    uint32 captainGuid = fields[7].GetUInt32();
+                    uint32 type = fields[8].GetUInt32();
+                    uint32 parentOption = teamTypeToOption(type);
+                        
+                    std::string seasonWinPercentage = getWinPercent(seasonWins, seasonLosses);
+                    std::string weekWinPercentage = getWinPercent(weekWins, weekLosses);
+                        
+                    std::stringstream buf;
+                    buf << "Õ½¶ÓÃû×Ö: " << "|cFF1E90FF" << name << "|r";
+                    player->ADD_GOSSIP_ITEM(7, buf.str(), GOSSIP_SENDER_MAIN, parentOption);
+                    buf.str("");
+                    
+                    buf << "µÈ¼¶: " << "|cFF1E90FF" << rating << "|r" << " (ÅÅÃû: " << "|cFF1E90FF" << rank << "|r" << ", Type: " << "|cFF1E90FF" << type << "v" << type << "|r"")";
+                    player->ADD_GOSSIP_ITEM(4, buf.str(), GOSSIP_SENDER_MAIN, parentOption);
+                    buf.str("");
+                    
+                    buf << "±¾ÖÜ: " << "|cFF1E90FF" << weekWins << "-" << weekLosses << "|r"" (" << "|cFF1E90FF" << weekWinPercentage << "|r" << "win)"; 
+                    player->ADD_GOSSIP_ITEM(4, buf.str(), GOSSIP_SENDER_MAIN, parentOption);
+                    buf.str("");
+                    
+                    buf << "È«Èü¼¾: " << "|cFF1E90FF" << seasonWins << "-" << seasonLosses << "|r" << " (" << "|cFF1E90FF" << seasonWinPercentage << "|r" << " win)"; 
+                    player->ADD_GOSSIP_ITEM(4, buf.str(), GOSSIP_SENDER_MAIN, parentOption);
+                        
+                    QueryResult members = CharacterDatabase.PQuery("SELECT  a.guid, a.personalRating, a.weekWins, a.weekGames - a.weekWins, a.seasonWins, a.seasonGames - a.seasonWins, c.name, c.race, c.class, c.level FROM arena_team_member a LEFT JOIN characters c ON c.guid = a.guid WHERE arenaTeamId = '%u' ORDER BY a.guid = '%u' DESC, a.seasonGames DESC, c.name ASC", teamId, captainGuid);
+                    if(!members) 
+                    {
+                        player->ADD_GOSSIP_ITEM(7, "Ã»ÓÐ·¢ÏÖÍÅ¶Ó³ÉÔ±¡­£¿", GOSSIP_SENDER_MAIN, parentOption);
+                    } 
+                    else 
+                    {
+                        uint32 memberPos = 1;
+                        uint32 memberCount = members->GetRowCount();
+                        uint32 guid, personalRating, level;
+                        std::string name, race, Class;
+                            
+                        buf.str("");
+                        buf << "      --- " << memberCount << " ÍÅ¶Ó" << ((memberCount == 1) ? " ³ÉÔ±" : " ³ÉÔ±") << " ·¢ÏÖ" << " ---";
+                        player->ADD_GOSSIP_ITEM(0, buf.str(), GOSSIP_SENDER_MAIN, parentOption);
+                        do 
+                        {
+                            fields = members->Fetch();
+                            guid = fields[0].GetUInt32();
+                            personalRating = fields[1].GetUInt32();
+                            weekWins= fields[2].GetUInt32();
+                            weekLosses = fields[3].GetUInt32();
+                            seasonWins = fields[4].GetUInt32();
+                            seasonLosses = fields[5].GetUInt32();
+                            name = fields[6].GetString();
+                            race = raceToString(fields[7].GetUInt8());
+                            Class = classToString(fields[8].GetUInt8());
+                            level = fields[9].GetUInt32();
+                                
+                            seasonWinPercentage = getWinPercent(seasonWins, seasonLosses);
+                            weekWinPercentage = getWinPercent(weekWins, weekLosses);
+                                
+                            buf.str(""); 
+                            buf << memberPos << ". "; 
+                            if (guid == captainGuid) 
+                                buf <<  "¶Ó ¶Ó³¤ ";
+                                
+                            
+                            buf << race << " " << Class << ", " << "|cFF1E90FF" << personalRating << "|r" << " ¸öÈËµÈ¼¶!";
+                            player->ADD_GOSSIP_ITEM(4, buf.str(), GOSSIP_SENDER_MAIN, parentOption);
+                            buf.str("");
+                            
+                            buf << "Ê¤Àû: " << "|cFF1E90FF" << weekWins << "-" << weekLosses << "|r" << " (" << "|cFF1E90FF" << weekWinPercentage << "|r" << " Ê¤Àû), " << "|cFF1E90FF" << (weekWins + weekLosses) << "|r" << " played!"; 
+                            player->ADD_GOSSIP_ITEM(4, buf.str(), GOSSIP_SENDER_MAIN, parentOption);
+                            buf.str("");
+                            
+                            buf << "Èü¼¾: " << "|cFF1E90FF" << seasonWins << "-" << seasonLosses << "|r" << " (" << "|cFF1E90FF" << seasonWinPercentage << "|r" << " Ê¤Àû), " << "|cFF1E90FF" << (seasonWins + seasonLosses) << "|r" << " played!"; 
+                            player->ADD_GOSSIP_ITEM(4, buf.str(), GOSSIP_SENDER_MAIN, parentOption);
+                            memberPos++;
+                        } 
+                        while(members->NextRow());
+                    }
+                    player->SEND_GOSSIP_MENU(90087, creature->GetGUID());
+                }
+            }
+        }
+        return true;
+    }
+};
+
+void AddSC_arena_top_teams()
+{
+    new arena_top_teams();
+}
diff --git a/src/server/scripts/Custom/Other/OnLogin.cpp b/src/server/scripts/Custom/Other/OnLogin.cpp
new file mode 100644
index 0000000..50cc09a
--- /dev/null
+++ b/src/server/scripts/Custom/Other/OnLogin.cpp
@@ -0,0 +1,108 @@
+#pragma execution_character_set("utf-8")
+#include "../AuthCheck/AuthCheck.h"
+#include "../DataLoader/DataLoader.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../Switch/Switch.h"
+#include "../Command/CustomCommand.h"
+#include "../GCAddon/GCAddon.h"
+#include "../LuckDraw/LuckDraw.h"
+
+class WhenLogin : PlayerScript
+{
+public:
+	WhenLogin() : PlayerScript("WhenLogin") {}
+
+	void OnLogin(Player* player)
+	{
+		player->SetUnderACKmount();
+
+		////¸üÐÂ¾üÏÎ
+		if (sSwitch->GetOnOff(ST_HR_ACCOUNT_BIND))
+			sCF->updateHRTitle(player);
+		
+		//ÉèÖÃÍæ¼ÒµôÂÊ
+		sCF->SetLootRate(player);
+
+		//¼ì²âÍæ¼ÒÔÚÏßÊýÁ¿£¬³¬¹ýÏÞÖÆ£¬Ìßµô
+		if (!sCF->onlineIsAllowed(player))
+			player->GetSession()->KickPlayer();
+
+		//Í³Ò»RELIC
+		if (sSwitch->GetOnOff(ST_SAME_RELIC))
+		{
+			if (player->getClass() == CLASS_PALADIN || player->getClass() == CLASS_DRUID || player->getClass() == CLASS_SHAMAN || player->getClass() == CLASS_DEATH_KNIGHT)
+			{
+				//Ä§Ó¡
+				if (!player->HasSpell(52665))
+					player->learnSpell(52665);
+				//Ê¥Îï
+				if (!player->HasSpell(27762))
+					player->learnSpell(27762);
+				//Í¼ÌÚ
+				if (!player->HasSpell(27763))
+					player->learnSpell(27763);
+				//ÉñÏñ
+				if (!player->HasSpell(27764))
+					player->learnSpell(27764);
+			}	
+		}
+		else
+		{
+			if (player->getClass() == CLASS_PALADIN || player->getClass() == CLASS_DRUID || player->getClass() == CLASS_SHAMAN || player->getClass() == CLASS_DEATH_KNIGHT)
+			{
+				//Ä§Ó¡
+				if (!player->HasSpell(52665))
+					player->removeSpell(52665, SPEC_MASK_ALL, true);
+				//Ê¥Îï
+				if (!player->HasSpell(27762))
+					player->removeSpell(27762, SPEC_MASK_ALL, true);
+				//Í¼ÌÚ
+				if (!player->HasSpell(27763))
+					player->removeSpell(27763, SPEC_MASK_ALL, true);
+				//ÉñÏñ
+				if (!player->HasSpell(27764))
+					player->removeSpell(27764, SPEC_MASK_ALL, true);
+			}
+		}
+
+		//player->LootCheckLoad();
+	}
+};
+
+class LootCheck : PlayerScript
+{
+public:
+	LootCheck() : PlayerScript("LootCheck") {}
+
+	void OnLogin(Player* player)
+	{
+		player->LootCheckLoad();
+	}
+
+	void OnLogout(Player* player)
+	{
+		player->LootCheckSave();
+	}
+
+	void OnGossipSelectCode(Player* player, uint32 menu_id, uint32 sender, uint32 /*action*/, const char* code) override
+	{
+		if (menu_id != 7878)
+			return;
+
+		if (sender == atoi(code))
+		{
+			player->LootCheckReset();
+			player->GetSession()->SendAreaTriggerMessage("[Ê°È¡ÑéÖ¤]¹§Ï²Äã£¬ÑéÖ¤Í¨¹ý£¡");
+			ChatHandler(player->GetSession()).PSendSysMessage("[Ê°È¡ÑéÖ¤]¹§Ï²Äã£¬ÑéÖ¤Í¨¹ý£¡");
+			player->ModifyMoney(sWorld->getIntConfig(CONFIG_LOOTCHECK_MONEY));
+		}
+		else
+			player->LootCheckPop(sWorld->getIntConfig(CONFIG_LOOTCHECK_SECONDS) - player->LootCheckTimer / IN_MILLISECONDS);
+	}
+};
+
+void AddSC_WhenLogin()
+{
+	new WhenLogin();
+	new LootCheck();
+}
diff --git a/src/server/scripts/Custom/Other/Test.cpp b/src/server/scripts/Custom/Other/Test.cpp
new file mode 100644
index 0000000..7c567dd
--- /dev/null
+++ b/src/server/scripts/Custom/Other/Test.cpp
@@ -0,0 +1,256 @@
+#pragma execution_character_set("utf-8")
+#include "../AuthCheck/AuthCheck.h"
+#include "../Switch/Switch.h"
+#include "../LeaderReward/LeaderReward.h"
+#include <fstream>
+#include <windows.h>
+#include "../QuickResponse/QuickResponse.h"
+#include "../Command/CustomCommand.h"
+#include "../Armory/Armory.h"
+#include "../SignIn/SignIn.h"
+#include "../GCAddon/GCAddon.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../ItemSet/ItemSet.h"
+#include "../CustomEvent/Event.h"
+#include "../Rank/Rank.h"
+#include "AccountMgr.h"
+#include "../Faker/Faker.h"
+#include "../Scripts/CustomScripts.h"
+#include "../ItemMod/ItemMod.h"
+#include "DBCStore.h"
+#include "DBCStores.h"
+#include "../PvP/PvP.h"
+#include "../AntiFarm/AntiFarm.h"
+#include "../Talisman/Talisman.h"
+#include "../ItemMod/NoPatchItem.h"
+#include "../Quest/QuestMod.h"
+#include "MapManager.h"
+#include "../EquipmentManager/EquipmentManager.h"
+#include "../CustomEvent/BattleIC/BattleIC.h"
+#include "../UnitMod/CharMod/CharMod.h"
+#include "Group.h"
+#include "../Recruit/Recruit.h"
+#include "LootItemStorage.h"
+#include "../AesEncryptor/aes_encryptor.h"
+#include <tchar.h>
+#include "../Requirement/Requirement.h"
+#include "../LuckDraw/LuckDraw.h"
+#include "../Reward/Reward.h"
+#include "../../../../authserver/Server/TOTP.h"
+#include "../MapMod/MapMod.h"
+
+void EncodeString(LPCTSTR lpszText, LPTSTR *lpszReturn, LPCTSTR lpszKey)
+{
+	int nTextLen = 0;
+	char *cPos = NULL;
+	char *pDest = NULL;
+	if (lpszReturn)    // ¼ÓÃÜ
+	{
+		nTextLen = ::_tcslen(lpszText);
+		pDest = new char[nTextLen + 3];    // ==\0
+	}
+	else    // ½âÃÜ
+	{
+		// ²éÕÒ×Ô¶¨µÄÖÐÖ¹±ê¼Ç
+		cPos = (LPTSTR)lpszText;
+		while (true)    // ´ÓÕâÀï¿ÉÒÔ¿´µ½£¬³ý·ÇËÑË÷µ½ÎÒÃÇ×Ô¶¨µÄÖÐÖ¹±ê¼Ç£¬·ñÔò»áÒ»Ö±ËÑË÷ÏÂÈ¥
+		{
+			if (*cPos == '=')
+				if (cPos[1] == '=')
+					if (cPos[2] == '\0')
+						break;
+			cPos++;
+		}
+		if (!cPos)    // Ã»ÓÐÕÒµ½½áÊø±ê¼Ç£¬Ò²²»ÊÇ¼ÓÃÜ
+			return;
+		nTextLen = cPos - lpszText;
+		pDest = (LPTSTR)lpszText;
+	}
+
+	int nKeyLen = ::_tcslen(lpszKey);
+	int i = 0;
+	int k = 0;
+	int t = nTextLen;
+	int cn = 0;
+	for (int a = 0; a < nKeyLen; a++)    // ½«ÃÜÔ¿ËùÓÐÖµ¼ÓÆðÀ´
+		cn += lpszKey[a];
+
+	for (; i < nTextLen; i++)
+	{
+		if (lpszReturn)    // ¼ÓÃÜ
+		{
+			pDest[i] = lpszText[i] + t;
+			pDest[i] = pDest[i] ^ lpszKey[k];
+			pDest[i] = pDest[i] ^ cn;
+		}
+		else    // ½âÃÜ£¬Ë³ÐòÓë¼ÓÃÜÊ±Ïà·´
+		{
+			pDest[i] = lpszText[i] ^ cn;
+			pDest[i] = pDest[i] ^ lpszKey[k];
+			pDest[i] = pDest[i] - t;
+		}
+		k++;
+		t--;
+		if (k >= nKeyLen)
+			k = 0;
+		if (t <= 0)
+			t = nTextLen;
+	}
+
+	if (!cPos)
+	{
+		memcpy(pDest + nTextLen, _T("==\0"), 3 * sizeof(TCHAR));
+		*lpszReturn = pDest;
+	}
+	else
+		memset(pDest + nTextLen, _T('\0'), sizeof(TCHAR));
+}
+
+
+uint32 cal(uint32 x)
+{
+	uint32 count = 0;
+
+	for (size_t i = 1; i < x + 1; i++)
+	{
+		count += i;
+	}
+
+	return count;
+}
+
+uint32 HL(uint16 h, uint16 l){ return (uint32)((h << 16) | (l & 0xFFFF)); }
+uint32 H(uint32 HL){ return (uint32)(HL & 0xFFFF); }
+uint32 L(uint32 HL){ return (uint32)(HL >> 16); }
+
+
+
+
+class TestCommand : public CommandScript
+{
+public:
+	TestCommand() : CommandScript("TestCommand") { }
+
+	static void Line()
+	{
+		printf("\n");
+		printf("\n");
+	}
+
+    std::vector<ChatCommand> GetCommands() const
+	{
+		static std::vector<ChatCommand> TestCommandTable =
+		{
+			{ "t", SEC_CONSOLE, true, &HandleTestCommand, "" },
+			{ "t1", SEC_CONSOLE, true, &HandleTest1Command, "" },
+			{ "t2", SEC_CONSOLE, true, &HandleTest2Command, "" },
+			{ "t3", SEC_CONSOLE, true, &HandleTest3Command, "" }
+		};
+
+		return TestCommandTable;
+	}
+	/* 1 + ... + x*/
+
+
+	static bool HandleTestCommand(ChatHandler* handler, const char* args)
+	{
+		uint32 i = uint32(atol(args));
+		Player* player = handler->GetSession()->GetPlayer();
+
+		switch (i)
+		{
+		case 1:
+		{
+
+		}
+		break;
+		case 2:
+		{
+
+		}
+		break;
+		case 3:
+		{
+
+		}
+		break;
+		case 4:
+		{
+
+		}
+		break;
+		default:
+			break;
+		}
+
+		return true;
+	}
+
+	static bool HandleTest1Command(ChatHandler* handler, const char* args)
+	{
+		uint32 i = uint32(atol(args));
+
+		Player* player = handler->GetSession()->GetPlayer();
+
+		for (auto itr = FakerSessions.begin(); itr != FakerSessions.end(); itr++)
+		{
+			WorldSession * s = *itr;
+			if (s && s->GetPlayer() && s->GetPlayer()->IsInWorld())
+			{
+				WorldPacket* const packet = new WorldPacket(CMSG_BATTLEMASTER_JOIN, 8 + 4 + 4 + 1);
+				*packet << uint64(0);
+				*packet << uint32(BATTLEGROUND_WS);
+				*packet << uint32(0);
+				*packet << uint8(0);
+				s->QueuePacket(packet);
+			}
+		}
+
+		return true;
+	}
+
+	static bool HandleTest2Command(ChatHandler* handler, const char* args)
+	{
+		uint32 i = uint32(atol(args));
+
+		Player* player = handler->GetSession()->GetPlayer();
+
+
+		return true;
+	}
+
+	static bool HandleTest3Command(ChatHandler* handler, const char* args)
+	{
+
+		uint32 i = uint32(atol(args));
+
+		Player* player = handler->GetSession()->GetPlayer();
+
+		if (Player* target = player->GetSelectedPlayer())
+		{
+			if (!target->IsFaker)
+				return true;
+
+			for (auto itr = FakerSessions.begin(); itr != FakerSessions.end();)
+				if ((*itr)->GetPlayer()->GetGUID() == target->GetGUID())
+					itr = FakerSessions.erase(itr);
+				else
+					itr++;
+
+			if (WorldSession * s = target->GetSession())
+			{
+				s->LogoutPlayer(true);
+				delete s;
+			}
+		}
+
+		
+
+		return true;
+	}
+};
+
+void AddSC_Test_Command()
+{
+	new TestCommand();
+}
diff --git a/src/server/scripts/Custom/Other/TimeReward.cpp b/src/server/scripts/Custom/Other/TimeReward.cpp
new file mode 100644
index 0000000..f8c1adb
--- /dev/null
+++ b/src/server/scripts/Custom/Other/TimeReward.cpp
@@ -0,0 +1,18 @@
+#include "../Switch/Switch.h"
+#include "../VIP/VIP.h"
+
+class TimeReward : PlayerScript
+{
+public:
+	TimeReward() : PlayerScript("TimeReward") {}
+	void OnLogin(Player* player) override
+	{
+		uint32 timeRewId  = sVIP->GetTimeRewId(player);
+		player->timeRewId = (timeRewId == 0 ? atoi(sSwitch->GetFlagByIndex(ST_TIME_REW, 1).c_str()) : timeRewId);
+	}
+};
+
+void AddSC_Time_Reward()
+{
+	new TimeReward();
+}
diff --git a/src/server/scripts/Custom/Other/TrainerNPC.cpp b/src/server/scripts/Custom/Other/TrainerNPC.cpp
new file mode 100644
index 0000000..f2d800a
--- /dev/null
+++ b/src/server/scripts/Custom/Other/TrainerNPC.cpp
@@ -0,0 +1,256 @@
+#pragma execution_character_set("utf-8")
+#include "../PrecompiledHeaders/ScriptPCH.h"
+
+const uint32 PALADIN = 5492;
+const uint32 WARRIOR = 914;
+const uint32 PRIEST = 5484;
+const uint32 MAGE = 331;
+const uint32 DRUID = 5504;
+const uint32 DEATH_KNIGHT = 29196;
+const uint32 HUNTER = 5516;
+const uint32 ROGUE = 918;
+const uint32 SHAMAN = 20407;
+const uint32 WARLOCK = 5496;
+
+class TRAINER_NPC : public CreatureScript
+{
+public:
+	TRAINER_NPC() : CreatureScript("TRAINER_NPC") { }
+	bool OnGossipHello(Player* player, Creature* creature) override
+	{
+		player->PlayerTalkClass->ClearMenus();
+		switch (player->getClass())
+		{
+		case CLASS_WARRIOR:
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Ability_Warrior_SavageBlow:30:30:0:0|tÖ°Òµ", GOSSIP_SENDER_MAIN + 1, GOSSIP_ACTION_INFO_DEF);
+			break;
+		case CLASS_PALADIN:
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Spell_Holy_AuraOfLight:30:30:0:0|tÖ°Òµ", GOSSIP_SENDER_MAIN + 1, GOSSIP_ACTION_INFO_DEF);
+			break;
+		case CLASS_HUNTER:
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Ability_Hunter_ChimeraShot2:30:30:0:0|tÖ°Òµ", GOSSIP_SENDER_MAIN + 1, GOSSIP_ACTION_INFO_DEF);
+			break;
+		case CLASS_ROGUE:
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Ability_Rogue_DeadlyBrew:30:30:0:0|tÖ°Òµ", GOSSIP_SENDER_MAIN + 1, GOSSIP_ACTION_INFO_DEF);
+			break;
+		case CLASS_PRIEST:
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Spell_Holy_Heal:30:30:0:0|tÖ°Òµ", GOSSIP_SENDER_MAIN + 1, GOSSIP_ACTION_INFO_DEF);
+			break;
+		case CLASS_DEATH_KNIGHT:
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Spell_Shadow_DeadofNight:30:30:0:0|tÖ°Òµ", GOSSIP_SENDER_MAIN + 1, GOSSIP_ACTION_INFO_DEF);
+			break;
+		case CLASS_SHAMAN:
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Ability_Shaman_Stormstrike:30:30:0:0|tÖ°Òµ", GOSSIP_SENDER_MAIN + 1, GOSSIP_ACTION_INFO_DEF);
+			break;
+		case CLASS_MAGE:
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Spell_Frost_IceStorm:30:30:0:0|tÖ°Òµ", GOSSIP_SENDER_MAIN + 1, GOSSIP_ACTION_INFO_DEF);
+			break;
+		case CLASS_WARLOCK:
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Ability_Warlock_DemonicPower:30:30:0:0|tÖ°Òµ", GOSSIP_SENDER_MAIN + 1, GOSSIP_ACTION_INFO_DEF);
+			break;
+		case CLASS_DRUID:
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Ability_Druid_Bash:30:30:0:0|tÖ°Òµ", GOSSIP_SENDER_MAIN + 1, GOSSIP_ACTION_INFO_DEF);
+			break;
+		default:
+			break;
+		}
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Ability_DualWield:30:30:0:0|tÎäÆ÷", GOSSIP_SENDER_MAIN + 4, GOSSIP_ACTION_INFO_DEF);
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/INV_Misc_Coin_06:30:30:0:0|tÉÌÒµ", GOSSIP_SENDER_MAIN + 2, GOSSIP_ACTION_INFO_DEF);
+		player->GetTeamId() == TEAM_ALLIANCE ? player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Ability_Mount_Gryphon_01:30:30:0:0|tÆïÊõ", GOSSIP_SENDER_MAIN + 3, GOSSIP_ACTION_INFO_DEF) : player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Ability_Mount_Wyvern_01:30:30:0:0|tÆïÊõ", GOSSIP_SENDER_MAIN + 3, GOSSIP_ACTION_INFO_DEF);
+		if (!player->HasSpell(63624))
+			player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Spell_Shadow_Charm:30:30:0:0|tÌì¸³", GOSSIP_SENDER_MAIN + 5, GOSSIP_ACTION_INFO_DEF, "È·¶¨ÒªÑ§Ï°Ë«Ìì¸³Âð£¿", 1000 * GOLD, false);
+		player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Achievement_BG_winWSG:30:30:0:0|tÖØÖÃÌì¸³", GOSSIP_SENDER_MAIN + 6, GOSSIP_ACTION_INFO_DEF, "È·¶¨ÒªÖØÖÃÌì¸³Âð£¿", 50 * GOLD, false);
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+		return true;
+	}
+
+	bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action) override
+	{
+		player->PlayerTalkClass->ClearMenus();
+
+		if (sender == GOSSIP_SENDER_MAIN + 100 && action == GOSSIP_ACTION_INFO_DEF + 100)
+		{
+			OnGossipHello(player, creature);
+			return true;
+		}
+
+		switch (sender)
+		{
+		case GOSSIP_SENDER_MAIN + 1:
+		{
+			switch (player->getClass())
+			{
+			case CLASS_WARRIOR:
+				player->GetSession()->SendTrainerList(creature->GetGUID(), WARRIOR);
+				player->NpcTrainerId = WARRIOR;
+				player->CLOSE_GOSSIP_MENU();
+				break;
+			case CLASS_PALADIN:
+				player->GetSession()->SendTrainerList(creature->GetGUID(), PALADIN);
+				player->NpcTrainerId = PALADIN;
+				player->CLOSE_GOSSIP_MENU();
+				break;
+			case CLASS_HUNTER:
+				player->GetSession()->SendTrainerList(creature->GetGUID(), HUNTER);
+				player->NpcTrainerId = HUNTER;
+				player->CLOSE_GOSSIP_MENU();
+				break;
+			case CLASS_ROGUE:
+				player->GetSession()->SendTrainerList(creature->GetGUID(), ROGUE);
+				player->NpcTrainerId = ROGUE;
+				player->CLOSE_GOSSIP_MENU();
+				break;
+			case CLASS_PRIEST:
+				player->GetSession()->SendTrainerList(creature->GetGUID(), PRIEST);
+				player->NpcTrainerId = PRIEST;
+				player->CLOSE_GOSSIP_MENU();
+				break;
+			case CLASS_DEATH_KNIGHT:
+				player->GetSession()->SendTrainerList(creature->GetGUID(), DEATH_KNIGHT);
+				player->NpcTrainerId = DEATH_KNIGHT;
+				player->CLOSE_GOSSIP_MENU();
+				break;
+			case CLASS_SHAMAN:
+				player->GetSession()->SendTrainerList(creature->GetGUID(), SHAMAN);
+				player->NpcTrainerId = SHAMAN;
+				player->CLOSE_GOSSIP_MENU();
+				break;
+			case CLASS_MAGE:
+				player->GetSession()->SendTrainerList(creature->GetGUID(), MAGE);
+				player->NpcTrainerId = MAGE;
+				player->CLOSE_GOSSIP_MENU();
+				break;
+			case CLASS_WARLOCK:
+				player->GetSession()->SendTrainerList(creature->GetGUID(), WARLOCK);
+				player->NpcTrainerId = WARLOCK;
+				player->CLOSE_GOSSIP_MENU();
+				break;
+			case CLASS_DRUID:
+				player->GetSession()->SendTrainerList(creature->GetGUID(), DRUID);
+				player->NpcTrainerId = DRUID;
+				player->CLOSE_GOSSIP_MENU();
+				break;
+			default:
+				break;
+			}
+		}
+		break;
+		case GOSSIP_SENDER_MAIN + 2:
+		{
+			//player->GetSession()->SendTrainerList(creature->GetGUID(), 28698);
+			//player->NpcTrainerId = 28698;
+			//break;
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Trade_Alchemy:30:30:0:0|tÁ¶½ð", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Trade_BlackSmithing:30:30:0:0|t¶ÍÔì", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 2);
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Trade_Engraving:30:30:0:0|t¸½Ä§", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 3);
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Trade_Engineering:30:30:0:0|t¹¤³Ì", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 4);
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Trade_Herbalism:30:30:0:0|t²ÝÒ©", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 5);
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/INV_Inscription_Tradeskill01:30:30:0:0|tÃúÎÄ", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 6);
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/INV_Jewelcrafting_DragonsEye02:30:30:0:0|tÖé±¦", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 7);
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Trade_LeatherWorking:30:30:0:0|tÖÆÆ¤", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 8);
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Trade_Mining:30:30:0:0|t²É¿ó", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 9);
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/INV_Misc_LeatherScrap_10:30:30:0:0|t°þÆ¤", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 10);
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Trade_Tailoring:30:30:0:0|t²Ã·ì", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 11);
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/INV_Misc_Food_64:30:30:0:0|tÅëâ¿", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 12);
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Spell_Holy_SealOfSacrifice:30:30:0:0|t¼±¾È", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 13);
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/Trade_Fishing:30:30:0:0|tµöÓã", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 14);
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "|TInterface/ICONS/misc_arrowleft:30:30:0:0|t·µ»Ø", GOSSIP_SENDER_MAIN + 100, GOSSIP_ACTION_INFO_DEF + 100);
+			player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+		}
+		break;
+		case GOSSIP_SENDER_MAIN + 3:
+			player->GetSession()->SendTrainerList(creature->GetGUID(), 31238);
+			player->NpcTrainerId = 31238;
+			break;
+		case GOSSIP_SENDER_MAIN + 4:
+			player->GetSession()->SendTrainerList(creature->GetGUID(), 11867);
+			player->NpcTrainerId = 11867;
+			break;
+		case GOSSIP_SENDER_MAIN + 5:
+			player->ModifyMoney(-1000 * GOLD);
+			player->CastSpell(player, 63680, true, NULL, NULL, player->GetGUID());
+			player->CastSpell(player, 63624, true, NULL, NULL, player->GetGUID());
+			player->learnSpell(63624);
+			player->CastSpell(player, 63707);
+			ChatHandler(player->GetSession()).PSendSysMessage("ÄãÑ§»áÁËË«Ìì¸³");
+			player->CLOSE_GOSSIP_MENU();
+			break;
+		case GOSSIP_SENDER_MAIN + 6:
+			player->resetTalents(true);
+			player->SendTalentsInfoData(false);
+			player->GetSession()->SendAreaTriggerMessage("ÒÑÖØÖÃ½ÇÉ«Ìì¸³");
+			player->ModifyMoney(-50 * GOLD);
+			player->CLOSE_GOSSIP_MENU();
+			break;
+		default:
+			break;
+		}
+		switch (action)
+		{
+		case GOSSIP_ACTION_INFO_DEF + 1:
+			player->GetSession()->SendTrainerList(creature->GetGUID(), 33630);
+			player->NpcTrainerId = 33630;
+			break;
+		case GOSSIP_ACTION_INFO_DEF + 2:
+			player->GetSession()->SendTrainerList(creature->GetGUID(), 28694);
+			player->NpcTrainerId = 28694;
+			break;
+		case GOSSIP_ACTION_INFO_DEF + 3:
+			player->GetSession()->SendTrainerList(creature->GetGUID(), 33633);
+			player->NpcTrainerId = 33633;
+			break;
+		case GOSSIP_ACTION_INFO_DEF + 4:
+			player->GetSession()->SendTrainerList(creature->GetGUID(), 28697);
+			player->NpcTrainerId = 28697;
+			break;
+		case GOSSIP_ACTION_INFO_DEF + 5:
+			player->GetSession()->SendTrainerList(creature->GetGUID(), 28704);
+			player->NpcTrainerId = 28704;
+			break;
+		case GOSSIP_ACTION_INFO_DEF + 6:
+			player->GetSession()->SendTrainerList(creature->GetGUID(), 28702);
+			player->NpcTrainerId = 28702;
+			break;
+		case GOSSIP_ACTION_INFO_DEF + 7:
+			player->GetSession()->SendTrainerList(creature->GetGUID(), 28701);
+			player->NpcTrainerId = 28701;
+			break;
+		case GOSSIP_ACTION_INFO_DEF + 8:
+			player->GetSession()->SendTrainerList(creature->GetGUID(), 28700);
+			player->NpcTrainerId = 28700;
+			break;
+		case GOSSIP_ACTION_INFO_DEF + 9:
+			player->GetSession()->SendTrainerList(creature->GetGUID(), 28698);
+			player->NpcTrainerId = 28698;
+			break;
+		case GOSSIP_ACTION_INFO_DEF + 10:
+			player->GetSession()->SendTrainerList(creature->GetGUID(), 28696);
+			player->NpcTrainerId = 28696;
+			break;
+		case GOSSIP_ACTION_INFO_DEF + 11:
+			player->GetSession()->SendTrainerList(creature->GetGUID(), 28699);
+			player->NpcTrainerId = 28699;
+			break;
+		case GOSSIP_ACTION_INFO_DEF + 12:
+			player->GetSession()->SendTrainerList(creature->GetGUID(), 28705);
+			player->NpcTrainerId = 28705;
+			break;
+		case GOSSIP_ACTION_INFO_DEF + 13:
+			player->GetSession()->SendTrainerList(creature->GetGUID(), 28706);
+			player->NpcTrainerId = 28706;
+			break;
+		case GOSSIP_ACTION_INFO_DEF + 14:
+			player->GetSession()->SendTrainerList(creature->GetGUID(), 28742);
+			player->NpcTrainerId = 28742;
+			break;
+		default:
+			break;
+		}
+		return true;
+	}
+};
+
+void AddSC_TRAINER_NPC()
+{
+	new TRAINER_NPC();
+}
diff --git a/src/server/scripts/Custom/Other/WorldRank.cpp b/src/server/scripts/Custom/Other/WorldRank.cpp
new file mode 100644
index 0000000..a71102d
--- /dev/null
+++ b/src/server/scripts/Custom/Other/WorldRank.cpp
@@ -0,0 +1,40 @@
+#pragma execution_character_set("utf-8")
+#include "../PrecompiledHeaders/ScriptPCH.h"
+
+class WorldRank_NPC : public CreatureScript
+{
+public:
+	WorldRank_NPC() : CreatureScript("WorldRank_NPC") { }
+	struct WorldRank_NPCAI : public ScriptedAI
+	{
+		WorldRank_NPCAI(Creature* creature) : ScriptedAI(creature), Summons(me){}
+
+		SummonList Summons;
+		uint32 Timer = 0;
+
+		void UpdateAI(uint32 diff) override
+		{
+			Timer += diff;
+			if (Timer > 1000)
+			{
+				Timer = 0;
+				SetPlayerGossipFlag();
+			}
+		}
+
+		void SetPlayerGossipFlag()
+		{
+			
+		}
+	};
+
+	CreatureAI* GetAI(Creature* creature) const override
+	{
+		return new WorldRank_NPCAI(creature);
+	}
+};
+
+void AddSC_WorldRank_NPC()
+{
+	new WorldRank_NPC();
+}
diff --git a/src/server/scripts/Custom/Other/World_chat.cpp b/src/server/scripts/Custom/Other/World_chat.cpp
new file mode 100644
index 0000000..4309f99
--- /dev/null
+++ b/src/server/scripts/Custom/Other/World_chat.cpp
@@ -0,0 +1,199 @@
+#pragma execution_character_set("utf-8")
+#include "../CommonFunc/CommonFunc.h"
+#include "../DataLoader/DataLoader.h"
+#include "../Requirement/Requirement.h"
+#include "../Switch/Switch.h"
+#include "../String/myString.h"
+#include "../VIP/VIP.h"
+
+class World_Chat : public CommandScript
+{
+public:
+	World_Chat() : CommandScript("World_Chat") { }
+
+	static bool HandleWorldChatCommand(ChatHandler * pChat, const char * msg)
+	{
+		if (!*msg)
+			return true;
+
+		Player * player = pChat->GetSession()->GetPlayer();
+
+		if (!player)
+			return true;
+
+		int32 value = sSwitch->GetValue(ST_WORLD_CHAT);
+
+		//-1 ÎÞÏÞÖÆ 0 ¹Ø±Õ >0 ÏûºÄ <-1 ÀäÈ´Ê±¼ä
+
+
+		if (value == 0)
+		{
+			player->GetSession()->SendNotification("ÊÀ½çÁÄÌì¹¦ÄÜÎ´¿ªÆô!");
+			return true;
+		}
+		
+		if (value > 0)
+		{
+			if (!sReq->Check(player, value))
+				return true;
+
+			sReq->Des(player, value);
+		}
+		
+		if (value < -1)
+		{
+			if (player->canWorldChat)
+			{
+				player->worldChatTimer = value * IN_MILLISECONDS;
+				player->canWorldChat = false;
+			}else
+			{
+				uint32 cd = abs(player->worldChatTimer) / IN_MILLISECONDS;
+
+				std::ostringstream oss;
+				oss << "ÊÀ½çÁÄÌì½«ÔÚ" << cd << "sºóÀäÈ´£¡";
+				player->GetSession()->SendNotification(oss.str().c_str());
+				return true;
+			}
+		}
+	
+		const char*  text = sString->Format(sString->GetText(CORE_STR_TYPES(STR_WORLD_CHAT)), sCF->GetPlayerTotalName(player, sSwitch->GetFlag(ST_WORLD_CHAT)).c_str(), msg);
+		sWorld->SendServerMessage(SERVER_MSG_STRING, text);
+		return true;
+	}
+
+	static bool HandleFactionChatCommand(ChatHandler * pChat, const char * msg)
+	{
+		if (!*msg)
+			return true;
+
+		Player * player = pChat->GetSession()->GetPlayer();
+
+		if (!player)
+			return true;
+
+		int32 value = sSwitch->GetValue(ST_FACTION_CHAT);
+
+		//-1 ÎÞÏÞÖÆ 0 ¹Ø±Õ >0 ÏûºÄ <-1 ÀäÈ´Ê±¼ä
+
+
+		if (value == 0)
+		{
+			player->GetSession()->SendNotification("ÕóÓªÁÄÌì¹¦ÄÜÎ´¿ªÆô!");
+			return true;
+		}
+
+		if (value > 0)
+		{
+			if (!sReq->Check(player, value))
+				return true;
+
+			sReq->Des(player, value);
+		}
+
+		if (value < -1)
+		{
+			if (player->canFactionChat)
+			{
+				player->factionChatTimer = value * IN_MILLISECONDS;
+				player->canFactionChat = false;
+			}
+			else
+			{
+				uint32 cd = abs(player->factionChatTimer) / IN_MILLISECONDS;
+
+				std::ostringstream oss;
+				oss << "ÕóÓªÁÄÌì½«ÔÚ" << cd << "sºóÀäÈ´£¡";
+				player->GetSession()->SendNotification(oss.str().c_str());
+				return true;
+			}
+		}
+
+
+		const char*  text = sString->Format(sString->GetText(CORE_STR_TYPES(STR_FACTION_CHAT)), sCF->GetPlayerTotalName(player, sSwitch->GetFlag(ST_FACTION_CHAT)).c_str(), msg);
+		sWorld->SendFactionMessage(SERVER_MSG_STRING, text, player->GetTeamId());
+		return true;
+	}
+
+	static bool HandleCustomFactionChatCommand(ChatHandler * pChat, const char * msg)
+	{
+		if (!*msg)
+			return true;
+
+		Player * player = pChat->GetSession()->GetPlayer();
+
+		if (!player)
+			return true;
+		
+		if (!player->faction)
+		{
+			ChatHandler(player->GetSession()).PSendSysMessage("Äã»¹Ã»ÓÐ¼ÓÈëÈÎºÎÃÅÅÉ£¡");
+			return true;
+		}
+
+		const char*  text = sString->Format(sString->GetText(CORE_STR_TYPES(STR_CUSTOM_FACTION_CHAT)), sCF->GetPlayerTotalName(player, sSwitch->GetFlag(ST_WORLD_CHAT)).c_str(), msg);
+
+		WorldPacket data(SMSG_SERVER_MESSAGE, 50);
+		data << uint32(SERVER_MSG_STRING);
+		data << text;
+
+		for (SessionMap::const_iterator itr = sWorld->GetAllSessions().begin(); itr != sWorld->GetAllSessions().end(); ++itr)
+		{
+			if (itr->second &&
+				itr->second->GetPlayer() &&
+				itr->second->GetPlayer()->IsInWorld() &&
+				itr->second->GetPlayer()->faction == player->faction)
+			{
+				itr->second->SendPacket(&data);
+			}
+		}
+		return true;
+	}
+
+    std::vector<ChatCommand> GetCommands() const
+	{
+		static std::vector<ChatCommand> WorldChatCommandTable =
+		{
+			{ "s", SEC_PLAYER, true, &HandleWorldChatCommand, "" },
+			{ "z", SEC_PLAYER, true, &HandleFactionChatCommand, "" },
+			{ "m", SEC_PLAYER, true, &HandleCustomFactionChatCommand, "" }
+		};
+
+		return WorldChatCommandTable;
+	}
+};
+
+class LoginAnnounce : PlayerScript
+{
+public:
+	LoginAnnounce() : PlayerScript("LoginAnnounce") {}
+	void OnLogin(Player* player) override
+	{
+		if (!sSwitch->GetOnOff(ST_LOG_IN))
+			return;
+		std::string text = sString->Format(sString->GetText(CORE_STR_TYPES(STR_LOGIN)), sCF->GetPlayerTotalName(player, sSwitch->GetFlag(ST_LOG_IN)).c_str());
+		sWorld->SendGlobalText(text.c_str(), NULL);
+	}
+
+    void OnFirstLogin(Player* player) override
+    {
+        std::string text = sString->Format(sString->GetText(CORE_STR_TYPES(STR_LOGIN)), sCF->GetPlayerTotalName(player, sSwitch->GetFlag(ST_LOG_IN)).c_str());
+        player->GetTeamId() == TEAM_ALLIANCE ? text = text + "\n" + (std::string)sString->Format(sString->GetText(CORE_STR_TYPES(STR_LOGIN_A)), sCF->GetPlayerTotalName(player, sSwitch->GetFlag(ST_LOG_IN)).c_str()) : text = text + "\n" + (std::string)sString->Format(sString->GetText(CORE_STR_TYPES(STR_LOGIN_H)), sCF->GetPlayerTotalName(player, sSwitch->GetFlag(ST_LOG_IN)).c_str());
+    }
+
+	void OnLogout(Player* player) override
+	{
+		if (!sSwitch->GetOnOff(ST_LOG_OUT))
+			return;
+
+		std::string text = sString->Format(sString->GetText(CORE_STR_TYPES(STR_LOGOUT)), sCF->GetPlayerTotalName(player, sSwitch->GetFlag(ST_LOG_OUT)).c_str());
+
+		sWorld->SendGlobalText(text.c_str(), NULL);
+	}
+};
+
+void AddSC_cs_world_chat()
+{
+	new World_Chat();
+	new LoginAnnounce();
+}
diff --git a/src/server/scripts/Custom/Other/killstreak.cpp b/src/server/scripts/Custom/Other/killstreak.cpp
new file mode 100644
index 0000000..ebbb357
--- /dev/null
+++ b/src/server/scripts/Custom/Other/killstreak.cpp
@@ -0,0 +1,201 @@
+#pragma execution_character_set("utf-8")
+#include "../PrecompiledHeaders/ScriptPCH.h"
+#include "../DataLoader/DataLoader.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../Reward/Reward.h"
+#include "../String/myString.h"
+#include "../Switch/Switch.h"
+#include "../Talisman/Talisman.h"
+#include "../PvP/PvP.h"
+
+
+//announceFlag		//0 - ²»ÌáÊ¾   1 - Á¬É±ÌáÊ¾		2 - ÖÕ½áÁ¬É±ÌáÊ¾		3 - ¶¼ÌáÊ¾
+//rewFlag			//0 - Ò°Íâ     1 - Õ½³¡			2 - Ò°ÍâºÍÕ½³¡
+//endRewFlag		//0 - Ò°Íâ     1 - Õ½³¡			2 - Ò°ÍâºÍÕ½³¡
+
+const int32 KillerStreak1 = 1;
+const int32 KillerStreak2 = 2;
+const int32 KillerStreak3 = 3;
+const int32 KillerStreak4 = 4;
+const int32 KillerStreak5 = 5;
+const int32 KillerStreak6 = 6;
+const int32 KillerStreak7 = 7;
+const int32 KillerStreak8 = 8;
+const int32 KillerStreak9 = 9;
+const int32 KillerStreak10 = 10;
+
+struct SystemInfo
+{
+	uint64 KillStreak;
+	uint64 LastGUIDKill;
+};
+
+static std::map<uint32, SystemInfo> KillingStreak;
+
+class System_OnPVPKill : public PlayerScript
+{
+public:
+	System_OnPVPKill() : PlayerScript("System_OnPVPKill") {}
+
+	void GetRewAndNotice(uint32 num, uint32 &rewId, uint32 &endRewId, uint32 &announceFlag, uint32 &rewFlag, uint32 &endRewFlag)
+	{
+		std::unordered_map<uint32, KillerStreakTemplate>::iterator iter = KillerStreakMap.find(num);
+		if (iter != KillerStreakMap.end())
+		{
+			rewId = iter->second.rewId;
+			endRewId = iter->second.endRewId;
+			announceFlag = iter->second.announceFlag;
+			rewFlag = iter->second.rewFlag;
+			endRewFlag = iter->second.endRewFlag;
+		}
+	}
+
+	void KillAnnounceAndRew(Player* pKiller, Player* pVictim, uint32 num)
+	{
+		uint32 rewId = 0;
+		uint32 endRewId = 0;
+		uint32 announceFlag = 0;
+		uint32 rewFlag = 0;
+		uint32 endRewFlag = 0;
+		GetRewAndNotice(num, rewId, endRewId, announceFlag,rewFlag,endRewFlag);
+
+		CORE_STR_TYPES type = STR_NONE;
+
+		switch (num)
+		{
+		case KillerStreak1:	type = STR_KILL_STREAK_1;	break;
+		case KillerStreak2:	type = STR_KILL_STREAK_2;	break;
+		case KillerStreak3:	type = STR_KILL_STREAK_3;	break;
+		case KillerStreak4:	type = STR_KILL_STREAK_4;	break;
+		case KillerStreak5:	type = STR_KILL_STREAK_5;	break;
+		case KillerStreak6:	type = STR_KILL_STREAK_6;	break;
+		case KillerStreak7:	type = STR_KILL_STREAK_7;	break;
+		case KillerStreak8:	type = STR_KILL_STREAK_8;	break;
+		case KillerStreak9:	type = STR_KILL_STREAK_9;	break;
+		case KillerStreak10:type = STR_KILL_STREAK_10; break;
+		default:
+			type = STR_NONE;
+		}
+
+		if (AreaTableEntry const* areaEntry = GetAreaEntryByAreaID(pKiller->GetAreaId()))
+		{
+			if (type != STR_NONE && (announceFlag == 1 || announceFlag == 3))
+				sWorld->SendServerMessage(SERVER_MSG_STRING, sString->Format(sString->GetText(type), areaEntry->area_name[4], pKiller->GetName().c_str(), pVictim->GetName().c_str()));
+
+			if (rewId != 0)
+			{
+				if (rewFlag == 2 || !pKiller->InBattleground() && rewFlag == 0 || pKiller->InBattleground() && rewFlag == 1)
+				{
+					sRew->Rew(pKiller, rewId);
+					sWorld->SendServerMessage(SERVER_MSG_STRING, sString->Format(sString->GetText(CORE_STR_TYPES(STR_KILL_STREAK_REW)), pKiller->GetName().c_str(), sRew->GetAnounceText(rewId).c_str()));
+				}
+			}
+
+			if (endRewId != 0)
+				sWorld->SendServerMessage(SERVER_MSG_STRING, sString->Format(sString->GetText(CORE_STR_TYPES(STR_KILL_STREAK_TO_REW)), pKiller->GetName().c_str(), sRew->GetAnounceText(endRewId).c_str()));
+		}	
+	}
+
+	void KilledAnnounceAndRew(Player* pKiller, Player* pVictim, uint32 num)
+	{
+		uint32 rewId = 0;
+		uint32 endRewId = 0;
+		uint32 announceFlag = 0;
+		uint32 rewFlag = 0;
+		uint32 endRewFlag = 0;
+		GetRewAndNotice(num, rewId, endRewId, announceFlag, rewFlag, endRewFlag);
+
+		uint32 type = STR_NONE;
+
+		switch (num)
+		{
+		case KillerStreak1:	type = STR_END_KILL_STREAK_1;	break;
+		case KillerStreak2:	type = STR_END_KILL_STREAK_2;	break;
+		case KillerStreak3:	type = STR_END_KILL_STREAK_3;	break;
+		case KillerStreak4:	type = STR_END_KILL_STREAK_4;	break;
+		case KillerStreak5:	type = STR_END_KILL_STREAK_5;	break;
+		case KillerStreak6:	type = STR_END_KILL_STREAK_6;	break;
+		case KillerStreak7:	type = STR_END_KILL_STREAK_7;	break;
+		case KillerStreak8:	type = STR_END_KILL_STREAK_8;	break;
+		case KillerStreak9:	type = STR_END_KILL_STREAK_9;	break;
+		case KillerStreak10:type = STR_END_KILL_STREAK_10;  break;
+		default:
+			break;
+		}
+
+		if (AreaTableEntry const* areaEntry = GetAreaEntryByAreaID(pKiller->GetAreaId()))
+		{
+			if (type != STR_NONE && (announceFlag == 2 || announceFlag == 3))
+				sWorld->SendServerMessage(SERVER_MSG_STRING, sString->Format(sString->GetText(CORE_STR_TYPES(type)), areaEntry->area_name[4], pVictim->GetName().c_str(), pKiller->GetName().c_str()));
+
+			if (endRewId != 0)
+			{
+				if (endRewFlag == 2 || !pKiller->InBattleground() && endRewFlag == 0 || pKiller->InBattleground() && endRewFlag == 1)
+				{
+					sRew->Rew(pKiller, endRewId);
+					sWorld->SendServerMessage(SERVER_MSG_STRING, sString->Format(sString->GetText(CORE_STR_TYPES(STR_END_KILL_STREAK_REW)), pKiller->GetName().c_str(), sRew->GetAnounceText(endRewId).c_str()));
+
+				}
+			}
+		}
+	}
+
+
+	void OnPVPKill(Player *pKiller, Player *pVictim)
+	{
+		if (pVictim->HasAura(2479) || pVictim->HasAura(46705))
+			return;
+
+		//ÐéÈõ¸´»î
+		if (pVictim->HasAura(15007))
+			return;
+
+		//Í¬IP
+		std::string kIP = pKiller->GetSession()->GetRemoteAddress();
+		std::string vIP = pVictim->GetSession()->GetRemoteAddress();
+		if (strcmp(kIP.c_str(), vIP.c_str()) == 0)
+			return;
+
+		uint32 kGUID = pKiller->GetGUID();
+		uint32 vGUID = pVictim->GetGUID();
+
+		//×ÔÉ±
+		if (kGUID == vGUID)
+			return;
+
+		//Á¬Ðø»÷É±Í¬Ò»Íæ¼Ò
+		if (KillingStreak[kGUID].LastGUIDKill == vGUID)
+			return;
+
+		//Á¬Ðø»÷É±Í¬Ò»IPÏÂµÄÍæ¼Ò
+		if (Player* lastVictim = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(KillingStreak[kGUID].LastGUIDKill, 0, HIGHGUID_PLAYER)))
+		{
+			if (WorldSession* session = lastVictim->GetSession())
+			{
+				std::string lastIp = session->GetRemoteAddress();
+		
+				if (strcmp(lastIp.c_str(), vIP.c_str()) == 0)
+					return;
+			}
+		}
+
+		sPvP->RewOnKill(pKiller, pVictim);
+
+		//sTalisman->OnKillStreak(pKiller);
+
+		KilledAnnounceAndRew(pKiller, pVictim, KillingStreak[vGUID].KillStreak);
+		//Á¬É±
+
+		KillingStreak[kGUID].KillStreak++;
+		KillingStreak[vGUID].KillStreak = 0;
+		KillingStreak[kGUID].LastGUIDKill = vGUID;
+		KillingStreak[vGUID].LastGUIDKill = 0;
+
+		KillAnnounceAndRew(pKiller, pVictim, KillingStreak[kGUID].KillStreak);
+	}
+};
+
+void AddSC_PvP_System()
+{
+	new System_OnPVPKill();
+}
diff --git a/src/server/scripts/Custom/Other/npc_arena1v1.cpp b/src/server/scripts/Custom/Other/npc_arena1v1.cpp
new file mode 100644
index 0000000..cc8bc28
--- /dev/null
+++ b/src/server/scripts/Custom/Other/npc_arena1v1.cpp
@@ -0,0 +1,320 @@
+/*
+ *
+ * Copyright (C) 2013 Emu-Devstore <http://emu-devstore.com/>
+ * Written by Teiby <http://www.teiby.de/>
+ *
+ */
+#pragma execution_character_set("utf-8")
+#include "ScriptMgr.h"
+#include "ArenaTeamMgr.h"
+#include "Common.h"
+#include "DisableMgr.h"
+#include "BattlegroundMgr.h"
+#include "Battleground.h"
+#include "ArenaTeam.h"
+#include "Language.h"
+#include "npc_arena1v1.h"
+
+
+class npc_1v1arena : public CreatureScript
+{
+public:
+    npc_1v1arena() : CreatureScript("npc_1v1arena")
+    {
+    }
+
+
+    bool JoinQueueArena(Player* player, Creature* me, bool isRated)
+    {
+        if(!player || !me)
+            return false;
+
+        if(sWorld->getIntConfig(CONFIG_ARENA_1V1_MIN_LEVEL) > player->getLevel())
+            return false;
+
+		uint64 guid = player->GetGUID();
+        uint8 arenaslot = ArenaTeam::GetSlotByType(ARENA_TEAM_5v5);
+        uint8 arenatype = ARENA_TYPE_5v5;
+        uint32 arenaRating = 0;
+        uint32 matchmakerRating = 0;
+
+        // ignore if we already in BG or BG queue
+        if (player->InBattleground())
+            return false;
+
+        //check existance
+        Battleground* bg = sBattlegroundMgr->GetBattlegroundTemplate(BATTLEGROUND_AA);
+        if (!bg)
+        {
+            sLog->outError("Arena", "Battleground: template bg (all arenas) not found");
+            return false;
+        }
+
+        if (DisableMgr::IsDisabledFor(DISABLE_TYPE_BATTLEGROUND, BATTLEGROUND_AA, NULL))
+        {
+            ChatHandler(player->GetSession()).PSendSysMessage(LANG_ARENA_DISABLED);
+            return false;
+        }
+
+		BattlegroundTypeId bgTypeId = bg->GetBgTypeID();
+        BattlegroundQueueTypeId bgQueueTypeId = BattlegroundMgr::BGQueueTypeId(bgTypeId, arenatype);
+        PvPDifficultyEntry const* bracketEntry = GetBattlegroundBracketByLevel(bg->GetMapId(), player->getLevel());
+        if (!bracketEntry)
+            return false;
+
+        GroupJoinBattlegroundResult err = ERR_GROUP_JOIN_BATTLEGROUND_FAIL;
+
+        // check if already in queue
+        if (player->GetBattlegroundQueueIndex(bgQueueTypeId) < PLAYER_MAX_BATTLEGROUND_QUEUES)
+            //player is already in this queue
+            return false;
+        // check if has free queue slots
+        if (!player->HasFreeBattlegroundQueueId())
+            return false;
+
+        uint32 ateamId = 0;
+
+        if(isRated)
+        {
+            ateamId = player->GetArenaTeamId(arenaslot);
+            ArenaTeam* at = sArenaTeamMgr->GetArenaTeamById(ateamId);
+            if (!at)
+            {
+                player->GetSession()->SendNotInArenaTeamPacket(arenatype);
+                return false;
+            }
+
+            // get the team rating for queueing
+            arenaRating = at->GetRating();
+            matchmakerRating = arenaRating;
+            // the arenateam id must match for everyone in the group
+
+            if (arenaRating <= 0)
+                arenaRating = 1;
+        }
+
+        BattlegroundQueue &bgQueue = sBattlegroundMgr->GetBattlegroundQueue(bgQueueTypeId);
+        bg->SetRated(isRated);
+
+		GroupQueueInfo* ginfo = bgQueue.AddGroup(player, NULL, bracketEntry, isRated, false, arenaRating, matchmakerRating, ateamId);
+        uint32 avgTime = bgQueue.GetAverageQueueWaitTime(ginfo);
+        uint32 queueSlot = player->AddBattlegroundQueueId(bgQueueTypeId);
+
+        WorldPacket data;
+        // send status packet (in queue)
+		sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, queueSlot, STATUS_WAIT_QUEUE, avgTime, 0, arenatype, TEAM_NEUTRAL, isRated);
+        player->GetSession()->SendPacket(&data);
+		if (ateamId)
+			sBattlegroundMgr->ScheduleArenaQueueUpdate(ateamId, bgQueueTypeId, bracketEntry->GetBracketId());
+
+        return true;
+    }
+
+
+    bool CreateArenateam(Player* player, Creature* me)
+    {
+        if(!player || !me)
+            return false;
+
+        uint8 slot = ArenaTeam::GetSlotByType(ARENA_TEAM_5v5);
+        if (slot >= MAX_ARENA_SLOT)
+            return false;
+
+        // Check if player is already in an arena team
+        if (player->GetArenaTeamId(slot))
+        {
+            player->GetSession()->SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, player->GetName(), "", ERR_ALREADY_IN_ARENA_TEAM);
+            return false;
+        }
+
+
+        // Teamname = playername
+        // if teamname exist, we have to choose another name (playername + number)
+        int i = 1;
+        std::stringstream teamName;
+        teamName << player->GetName();
+        do
+        {
+            if(sArenaTeamMgr->GetArenaTeamByName(teamName.str()) != NULL) // teamname exist, so choose another name
+            {
+                teamName.str(std::string());
+                teamName << player->GetName() << (i++);
+            }
+            else
+                break;
+        } while (i < 100); // should never happen
+
+        // Create arena team
+        ArenaTeam* arenaTeam = new ArenaTeam();
+
+        if (!arenaTeam->Create(player->GetGUID(), ARENA_TEAM_5v5, teamName.str(), 4283124816, 45, 4294242303, 5, 4294705149))
+        {
+            delete arenaTeam;
+            return false;
+        }
+
+        // Register arena team
+        sArenaTeamMgr->AddArenaTeam(arenaTeam);
+        arenaTeam->AddMember(player->GetGUID());
+
+        ChatHandler(player->GetSession()).SendSysMessage("ÒÑ¾­½¨Á¢µµ°¸");
+
+        return true;
+    }
+
+
+    bool OnGossipHello(Player* player, Creature* me)
+    {
+        if(!player || !me)
+            return true;
+
+		if (sWorld->getBoolConfig(CONFIG_ARENA_1V1_ENABLE) == false)//Èç¹û¶ÁÈ¡²»ÁËconfÖµ,ÄÇ¾ÍÔÝÊ±¸ÄÎªtrue
+        {
+            ChatHandler(player->GetSession()).SendSysMessage("1VS1ÒÑ±»½ûÖ¹");
+            return true;
+        }
+		
+		if (sWorld->getIntConfig(CONFIG_ARENA_1V1_MIN_LEVEL) > player->getLevel())//Ôö¼ÓµÈ¼¶¹ýÂË
+		{
+			ChatHandler(player->GetSession()).PSendSysMessage("ÄãµÄµÈ¼¶²»¹»£¬¿ìÈ¥Á·¼¶£¡", sWorld->getIntConfig(CONFIG_ARENA_1V1_MIN_LEVEL));
+			player->CLOSE_GOSSIP_MENU();
+			return true;
+		}
+		
+        if(player->InBattlegroundQueueForBattlegroundQueueType(BATTLEGROUND_QUEUE_5v5))
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "ËãÁË ÎÒ²»ÅÅÁË", GOSSIP_SENDER_MAIN, 3, "ÄãÈ·¶¨Âð?", 0, false);
+        else
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "È¥Á·Ï°ÈüÇÐ´è", GOSSIP_SENDER_MAIN, 20);
+
+        if(player->GetArenaTeamId(ArenaTeam::GetSlotByType(ARENA_TEAM_5v5)) == 0)
+            player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "½¨Á¢µµ°¸", GOSSIP_SENDER_MAIN, 1, "Äã»á±»Å°ËÀµÄ ÏÈ½»Ç®°É", sWorld->getIntConfig(CONFIG_ARENA_1V1_COSTS), false);
+        else
+        {
+            if(player->InBattlegroundQueueForBattlegroundQueueType(BATTLEGROUND_QUEUE_5v5) == false)
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "ÀÏ×ÓÒªÈ¥±ÈÈü", GOSSIP_SENDER_MAIN, 2);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "É¾³ýµµ°¸", GOSSIP_SENDER_MAIN, 5, "ÄãÈ·¶¨Âð?", 0, false);
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "²éÔÄÎÒµÄÕ½¼¨", GOSSIP_SENDER_MAIN, 4);
+        }
+
+        //player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Script Info", GOSSIP_SENDER_MAIN, 8);
+        player->SEND_GOSSIP_MENU(68, me->GetGUID());
+        return true;
+    }
+
+
+
+    bool OnGossipSelect(Player* player, Creature* me, uint32 /*uiSender*/, uint32 uiAction)
+    {
+        if(!player || !me)
+            return true;
+
+        player->PlayerTalkClass->ClearMenus();
+
+        switch (uiAction)
+        {
+        case 1: // Create new Arenateam
+            {
+                if(sWorld->getIntConfig(CONFIG_ARENA_1V1_MIN_LEVEL) <= player->getLevel())
+                {
+                    if(player->GetMoney() >= sWorld->getIntConfig(CONFIG_ARENA_1V1_COSTS) && CreateArenateam(player, me))
+                        player->ModifyMoney(sWorld->getIntConfig(CONFIG_ARENA_1V1_COSTS) * -1);
+                }
+                else
+                {
+                    ChatHandler(player->GetSession()).PSendSysMessage("You need level %u .", sWorld->getIntConfig(CONFIG_ARENA_1V1_MIN_LEVEL));
+                    //player->CLOSE_GOSSIP_MENU();
+                    //return true;
+                }
+				player->CLOSE_GOSSIP_MENU();
+				return true;
+            }
+            break;
+
+        case 2: // Join Queue Arena (rated)
+            {
+                if(Arena1v1CheckTalents(player) && JoinQueueArena(player, me, true) == false)
+                    ChatHandler(player->GetSession()).SendSysMessage("°¥Ñ½£¬³ö´íÀ²£¬ÄãÒªÔÙÅÅ¹ý");
+
+                player->CLOSE_GOSSIP_MENU();
+                return true;
+            }
+            break;
+
+        case 20: // Join Queue Arena (unrated)
+            {
+                if(Arena1v1CheckTalents(player) && JoinQueueArena(player, me, false) == false)
+                    ChatHandler(player->GetSession()).SendSysMessage("°¥Ñ½£¬³ö´íÀ²£¬ÄãÒªÔÙÅÅ¹ý");
+
+                player->CLOSE_GOSSIP_MENU();
+                return true;
+            }
+            break;
+
+        case 3: // Leave Queue
+            {
+                WorldPacket Data;
+                Data << (uint8)0x1 << (uint8)0x0 << (uint32)BATTLEGROUND_AA << (uint16)0x0 << (uint8)0x0;
+                player->GetSession()->HandleBattleFieldPortOpcode(Data);
+                player->CLOSE_GOSSIP_MENU();
+                return true;
+            }
+            break;
+
+        case 4: // get statistics
+            {
+                ArenaTeam* at = sArenaTeamMgr->GetArenaTeamById(player->GetArenaTeamId(ArenaTeam::GetSlotByType(ARENA_TEAM_5v5)));
+                if(at)
+                {
+                    std::stringstream s;
+                    s << "Rating: " << at->GetStats().Rating;
+                    s << "\nRank: " << at->GetStats().Rank;
+                    s << "\nSeason Games: " << at->GetStats().SeasonGames;
+                    s << "\nSeason Wins: " << at->GetStats().SeasonWins;
+                    s << "\nWeek Games: " << at->GetStats().WeekGames;
+                    s << "\nWeek Wins: " << at->GetStats().WeekWins;
+
+                    ChatHandler(player->GetSession()).PSendSysMessage(s.str().c_str());
+                }
+				player->CLOSE_GOSSIP_MENU();
+				return true;
+            }
+            break;
+
+
+        case 5: // Disband arenateam
+            {
+                WorldPacket Data;
+                Data << (uint32)player->GetArenaTeamId(ArenaTeam::GetSlotByType(ARENA_TEAM_5v5));
+                player->GetSession()->HandleArenaTeamLeaveOpcode(Data);
+                ChatHandler(player->GetSession()).SendSysMessage("ÒÑÉ¾³ýµµ°¸£¡");
+                player->CLOSE_GOSSIP_MENU();
+                return true;
+            }
+            break;
+
+        case 8: // Script Info
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Developer: sunwellcore", GOSSIP_SENDER_MAIN, uiAction);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Website: www.iwowo.top", GOSSIP_SENDER_MAIN, uiAction);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Version: 1.-", GOSSIP_SENDER_MAIN, uiAction);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<-- Back", GOSSIP_SENDER_MAIN, 7);
+                player->SEND_GOSSIP_MENU(68, me->GetGUID());
+                return true;
+            }
+            break;
+
+        }
+
+        OnGossipHello(player, me);
+        return true;
+    }
+};
+
+
+void AddSC_npc_1v1arena()
+{
+    new npc_1v1arena();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Other/npc_arena1v1.h b/src/server/scripts/Custom/Other/npc_arena1v1.h
new file mode 100644
index 0000000..caa75a2
--- /dev/null
+++ b/src/server/scripts/Custom/Other/npc_arena1v1.h
@@ -0,0 +1,69 @@
+/*
+ *
+ * Copyright (C) 2013 Emu-Devstore <http://emu-devstore.com/>
+ * Written by Teiby <http://www.teiby.de/>
+ *
+ */
+
+#ifndef ARENA_1V1_H
+#define ARENA_1V1_H
+
+// TalentTab.dbc -> TalentTabID
+const uint32 FORBIDDEN_TALENTS_IN_1V1_ARENA[] =
+{
+    // Healer
+    201, // PriestDiscipline
+    202, // PriestHoly
+    382, // PaladinHoly
+    262, // ShamanRestoration
+    282, // DruidRestoration
+
+    // Tanks
+    //383, // PaladinProtection
+    //163, // WarriorProtection
+
+    0 // End
+};
+
+
+// Return false, if player have invested more than 35 talentpoints in a forbidden talenttree.
+static bool Arena1v1CheckTalents(Player* player)
+{
+    if(!player)
+        return false;
+
+    if(sWorld->getBoolConfig(CONFIG_ARENA_1V1_BLOCK_FORBIDDEN_TALENTS) == false)
+        return true;
+
+    uint32 count = 0;
+    for (uint32 talentId = 0; talentId < sTalentStore.GetNumRows(); ++talentId)
+    {
+        TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);
+
+        if (!talentInfo)
+            continue;
+
+        for (int8 rank = MAX_TALENT_RANK-1; rank >= 0; --rank)
+        {
+            if (talentInfo->RankID[rank] == 0)
+                continue;
+
+            if (player->HasTalent(talentInfo->RankID[rank], player->GetActiveSpec()))
+            {
+                for(int8 i = 0; FORBIDDEN_TALENTS_IN_1V1_ARENA[i] != 0; i++)
+                    if(FORBIDDEN_TALENTS_IN_1V1_ARENA[i] == talentInfo->TalentTab)
+                        count += rank + 1;
+            }
+        }
+    }
+
+    if(count >= 36)
+    {
+        ChatHandler(player->GetSession()).SendSysMessage("You can't join, because you have invested too many points in a forbidden talent. Please edit your talents.");
+        return false;
+    }
+    else
+        return true;
+}
+
+#endif
\ No newline at end of file
diff --git a/src/server/scripts/Custom/PetMod/PetMod.cpp b/src/server/scripts/Custom/PetMod/PetMod.cpp
new file mode 100644
index 0000000..7356a4f
--- /dev/null
+++ b/src/server/scripts/Custom/PetMod/PetMod.cpp
@@ -0,0 +1,159 @@
+#pragma execution_character_set("utf-8")
+#include "PetMod.h"
+#include "../MapMod/MapMod.h"
+
+std::unordered_map<uint8, PetModTemplate> PetModMap;
+
+void PetMod::Load()
+{
+	PetModMap.clear();
+
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT Ö°ÒµË÷Òý, ¸ù¾ÝÍæ¼ÒÉËº¦Ôö¼ÓÎïÀíÉËº¦°Ù·Ö±È, ¸ù¾ÝÍæ¼ÒÉËº¦Ôö¼Ó·¨ÊõÉËº¦°Ù·Ö±È, ¸ù¾ÝÍæ¼ÒÑªÁ¿Ôö¼ÓÑªÁ¿°Ù·Ö±È, »¤¼×ÖµÉÏÏÞ FROM _ÊôÐÔµ÷Õû_³èÎï" :
+		"SELECT classIndex, DmgAddPct, SpAddPct, HpAddPct, ArmorLimit FROM _pet");
+
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint8 classIndex = fields[0].GetUInt8();
+			PetModTemplate Temp;
+			Temp.DmgAddPct	= fields[1].GetFloat();
+			Temp.SpAddPct	= fields[2].GetFloat();
+			Temp.HpAddPct	= fields[3].GetFloat();
+			Temp.ArmorLimit = fields[4].GetFloat();
+			PetModMap.insert(std::make_pair(classIndex, Temp));
+
+		} while (result->NextRow());
+	}
+}
+
+void PetMod::GetMinDmgMod(Guardian* guardian, float &mindamage, float &maxdamage)
+{
+	Unit* owner = guardian->GetOwner();
+
+	if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
+		return;
+
+	float DmgAddPct = 0.0f;
+
+	std::unordered_map<uint8, PetModTemplate>::iterator iter = PetModMap.find(owner->getClass());
+
+	if (iter != PetModMap.end())
+		DmgAddPct = iter->second.DmgAddPct;
+
+	int32 base = 0;
+
+	switch (owner->getClass())
+	{
+	case CLASS_HUNTER:
+		base = owner->GetTotalAttackPowerValue(RANGED_ATTACK);
+		break;
+	case CLASS_PRIEST:
+		base = owner->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_SHADOW);
+		break;
+	case CLASS_DEATH_KNIGHT:
+		base = owner->GetTotalAttackPowerValue(BASE_ATTACK);
+		break;
+	case CLASS_SHAMAN:
+		base = owner->GetTotalAttackPowerValue(BASE_ATTACK);
+		break;
+	case CLASS_DRUID:
+		base = owner->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_NATURE);
+		break;
+	case CLASS_WARLOCK:
+	{
+		int32 fire = owner->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_FIRE);
+		int32 shadow = owner->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_SHADOW);
+		base = (fire > shadow) ? fire : shadow;
+	}
+		break;
+	default:
+		break;
+	}
+
+	if (guardian->GetEntry() == 24207)//Ñª³æ
+		DmgAddPct = 5;
+
+	mindamage = mindamage + CalculatePct(base, DmgAddPct);
+	maxdamage = maxdamage + CalculatePct(base, DmgAddPct);
+
+	if (owner->getClass() == CLASS_HUNTER)
+	{
+		if (owner->HasAura(19551))
+		{
+			mindamage = mindamage + owner->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE) * 0.3;
+			maxdamage = maxdamage + owner->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE) * 0.3;
+		}
+		else if (owner->HasAura(19550))
+		{
+			mindamage = mindamage + owner->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE) * 0.2;
+			maxdamage = maxdamage + owner->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE) * 0.2;
+		}
+		if (owner->HasAura(19549))
+		{
+			mindamage = mindamage + owner->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE) * 0.1;
+			maxdamage = maxdamage + owner->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE) * 0.1;
+		}
+	}
+}
+
+float PetMod::GetSpAddPct(Unit* owner)
+{
+	std::unordered_map<uint8, PetModTemplate>::iterator iter = PetModMap.find(owner->getClass());
+
+	if (iter != PetModMap.end())
+		return iter->second.SpAddPct;
+
+	return 0.0f;
+}
+
+void PetMod::GetHpMod(Guardian* guardian, float &value)
+{
+	Unit* owner = guardian->GetOwner();
+
+	if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
+		return;
+
+	float HpAddPct = 0.0f;
+
+	std::unordered_map<uint8, PetModTemplate>::iterator iter = PetModMap.find(owner->getClass());
+
+	if (iter != PetModMap.end())
+		HpAddPct = iter->second.HpAddPct;
+
+	uint32 base = owner->GetMaxHealth();
+
+	if (guardian->GetEntry() == 24207)//Ñª³æ
+		HpAddPct = 20;
+
+	value += CalculatePct(base, HpAddPct);
+
+	if (owner->getClass() == CLASS_HUNTER)
+	{
+		if (owner->HasAura(19587))
+			value += base * 0.5;
+		else if (owner->HasAura(19586))
+			value += base * 0.4;
+		else if (owner->HasAura(19585))
+			value += base * 0.3;
+		else if (owner->HasAura(19584))
+			value += base * 0.2;
+		else if (owner->HasAura(19583))
+			value += base * 0.1;
+	}
+}
+
+void PetMod::GetArmorLimit(Guardian* guardian, float &value)
+{
+	Unit* owner = guardian->GetOwner();
+
+	if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
+		return;
+
+	std::unordered_map<uint8, PetModTemplate>::iterator iter = PetModMap.find(owner->getClass());
+
+	if (iter != PetModMap.end())
+		value = std::min(value, iter->second.ArmorLimit);
+}
diff --git a/src/server/scripts/Custom/PetMod/PetMod.h b/src/server/scripts/Custom/PetMod/PetMod.h
new file mode 100644
index 0000000..a631f0d
--- /dev/null
+++ b/src/server/scripts/Custom/PetMod/PetMod.h
@@ -0,0 +1,27 @@
+struct PetModTemplate
+{
+	float HpAddPct;
+	float DmgAddPct;
+	float SpAddPct;
+	float ArmorLimit;
+};
+
+extern std::unordered_map<uint8, PetModTemplate> PetModMap;
+
+class PetMod
+{
+public:
+	static PetMod* instance()
+	{
+		static PetMod instance;
+		return &instance;
+	}
+	void Load();
+	void GetHpMod(Guardian* guardian, float &value);
+	void GetMinDmgMod(Guardian* guardian, float &mindamage, float &maxdamage);
+	float GetSpAddPct(Unit* owner);
+	void GetArmorLimit(Guardian* guardian, float &value);
+private:
+
+};
+#define sPetMod PetMod::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/PlayerLoot/PlayerLoot.cpp b/src/server/scripts/Custom/PlayerLoot/PlayerLoot.cpp
new file mode 100644
index 0000000..2d73353
--- /dev/null
+++ b/src/server/scripts/Custom/PlayerLoot/PlayerLoot.cpp
@@ -0,0 +1,197 @@
+#pragma execution_character_set("utf-8")
+#include "PlayerLoot.h"
+
+std::unordered_map<uint32/*itemid*/, PlayerLootTemplate> PlayerLootMap;
+
+void PlayerLoot::Load()
+{
+	PlayerLootMap.clear();
+
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÎïÆ·ID,µôÂäÊýÁ¿,µôÂä¼¸ÂÊ,ÊÇ·ñ½ûÖ¹ÒøÐÐµôÂä,ÊÇ·ñ½ûÖ¹±³°üµôÂä FROM __Íæ¼ÒµôÂä" :
+		"SELECT entry,lootCount,chance,banBank,banBag FROM _pvp_killed_loot");
+
+	if (!result) 
+		return;
+	do
+	{
+		Field* fields		= result->Fetch();
+		uint32 entry		= fields[0].GetUInt32();
+		PlayerLootTemplate Temp;
+		Temp.lootCount		= fields[1].GetUInt32();
+		Temp.chance			= fields[2].GetFloat();
+		Temp.banBank		= fields[3].GetBool();
+		Temp.banBag			= fields[4].GetBool();
+		PlayerLootMap.insert(std::make_pair(entry, Temp));
+	} while (result->NextRow());
+}
+
+bool PlayerLoot::GetLootInfo(uint32 entry, uint32 &lootCount, bool &banBag, bool &banBank)
+{
+	auto iter = PlayerLootMap.find(entry);
+
+	if (iter == PlayerLootMap.end())
+		return false;
+
+	if (!roll_chance_f(iter->second.chance))
+		return false;
+
+	lootCount = iter->second.lootCount;
+	banBag = iter->second.banBag;
+	banBank = iter->second.banBank;	
+	return true;
+}
+
+uint32 PlayerLoot::GetItemCount(Player* player, uint32 entry, bool banBag, bool banBank)
+{
+	uint32 count = 0;
+
+	for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; i++)
+		if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+			if (pItem->GetEntry() == entry)
+				count += pItem->GetCount();
+
+	if (!banBag)
+	{
+		for (uint8 i = KEYRING_SLOT_START; i < CURRENCYTOKEN_SLOT_END; ++i)
+			if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+				if (pItem->GetEntry() == entry)
+					count += pItem->GetCount();
+
+		for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+			if (Bag* pBag = player->GetBagByPos(i))
+				count += pBag->GetItemCount(entry);
+	}
+	
+	if (!banBank)
+	{
+		for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
+			if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+				if (pItem->GetEntry() == entry)
+					count += pItem->GetCount();
+
+		for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+			if (Bag* pBag = player->GetBagByPos(i))
+				count += pBag->GetItemCount(entry);
+	}
+
+	return count;
+}
+
+void PlayerLoot::LootOnKilled(Player* killer, Player* victim)
+{
+	std::unordered_map<uint32, uint32> LootExtraItems;
+
+	for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
+		if (Item* item = victim->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+		{
+			uint32 entry = item->GetEntry();
+			uint32 lootCount = 0; bool banBag = false; bool banBank = false;
+			if (!GetLootInfo(entry, lootCount, banBag, banBank))
+				continue;
+
+			if (LootExtraItems.find(entry) == LootExtraItems.end())
+				LootExtraItems.insert(std::make_pair(entry, 0));
+		}
+
+	for (uint8 i = KEYRING_SLOT_START; i < CURRENCYTOKEN_SLOT_END; ++i)
+		if (Item* item = victim->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+		{
+			uint32 entry = item->GetEntry();
+			uint32 lootCount = 0; bool banBag = false; bool banBank = false;
+			if (!GetLootInfo(entry, lootCount, banBag, banBank) || banBag)
+				continue;
+
+			if (LootExtraItems.find(entry) == LootExtraItems.end())
+				LootExtraItems.insert(std::make_pair(entry, 0));
+		}
+
+	for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
+		if (Item* item = victim->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+		{
+			uint32 entry = item->GetEntry();
+			uint32 lootCount = 0; bool banBag = false; bool banBank = false;
+			if (!GetLootInfo(entry, lootCount, banBag, banBank) || banBag)
+				continue;
+
+			if (LootExtraItems.find(entry) == LootExtraItems.end())
+				LootExtraItems.insert(std::make_pair(entry, 0));
+		}
+
+	for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+		if (Bag* pBag = victim->GetBagByPos(i))
+			for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+				if (Item* item = victim->GetItemByPos(i, j))
+				{
+					uint32 entry = item->GetEntry();
+					uint32 lootCount = 0; bool banBag = false; bool banBank = false;
+					if (!GetLootInfo(entry, lootCount, banBag, banBank) || banBag)
+						continue;
+
+					if (LootExtraItems.find(entry) == LootExtraItems.end())
+						LootExtraItems.insert(std::make_pair(entry, 0));
+				}
+
+	for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
+		if (Item* item = victim->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+		{
+			uint32 entry = item->GetEntry();
+			uint32 lootCount = 0; bool banBag = false; bool banBank = false;
+			if (!GetLootInfo(entry, lootCount, banBag, banBank) || banBank)
+				continue;
+
+			if (LootExtraItems.find(entry) == LootExtraItems.end())
+				LootExtraItems.insert(std::make_pair(entry, 0));
+		}
+
+	for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+		if (Bag* pBag = victim->GetBagByPos(i))
+			for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+				if (Item* item = victim->GetItemByPos(i, j))
+				{
+					uint32 entry = item->GetEntry();
+					uint32 lootCount = 0; bool banBag = false; bool banBank = false;
+					if (!GetLootInfo(entry, lootCount, banBag, banBank) || banBank)
+						continue;
+
+					if (LootExtraItems.find(entry) == LootExtraItems.end())
+						LootExtraItems.insert(std::make_pair(entry, 0));
+				}
+
+	if (LootExtraItems.empty())
+		return;
+
+	if (GameObject* chest = killer->GetMap()->SummonGameObject(PLAYER_LOOT_GAMEOBJECT, victim->GetPositionX(), victim->GetPositionY(), victim->GetPositionZ(),
+		0, 0, 0, 0, 0, PLAYER_LOOT_GAMEOBJECT_DURATION_TIME))
+	{
+		
+		for (auto iter = LootExtraItems.begin(); iter != LootExtraItems.end(); iter++)
+		{
+			auto itr = PlayerLootMap.find(iter->first);
+			if (itr != PlayerLootMap.end())
+			{
+				uint32 count = GetItemCount(victim, iter->first, itr->second.banBag, itr->second.banBank);
+				iter->second = count > itr->second.lootCount ? itr->second.lootCount : count;
+				victim->DestroyItemCount(iter->first, iter->second, true);
+			}
+		}
+
+		chest->LootExtraItems = LootExtraItems;
+	}
+}
+
+class PlayerLootScript : PlayerScript
+{
+public:
+	PlayerLootScript() : PlayerScript("PlayerLootScript") {}
+
+	void OnPVPKill(Player* killer, Player* killed)
+	{
+		sPlayerLoot->LootOnKilled(killer, killed);
+	}
+};
+
+void AddSC_PlayerLoot()
+{
+	new PlayerLootScript();
+}
diff --git a/src/server/scripts/Custom/PlayerLoot/PlayerLoot.h b/src/server/scripts/Custom/PlayerLoot/PlayerLoot.h
new file mode 100644
index 0000000..30ab9b7
--- /dev/null
+++ b/src/server/scripts/Custom/PlayerLoot/PlayerLoot.h
@@ -0,0 +1,29 @@
+#define PLAYER_LOOT_GAMEOBJECT 5
+#define PLAYER_LOOT_GAMEOBJECT_DURATION_TIME 120
+
+struct PlayerLootTemplate
+{
+	uint32 lootCount;
+	float chance;
+	bool banBank;
+	bool banBag;
+};
+
+extern std::unordered_map<uint32/*itemid*/, PlayerLootTemplate> PlayerLootMap;
+
+class PlayerLoot
+{
+public:
+	static PlayerLoot* instance()
+	{
+		static PlayerLoot instance;
+		return &instance;
+	}
+
+public:
+	void Load();
+	bool GetLootInfo(uint32 entry, uint32 &lootCount, bool &banBag, bool &banBank);
+	uint32 GetItemCount(Player* player, uint32 entry, bool banBag, bool banBank);
+	void LootOnKilled(Player* killer, Player* victim);
+};
+#define sPlayerLoot PlayerLoot::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/PvP/PvP.cpp b/src/server/scripts/Custom/PvP/PvP.cpp
new file mode 100644
index 0000000..be5eaa0
--- /dev/null
+++ b/src/server/scripts/Custom/PvP/PvP.cpp
@@ -0,0 +1,215 @@
+#pragma execution_character_set("utf-8")
+#include "PvP.h"
+#include "../Switch/Switch.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../CharNameMod/CharNameMod.h"
+#include "../Faction/Faction.h"
+#include "../String/myString.h"
+#include "GroupMgr.h"
+#include "../GCAddon/GCAddon.h"
+#include "../Reward/Reward.h"
+
+std::vector<PvPTemplate> PvPVec;
+
+void PvP::Load()
+{
+	PvPVec.clear();
+	
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//		0			1		2			3				4			5	6			7				8			9
+		"SELECT µØÓòID, ÇøÓòÊôÐÔ, ½øÈëÌáÊ¾ÎÄ±¾,½øÈë»ñµÃÃû×ÖÇ°×º,ÉúÃüÖµÏÂÏÞ,ÇøÓòID,ÉúÃüÖµÉÏÏÞ,»÷É±½±ÀøÄ£°åID,±»É±½±ÀøÄ£°åID,»ñµÃ½±ÀøÊ±Âú×ãµÄÊÂ¼þ×é,½øÈë×Ô¶¯ÂúÑª FROM _ÊôÐÔµ÷Õû_ÇøÓò" :
+		//		0		1		2		3	4	5		6		7		8			9
+		"SELECT area, type, notice,prefix,minHp,zone,maxHp,killRewId,killedRewId,rewEventData FROM _pvp");
+
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			PvPTemplate Temp;
+			Temp.area			= fields[0].GetUInt32();
+
+			const char*  type = fields[1].GetCString();
+
+			if (strcmp("°²È«Çø", type) == 0)
+				Temp.type = PVP_TYPE_SANCTUARY;
+			else if (strcmp("×ÔÓÉPVP", type) == 0)
+				Temp.type = PvP_TYPE_FFA;
+			else if (strcmp("×ÔÓÉPVP - ½ûÖ¹×é¶Ó", type) == 0)
+				Temp.type = PvP_TYPE_NO_GROUP_FFA;
+			else if (strcmp("×Ô¶¨ÒåÕóÓª", type) == 0)
+				Temp.type = PvP_TYPE_CUSTOM_FACTION;
+			else if (strcmp("¹«»áPVP", type) == 0)
+				Temp.type = PvP_TYPE_GUILD;
+			else
+				Temp.type = PVP_TYPE_NONE;
+
+			Temp.notice			= fields[2].GetString();
+			Temp.prefix			= fields[3].GetString();
+			Temp.minHp			= fields[4].GetInt32();
+			Temp.zone			= fields[5].GetInt32();
+			Temp.maxHp			= fields[6].GetInt32();
+			Temp.killRewId		= fields[7].GetInt32();
+			Temp.killedRewId	= fields[8].GetInt32();
+			Tokenizer tokens(fields[9].GetString(), ' ');
+			for (Tokenizer::const_iterator itr = tokens.begin(); itr != tokens.end(); ++itr)
+				Temp.eventData.push_back(uint32(atol(*itr)));
+			Temp.autoMaxHp		= fields[10].GetBool();
+			PvPVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+}
+
+PvPTypes PvP::GetType(uint32 zone, uint32 area)
+{
+	uint32 length = PvPVec.size();
+
+	for (size_t i = 0; i < length; i++)
+		if (PvPVec[i].zone == zone && PvPVec[i].area == 0 || PvPVec[i].zone == zone && PvPVec[i].area == area)
+			return PvPVec[i].type;
+
+	return PVP_TYPE_NONE;
+}
+
+uint32 PvP::GetMinHp(uint32 zone, uint32 area)
+{
+	uint32 length = PvPVec.size();
+
+	for (size_t i = 0; i < length; i++)
+		if (PvPVec[i].zone == zone && PvPVec[i].area == 0 || PvPVec[i].zone == zone && PvPVec[i].area == area)
+			return PvPVec[i].minHp;
+
+	return 0;
+}
+
+uint32 PvP::GetMaxHp(uint32 zone, uint32 area)
+{
+	uint32 length = PvPVec.size();
+
+	for (size_t i = 0; i < length; i++)
+		if (PvPVec[i].zone == zone && PvPVec[i].area == 0 || PvPVec[i].zone == zone && PvPVec[i].area == area)
+			return PvPVec[i].maxHp;
+
+	return 0;
+}
+
+bool PvP::AutoMaxHP(uint32 zone, uint32 area)
+{
+	uint32 length = PvPVec.size();
+
+	for (size_t i = 0; i < length; i++)
+		if (PvPVec[i].zone == zone && PvPVec[i].area == 0 || PvPVec[i].zone == zone && PvPVec[i].area == area)
+			return PvPVec[i].autoMaxHp;
+
+	return false;
+}
+
+void PvP::RewOnKill(Player *pKiller, Player *pVictim)
+{
+	uint32 zone = pKiller->GetZoneId();
+	uint32 area = pKiller->GetAreaId();
+
+	for (auto itr = PvPVec.begin(); itr != PvPVec.end(); itr++)
+	{
+		if (itr->zone == zone && itr->area == 0 || itr->zone == zone && itr->area == area)
+		{
+			bool valid = false;
+
+			if (itr->eventData.empty())
+				valid = true;
+
+			for (auto i = itr->eventData.begin(); i != itr->eventData.end(); i++)
+				if (sGameEventMgr->IsActiveEvent(*i))
+					valid = true;
+
+			if (valid)
+			{
+				sRew->Rew(pKiller, itr->killRewId);
+				sRew->Rew(pVictim, itr->killedRewId);
+			}
+
+			return;
+		}
+	}
+}
+
+bool PvP::EnableGroup(uint32 zone, uint32 area)
+{
+	uint32 length = PvPVec.size();
+
+	for (size_t i = 0; i < length; i++)
+		if (PvPVec[i].zone == zone && PvPVec[i].area == 0 || PvPVec[i].zone == zone && PvPVec[i].area == area)
+			if (PvPVec[i].type == PvP_TYPE_NO_GROUP_FFA)
+				return false;
+
+	return true;
+}
+
+void PvP::Update(Player* player, uint32 zone, uint32 area)
+{
+	bool automaxhp = AutoMaxHP(zone, area);
+
+	player->UpdateMaxHealth();
+
+	if (automaxhp)
+		player->SetHealth(player->GetMaxHealth());
+
+	if (Unit* pet = player->GetGuardianPet())
+		pet->UpdateMaxHealth();
+		
+	player->SetUInt32Value(PLAYER_DUEL_TEAM, 0);
+
+	std::string newName;
+	bool exsit = false;
+
+
+	uint32 length = PvPVec.size();
+
+	for (size_t i = 0; i < length; i++)
+	{
+		if (PvPVec[i].zone == zone && PvPVec[i].area == 0 || PvPVec[i].zone == zone && PvPVec[i].area == area)
+		{
+			sWorld->UpdateNamePrefixSuffix(player, PvPVec[i].prefix + player->namePrefix, player->nameSuffix);
+			
+			if (!PvPVec[i].notice.empty())
+				ChatHandler(player->GetSession()).PSendSysMessage(PvPVec[i].notice.c_str());
+
+			switch (PvPVec[i].type)
+			{
+			case PvP_TYPE_NO_GROUP_FFA:
+				player->UninviteFromGroup();
+				if (player->GetGroup())
+					player->RemoveFromGroup();
+				break;
+			case PvP_TYPE_CUSTOM_FACTION:
+				player->SetUInt32Value(PLAYER_DUEL_TEAM, FACTION_DUEL + player->faction);
+				break;
+			case PvP_TYPE_GUILD:
+				player->SetUInt32Value(PLAYER_DUEL_TEAM, GUILD_DUEL + player->GetGuildId());
+				break;
+			}
+
+			exsit = true;
+			break;
+		}
+	}
+
+	if (!exsit)
+		sWorld->UpdateNamePrefixSuffix(player, player->namePrefix, player->nameSuffix);
+}
+
+class FFAPvPPlayer : PlayerScript
+{
+public:
+	FFAPvPPlayer() : PlayerScript("FFAPvPPlayer") {}
+
+	void OnUpdateZone(Player* player, uint32 newZone, uint32 newArea)
+	{
+		
+	}
+};
+
+void AddSC_FFAPvP()
+{
+	//new FFAPvPPlayer();
+}
diff --git a/src/server/scripts/Custom/PvP/PvP.h b/src/server/scripts/Custom/PvP/PvP.h
new file mode 100644
index 0000000..9eb685e
--- /dev/null
+++ b/src/server/scripts/Custom/PvP/PvP.h
@@ -0,0 +1,49 @@
+#define FACTION_DUEL 10000
+#define GUILD_DUEL 20000
+
+enum PvPTypes
+{
+	PVP_TYPE_NONE = 0,	//ä¿æåç¶
+	PVP_TYPE_SANCTUARY = 1,	//å®å¨åº
+	PvP_TYPE_FFA = 2,	//FFAPVP
+	PvP_TYPE_NO_GROUP_FFA = 3,	//ç¦æ­¢ç»éFFAPVP
+	PvP_TYPE_CUSTOM_FACTION = 4,	//èªå®ä¹éµè¥
+	PvP_TYPE_GUILD = 5,//å¬ä¼
+};
+
+struct PvPTemplate
+{
+	uint32 zone;
+	uint32 area;
+	PvPTypes type;
+	std::string prefix;
+	std::string notice;
+	uint32 minHp;
+	uint32 maxHp;
+	uint32 killRewId;
+	uint32 killedRewId;
+	std::vector<uint32> eventData;
+	bool autoMaxHp;
+};
+
+extern std::vector<PvPTemplate> PvPVec;
+
+class PvP
+{
+public:
+	static PvP* instance()
+	{
+		static PvP instance;
+		return &instance;
+	}
+	void Load();
+	PvPTypes GetType(uint32 zone, uint32 area);
+	bool EnableGroup(uint32 zone, uint32 area);
+	void Update(Player* player, uint32 zone, uint32 area);
+	uint32 GetMinHp(uint32 zone, uint32 area);
+	uint32 GetMaxHp(uint32 zone, uint32 area);
+	bool AutoMaxHP(uint32 zone, uint32 area);
+	void RewOnKill(Player *pKiller, Player *pVictim);
+private:
+};
+#define sPvP PvP::instance()
diff --git a/src/server/scripts/Custom/Quest/QuestMod.cpp b/src/server/scripts/Custom/Quest/QuestMod.cpp
new file mode 100644
index 0000000..f41e11d
--- /dev/null
+++ b/src/server/scripts/Custom/Quest/QuestMod.cpp
@@ -0,0 +1,268 @@
+#pragma execution_character_set("utf-8")
+#include "../CommonFunc/CommonFunc.h"
+#include "../FunctionCollection/FunctionCollection.h"
+#include "../Reward/Reward.h"
+#include "../Requirement/Requirement.h"
+#include "QuestMod.h"
+#include "../CustomEvent/Event.h"
+#include "Language.h"
+
+std::unordered_map<uint32, QuestModTemplate> QuestModMap;
+std::unordered_map<uint32, float> QuestRandomMap;
+
+void QuestMod::Load()
+{
+	QuestModMap.clear();
+	QuestRandomMap.clear();
+
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+		//			0	1				2					3			4				5				6				7			8				9		10				11
+		"SELECT ÈÎÎñID,½ÓÊÜÈÎÎñÐèÇóÄ£°åID,ÊÇ·ñÏûºÄÐèÇó, ÈÎÎñ´«ËÍ×ø±êID, Ëæ»ú½±ÀøÄ£°åID1,Ëæ»ú½±ÀøÄ£°åID2,Ëæ»ú½±ÀøÄ£°åID3,Ëæ»ú½±ÀøÄ£°åID4,Ëæ»ú½±Àø¼¸ÂÊ1,Ëæ»ú½±Àø¼¸ÂÊ2,Ëæ»ú½±Àø¼¸ÂÊ3,Ëæ»ú½±Àø¼¸ÂÊ4 FROM _ÈÎÎñ" :
+		//			0	1		2				3			4				5		6		7			8		9			10			11
+		"SELECT questId,reqId,desReq,telePosId,randomRewId1,randomRewId2,randomRewId3,randomRewId4,rewChance1,rewChance2,rewChance3,rewChance4 FROM _quest_mod");
+
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			QuestModTemplate QuestModTemp;
+			uint32 questId			= fields[0].GetUInt32();
+			QuestModTemp.reqId		= fields[1].GetUInt32();
+			QuestModTemp.desReq		= fields[2].GetBool();
+			QuestModTemp.telePosId	= fields[3].GetUInt32();
+
+			for (size_t i = 0; i < MAX_QUEST_MOD_REW_COUNT; i++)
+				QuestModTemp.randomRewId[i] = fields[4 + i].GetUInt32();
+
+			for (size_t i = 0; i < MAX_QUEST_MOD_REW_COUNT; i++)
+				QuestModTemp.rewChance[i] = fields[8 + i].GetUInt32();
+			
+			QuestModMap.insert(std::make_pair(questId, QuestModTemp));
+		} while (result->NextRow());
+	}
+
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+		"SELECT ÈÎÎñID,½Óµ½¼¸ÂÊ FROM _ÈÎÎñ_Ëæ»úÅäÖÃ" :
+		"SELECT questId,chance FROM _quest_random");
+
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 questId = fields[0].GetUInt32();
+			float chance = fields[1].GetFloat();
+			Quest const* quest = sObjectMgr->GetQuestTemplate(questId);
+			if (!quest)
+				continue;
+			QuestRandomMap.insert(std::make_pair(questId, chance));
+		} while (result->NextRow());
+	}
+}
+
+void QuestMod::AddTeleGossip(Player* player, Object* obj)
+{
+	for (auto itr = QuestModMap.begin(); itr != QuestModMap.end(); itr++)
+	{
+		Quest const* quest = sObjectMgr->GetQuestTemplate(itr->first);
+
+		if (quest && player->IsActiveQuest(itr->first) && itr->second.telePosId != 0)
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, quest->GetTitle(), SENDER_QUEST_TELE, quest->GetQuestId());
+	}
+
+	if (obj->ToCreature())
+		player->SEND_GOSSIP_MENU(obj->GetEntry(), obj->GetGUID());
+	else
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+}
+
+
+void QuestMod::Tele(Player* player, uint32 questId)
+{
+	auto itr = QuestModMap.find(questId);
+
+	if (itr != QuestModMap.end())
+	{
+		auto it = PosMap.find(itr->second.telePosId);
+
+		if (it != PosMap.end())
+			player->TeleportTo(it->second.map, it->second.x, it->second.y, it->second.z, it->second.o);
+	}
+}
+
+bool QuestMod::CanTakeQuest(Player* player, uint32 questId)
+{
+	auto itr = QuestModMap.find(questId);
+
+	if (itr != QuestModMap.end())
+	{
+		if (sReq->Check(player, itr->second.reqId))
+		{
+			if (itr->second.desReq)
+				sReq->Des(player, itr->second.reqId);
+
+			return true;
+		}
+		else
+			return false;
+	}
+
+	return true;
+}
+
+void QuestMod::RandomReward(Player* player, uint32 questId)
+{
+	auto itr = QuestModMap.find(questId);
+
+	if (itr != QuestModMap.end())
+	{
+		for (size_t i = 0; i < MAX_QUEST_MOD_REW_COUNT; i++)
+			if (CanRandomReward(itr->second.rewChance[i]))
+				sRew->Rew(player, itr->second.randomRewId[i]);
+	}
+}
+
+bool QuestMod::CanRandomReward(uint32 chance)
+{
+	if (urand(1, 100) <= chance)
+		return true;
+
+	return false;
+}
+
+
+std::string QuestMod::GetExtraDes(uint32 questId, Player* player)
+{
+	auto itr = QuestModMap.find(questId);
+
+	if (itr != QuestModMap.end())
+	{
+		std::ostringstream oss;
+
+		if (sReq->IsExist(itr->second.reqId))
+		{
+			if (itr->second.desReq)
+				oss << "\n\n|cFF660066¡¸½ÓÊÜÈÎÎñÐèÒªÂú×ã²¢ÏûºÄ¡¹|r\n\n";
+			else
+				oss << "\n\n|cFF660066¡¸½ÓÊÜÈÎÎñÐèÒªÂú×ã¡¹|r\n\n";
+
+			oss << sReq->GetDescription(itr->second.reqId, player);
+		}
+
+		for (size_t i = 0; i < MAX_QUEST_MOD_REW_COUNT; i++)
+		{
+			if (sRew->IsExist(itr->second.randomRewId[i]) && itr->second.rewChance[i] > 0)
+			{
+				oss << "\n\n|cFF0000FF¡¸Íê³ÉÈÎÎñÓÐ";
+				oss << itr->second.rewChance[i];
+				oss << "%¼¸ÂÊ»ñµÃ¡¹|r\n\n";
+				oss << sRew->GetDescription(itr->second.randomRewId[i], true);
+			}
+		}
+
+		return oss.str();
+	}
+
+	return "";
+}
+
+bool QuestMod::AddRandomQuest(Player* player)
+{
+	if (QuestRandomMap.empty())
+	{
+		sLog->outString("_quest_randomÎ´ÅäÖÃËæ»úÈÎÎñ");
+		return false;
+	}
+
+
+	std::unordered_map<uint32, float> randomMap;
+
+	uint32 count = 1;
+
+	for (auto it = QuestRandomMap.begin(); it != QuestRandomMap.end(); it++)
+	{
+		QuestStatusMap::iterator itr = player->getQuestStatusMap().find(it->first);
+
+		if (itr != player->getQuestStatusMap().end())
+		{
+			if (itr->second.Status != QUEST_STATUS_REWARDED)
+				count++;
+			else
+				randomMap.insert(std::make_pair(it->first, it->second));
+		}
+		else
+			randomMap.insert(std::make_pair(it->first, it->second));
+	}
+
+	std::ostringstream oss;
+
+	if (count > MAX_RANDOM_QUEST_COUNT)
+	{
+		oss << "Äã²»ÄÜÁìÈ¡¸ü¶àËæ»úÈÎÎñ (" << MAX_RANDOM_QUEST_COUNT << "/" << MAX_RANDOM_QUEST_COUNT << ")";
+		player->GetSession()->SendNotification(oss.str().c_str());
+		return false;
+	}
+
+	uint32 questId = 0;
+
+	std::vector<std::pair<int, float>> vtMap;
+	for (auto it = randomMap.begin(); it != randomMap.end(); it++)
+		vtMap.push_back(std::make_pair(it->first, it->second));
+
+	sort(vtMap.begin(), vtMap.end(),
+		[](const std::pair<int, float> &x, const std::pair<int, float> &y) -> int {
+		return x.second < y.second;
+	});
+
+	float sum = 0;
+
+	for (auto it = vtMap.begin(); it != vtMap.end(); it++)
+		sum += it->second;
+
+	float rand = frand(0, sum);
+
+	sum = 0;
+
+	for (auto it = vtMap.begin(); it != vtMap.end(); it++)
+	{
+		sum += it->second;
+		if (rand < sum)
+		{
+			questId = it->first;
+			break;
+		}
+	}
+
+	//uint32 questId = filterVec[urand(0, filterVec.size() - 1)];
+
+	Quest const* quest = sObjectMgr->GetQuestTemplate(questId);
+
+	if (!quest)
+		return false;
+
+	ItemTemplateContainer const* itc = sObjectMgr->GetItemTemplateStore();
+	ItemTemplateContainer::const_iterator result = find_if(itc->begin(), itc->end(), Finder<uint32, ItemTemplate>(questId, &ItemTemplate::StartQuest));
+
+	if (result != itc->end())
+	{
+		ChatHandler(player->GetSession()).PSendSysMessage(LANG_COMMAND_QUEST_STARTFROMITEM, questId, result->second.ItemId);
+		return false;
+	}
+
+	if (player->CanAddQuest(quest, true))
+		player->AddQuestAndCheckCompletion(quest, NULL);
+
+	oss.str("");
+	oss << "ÁìÈ¡Ëæ»úÈÎÎñ [" << quest->GetTitle() << "] (" << count << "/" << MAX_RANDOM_QUEST_COUNT << ")";
+	player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+
+	return true;
+}
+
+void QuestMod::AddAllRandomQuest(Player* player)
+{
+	for (size_t i = 0; i < MAX_RANDOM_QUEST_COUNT; i++)
+		if (!AddRandomQuest(player))
+			break;
+}
diff --git a/src/server/scripts/Custom/Quest/QuestMod.h b/src/server/scripts/Custom/Quest/QuestMod.h
new file mode 100644
index 0000000..3b8da06
--- /dev/null
+++ b/src/server/scripts/Custom/Quest/QuestMod.h
@@ -0,0 +1,40 @@
+#define MAX_QUEST_MOD_REW_COUNT 4
+#define MAX_RANDOM_QUEST_COUNT 5
+
+//ä»»å¡åºåä¼ é
+struct QuestModTemplate
+{
+	uint32 reqId;
+	bool desReq;
+	uint32 randomRewId[MAX_QUEST_MOD_REW_COUNT];
+	uint32 rewChance[MAX_QUEST_MOD_REW_COUNT];
+	uint32 telePosId;
+};
+extern std::unordered_map<uint32, QuestModTemplate> QuestModMap;
+
+extern std::unordered_map<uint32, float> QuestRandomMap;
+
+class QuestMod
+{
+public:
+	static QuestMod* instance()
+	{
+		static QuestMod instance;
+		return &instance;
+	}
+	void Load();
+	void Tele(Player* player,uint32 questId);
+	void AddTeleGossip(Player* player, Object* obj);
+
+	bool CanTakeQuest(Player* player, uint32 questId);
+	void RandomReward(Player* player, uint32 questId);
+	bool CanRandomReward(uint32 chance);
+
+	std::string GetExtraDes(uint32 questId, Player* player);
+
+	bool AddRandomQuest(Player* player);
+	void AddAllRandomQuest(Player* player);
+private:
+
+};
+#define sQuestMod QuestMod::instance()
diff --git a/src/server/scripts/Custom/Quest/QuestScripts.cpp b/src/server/scripts/Custom/Quest/QuestScripts.cpp
new file mode 100644
index 0000000..603b000
--- /dev/null
+++ b/src/server/scripts/Custom/Quest/QuestScripts.cpp
@@ -0,0 +1,278 @@
+#pragma execution_character_set("utf-8")
+#include "../PrecompiledHeaders/ScriptPCH.h"
+#include "../CommonFunc/CommonFunc.h"
+
+
+class NPC_Quest : public CreatureScript
+{
+public:
+	NPC_Quest() : CreatureScript("NPC_Quest") { }
+	struct NPC_QuestAI : public ScriptedAI
+	{
+		NPC_QuestAI(Creature* creature) : ScriptedAI(creature) {}
+
+		void Reset() override {}
+		void UpdateAI(uint32 diff) override
+		{
+
+		}
+	};
+	CreatureAI* GetAI(Creature* creature) const
+	{
+		return new NPC_QuestAI(creature);
+	}
+	//½ÓÊÜÈÎÎñ
+	bool OnQuestAccept(Player* player, Creature* creature, Quest const* quest)
+	{
+		switch (quest->GetQuestId())
+		{
+		break;
+		//ôä´äËÄÁú
+		case 100001:
+			player->SetPhaseMask(1, true);//chatHandler.cpp /sleep
+			player->RemoveAura(35838);
+			break;
+		default:
+			break;
+		}
+		return false;
+	}
+	//Íê³ÉÈÎÎñ
+	bool OnQuestReward(Player* player, Creature* creature, Quest const* quest, uint32)
+	{
+		switch (quest->GetQuestId())
+		{
+			//ôä´äËÄÁú
+		case 100001:
+			player->SetPhaseMask(1, true);
+			player->RemoveAura(35838);
+			break;
+		default:
+			break;
+		}
+		return true;
+	}
+};
+
+//³éÈ¡ÃÎ÷ÊÈÎÎñ
+
+enum Events
+{
+	EVENT_CALL_Y = 1,
+
+	EVENT_Y_SAY1 = 2,//ÒÁÀ¼Äá¿âË¹:½Æ»«µÄ¾«Áé£¬ÄãÃÇÉèÏÂ¿É¶ñµÄÈ¦Ì×·âÓ¡ÁËÎÒ£¬ÏÖÔÚÓÖÒªÀ´È¡Ð¦ÎÒµÄÃ´£¿ÃÎ÷Ê±©¾ý¾ø²»»á¶ÔÄãÃÇ±°¹ªÇüÏ¥£¡
+	EVENT_REMULUS_SAY1 = 3,//ÊØ»¤ÕßÀ×Ä·ÂåË¹£ºÒÁÀ¼Äá¿âË¹£¬ÄãÔøÓÃÃÎ÷ÊÖ®Á¦ÕÛÄ¥ÁËÎÞÊýÎÞ¹¼µÄÊÜº¦Õß£¬ÕâÊÇ¶ÔÄãÓ¦ÓÐµÄ³Í·££¬ÏÖÔÚ£¬ÄãÓÐÒ»¸ö×ÔÎÒ¾ÈÊêµÄ»ú»á
+	EVENT_REMULUS_SAY2 = 4, //ÊØ»¤ÕßÀ×Ä·ÂåË¹£ºÄã±ØÐë´ÓÕâ°Ñ½£ÖÐÍêÈ«³éÈ¡³ö²Ð´æµÄÃÎ÷ÊÓ¡¼Ç£¬²¢·¢ÊÄ²»ÔÙ²Ðº¦°¬ÔóÀ­Ë¹µÄÎÞ¹¼ÉúÃü£¬·ñÔòÎÒ½«ÈÃÄãÏÝÈëÓÀ¾ÃµÄ³ÁË¯¡£
+	EVENT_Y_SAY2 = 5,//ÒÁÀ¼Äá¿âË¹:ÎÒ¡­´ðÓ¦ÄãµÄÒªÇó£¬µ«Õâ¸öÊÄÑÔÖÐ²»°üÀ¨¶ÔÄãµÄ³ðºÞ£¬ÎÒÒ»¶¨»áÈÃÄã¸¶³ö´ú¼ÛµÄ£¡
+	EVENT_REMULUS_SAY3 = 6, //ÊØ»¤ÕßÀ×Ä·ÂåË¹£ºÎÒÍ¬Òâ£¬ÎÒ»áÔÚÕâÒ»Ö±µÈ×ÅÄã¡£ÄÇÃ´£¬¿ªÊ¼°É
+
+	EVENT_HOLD_SWORD = 7,
+	EVENT_CLEAN_SOWRD = 8,
+	EVENT_CALL_4_DK = 9,
+
+	//¿â¶ûËþ×È¹«¾ô960020 Å®²®¾ô²¼ÀÍçÑ¿ËË¹960021 ÉªÀïÒ®¿Ë¾ôÊ¿960022 ÈðÎÄ´÷¶ûÄÐ¾ô960023 ÒÁÀ¼Äá¿âË¹960016
+	EVENT_K_SAY = 10,
+	EVENT_N_SAY = 11,
+	EVENT_S_SAY = 12,
+	EVENT_R_SAY1 = 13,
+	EVENT_Y_SAY3 = 14,
+	EVENT_R_SAY2 = 15,
+	EVENT_R_SAY3 = 16,
+	EVENT_Y_SAY4 = 17,
+	EVENT_KILL_4_DK = 18,
+	EVENT_Y_LEAVE = 19,
+	EVENT_DONE = 20
+
+};
+
+bool PureSwordStartFlag = false;
+
+class npc_remulus : public CreatureScript
+{
+public:
+	npc_remulus() : CreatureScript("npc_remulus") { }
+
+
+	bool OnGossipHello(Player *player, Creature *creature)
+	{
+		if (PureSwordStartFlag) return true;
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "ÈÃÎÒÃÇ¿ªÊ¼", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
+		player->SEND_GOSSIP_MENU(player->GetGossipTextId(creature), creature->GetGUID());
+		return true;
+	}
+	bool OnGossipSelect(Player *player, Creature *creature, uint32 sender, uint32 action)
+	{
+		player->PlayerTalkClass->ClearMenus();
+		PureSwordStartFlag = true;
+		player->CLOSE_GOSSIP_MENU();
+		return true;
+	}
+	struct npc_remulusAI : public ScriptedAI
+	{
+		npc_remulusAI(Creature* creature) : ScriptedAI(creature) {}
+
+		Creature *k, *n, *s, *r, *y;//¿â¶ûËþ×È¹«¾ô960020 Å®²®¾ô²¼ÀÍçÑ¿ËË¹960021 ÉªÀïÒ®¿Ë¾ôÊ¿960022 ÈðÎÄ´÷¶ûÄÐ¾ô960023 ÒÁÀ¼Äá¿âË¹960016
+
+
+		void Reset() override
+		{
+
+		}
+		void UpdateAI(uint32 diff) override
+		{
+			if (PureSwordStartFlag)
+			{
+				PureSwordStartFlag = false;
+				_events.ScheduleEvent(EVENT_CALL_Y, 2000);
+				sWorld->SendGlobalText("ÊÂ¼þ¿ªÊ¼", NULL);
+			}
+			_events.Update(diff);
+
+			while (uint32 eventId = _events.ExecuteEvent())
+			{
+				switch (eventId)
+				{
+				case EVENT_CALL_Y:
+					y = me->SummonCreature(960016, me->GetPositionX(), me->GetPositionY() + 100, me->GetPositionZ() + 70, 0, TEMPSUMMON_TIMED_DESPAWN, 180000);
+					if (y)
+					{
+						y->GetMotionMaster()->MovePoint(0, me->GetPositionX(), me->GetPositionY() + 40, me->GetPositionZ() + 15, false);
+					}
+					_events.ScheduleEvent(EVENT_Y_SAY1, 16000);
+					break;
+				case EVENT_Y_SAY1:
+					if (y = me->FindNearestCreature(960016, 200.0f))
+					{
+						y->MonsterYell("ÊÇË­ÔÚÕÙ»½ÎÒ£¿", LANG_UNIVERSAL, NULL);
+						y->MonsterSay("½Æ»«µÄ¾«Áé£¬ÄãÃÇÉèÏÂ¿É¶ñµÄÈ¦Ì×·âÓ¡ÁËÎÒ£¬ÏÖÔÚÓÖÒªÀ´È¡Ð¦ÎÒµÄÃ´£¿ÃÎ÷Ê±©¾ý¾ø²»»á¶ÔÄãÃÇ±°¹ªÇüÏ¥£¡", LANG_UNIVERSAL, NULL);
+
+					}
+					me->AddAura(63771, me);
+					_events.ScheduleEvent(EVENT_REMULUS_SAY1, 5000);
+					break;
+				case EVENT_REMULUS_SAY1:
+					me->MonsterSay("ÒÁÀ¼Äá¿âË¹£¬ÄãÔøÓÃÃÎ÷ÊÖ®Á¦ÕÛÄ¥ÁËÎÞÊýÎÞ¹¼µÄÊÜº¦Õß£¬ÕâÊÇ¶ÔÄãÓ¦ÓÐµÄ³Í·££¬ÏÖÔÚ£¬ÄãÓÐÒ»¸ö×ÔÎÒ¾ÈÊêµÄ»ú»á¡£", LANG_UNIVERSAL, NULL);
+					_events.ScheduleEvent(EVENT_REMULUS_SAY2, 5000);
+					break;
+				case EVENT_REMULUS_SAY2:
+					me->MonsterSay("Äã±ØÐë´ÓÕâ°Ñ½£ÖÐÍêÈ«³éÈ¡³ö²Ð´æµÄÃÎ÷ÊÓ¡¼Ç£¬²¢·¢ÊÄ²»ÔÙ²Ðº¦°¬ÔóÀ­Ë¹µÄÎÞ¹¼ÉúÃü£¬·ñÔòÎÒ½«ÈÃÄãÏÝÈëÓÀ¾ÃµÄ³ÁË¯¡£", LANG_UNIVERSAL, NULL);
+					_events.ScheduleEvent(EVENT_Y_SAY2, 5000);
+					break;
+				case EVENT_Y_SAY2:
+					if (y = me->FindNearestCreature(960016, 200.0f))
+						y->MonsterSay("ÎÒ¡­´ðÓ¦ÄãµÄÒªÇó£¬µ«Õâ¸öÊÄÑÔÖÐ²»°üÀ¨¶ÔÄãµÄ³ðºÞ£¬ÎÒÒ»¶¨»áÈÃÄã¸¶³ö´ú¼ÛµÄ£¡", LANG_UNIVERSAL, NULL);
+					_events.ScheduleEvent(EVENT_REMULUS_SAY3, 5000);
+					break;
+				case EVENT_REMULUS_SAY3:
+					me->MonsterSay("ÎÒÍ¬Òâ£¬ÎÒ»áÔÚÕâÒ»Ö±µÈ×ÅÄã¡£ÄÇÃ´£¬¿ªÊ¼°É¡£", LANG_UNIVERSAL, NULL);
+					_events.ScheduleEvent(EVENT_CLEAN_SOWRD, 5000);
+					break;
+				case EVENT_CLEAN_SOWRD:
+				{
+					me->SummonCreature(960019, me->GetPositionX() + 1.5, me->GetPositionY() + 1, me->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 15000);
+					me->SummonCreature(960019, me->GetPositionX() + 1.5, me->GetPositionY() + 1, me->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 15000);
+
+					std::list<Creature*> triggerlist;
+					me->GetCreatureListWithEntryInGrid(triggerlist, 960019, 200.0f);
+
+					for (std::list<Creature*>::iterator itr = triggerlist.begin(); itr != triggerlist.end(); ++itr)
+					{
+						if (Creature* target = (*itr)->FindNearestCreature(960016, 200.0f))
+							(*itr)->CastSpell(target, 43151);
+					}
+				}
+				_events.ScheduleEvent(EVENT_CALL_4_DK, 18000);
+				break;
+				case EVENT_CALL_4_DK:
+
+					//¿â¶ûËþ×È¹«¾ô960020 Å®²®¾ô²¼ÀÍçÑ¿ËË¹960021 ÉªÀïÒ®¿Ë¾ôÊ¿960022 ÈðÎÄ´÷¶ûÄÐ¾ô960023 ÒÁÀ¼Äá¿âË¹960016
+
+					me->SummonCreature(960020, me->GetPositionX() + 3, me->GetPositionY() + 15, me->GetPositionZ(), me->GetOrientation(), TEMPSUMMON_TIMED_DESPAWN, 120000);
+					me->SummonCreature(960021, me->GetPositionX() + 1, me->GetPositionY() + 15, me->GetPositionZ(), me->GetOrientation(), TEMPSUMMON_TIMED_DESPAWN, 120000);
+					me->SummonCreature(960022, me->GetPositionX() - 1, me->GetPositionY() + 15, me->GetPositionZ(), me->GetOrientation(), TEMPSUMMON_TIMED_DESPAWN, 120000);
+					me->SummonCreature(960023, me->GetPositionX() - 3, me->GetPositionY() + 16, me->GetPositionZ(), me->GetOrientation(), TEMPSUMMON_TIMED_DESPAWN, 120000);
+					_events.ScheduleEvent(EVENT_K_SAY, 5000);
+					break;
+				case EVENT_K_SAY:
+					if (k = me->FindNearestCreature(960020, 200.0f))
+						k->MonsterSay("ÖÕÓÚ³öÀ´ÁË£¬ÎÒ¶¼±»Ê¥¹âÖ®Á¦Ñ¹ÆÈµÄÊÜ²»ÁËÁË¡£", LANG_UNIVERSAL, NULL);
+					_events.ScheduleEvent(EVENT_N_SAY, 5000);
+					break;
+				case EVENT_N_SAY:
+					if (n = me->FindNearestCreature(960021, 200.0f))
+						n->MonsterSay("¸ÃËÀµÄ£¬ÊÇË­¾»»¯ÁË»Ò½ýÊ¹Õß£¡", LANG_UNIVERSAL, NULL);
+					_events.ScheduleEvent(EVENT_S_SAY, 5000);
+					break;
+				case EVENT_S_SAY:
+					if (s = me->FindNearestCreature(960022, 200.0f))
+						s->MonsterSay("ÎÒÒª°ÇÁËÄÇ¼Ò»ïµÄÆ¤ÓÃÀ´×°ÊÎÎÒµÄÂí°°£¡", LANG_UNIVERSAL, NULL);
+					_events.ScheduleEvent(EVENT_R_SAY1, 5000);
+					break;
+				case EVENT_R_SAY1:
+					if (r = me->FindNearestCreature(960023, 200.0f))
+						r->MonsterSay("¶¼±ðËµÁË£¬¿´¿´ÑÛÇ°µÄÊÇË­£¬ÃÎ÷Ê±©¾ý¡ªÒÁÀ¼Äá¿âË¹£¬ÎªÊ²Ã´ÎÒÃÇ»áÔÚÕâÀï£¬ÄãÓÖÊÇÀ´¸ÉÊ²Ã´µÄ¡£", LANG_UNIVERSAL, NULL);
+					_events.ScheduleEvent(EVENT_Y_SAY3, 5000);
+					break;
+				case EVENT_Y_SAY3:
+					if (y = me->FindNearestCreature(960016, 200.0f))
+						y->MonsterSay("ÕæÊÇÓÞ´ÀÍ¸¶¥£¬ÄãÃÇÖ»²»¹ýÊÇÄÇËÄ¸ö·ÏÎï²Ð´æµÄÒâÊ¶°ÕÁË£¬ÊÇÊ±ºòÁË½áÕâ¼þÊÂÁË¡£", LANG_UNIVERSAL, NULL);
+					_events.ScheduleEvent(EVENT_R_SAY2, 5000);
+					break;
+				case EVENT_R_SAY2:
+					if (r = me->FindNearestCreature(960023, 200.0f))
+						r->MonsterSay("ÄãÒÑ¾­±³ÅÑÁËÌìÔÖ¾üÍÅÃ´£¿Î×ÑýÍõ²»»á·Å¹ýÄãµÄ¡£", LANG_UNIVERSAL, NULL);
+					_events.ScheduleEvent(EVENT_Y_SAY4, 5000);
+					break;
+				case EVENT_Y_SAY4:
+					if (y = me->FindNearestCreature(960016, 200.0f))
+						y->MonsterSay("ÄãÃÇÖ»²»¹ýÊÇµ±³õÎÒ´ÍÓèÄãÃÇÖ÷×ÓµÄÒ»Ë¿ÃÎ÷ÊÖ®Á¦°ÕÁË£¬Õâ¸ù±¾Ëã²»ÉÏ±³ÅÑ£¬ÎÒÖ»²»¹ýÊÇ°ÑÁ¦Á¿ÊÕ»Ø¶øÒÑ¡£ÌìÆôËÄÆïÊ¿µÄÁ¦Á¿»á½øÒ»²½±»Ï÷Èõ¡£", LANG_UNIVERSAL, NULL);
+					_events.ScheduleEvent(EVENT_KILL_4_DK, 5000);
+					break;
+				case EVENT_KILL_4_DK:
+					if (y = me->FindNearestCreature(960016, 200.0f))
+					{
+						if (k = me->FindNearestCreature(960020, 200.0f)) k->setDeathState(JUST_DIED);
+						if (n = me->FindNearestCreature(960021, 200.0f))
+						{
+							y->CastSpell(n, 74768);
+							n->CastSpell(n, 67043);
+							n->setDeathState(JUST_DIED);
+						}
+						if (s = me->FindNearestCreature(960022, 200.0f)) s->setDeathState(JUST_DIED);
+						if (r = me->FindNearestCreature(960023, 200.0f)) r->setDeathState(JUST_DIED);
+					}
+					_events.ScheduleEvent(EVENT_Y_LEAVE, 2000);
+					break;
+				case EVENT_Y_LEAVE:
+					if (y = me->FindNearestCreature(960016, 200.0f))
+					{
+						y->MonsterYell("Ø¬ÃÎÓÀ²»ÖÕ½á...", LANG_UNIVERSAL, NULL);
+						y->RemoveFromWorld();
+					}
+					_events.ScheduleEvent(EVENT_DONE, 5000);
+					break;
+				case EVENT_DONE:
+					me->MonsterYell("´ø×ÅÄãµÄ×Ô¸ºÓÀÔ¶Àë¿ªÕâ¸öÊÀ½ç£¡", LANG_UNIVERSAL, NULL);
+					me->RemoveAura(63771);
+					sWorld->SendGlobalText("ÊÂ¼þ½áÊø", NULL);
+					break;
+				default:
+					break;
+				}
+			}
+		}
+	private:
+		EventMap _events;
+	};
+	CreatureAI* GetAI(Creature* creature) const
+	{
+		return new npc_remulusAI(creature);
+	}
+};
+
+
+void AddSC_Quest_Scripts()
+{
+	new NPC_Quest();
+	new npc_remulus();
+}
diff --git a/src/server/scripts/Custom/QuickResponse/QuickResponse.cpp b/src/server/scripts/Custom/QuickResponse/QuickResponse.cpp
new file mode 100644
index 0000000..c09cc9a
--- /dev/null
+++ b/src/server/scripts/Custom/QuickResponse/QuickResponse.cpp
@@ -0,0 +1,184 @@
+#pragma execution_character_set("utf-8")
+#include "QuickResponse.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../Reward/Reward.h"
+#include "../Switch/Switch.h"
+#include "../CustomEvent/Event.h"
+
+std::vector<QuickResponseTemplate> QuickResponseVec;
+std::vector<uint32/*guid*/> QuickResponsePlayerVec;
+std::vector<uint32 /*guid*/> CorrectResponsePlayerVec;
+
+
+void QuickResponse::Load()
+{
+	QuickResponseVec.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ½±ÀøÄ£°åID,ÎÊÌâÎÄ±¾,ÕýÈ·Ñ¡Ïî,Ñ¡ÏîA,Ñ¡ÏîB,Ñ¡ÏîC,Ñ¡ÏîD FROM __ÇÀ´ð" :
+		"SELECT rewId,question,correctAnswer,answerA,answerB,answerC,answerD FROM _quick_response");
+	if (!result) return;
+	do
+	{
+		Field* fields = result->Fetch();
+		QuickResponseTemplate Temp;
+		Temp.rewId			= fields[0].GetUInt32();
+		Temp.question		= fields[1].GetString();
+		Temp.correctAnswer	= fields[2].GetString();
+		Temp.answerA		= fields[3].GetString();
+		Temp.answerB		= fields[4].GetString();
+		Temp.answerC		= fields[5].GetString();
+		Temp.answerD		= fields[6].GetString();
+		QuickResponseVec.push_back(Temp);
+	} while (result->NextRow());
+
+	//³õÊ¼»¯
+	SetAnswerFlag(true);
+	SetAnswer("A");
+	SetRewId(0);
+}
+
+void QuickResponse::Anounce()
+{
+	uint32 len = QuickResponseVec.size();
+	uint32 urand_i = urand(0, len -1);
+
+	for (size_t i = 0; i < len; i++)
+	{
+		if (i == urand_i)
+		{
+			QuickResponsePlayerVec.clear();
+			CorrectResponsePlayerVec.clear();
+
+			SetAnswerFlag(false);
+			SetAnswer(QuickResponseVec[i].correctAnswer);
+			SetRewId(QuickResponseVec[i].rewId);
+
+			std::ostringstream ossQuestion;
+			ossQuestion << "|cFFFF1717[ÇÀ´ð]|r " << QuickResponseVec[i].question;
+			sWorld->SendServerMessage(SERVER_MSG_STRING, ossQuestion.str().c_str());
+
+			if (!QuickResponseVec[i].answerA.empty())
+			{
+				std::ostringstream oss;
+				oss << "|cFFFF1717[ÇÀ´ð]|r " << "[ A ] " << QuickResponseVec[i].answerA;
+				sWorld->SendServerMessage(SERVER_MSG_STRING, oss.str().c_str());
+			}
+
+			if (!QuickResponseVec[i].answerB.empty())
+			{
+				std::ostringstream oss;
+				oss << "|cFFFF1717[ÇÀ´ð]|r " << "[ B ] " << QuickResponseVec[i].answerB;
+				sWorld->SendServerMessage(SERVER_MSG_STRING, oss.str().c_str());
+			}
+
+			if (!QuickResponseVec[i].answerC.empty())
+			{
+				std::ostringstream oss;
+				oss << "|cFFFF1717[ÇÀ´ð]|r " << "[ C ] " << QuickResponseVec[i].answerC;
+				sWorld->SendServerMessage(SERVER_MSG_STRING, oss.str().c_str());
+			}
+
+			if (!QuickResponseVec[i].answerD.empty())
+			{
+				std::ostringstream oss;
+				oss << "|cFFFF1717[ÇÀ´ð]|r " << "[ D ] " << QuickResponseVec[i].answerD;
+				sWorld->SendServerMessage(SERVER_MSG_STRING, oss.str().c_str());
+			}
+			break;
+		}
+	}
+}
+
+void QuickResponse::Reward()
+{
+	if (CorrectResponsePlayerVec.empty())
+		return;
+
+	sQuickResponse->SetAnswerFlag(true);
+
+	for (std::vector<uint32>::iterator iter = CorrectResponsePlayerVec.begin(); iter != CorrectResponsePlayerVec.end(); ++iter)
+	{
+		Player* pl = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(*iter, 0, HIGHGUID_PLAYER));
+
+		if (pl)
+		{
+			sRew->Rew(pl, GetRewId());
+			std::ostringstream oss;
+			std::string nameLink, nameLinkWithColor;
+			sCF->GetNameLink(pl, nameLink, nameLinkWithColor);
+			oss << "|cFFFF1717[ÇÀ´ð]|r " << nameLinkWithColor << "ÇÀ´ðÕýÈ·,ÕæÊÇ²Å¸ß°Ë¶·£¡";
+			sWorld->SendServerMessage(SERVER_MSG_STRING, oss.str().c_str());
+		}
+
+	}
+
+	CorrectResponsePlayerVec.clear();
+}
+
+class QuickResponseScript : public CommandScript
+{
+public:
+	QuickResponseScript() : CommandScript("QuickResponseScript") { }
+
+	static bool HandleQuickResponseCommand(ChatHandler * pChat, const char * msg)
+	{
+		if (!*msg)
+			return true;
+
+		Player * player = pChat->GetSession()->GetPlayer();
+
+		if (!player)
+			return true;
+		
+		if (!sGameEventMgr->IsActiveEvent(EVENT_ID_QUICK_RESPONSE) || sQuickResponse->GetAnswerFlag())
+		{
+			player->GetSession()->SendAreaTriggerMessage("|cFFFF1717[ÇÀ´ð]|r ÒÑ½áÊø£¡");
+			return true;
+		}
+
+		if (std::find(QuickResponsePlayerVec.begin(), QuickResponsePlayerVec.end(), player->GetGUIDLow()) != QuickResponsePlayerVec.end())
+		{
+			player->GetSession()->SendAreaTriggerMessage("|cFFFF1717[ÇÀ´ð]|r ½ûÖ¹ÖØ¸´´ðÌâ£¡");
+			return true;
+		}
+		
+		std::string answer = msg;
+
+		std::transform(answer.begin(), answer.end(), answer.begin(), ::toupper);
+
+		if (strcmp(answer.c_str(), "A") != 0 && strcmp(answer.c_str(), "B") != 0 && strcmp(answer.c_str(), "C") != 0 && strcmp(answer.c_str(), "D") != 0)
+		{
+			ChatHandler(player->GetSession()).PSendSysMessage("|cFFFF1717[ÇÀ´ð]|r ÕýÈ·´ðÌâ¸ñÊ½Îª£º.qd A »ò .qd a");
+			return true;
+		}
+
+		QuickResponsePlayerVec.push_back(player->GetGUIDLow());
+
+		std::string correctAnswer = sQuickResponse->GetAnswer();
+
+		if (strcmp(correctAnswer.c_str(), answer.c_str()) == 0)
+		{
+			CorrectResponsePlayerVec.push_back(player->GetGUIDLow());
+
+			if (CorrectResponsePlayerVec.size() >= sSwitch->GetValue(ST_QUICK_RESPONSE))
+				sGameEventMgr->StopEvent(EVENT_ID_QUICK_RESPONSE, false, false);
+		}
+
+		return true;
+	}
+
+    std::vector<ChatCommand> GetCommands() const
+	{
+		static std::vector<ChatCommand> QuickResponseCommandTable =
+		{
+			{ "qd", SEC_PLAYER, true, &HandleQuickResponseCommand, "" }
+		};
+
+		return QuickResponseCommandTable;
+	}
+};
+
+void AddSC_QuickResponse()
+{
+	new QuickResponseScript();
+}
diff --git a/src/server/scripts/Custom/QuickResponse/QuickResponse.h b/src/server/scripts/Custom/QuickResponse/QuickResponse.h
new file mode 100644
index 0000000..300bdab
--- /dev/null
+++ b/src/server/scripts/Custom/QuickResponse/QuickResponse.h
@@ -0,0 +1,65 @@
+struct QuickResponseTemplate
+{
+	uint32 rewId;
+	std::string correctAnswer;
+	std::string question;
+	std::string answerA;
+	std::string answerB;
+	std::string answerC;
+	std::string answerD;
+};
+
+extern std::vector<QuickResponseTemplate> QuickResponseVec;
+
+extern std::vector<uint32/*guid*/> QuickResponsePlayerVec;
+
+extern std::vector<uint32 /*guid*/> CorrectResponsePlayerVec;
+
+class QuickResponse
+{
+public:
+	static QuickResponse* instance()
+	{
+		static QuickResponse instance;
+		return &instance;
+	}
+	void Load();
+	void Anounce();
+	bool GetAnswerFlag()
+	{
+		return _answereFlag;
+	}
+
+	void SetAnswerFlag(bool flag)
+	{
+		_answereFlag = flag;
+	}
+
+	void SetAnswer(std::string answer)
+	{
+		_answer = answer;
+	}
+
+	std::string GetAnswer()
+	{
+		return _answer;
+	}
+
+	void SetRewId(uint32 rewId)
+	{
+		_rewId = rewId;
+	}
+
+	uint32 GetRewId()
+	{
+		return _rewId;
+	}
+
+	void Reward();
+
+private:
+	std::string _answer;
+	bool _answereFlag;
+	uint32 _rewId;
+};
+#define sQuickResponse QuickResponse::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/RandomEnchant/RandomEnchant.cpp b/src/server/scripts/Custom/RandomEnchant/RandomEnchant.cpp
new file mode 100644
index 0000000..d6250f9
--- /dev/null
+++ b/src/server/scripts/Custom/RandomEnchant/RandomEnchant.cpp
@@ -0,0 +1,559 @@
+#pragma execution_character_set("utf-8")
+#include "RandomEnchant.h"
+#include "../ItemMod/ItemMod.h"
+#include "../Switch/Switch.h"
+#include "DisableMgr.h"
+#include "../ItemMod/NoPatchItem.h"
+
+std::vector<RandomEnchantTemplate> RandomEnchantVec;
+std::unordered_map<uint32, ExtractEnchantTemplate> ExtractEnchantMap;
+
+void RandomEnchant::Load()
+{
+	RandomEnchantVec.clear();
+
+	/*QueryResult result = WorldDatabase.PQuery("SELECT entry, enchantId from _random_enchant");
+
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			RandomEnchantTemplate Temp;
+			Temp.entry = fields[0].GetUInt32();
+			Temp.enchantId = fields[1].GetUInt32();
+			RandomEnchantVec.push_back(Temp);
+		} while (result->NextRow());
+	}*/
+
+	ExtractEnchantMap.clear();
+
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÎïÆ·ID, ÊÇ·ñ¿ÉÒÔÌáÈ¡¸½Ä§,ÊÇ·ñ¿ÉÒÔ¸²¸Ç¸½Ä§ from _ÎïÆ·_¸½Ä§ÌáÈ¡Óë¸²¸Ç" :
+		"SELECT entry, CanExtract,CanEnchant from _itemmod_extract_enchant");
+
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 entry = fields[0].GetUInt32();
+			ExtractEnchantTemplate Temp;
+			Temp.CanExtract = fields[1].GetBool();
+			Temp.CanEnchant = fields[2].GetBool();
+			ExtractEnchantMap.insert(std::make_pair(entry, Temp));
+		} while (result->NextRow());
+	}
+
+}
+
+void RandomEnchant::OnCreate(Item* item)
+{
+	if (item->GetTemplate()->Class != ITEM_CLASS_WEAPON && item->GetTemplate()->Class != ITEM_CLASS_ARMOR)
+		return;
+
+	if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(ON_CREATE_ENCHANT_ID))
+		item->SetEnchantment(PROP_ENCHANTMENT_SLOT_4, ON_CREATE_ENCHANT_ID, 0, 0);
+}
+
+bool RandomEnchant::Enchant(Player* owner, Item* castItem, Item* targetItem)
+{
+	if (targetItem->GetOwner() != owner)
+		return false;
+
+	if (ON_CREATE_ENCHANT_ID != targetItem->GetEnchantmentId(PROP_ENCHANTMENT_SLOT_4))
+		return false;
+
+	if (RandomEnchantVec.empty())
+		return false;
+
+	std::vector<uint32> vec;
+
+	for (size_t i = 0; i < RandomEnchantVec.size(); i++)
+		if (castItem->GetEntry() == RandomEnchantVec[i].entry)
+			if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(RandomEnchantVec[i].enchantId))
+				vec.push_back(RandomEnchantVec[i].enchantId);
+
+	if (vec.empty())
+		return false;
+
+	owner->ApplyEnchantment(targetItem, PROP_ENCHANTMENT_SLOT_4, false);
+	targetItem->SetEnchantment(PROP_ENCHANTMENT_SLOT_4, vec[urand(0, vec.size() - 1)], 0, 0);
+	owner->ApplyEnchantment(targetItem, PROP_ENCHANTMENT_SLOT_4, true);
+
+	return true;
+}
+
+class spell_random_enchant : public SpellScriptLoader
+{
+public:
+	spell_random_enchant() : SpellScriptLoader("spell_random_enchant") { }
+
+	class spell_random_enchant_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_random_enchant_SpellScript);
+
+		SpellCastResult CheckCast()
+		{
+			Player* owner = GetCaster()->ToPlayer();
+			Item* targetItem = GetExplTargetItem();
+			Item* castItem = GetCastItem();
+
+			if (!owner || !targetItem || !castItem)
+				return SPELL_FAILED_BAD_TARGETS;
+
+			if (!sRandomEnchant->Enchant(owner, castItem, targetItem))
+				return SPELL_FAILED_BAD_TARGETS;
+
+			return SPELL_CAST_OK;
+		}
+
+		void Register() override
+		{
+			OnCheckCast += SpellCheckCastFn(spell_random_enchant_SpellScript::CheckCast);
+		}
+	};
+
+	SpellScript* GetSpellScript() const override
+	{
+		return new spell_random_enchant_SpellScript();
+	}
+};
+
+class spell_extract_enchant : public SpellScriptLoader
+{
+public:
+	spell_extract_enchant() : SpellScriptLoader("spell_extract_enchant") { }
+
+	class spell_extract_enchant_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_extract_enchant_SpellScript);
+
+		SpellCastResult CheckCast()
+		{
+			Player* owner = GetCaster()->ToPlayer();
+			Item* targetItem = GetExplTargetItem();
+			Item* castItem = GetCastItem();
+
+			if (!owner || !targetItem || !castItem)
+				return SPELL_FAILED_BAD_TARGETS;
+
+			if (targetItem->GetEntry() == atoi(sSwitch->GetFlagByIndex(ST_ENCHANT_SCROLL, 1).c_str()))
+				return SPELL_FAILED_BAD_TARGETS;
+
+			std::unordered_map<uint32, ExtractEnchantTemplate>::iterator itr = ExtractEnchantMap.find(targetItem->GetEntry());
+
+			if (itr == ExtractEnchantMap.end())
+				return SPELL_FAILED_BAD_TARGETS;
+
+			if (!itr->second.CanExtract)
+				return SPELL_FAILED_BAD_TARGETS;
+				
+			std::vector<uint32> enchantIdVec;
+
+			for (uint8 i = PROP_ENCHANTMENT_SLOT_0; i < MAX_ENCHANTMENT_SLOT; i++)
+			{
+				uint32 enchantId = targetItem->GetEnchantmentId(EnchantmentSlot(i));
+				if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchantId))
+					enchantIdVec.push_back(enchantId);
+			}
+				
+			if (enchantIdVec.empty())
+				return SPELL_FAILED_BAD_TARGETS;
+
+			uint32 enchantId = enchantIdVec[urand(0, enchantIdVec.size() - 1)];
+
+			if (Item* item = sItemMod->AddItem(owner, atoi(sSwitch->GetFlagByIndex(ST_ENCHANT_SCROLL,1).c_str()), 1))
+				item->SetEnchantment(PROP_ENCHANTMENT_SLOT_0, enchantId, 0, 0);
+			else
+				return SPELL_FAILED_ITEM_NOT_READY;
+			
+			owner->DestroyItem(targetItem->GetBagSlot(), targetItem->GetSlot(), true);
+
+			return SPELL_CAST_OK;
+		}
+
+		void Register() override
+		{
+			OnCheckCast += SpellCheckCastFn(spell_extract_enchant_SpellScript::CheckCast);
+		}
+	};
+
+	SpellScript* GetSpellScript() const override
+	{
+		return new spell_extract_enchant_SpellScript();
+	}
+};
+
+class spell_extract_enchant_all : public SpellScriptLoader
+{
+public:
+	spell_extract_enchant_all() : SpellScriptLoader("spell_extract_enchant_all") { }
+
+	class spell_extract_enchant_all_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_extract_enchant_all_SpellScript);
+
+		SpellCastResult CheckCast()
+		{
+			Player* owner = GetCaster()->ToPlayer();
+			Item* targetItem = GetExplTargetItem();
+			Item* castItem = GetCastItem();
+
+			if (!owner || !targetItem || !castItem)
+				return SPELL_FAILED_BAD_TARGETS;
+
+			if (targetItem->GetEntry() == atoi(sSwitch->GetFlagByIndex(ST_ENCHANT_SCROLL, 2).c_str()))
+				return SPELL_FAILED_BAD_TARGETS;
+
+			std::unordered_map<uint32, ExtractEnchantTemplate>::iterator itr = ExtractEnchantMap.find(targetItem->GetEntry());
+
+			if (itr == ExtractEnchantMap.end())
+				return SPELL_FAILED_BAD_TARGETS;
+
+			if (!itr->second.CanExtract)
+				return SPELL_FAILED_BAD_TARGETS;
+
+			std::vector<uint32> enchantIdVec;
+
+			for (uint8 i = PROP_ENCHANTMENT_SLOT_0; i < MAX_ENCHANTMENT_SLOT; i++)
+			{
+				uint32 enchantId = targetItem->GetEnchantmentId(EnchantmentSlot(i));
+				if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchantId))
+					enchantIdVec.push_back(enchantId);
+			}
+
+			if (enchantIdVec.empty())
+				return SPELL_FAILED_BAD_TARGETS;
+
+			if (Item* item = sItemMod->AddItem(owner, atoi(sSwitch->GetFlagByIndex(ST_ENCHANT_SCROLL, 2).c_str()), 1))
+			{
+				for (uint32 i = 0; i < enchantIdVec.size(); i++)
+				{
+					item->SetEnchantment(EnchantmentSlot(PROP_ENCHANTMENT_SLOT_0 + i), enchantIdVec[i], 0, 0);
+				}
+			}
+			else
+				return SPELL_FAILED_ITEM_NOT_READY;
+
+			owner->DestroyItem(targetItem->GetBagSlot(), targetItem->GetSlot(), true);
+
+			return SPELL_CAST_OK;
+		}
+
+		void Register() override
+		{
+			OnCheckCast += SpellCheckCastFn(spell_extract_enchant_all_SpellScript::CheckCast);
+		}
+	};
+
+	SpellScript* GetSpellScript() const override
+	{
+		return new spell_extract_enchant_all_SpellScript();
+	}
+};
+
+
+class spell_override_enchant : public SpellScriptLoader
+{
+public:
+	spell_override_enchant() : SpellScriptLoader("spell_override_enchant") { }
+
+	class spell_override_enchant_SpellScript : public SpellScript
+	{
+		uint32 GetRandomEnchantId(std::vector<uint32> &enchantIdVec)
+		{
+			if (enchantIdVec.empty())
+				return 0;
+
+			uint32 i = urand(0, enchantIdVec.size() - 1);
+			uint32 enchantId = enchantIdVec[i];
+			enchantIdVec.erase(enchantIdVec.begin() + i);
+
+			return enchantId;
+		}
+
+
+		PrepareSpellScript(spell_override_enchant_SpellScript);
+
+		SpellCastResult CheckCast()
+		{
+			Player* owner = GetCaster()->ToPlayer();
+			Item* targetItem = GetExplTargetItem();
+			Item* castItem = GetCastItem();
+
+			if (!owner || !targetItem || !castItem)
+				return SPELL_FAILED_BAD_TARGETS;
+
+			std::unordered_map<uint32, ExtractEnchantTemplate>::iterator itr = ExtractEnchantMap.find(targetItem->GetEntry());
+
+			if (itr == ExtractEnchantMap.end())
+				return SPELL_FAILED_BAD_TARGETS;
+
+			if (!itr->second.CanEnchant)
+				return SPELL_FAILED_BAD_TARGETS;
+
+			//castItem
+			std::vector<uint32> enchantIdVec;
+
+			for (uint8 i = PROP_ENCHANTMENT_SLOT_0; i < MAX_ENCHANTMENT_SLOT; i++)
+			{
+				uint32 enchantId = castItem->GetEnchantmentId(EnchantmentSlot(i));
+				if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchantId))
+					enchantIdVec.push_back(enchantId);
+			}
+
+			if (enchantIdVec.empty())
+				return SPELL_FAILED_ITEM_NOT_READY;
+
+			std::vector<uint8> slotVec;
+
+			for (uint8 i = PROP_ENCHANTMENT_SLOT_0; i < MAX_ENCHANTMENT_SLOT; i++)
+			{
+				uint32 enchantId = targetItem->GetEnchantmentId(EnchantmentSlot(i));
+
+				if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchantId))
+					slotVec.push_back(i);
+			}
+
+			if (slotVec.empty())
+				return SPELL_FAILED_ITEM_NOT_READY;
+
+			owner->ApplyEnchantment(targetItem, false);
+
+			//Ò»ÌõÊôÐÔ Ëæ»ú¸²¸Ç
+			if (castItem->GetEntry() == atoi(sSwitch->GetFlagByIndex(ST_ENCHANT_SCROLL, 1).c_str()))
+			{
+				
+				uint8 slot = slotVec[urand(0, slotVec.size() - 1)];
+				targetItem->SetEnchantment(EnchantmentSlot(slot), enchantIdVec[0], 0, 0);
+			}
+
+			//È«²¿ÊôÐÔ È«²¿¸²¸Ç
+			if (castItem->GetEntry() == atoi(sSwitch->GetFlagByIndex(ST_ENCHANT_SCROLL, 2).c_str()))
+			{
+				for (uint8 i = PROP_ENCHANTMENT_SLOT_0; i < MAX_ENCHANTMENT_SLOT; i++)
+					targetItem->SetEnchantment(EnchantmentSlot(i), 0, 0, 0);
+
+				for (uint32 i = 0; i < enchantIdVec.size(); i++)
+					targetItem->SetEnchantment(EnchantmentSlot(i + PROP_ENCHANTMENT_SLOT_0), enchantIdVec[i], 0, 0);	
+			}
+
+			owner->ApplyEnchantment(targetItem, true);
+			return SPELL_CAST_OK;
+		}
+
+		void Register() override
+		{
+			OnCheckCast += SpellCheckCastFn(spell_override_enchant_SpellScript::CheckCast);
+		}
+	};
+
+	SpellScript* GetSpellScript() const override
+	{
+		return new spell_override_enchant_SpellScript();
+	}
+};
+
+
+class spell_refresh_create_enchant : public SpellScriptLoader
+{
+public:
+	spell_refresh_create_enchant() : SpellScriptLoader("spell_refresh_create_enchant") { }
+
+	class spell_refresh_create_enchant_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_refresh_create_enchant_SpellScript);
+
+		SpellCastResult CheckCast()
+		{
+			Player* owner = GetCaster()->ToPlayer();
+			Item* targetItem = GetExplTargetItem();
+			Item* castItem = GetCastItem();
+
+			if (!owner || !targetItem || !castItem)
+				return SPELL_FAILED_BAD_TARGETS;
+
+			bool exsit = false;
+
+			for (auto itr = CreateEnchantVec.begin(); itr != CreateEnchantVec.end(); itr++)
+				if (itr->entry == targetItem->GetEntry())
+					exsit = true;
+
+			if (!exsit)
+				return SPELL_FAILED_BAD_TARGETS;
+
+			owner->ApplyEnchantment(targetItem, false);
+
+			for (auto itr = CreateEnchantVec.begin(); itr != CreateEnchantVec.end(); itr++)
+				if (itr->entry == targetItem->GetEntry())
+					targetItem->SetEnchantment(EnchantmentSlot(itr->slot), 0, 0, 0);
+
+			for (uint8 slot = PERM_ENCHANTMENT_SLOT; slot < MAX_ENCHANTMENT_SLOT; slot++)
+			{
+				uint32 enchant_id = sItemMod->GenerateEnchantId(targetItem->GetEntry(), slot);
+				if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id))
+					targetItem->SetEnchantment(EnchantmentSlot(slot), enchant_id, 0, 0);
+			}
+
+			owner->ApplyEnchantment(targetItem, true);
+
+			return SPELL_CAST_OK;
+		}
+
+		void Register() override
+		{
+			OnCheckCast += SpellCheckCastFn(spell_refresh_create_enchant_SpellScript::CheckCast);
+		}
+	};
+
+	SpellScript* GetSpellScript() const override
+	{
+		return new spell_refresh_create_enchant_SpellScript();
+	}
+};
+
+class EnchantSpellDisable : PlayerScript
+{
+public:
+	EnchantSpellDisable() : PlayerScript("EnchantSpellDisable") {}
+
+	void OnUpdateZone(Player* player, uint32 /*newZone*/, uint32 /*newArea*/)
+	{
+		Unit::AuraApplicationMap &myAuras = player->GetAppliedAuras();
+		for (Unit::AuraApplicationMap::iterator i = myAuras.begin(); i != myAuras.end();)
+		{
+			Aura const* aura = i->second->GetBase();
+
+			if (aura && DisableMgr::IsDisabledFor(DISABLE_TYPE_SPELL, aura->GetId(), player))
+				player->RemoveAura(i);
+			else
+				++i;
+		}
+
+		for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
+		{
+			if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+			{
+				for (uint8 slot = PERM_ENCHANTMENT_SLOT; slot < MAX_ENCHANTMENT_SLOT; slot++)
+				{
+					uint32 enchant_id = pItem->GetEnchantmentId(EnchantmentSlot(slot));
+
+					if (SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id))
+					{
+						for (int s = 0; s < MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+						{
+							uint32 enchant_display_type = pEnchant->type[s];
+							
+							if (enchant_display_type == ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL)
+							{
+								uint32 enchant_amount = pEnchant->amount[s];
+								uint32 enchant_spell_id = pEnchant->spellid[s];
+
+								if (enchant_spell_id)
+								{
+									bool hasAura = player->HasAura(enchant_spell_id);
+									bool disable = DisableMgr::IsDisabledFor(DISABLE_TYPE_SPELL, enchant_spell_id, player);
+
+									if (hasAura && disable)
+										player->RemoveAurasDueToItemSpell(enchant_spell_id, pItem->GetGUID());
+									else if (!hasAura && !disable)
+									{
+										int32 basepoints = 0;
+										// Random Property Exist - try found basepoints for spell (basepoints depends from item suffix factor)
+										if (pItem->GetItemRandomPropertyId())
+										{
+											ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(pItem->GetItemRandomPropertyId()));
+											if (item_rand)
+											{
+												// Search enchant_amount
+												for (int k = 0; k < MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+												{
+													if (item_rand->enchant_id[k] == enchant_id)
+													{
+														basepoints = int32((item_rand->prefix[k] * pItem->GetItemSuffixFactor()) / 10000);
+														break;
+													}
+												}
+											}
+										}
+										// Cast custom spell vs all equal basepoints got from enchant_amount
+										if (basepoints)
+											player->CastCustomSpell(player, enchant_spell_id, &basepoints, &basepoints, &basepoints, true, pItem);
+										else
+											player->CastSpell(player, enchant_spell_id, true, pItem);
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+};
+
+class spell_np_to_level : public SpellScriptLoader
+{
+public:
+	spell_np_to_level() : SpellScriptLoader("spell_np_to_level") { }
+
+	class spell_refresh_create_enchant_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_refresh_create_enchant_SpellScript);
+
+		SpellCastResult CheckCast()
+		{
+			Player* owner = GetCaster()->ToPlayer();
+			Item* targetItem = GetExplTargetItem();
+			Item* casterItem = GetCastItem();
+
+
+			sNoPatchItem->Compound(owner, targetItem);
+
+			//if (!owner || !targetItem || !casterItem)
+			//	return SPELL_FAILED_BAD_TARGETS;
+			//
+			//if (!targetItem->IsNoPatch())
+			//	return SPELL_FAILED_BAD_TARGETS;
+			//
+			//auto itr = NpToLevelMap.find(casterItem->GetEntry());
+			//if (itr == NpToLevelMap.end())
+			//	return SPELL_FAILED_BAD_TARGETS;
+			//
+			//float chance = itr->second.chance;
+			//uint32 level = itr->second.level;
+			//
+			//if (!roll_chance_f(itr->second.chance))
+			//{
+			//	owner->GetSession()->SendNotification("Éý¼¶Ê§°Ü");
+			//	return SPELL_CAST_OK;
+			//}
+			//else
+			//	sNoPatchItem->LevelUp(owner, targetItem, level);
+
+			return SPELL_CAST_OK;
+		}
+
+		void Register() override
+		{
+			OnCheckCast += SpellCheckCastFn(spell_refresh_create_enchant_SpellScript::CheckCast);
+		}
+	};
+
+	SpellScript* GetSpellScript() const override
+	{
+		return new spell_refresh_create_enchant_SpellScript();
+	}
+};
+
+void AddSC_Random_Enchant()
+{
+	new spell_refresh_create_enchant();
+	new spell_random_enchant();
+	new spell_extract_enchant();
+	new spell_extract_enchant_all();
+	new spell_override_enchant();
+	new EnchantSpellDisable();
+	new spell_np_to_level();
+}
diff --git a/src/server/scripts/Custom/RandomEnchant/RandomEnchant.h b/src/server/scripts/Custom/RandomEnchant/RandomEnchant.h
new file mode 100644
index 0000000..7c401ea
--- /dev/null
+++ b/src/server/scripts/Custom/RandomEnchant/RandomEnchant.h
@@ -0,0 +1,34 @@
+#define ON_CREATE_ENCHANT_ID 1
+
+struct RandomEnchantTemplate
+{
+	uint32 entry;
+	uint32 enchantId;
+};
+
+extern std::vector<RandomEnchantTemplate> RandomEnchantVec;
+
+struct ExtractEnchantTemplate
+{
+	bool CanExtract;
+	bool CanEnchant;
+};
+
+extern std::unordered_map<uint32, ExtractEnchantTemplate> ExtractEnchantMap;
+
+class RandomEnchant
+{
+public:
+	static RandomEnchant* instance()
+	{
+		static RandomEnchant instance;
+		return &instance;
+	}
+
+	void Load();
+	void OnCreate(Item* item);
+	bool Enchant(Player* owner, Item* castItem, Item* targetItem);
+private:
+
+};
+#define sRandomEnchant RandomEnchant::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Rank/Rank.cpp b/src/server/scripts/Custom/Rank/Rank.cpp
new file mode 100644
index 0000000..1747801
--- /dev/null
+++ b/src/server/scripts/Custom/Rank/Rank.cpp
@@ -0,0 +1,254 @@
+#pragma execution_character_set("utf-8")
+#include "Rank.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../Reward/Reward.h"
+#include "../Requirement/Requirement.h"
+#include "../Switch/Switch.h"
+#include "../String/myString.h"
+#include "../CharNameMod/CharNameMod.h"
+#include "../FunctionCollection/FunctionCollection.h"
+#include "../GCAddon/GCAddon.h"
+#include "../MapMod/MapMod.h"
+
+std::map<uint32, RankTemplate> RankDataMap;
+
+
+void Rank::Load()
+{
+	RankDataMap.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT µÈ¼¶,Éý¼¶Ðè´ïµ½µÄÖµ,Ãû³Æ,²Ëµ¥ÎÄ±¾,Éý¼¶½±ÀøÄ£°åID,Íæ¼ÒÃû×ÖÇ°×º FROM __×Ô¶¨ÒåµÈ¼¶" :
+		"SELECT level,meetValue,name,gossipText,rewId,prefix FROM _rank");
+	if (!result) return;
+	do
+	{
+		Field* fields = result->Fetch();
+		uint32 level = fields[0].GetUInt32();
+
+		RankTemplate Temp;
+		Temp.meetValue			= fields[1].GetUInt32();
+		Temp.name				= fields[2].GetString();
+		Temp.gossipText			= fields[3].GetString();
+		Temp.rewId				= fields[4].GetUInt32();
+		Temp.prefix				= fields[5].GetString();
+		RankDataMap.insert(std::make_pair(level, Temp));
+	} while (result->NextRow());
+
+}
+
+uint32 Rank::GetMeetValue(uint32 level)
+{
+	std::map<uint32, RankTemplate>::iterator iter = RankDataMap.find(level);
+
+	if (iter != RankDataMap.end())
+		return iter->second.meetValue;
+
+	return 0;
+}
+
+std::string Rank::GetName(uint32 level)
+{
+	std::map<uint32, RankTemplate>::iterator iter = RankDataMap.find(level);
+
+	if (iter != RankDataMap.end())
+		return iter->second.name;
+
+	return "[ÎÞ]";
+}
+
+std::string Rank::GetGosstipText(uint32 level)
+{
+	std::map<uint32, RankTemplate>::iterator iter = RankDataMap.find(level);
+
+	if (iter != RankDataMap.end())
+		return iter->second.gossipText;
+
+	return "";
+}
+
+uint32 Rank::GetRewId(uint32 level)
+{
+	std::map<uint32, RankTemplate>::iterator iter = RankDataMap.find(level);
+
+	if (iter != RankDataMap.end())
+		return iter->second.rewId;
+
+	return 0;
+}
+std::string Rank::GetPrefix(uint32 level)
+{
+	std::map<uint32, RankTemplate>::iterator iter = RankDataMap.find(level);
+
+	if (iter != RankDataMap.end())
+		return iter->second.prefix;
+
+	return "";
+}
+
+bool Rank::AccountBind()
+{
+	return sSwitch->GetOnOff(ST_RANK_ACCOUNT_BIND);
+}
+
+uint32 Rank::GetMaxLevel()
+{
+	return RankDataMap.size();
+}
+
+void Rank::SendPacket(Player* player)
+{
+	std::ostringstream oss;
+	oss << player->rankValue << " ";
+	oss << player->maxRankValue << " ";
+	oss << GetName(player->rankLevel);
+	sGCAddon->SendPacketTo(player, "GC_S_RANKVALUE", oss.str());
+}
+
+void Rank::Update(Player* player, uint32 value/* = 0*/, bool updateDB/* = false*/)
+{
+	if (player->rankLevel >= GetMaxLevel())
+		return;
+		
+	player->rankValue += value;
+	player->maxRankValue = GetMeetValue(player->rankLevel);
+
+	if (player->rankValue > player->maxRankValue)
+	{
+		player->rankLevel++;
+		ChatHandler(player->GetSession()).PSendSysMessage("|cffFF0000[ÐÞÁ¶ÏµÍ³]|r ½ø½×%s", GetName(player->rankLevel).c_str());
+		sRew->Rew(player, GetRewId(player->rankLevel));
+		sMapMod->OnEnterMap(player);
+
+		player->rankValue = player->rankValue - player->maxRankValue;
+		player->maxRankValue = GetMeetValue(player->rankLevel);
+
+		//¸üÐÂÇ°×º
+		sCharNameMod->UpdatePrefix(player, GetPrefix(player->rankLevel));
+
+		if (player->rankValue > player->maxRankValue)
+			Update(player, 0, updateDB);
+	}
+
+	if (value > 0)
+		SendPacket(player);
+
+	if (updateDB)
+		UpdateDBValue(player);
+}
+
+void Rank::UpdateDBValue(Player* player)
+{
+	if (AccountBind())
+	{
+		PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_UPD_RANKVALUE);
+		stmt->setUInt32(0, player->GetSession()->GetAccountId());
+		stmt->setUInt32(1, player->rankLevel);
+		stmt->setUInt32(2, player->rankValue);
+		LoginDatabase.Execute(stmt);
+	}
+	else
+	{
+		PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_RANKVALUE);
+		stmt->setUInt32(0, player->GetGUIDLow());
+		stmt->setUInt32(1, player->rankLevel);
+		stmt->setUInt32(2, player->rankValue);
+		CharacterDatabase.Execute(stmt);
+	}	
+}
+
+void Rank::GetDBValue(Player* player, uint32 &rankLevel, uint32 &rankValue)
+{
+	if (AccountBind())
+	{
+		if (QueryResult result = LoginDatabase.PQuery("SELECT level, value FROM account_rank WHERE account = %u", player->GetSession()->GetAccountId()))
+		{
+			Field* fields = result->Fetch();
+			rankLevel = fields[0].GetUInt32();
+			rankValue = fields[1].GetUInt32();
+		}		
+	}
+	else
+	{
+		if (QueryResult result = CharacterDatabase.PQuery("SELECT level, value FROM character_rank WHERE guid = %u", player->GetGUIDLow()))
+		{
+			Field* fields = result->Fetch();
+			rankLevel = fields[0].GetUInt32();
+			rankValue = fields[1].GetUInt32();
+		}
+	}
+}
+
+void Rank::AddGossip(Player* player, Object* obj)
+{
+	for (std::map<uint32, RankTemplate>::iterator iter = RankDataMap.begin(); iter != RankDataMap.end(); iter++)
+	{
+		std::string text = "";
+
+		if (iter->first > player->rankLevel)
+			text = "|cffFF0000" + GetName(iter->first) + "|r";
+		else if (iter->first == player->rankLevel)
+			text = "|cff0033FF" + GetName(iter->first) + "|r";
+		else
+			text = GetName(iter->first);
+
+		player->ADD_GOSSIP_ITEM(0, text, SENDER_RANK, GOSSIP_ACTION_INFO_DEF + iter->first);
+	}
+
+	if (obj->ToCreature())
+		player->SEND_GOSSIP_MENU(obj->GetEntry(), obj->GetGUID());
+	else
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+}
+
+void Rank::Action(Player*player, uint32 action, Object*obj)
+{
+	if (action == GOSSIP_ACTION_INFO_DEF)
+		AddGossip(player, obj);
+	else
+	{
+		player->ADD_GOSSIP_ITEM(0, GetGosstipText(action - GOSSIP_ACTION_INFO_DEF), SENDER_RANK, GOSSIP_ACTION_INFO_DEF);
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+	}
+}
+
+class RankScript : PlayerScript
+{
+public:
+	RankScript() : PlayerScript("RankScript") {}
+
+	void OnLogin(Player* player) 
+	{ 
+		uint32 rankLevel = 1;
+		uint32 rankValue = 1;
+
+		sRank->GetDBValue(player, rankLevel, rankValue);
+
+		player->rankLevel = rankLevel;
+		player->rankValue = rankValue;
+		player->maxRankValue = sRank->GetMeetValue(player->rankLevel);
+
+		uint32 maxRankLevel = sRank->GetMaxLevel();
+
+		if (player->rankLevel >= maxRankLevel)
+		{
+			player->rankValue = 100;
+			player->maxRankValue = 100;	
+		}
+
+		sCharNameMod->UpdatePrefix(player, sRank->GetPrefix(player->rankLevel));
+
+		sGCAddon->SendCharData(player);
+
+		sMapMod->OnEnterMap(player);
+	}
+
+	void OnLogout(Player* player) 
+	{ 
+		sRank->UpdateDBValue(player);
+	}
+};
+
+void AddSC_RankScript()
+{
+	new RankScript();
+}
diff --git a/src/server/scripts/Custom/Rank/Rank.h b/src/server/scripts/Custom/Rank/Rank.h
new file mode 100644
index 0000000..414f900
--- /dev/null
+++ b/src/server/scripts/Custom/Rank/Rank.h
@@ -0,0 +1,39 @@
+struct RankTemplate
+{
+	uint32 meetValue;
+	std::string name;
+	std::string gossipText;
+	uint32 rewId;
+	std::string prefix;
+};
+
+extern std::map<uint32, RankTemplate> RankDataMap;
+
+class Rank
+{
+public:
+	static Rank* instance()
+	{
+		static Rank instance;
+		return &instance;
+	}
+	void Load();
+
+	bool AccountBind();
+	uint32 GetMeetValue(uint32 level);
+	std::string GetName(uint32 level);
+	std::string GetGosstipText(uint32 level);
+	uint32 GetRewId(uint32 level);
+	std::string GetPrefix(uint32 level);
+	uint32 GetMaxLevel();
+
+	void UpdateDBValue(Player* player);
+	void GetDBValue(Player* player, uint32 &rankLevel, uint32 &rankValue);
+	void Update(Player* player, uint32 value = 0, bool updateDB = false);
+	void SendPacket(Player* player);
+	void AddGossip(Player* player,Object* obj);
+	void Action (Player*player, uint32 action, Object*obj);
+private:
+
+};
+#define sRank Rank::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Rc4Encryptor/Base64.cpp b/src/server/scripts/Custom/Rc4Encryptor/Base64.cpp
new file mode 100644
index 0000000..f9ae35e
--- /dev/null
+++ b/src/server/scripts/Custom/Rc4Encryptor/Base64.cpp
@@ -0,0 +1,96 @@
+#include "Base64.h"  
+#include <iostream>  
+#include <ctype.h>  
+static const std::string base64_chars =
+"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+"abcdefghijklmnopqrstuvwxyz"
+"0123456789+/";
+
+
+static inline bool is_base64(unsigned char c) {
+	return (isalnum(c) || (c == '+') || (c == '/'));
+}
+
+std::string base64_encode(unsigned char const* bytes_to_encode, unsigned int in_len) {
+	std::string ret;
+	int i = 0;
+	int j = 0;
+	unsigned char char_array_3[3];
+	unsigned char char_array_4[4];
+
+	while (in_len--) {
+		char_array_3[i++] = *(bytes_to_encode++);
+		if (i == 3) {
+			char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
+			char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
+			char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
+			char_array_4[3] = char_array_3[2] & 0x3f;
+
+			for (i = 0; (i <4); i++)
+				ret += base64_chars[char_array_4[i]];
+			i = 0;
+		}
+	}
+
+	if (i)
+	{
+		for (j = i; j < 3; j++)
+			char_array_3[j] = '\0';
+
+		char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
+		char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
+		char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
+		char_array_4[3] = char_array_3[2] & 0x3f;
+
+		for (j = 0; (j < i + 1); j++)
+			ret += base64_chars[char_array_4[j]];
+
+		while ((i++ < 3))
+			ret += '=';
+
+	}
+
+	return ret;
+
+}
+
+std::string base64_decode(std::string const& encoded_string) {
+	int in_len = encoded_string.size();
+	int i = 0;
+	int j = 0;
+	int in_ = 0;
+	unsigned char char_array_4[4], char_array_3[3];
+	std::string ret;
+
+	while (in_len-- && (encoded_string[in_] != '=') && is_base64(encoded_string[in_])) {
+		char_array_4[i++] = encoded_string[in_]; in_++;
+		if (i == 4) {
+			for (i = 0; i <4; i++)
+				char_array_4[i] = base64_chars.find(char_array_4[i]);
+
+			char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
+			char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
+			char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];
+
+			for (i = 0; (i < 3); i++)
+				ret += char_array_3[i];
+			i = 0;
+		}
+	}
+
+	if (i) {
+		for (j = i; j <4; j++)
+			char_array_4[j] = 0;
+
+		for (j = 0; j <4; j++)
+			char_array_4[j] = base64_chars.find(char_array_4[j]);
+
+		char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
+		char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
+		char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];
+
+		for (j = 0; (j < i - 1); j++) ret += char_array_3[j];
+	}
+
+	return ret;
+}
diff --git a/src/server/scripts/Custom/Rc4Encryptor/Base64.h b/src/server/scripts/Custom/Rc4Encryptor/Base64.h
new file mode 100644
index 0000000..c291c10
--- /dev/null
+++ b/src/server/scripts/Custom/Rc4Encryptor/Base64.h
@@ -0,0 +1,6 @@
+#ifndef BASE_64_H  
+#define BASE_64_H  
+#include <string>  
+std::string base64_encode(unsigned char const*, unsigned int len);
+std::string base64_decode(std::string const& s);
+#endif  
diff --git a/src/server/scripts/Custom/Rc4Encryptor/RC4.cpp b/src/server/scripts/Custom/Rc4Encryptor/RC4.cpp
new file mode 100644
index 0000000..ec7a9f6
--- /dev/null
+++ b/src/server/scripts/Custom/Rc4Encryptor/RC4.cpp
@@ -0,0 +1,55 @@
+#include "RC4.h"
+//#include <iostream>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+using namespace std;
+
+void rc4_setup(struct rc4_state *s, unsigned char *key, int length)
+{
+    int i, j, k, *m, a;
+
+    s->x = 0;
+    s->y = 0;
+    m = s->m;
+
+    for (i = 0; i < 256; i++)
+    {
+        m[i] = i;
+    }
+
+    j = k = 0;
+
+    for (i = 0; i < 256; i++)
+    {
+        a = m[i];
+        j = (unsigned char)(j + a + key[k]);
+        m[i] = m[j];
+        m[j] = a;
+        if (++k >= length)
+            k = 0;
+    }
+}
+
+void rc4_crypt(struct rc4_state *s, unsigned char *data, int length)
+{
+    int i, x, y, *m, a, b;
+
+    x = s->x;
+    y = s->y;
+    m = s->m;
+
+    for (i = 0; i < length; i++)
+    {
+        x = (unsigned char)(x + 1);
+        a = m[x];
+        y = (unsigned char)(y + a);
+        m[x] = b = m[y];
+        m[y] = a;
+        data[i] ^= m[(unsigned char)(a + b)];
+    }
+
+    s->x = x;
+    s->y = y;
+}
diff --git a/src/server/scripts/Custom/Rc4Encryptor/RC4.h b/src/server/scripts/Custom/Rc4Encryptor/RC4.h
new file mode 100644
index 0000000..da15a40
--- /dev/null
+++ b/src/server/scripts/Custom/Rc4Encryptor/RC4.h
@@ -0,0 +1,12 @@
+#ifndef _RC4_H
+#define _RC4_H
+
+struct rc4_state
+{
+    int x, y, m[256];
+};
+
+void rc4_setup(struct rc4_state *s, unsigned char *key, int length);
+void rc4_crypt(struct rc4_state *s, unsigned char *data, int length);
+
+#endif
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Rc4Encryptor/RC4_Base64.cpp b/src/server/scripts/Custom/Rc4Encryptor/RC4_Base64.cpp
new file mode 100644
index 0000000..778b6be
--- /dev/null
+++ b/src/server/scripts/Custom/Rc4Encryptor/RC4_Base64.cpp
@@ -0,0 +1,51 @@
+#include <iostream>
+#include <cstring>
+#include "RC4.h"
+#include "Base64.h"
+#include "RC4_Base64.h"
+
+using namespace std;
+
+char key[128] = {"C2D11B476BCADAA9B9C422D99A912265"};
+
+void Rc4Base64EnCode(std::string key, std::string data, std::string &EnCodeData)
+{
+    struct rc4_state *s;
+    s = (struct rc4_state *)malloc(sizeof(struct rc4_state));
+
+    rc4_setup(s, (unsigned char *)key.c_str(), key.length());
+    rc4_crypt(s, (unsigned char *)data.c_str(), data.length());
+
+    std::string strMyPwd = data;
+    EnCodeData = base64_encode((unsigned char const *)strMyPwd.c_str(), strMyPwd.length());
+    return;
+}
+
+void Rc4Base64DeCode(std::string key, std::string data, std::string &DeCodeData)
+{
+    struct rc4_state *s;
+    s = (struct rc4_state *)malloc(sizeof(struct rc4_state));
+    std::string Strbase64DeCode = base64_decode(data);
+    char Chardata[512];
+    strcpy(Chardata, Strbase64DeCode.data());
+
+    rc4_setup(s, (unsigned char *)key.c_str(), key.length());
+    rc4_crypt(s, (unsigned char *)Chardata, strlen(Chardata));
+
+    DeCodeData = Chardata;
+    return;
+}
+
+string EncryptionRC4(const string &strSrc)
+{
+    std::string str;
+    Rc4Base64EnCode(key, strSrc, str);
+    return str;
+}
+
+string DecryptionRC4(const string &strSrc)
+{
+    std::string str;
+    Rc4Base64DeCode(key, strSrc, str);
+    return str;
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Rc4Encryptor/RC4_Base64.h b/src/server/scripts/Custom/Rc4Encryptor/RC4_Base64.h
new file mode 100644
index 0000000..5786053
--- /dev/null
+++ b/src/server/scripts/Custom/Rc4Encryptor/RC4_Base64.h
@@ -0,0 +1,6 @@
+#pragma once
+
+void Rc4Base64EnCode(std::string key, std::string data, std::string &EnCodeData);
+void Rc4Base64DeCode(std::string key, std::string data, std::string &DeCodeData);
+std::string EncryptionRC4(const std::string &strSrc);
+std::string DecryptionRC4(const std::string &strSrc);
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Recovery/Recovery.cpp b/src/server/scripts/Custom/Recovery/Recovery.cpp
new file mode 100644
index 0000000..84aebda
--- /dev/null
+++ b/src/server/scripts/Custom/Recovery/Recovery.cpp
@@ -0,0 +1,268 @@
+#pragma execution_character_set("utf-8")
+#include "Recovery.h"
+#include "../GCAddon/GCAddon.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../String/myString.h"
+#include "..\..\server\scripts\Custom\Reward\Reward.h"
+std::unordered_map<uint32/*entry*/, RecoveryTemplate> RecoveryMap;
+std::unordered_map<uint32/*categoryId*/, std::string/*categoryName*/> RecoveryCategoryMap;
+
+void Recovery::Load()
+{
+	RecoveryMap.clear();
+	RecoveryCategoryMap.clear();
+
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+        "SELECT ÎïÆ·ID,·Ö×éID,½±Àø»ý·ÖÊýÁ¿,ÎïÆ·,ÊýÁ¿,½±ÀøÄ£°åID FROM _ÎïÆ·_»ØÊÕ" :
+		"SELECT entry,categoryId,rewToken FROM _recovery");
+	if (result)
+	{
+		do
+		{
+            Field* fields = result->Fetch();
+            uint32 entry = fields[0].GetUInt32();
+            RecoveryTemplate Temp;
+            Temp.categoryId = fields[1].GetUInt32();
+            Temp.rewToken = fields[2].GetFloat();
+            Temp.rewitem = fields[3].GetUInt32();
+            Temp.rewcunt = fields[4].GetUInt32();
+            Temp.rewid = fields[5].GetUInt32();
+			RecoveryMap.insert(std::make_pair(entry, Temp));
+		} while (result->NextRow());
+	}
+	
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+		"SELECT ·Ö×éID,·Ö×éÃû³Æ FROM _ÎïÆ·_»ØÊÕ·Ö×é" :
+		"SELECT categoryId,categoryName FROM _recovery_category");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 categoryId			= fields[0].GetUInt32();
+			std::string categoryName	= fields[1].GetString();
+			RecoveryCategoryMap.insert(std::make_pair(categoryId, categoryName));
+		} while (result->NextRow());
+	}
+}
+
+std::string Recovery::GetDes(uint32 entry)
+{
+	const ItemTemplate * temp = sObjectMgr->GetItemTemplate(entry);
+	if (!temp)
+		return "";
+
+	std::ostringstream oss;
+	std::unordered_map<uint32, RecoveryTemplate>::iterator iter = RecoveryMap.find(entry);
+
+	if (iter != RecoveryMap.end())
+		return "|cFF00FF00¡¸¿É»ØÊÕ¡¹|r\n";
+
+	return "";
+}
+
+void Recovery::GetItemInfo(uint32 entry, uint32 count, uint32 &categoryId, float &tokenAmount)
+{
+	const ItemTemplate * temp = sObjectMgr->GetItemTemplate(entry);
+	if (!temp)
+		return;
+
+	std::unordered_map<uint32, RecoveryTemplate>::iterator iter = RecoveryMap.find(entry);
+
+	if (iter != RecoveryMap.end())
+	{
+		categoryId = iter->second.categoryId;
+		tokenAmount = count * iter->second.rewToken;
+	}
+}
+
+uint32 Recovery::GetCategoryId(uint32 entry)
+{
+	const ItemTemplate * temp = sObjectMgr->GetItemTemplate(entry);
+	if (!temp)
+		return 0;
+
+	std::unordered_map<uint32, RecoveryTemplate>::iterator iter = RecoveryMap.find(entry);
+
+	if (iter != RecoveryMap.end())
+		return iter->second.categoryId;
+
+	return 0;
+}
+
+uint32 Recovery::GetTokenAmount(Player* player, uint32 categoryId)
+{
+	float tokenAmount = 0;
+
+	//Ö÷±³°ü
+	for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
+		if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+		{
+			uint32 entry = item->GetEntry();
+			uint32 count = item->GetCount();
+			uint32 _categoryId = 0;
+			float _tokenAmount = 0;
+			GetItemInfo(entry, count, _categoryId, _tokenAmount);
+			if (_categoryId == categoryId)
+				tokenAmount += _tokenAmount;
+		}
+
+	//¶îÍâÈý¸ö±³°ü
+	for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+		if (Bag* pBag = player->GetBagByPos(i))
+			for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+				if (Item* item = player->GetItemByPos(i, j))
+				{
+					uint32 entry = item->GetEntry();
+					uint32 count = item->GetCount();
+					uint32 _categoryId = 0;
+					float _tokenAmount = 0;
+					GetItemInfo(entry, count, _categoryId, _tokenAmount);
+					if (_categoryId == categoryId)
+						tokenAmount += _tokenAmount;
+				}
+
+	return uint32(tokenAmount);
+}
+
+bool Recovery::HasCategoryItem(Player* player, uint32 categoryId)
+{
+	uint32 flag = false;
+
+	//Ö÷±³°ü
+	for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
+		if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+		{
+			uint32 entry = item->GetEntry();
+			uint32 count = item->GetCount();
+			uint32 _categoryId = 0;
+			float _tokenAmount = 0;
+			GetItemInfo(entry, count, _categoryId, _tokenAmount);
+			if (_categoryId == categoryId)
+				flag = true;
+		}
+
+	if (flag)
+		return true;
+
+	//¶îÍâÈý¸ö±³°ü
+	for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+		if (Bag* pBag = player->GetBagByPos(i))
+			for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+				if (Item* item = player->GetItemByPos(i, j))
+				{
+					uint32 entry = item->GetEntry();
+					uint32 count = item->GetCount();
+					uint32 _categoryId = 0;
+					float _tokenAmount = 0;
+					GetItemInfo(entry, count, _categoryId, _tokenAmount);
+					if (_categoryId == categoryId)
+						flag = true;
+				}
+
+	return flag;
+}
+
+void Recovery::OpenPanel(Player* player)
+{
+	std::ostringstream oss;
+	oss << "0#";
+	for (std::unordered_map<uint32, std::string>::iterator iter = RecoveryCategoryMap.begin(); iter != RecoveryCategoryMap.end(); iter++)
+		if (HasCategoryItem(player, iter->first))
+			oss << iter->first << "-" << iter->second << ":";
+	
+	sGCAddon->SendPacketTo(player, "GC_S_RECOVERY", oss.str());
+}
+
+void Recovery::SendCategoryMsg(Player* player, uint32 categoryId)
+{
+	std::ostringstream oss;
+	oss << "1#" << GetTokenAmount(player, categoryId) << "#";
+
+	//Ö÷±³°ü
+	for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
+		if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+		{
+			uint32 entry = item->GetEntry();
+			uint32 count = item->GetCount();
+			if (GetCategoryId(entry) == categoryId)
+				oss << entry << "-" << count << ":";
+		}
+
+	//¶îÍâÈý¸ö±³°ü
+	for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+		if (Bag* pBag = player->GetBagByPos(i))
+			for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+				if (Item* item = player->GetItemByPos(i, j))
+				{
+					uint32 entry = item->GetEntry();
+					uint32 count = item->GetCount();
+					if (GetCategoryId(entry) == categoryId)
+						oss << entry << "-" << count << ":";
+				}
+
+	sGCAddon->SendPacketTo(player, "GC_S_RECOVERY", oss.str());
+}
+
+void Recovery::Action(Player* player, uint32 categoryId)
+{
+	uint32 tokenAmount = 0;
+
+	//Ö÷±³°ü
+	for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
+		if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+		{
+			uint32 entry = item->GetEntry();
+			uint32 count = item->GetCount();
+			uint32 _categoryId = 0;
+			float _tokenAmount = 0;
+			GetItemInfo(entry, count, _categoryId, _tokenAmount);
+			if (_categoryId == categoryId)
+			{
+                std::unordered_map<uint32, RecoveryTemplate>::iterator iter = RecoveryMap.find(entry);
+                if (iter != RecoveryMap.end())
+                {
+                    if (iter->second.rewitem && iter->second.rewcunt)
+                        player->AddItem(iter->second.rewitem, iter->second.rewcunt * count);
+                    if (iter->second.rewid)
+                        sRew->Rew(player, iter->second.rewid, count);
+                }
+				player->DestroyItem(INVENTORY_SLOT_BAG_0, i, true);
+				tokenAmount += _tokenAmount;
+			}
+		}
+
+	//¶îÍâÈý¸ö±³°ü
+	for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
+		if (Bag* pBag = player->GetBagByPos(i))
+			for (uint32 j = 0; j < pBag->GetBagSize(); j++)
+				if (Item* item = player->GetItemByPos(i, j))
+				{
+					uint32 entry = item->GetEntry();
+					uint32 count = item->GetCount();
+					uint32 _categoryId = 0;
+					float _tokenAmount = 0;
+					GetItemInfo(entry, count, _categoryId, _tokenAmount);
+					if (_categoryId == categoryId)
+					{
+                        std::unordered_map<uint32, RecoveryTemplate>::iterator iter = RecoveryMap.find(entry);
+                        if (iter != RecoveryMap.end())
+                        {
+                            if (iter->second.rewitem && iter->second.rewcunt)
+                                player->AddItem(iter->second.rewitem, iter->second.rewcunt * count);
+                            if (iter->second.rewid)
+                                sRew->Rew(player, iter->second.rewid, count);
+                        }
+
+						player->DestroyItem(i, j, true);
+						tokenAmount += _tokenAmount;
+					}
+				}
+
+	OpenPanel(player);
+
+	ChatHandler(player->GetSession()).PSendSysMessage("»ØÊÕÎïÆ·»ñµÃ[%s] X %u", sString->GetText(CORE_STR_TYPES(STR_TOKEN)), tokenAmount);
+	sCF->UpdateTokenAmount(player, tokenAmount, true, "[»ØÊÕ]½±Àø");
+
+	sCF->CompleteQuest(player, 30002);
+}
diff --git a/src/server/scripts/Custom/Recovery/Recovery.h b/src/server/scripts/Custom/Recovery/Recovery.h
new file mode 100644
index 0000000..97554ac
--- /dev/null
+++ b/src/server/scripts/Custom/Recovery/Recovery.h
@@ -0,0 +1,33 @@
+ï»¿struct RecoveryTemplate
+{
+	uint32 categoryId;
+	float rewToken;
+    uint32 rewitem;
+    uint32 rewcunt;
+    uint32 rewid;
+};
+
+extern std::unordered_map<uint32/*entry*/, RecoveryTemplate> RecoveryMap;
+extern std::unordered_map<uint32/*categoryId*/, std::string/*categoryName*/> RecoveryCategoryMap;
+
+class Recovery
+{
+public:
+	static Recovery* instance()
+	{
+		static Recovery instance;
+		return &instance;
+	}
+	void Load();
+	std::string Recovery::GetDes(uint32 entry);
+	bool HasCategoryItem(Player* player, uint32 categoryId);
+	void OpenPanel(Player* player);
+	void GetItemInfo(uint32 entry, uint32 count, uint32 &categoryId, float &tokenAmount);
+	uint32 GetCategoryId(uint32 entry);
+	uint32 GetTokenAmount(Player* player, uint32 categoryId);
+	void SendCategoryMsg(Player* player, uint32 categoryId);
+	void Action(Player* player, uint32 categoryId);
+private:
+
+};
+#define sRecovery Recovery::instance()
diff --git a/src/server/scripts/Custom/Recruit/Recruit.cpp b/src/server/scripts/Custom/Recruit/Recruit.cpp
new file mode 100644
index 0000000..045facd
--- /dev/null
+++ b/src/server/scripts/Custom/Recruit/Recruit.cpp
@@ -0,0 +1,850 @@
+#pragma execution_character_set("utf-8")
+#include "../PrecompiledHeaders/ScriptPCH.h"
+#include "Recruit.h"
+#include "Pet.h"
+#include "GuildMgr.h"
+#include "../Custom/Requirement/Requirement.h"
+#include "../Custom/Reward/Reward.h"
+#include "../CommonFunc/CommonFunc.h"
+
+#define RECRUIT_MENU_ID 8000
+
+std::vector <RecruitTemplate> RecruitInfo;
+std::vector<RecruitOrDissTemplate> RecruitOrDissVec;
+std::unordered_map<uint32, RucruitLootShareTemplate> RecruitLootMap;
+
+void Recruit::PopMsg(Player* player, uint32 menuId, std::string text)
+{
+	WorldPacket data(SMSG_GOSSIP_MESSAGE, 100);
+	data << uint64(player->GetGUID());
+	data << uint32(menuId);
+	data << uint32(1);
+	data << uint32(1);
+	data << uint32(1);
+	data << uint8(1);
+	data << uint8(0);
+	data << uint32(0);
+	data << "¹«¸æ";
+	data << text;
+	player->GetSession()->SendPacket(&data);
+}
+
+bool Recruit::IsRecruited(Player* player)
+{
+	for (size_t i = 0; i < RecruitInfo.size(); i++)
+	{
+		if (player->GetGUIDLow() == RecruitInfo[i].friendGUIDLow)
+			return true;
+	}
+
+	return false;
+}
+
+bool Recruit::IsRecruitYourRecruiter(uint32 recruiterGUIDLow, uint32 friendGUIDLow)
+{
+	for (size_t i = 0; i < RecruitInfo.size(); i++)
+	{
+		if (friendGUIDLow == RecruitInfo[i].recruiterGUIDLow)
+		{
+			for (size_t j = 0; j < RecruitInfo.size(); j++)
+			{
+				if (recruiterGUIDLow == RecruitInfo[i].friendGUIDLow)
+				{
+					return false;
+				}
+			}
+		}
+	}
+
+	return true;
+}
+
+uint32 Recruit::GetFriendAmount(Player* recruiter)
+{
+	uint32 friendAmount = 0;
+	for (size_t i = 0; i < RecruitInfo.size(); i++)
+	{
+		if (recruiter->GetGUIDLow() == RecruitInfo[i].recruiterGUIDLow)
+			friendAmount++;
+	}
+	return friendAmount;
+}
+
+bool Recruit::RecruitAcceptOrCancel(Player*player, uint32 menuId)
+{
+	if (menuId != RECRUIT_MENU_ID)
+		return false;
+
+	Player* recruiter = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(player->recruiterGUIDLow, 0, HIGHGUID_PLAYER));
+	if (player && recruiter)
+	{
+		sReq->Des(recruiter, GetRecReqId());
+		sRew->Rew(recruiter, GetRewId1());
+		sRew->Rew(player, GetRewId2());
+
+		RecruitTemplate RecruitTemp;
+		RecruitTemp.recruiterGUIDLow = player->recruiterGUIDLow;
+		RecruitTemp.friendGUIDLow = player->GetGUIDLow();
+
+		RecruitInfo.push_back(RecruitTemp);
+
+		if (UpdateRecruitDB(player->recruiterGUIDLow, player->GetGUIDLow()))
+			if (player->getLevel() < GetInsLevel())
+				player->SetLevel(GetInsLevel(), true);
+
+		std::ostringstream oss;
+		oss << "|cFFFF1717[ÕÐÄ¼ÏµÍ³]|r´óµÀÎÞÇéÈËÓÐÇé£¬[ÕÐÄ¼Õß]|cFF0177EC" << sCF->GetNameLink(recruiter) << "|rÓë|cFF0177EC" << sCF->GetNameLink(player) << "|r½¨Á¢»ï°é¹ØÏµ";
+		sWorld->SendScreenMessage(oss.str().c_str());
+		sCF->CompleteQuest(recruiter, 30003);
+	}
+
+	return true;
+}
+
+bool Recruit::UpdateRecruitDB(uint32 recruiterGUIDLow, uint32 friendGUIDLow)
+{
+	Player* recruiter = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(recruiterGUIDLow, 0, HIGHGUID_PLAYER));
+	Player* pFriend = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(friendGUIDLow, 0, HIGHGUID_PLAYER));
+
+	if (!pFriend || !recruiter) 
+		return false;
+
+	CharacterDatabase.DirectPExecute("INSERT INTO character_recruit(recruiter,friend,recruiterGUID,friendGUID,friendPlayedTime) VALUES ('%s','%s','%u','%u','%u')", recruiter->GetName().c_str(), pFriend->GetName().c_str(), recruiterGUIDLow, friendGUIDLow, pFriend->GetTotalPlayedTime());
+
+	return true;
+}
+
+void Recruit::Load()
+{
+	RecruitInfo.clear();
+	QueryResult result1 = CharacterDatabase.PQuery("SELECT recruiterGUID,friendGUID,friendPlayedTime,timeRewarded1,timeRewarded2,timeRewarded3 from character_recruit");
+	if (result1)
+	{
+		do
+		{
+			Field* fields = result1->Fetch();
+			RecruitTemplate RecruitTemp;
+			RecruitTemp.recruiterGUIDLow = fields[0].GetUInt32();
+			RecruitTemp.friendGUIDLow = fields[1].GetUInt32();
+			RecruitTemp.friendPlayedTime = fields[2].GetUInt32();
+			RecruitTemp.timeRewarded1 = fields[3].GetBool();
+			RecruitTemp.timeRewarded2 = fields[4].GetBool();
+			RecruitTemp.timeRewarded3 = fields[5].GetBool();
+			RecruitInfo.push_back(RecruitTemp);
+		} while (result1->NextRow());
+	}
+
+	RecruitOrDissVec.clear();
+	QueryResult result2 = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		//			0				1				2				3						4						5			6					7					8					9					10						11						12					13
+		"SELECT ÕÐÄ¼ÐèÇóÄ£°åID,ÕÐÄ¼Õß½±ÀøÄ£°åID,±»ÕÐÄ¼Õß½±ÀøÄ£°åID,ÕÐÄ¼Õß½â³ýÕÐÄ¼ÐèÇóÄ£°åID,±»ÕÐÄ¼Õß½â³ýÕÐÄ¼ÐèÇóÄ£°åID,ÕÐÄ¼ÊýÁ¿ÉÏÏÞ,ÊÇ·ñÔÊÐí¿çÕóÓªÕÐÄ¼,±»ÕÐÄ¼ÕßÁ¢¼´ÌáÉýµÈ¼¶,ÕÐÄ¼Õß»ñÈ¡½±ÀøÀÛ¼ÆÊ±¼ä1,ÕÐÄ¼Õß»ñÈ¡½±ÀøÄ£°åID1,ÕÐÄ¼Õß»ñÈ¡½±ÀøÀÛ¼ÆÊ±¼ä2,ÕÐÄ¼Õß»ñÈ¡½±ÀøÄ£°åID2,ÕÐÄ¼Õß»ñÈ¡½±ÀøÀÛ¼ÆÊ±¼ä3,ÕÐÄ¼Õß»ñÈ¡½±ÀøÄ£°åID3 FROM __ÕÐÄ¼" :
+		//			0	1		2		3		4			5			6				7			8			9			10			11				12			13
+		"SELECT reqId,rewId1,rewId2,disReqId1,disReqId2,playersLimit,allowCrossFaction,insLevel,timeForRew1,timeForRewId1,timeForRew2,timeForRewId2,timeForRew3,timeForRewId3 FROM _recruit");
+	if (result2)
+	{
+		do
+		{
+			Field* fields = result2->Fetch();
+			RecruitOrDissTemplate RecruitOrDissTemp;
+			RecruitOrDissTemp.recruitReqId = fields[0].GetUInt32();
+			RecruitOrDissTemp.rewId1 = fields[1].GetUInt32();
+			RecruitOrDissTemp.rewId2 = fields[2].GetUInt32();
+			RecruitOrDissTemp.disReqId1 = fields[3].GetUInt32();
+			RecruitOrDissTemp.disReqId2 = fields[4].GetUInt32();
+			RecruitOrDissTemp.playersLimit = fields[5].GetUInt32();
+			RecruitOrDissTemp.crossFaction = fields[6].GetBool();
+			RecruitOrDissTemp.insLevel = fields[7].GetUInt32();
+			RecruitOrDissTemp.timeForRew1 = fields[8].GetUInt32();
+			RecruitOrDissTemp.timeForRewId1 = fields[9].GetUInt32();
+			RecruitOrDissTemp.timeForRew2 = fields[10].GetUInt32();
+			RecruitOrDissTemp.timeForRewId2 = fields[11].GetUInt32();
+			RecruitOrDissTemp.timeForRew3 = fields[12].GetUInt32();
+			RecruitOrDissTemp.timeForRewId3 = fields[13].GetUInt32();
+			RecruitOrDissVec.push_back(RecruitOrDissTemp);
+		} while (result2->NextRow());
+	}
+
+	RecruitLootMap.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+		"SELECT ÎïÆ·ID,¹²ÏíÊýÁ¿ÉÏÏÞ, ¹²Ïí¼¸ÂÊ,±»ÕÐÄ¼ÕßÍ¬Ê±»ñÈ¡½±Àø¼¸ÂÊ,±»ÕÐÄ¼ÕßÍ¬Ê±»ñÈ¡½±ÀøÎïÆ·ÉÏÏÞ FROM __ÕÐÄ¼_µôÂä¹²Ïí" :
+		"SELECT entry,shareCountLimit, shareChance,rewChanceOnShare,rewCountLimit FROM _recruit_lootshare");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+
+			uint32 entry = fields[0].GetUInt32();
+
+			RucruitLootShareTemplate Temp;
+			Temp.shareCountLimit	= fields[1].GetUInt32();
+			Temp.shareChance		= fields[2].GetFloat();
+			Temp.rewChanceOnShare	= fields[3].GetFloat();
+			Temp.rewCountLimit		= fields[4].GetUInt32();
+			RecruitLootMap.insert(std::make_pair(entry, Temp));
+		} while (result->NextRow());
+	}
+
+}
+
+GlobalPlayerData const* Recruit::GetRecruiterData(Player* player)
+{
+	if (!player)
+		return NULL;
+
+	uint32 recruiterGUIDLow = 0;
+
+	for (uint32 i = 0; i < RecruitInfo.size(); i++)
+	{
+		if (RecruitInfo[i].friendGUIDLow == player->GetGUIDLow())
+		{
+			recruiterGUIDLow = RecruitInfo[i].recruiterGUIDLow;
+			break;
+		}
+	}
+
+	GlobalPlayerData const* recruiterPlayerData = sWorld->GetGlobalPlayerData(recruiterGUIDLow);
+
+	if (!recruiterPlayerData)
+		return NULL;
+
+	return recruiterPlayerData;
+}
+
+void Recruit::GetFriendsDataList(std::vector<GlobalPlayerData const*> &friendsDataList, Player* player)
+{
+	friendsDataList.clear();
+
+	if (!player)
+		return;
+
+	for (uint32 i = 0; i < RecruitInfo.size(); i++)
+	{
+		if (RecruitInfo[i].recruiterGUIDLow == player->GetGUIDLow())
+		{
+			GlobalPlayerData const* friendPlayerData = sWorld->GetGlobalPlayerData(RecruitInfo[i].friendGUIDLow);
+			if (friendPlayerData)
+				friendsDataList.push_back(friendPlayerData);
+		}
+	}
+}
+
+void Recruit::DismissRecruit(uint32 recruiterGUIDLow, uint32 friendGUIDLow)
+{
+	CharacterDatabase.DirectPExecute("DELETE FROM character_recruit WHERE recruiterGUID = %u AND friendGUID = %u", recruiterGUIDLow, friendGUIDLow);
+
+	for (std::vector<RecruitTemplate>::iterator itr = RecruitInfo.begin(); itr != RecruitInfo.end();)
+	{
+		if (itr->friendGUIDLow == friendGUIDLow && itr->recruiterGUIDLow == recruiterGUIDLow)
+			itr = RecruitInfo.erase(itr);	
+		else
+			++itr;
+	}
+}
+
+void Recruit::RecruitItemReward(Player* player, Item* newItem, uint32 count)
+{
+	if (!newItem)
+		return;
+
+	uint32 entry = newItem->GetEntry();
+	uint32 recruiterItemCount = 0;
+	uint32 followerItemCount = 0;
+
+	GetItemCount(entry, count, recruiterItemCount, followerItemCount);
+
+	if (!recruiterItemCount)
+		return;
+
+	GlobalPlayerData const* recruiterPlayerData = sRecruit->GetRecruiterData(player);
+
+	if (!recruiterPlayerData) 
+		return;
+
+	Player* recruiter = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(recruiterPlayerData->guidLow, 0, HIGHGUID_PLAYER));
+
+	if (recruiter)
+	{
+		std::string itemlink = sCF->GetItemLink(newItem->GetEntry());
+		ChatHandler(recruiter->GetSession()).PSendSysMessage("|cFFFF1717[ÕÐÄ¼ÏµÍ³]|rÄã»ñµÃ|cFF0177EC%s|rµÄ¹²ÏíµôÂä%s X %u", sCF->GetNameLink(player).c_str(), itemlink.c_str(), recruiterItemCount);
+		recruiter->AddItem(entry, recruiterItemCount);
+
+		if (followerItemCount)
+		{
+			player->AddItem(entry, followerItemCount);
+			ChatHandler(player->GetSession()).PSendSysMessage("|cFFFF1717[ÕÐÄ¼ÏµÍ³]|r|cFF0177EC%s|r»ñµÃÄãµÄ¹²ÏíµôÂä%s X %u£¬²¢ÇÒÄã»ñµÃ¶îÍâ½±Àø%s X %u", sCF->GetNameLink(recruiter).c_str(), itemlink.c_str(), recruiterItemCount, itemlink.c_str(), followerItemCount);
+		}
+	}		
+}
+
+void Recruit::RecruitMoneyReward(Player* player, uint32 count)
+{
+	uint32 recruiterItemCount = 0;
+	uint32 followerItemCount = 0;
+
+	GetItemCount(0, count, recruiterItemCount, followerItemCount);
+
+	if (!recruiterItemCount)
+		return;
+
+	GlobalPlayerData const* recruiterPlayerData = sRecruit->GetRecruiterData(player);
+	if (!recruiterPlayerData) return;
+
+	Player* recruiter = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(recruiterPlayerData->guidLow, 0, HIGHGUID_PLAYER));
+
+	if (recruiter)
+	{
+		recruiter->ModifyMoney(count);
+
+		WorldPacket data(SMSG_LOOT_MONEY_NOTIFY, 4 + 1);
+		data << uint32(count);
+		data << uint8(1);
+		recruiter->GetSession()->SendPacket(&data);
+	}
+
+}
+
+void Recruit::RecruitXPReward(Player* player, uint32 xp, Unit* _victim, float _groupRate, Group* _group)
+{
+	uint32 recruiterItemCount = 0;
+	uint32 followerItemCount = 0;
+
+	GetItemCount(2, xp, recruiterItemCount, followerItemCount);
+
+	if (!recruiterItemCount)
+		return;
+
+	GlobalPlayerData const* recruiterPlayerData = sRecruit->GetRecruiterData(player);
+	if (!recruiterPlayerData) 
+		return;
+
+	Player* recruiter = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(recruiterPlayerData->guidLow, 0, HIGHGUID_PLAYER));
+
+	if (recruiter)
+	{
+		recruiter->GiveXP(xp, _victim, _groupRate);
+		if (Pet* pet = recruiter->GetPet())
+			pet->GivePetXP(_group ? xp / 2 : xp);
+	}
+}
+
+void Recruit::RecruitHonorReward(Player* player, uint32 honor)
+{
+	uint32 recruiterItemCount = 0;
+	uint32 followerItemCount = 0;
+
+	GetItemCount(1, honor, recruiterItemCount, followerItemCount);
+
+	if (!recruiterItemCount)
+		return;
+
+	GlobalPlayerData const* recruiterPlayerData = sRecruit->GetRecruiterData(player);
+	if (!recruiterPlayerData) return;
+
+	Player* recruiter = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(recruiterPlayerData->guidLow, 0, HIGHGUID_PLAYER));
+
+	if (recruiter)
+	{
+		recruiter->ModifyHonorPoints(honor);
+		recruiter->ApplyModUInt32Value(PLAYER_FIELD_TODAY_CONTRIBUTION, honor, true);
+	}
+}
+
+
+void Recruit::GetItemCount(uint32 entry, uint32 itemCount, uint32 &recruiterItemCount, uint32 &followerItemCount)
+{
+	std::unordered_map<uint32, RucruitLootShareTemplate>::iterator iter = RecruitLootMap.find(entry);
+
+	if (iter != RecruitLootMap.end())
+		if (frand(0, 100) <= iter->second.shareChance)
+		{
+			recruiterItemCount = std::min(itemCount, iter->second.shareCountLimit);
+
+			if (frand(0, 100) <= iter->second.rewChanceOnShare)
+				followerItemCount = std::min(itemCount, iter->second.rewCountLimit);
+		}
+
+}
+
+void Recruit::RecruitTelePort(Player* player, uint32 targetGUIDLow)
+{
+	if (Player* target = ObjectAccessor::FindPlayerInOrOutOfWorld(MAKE_NEW_GUID(targetGUIDLow, 0, HIGHGUID_PLAYER)))
+	{
+		if (target->InBattleground())
+		{
+			player->GetSession()->SendNotification("´«ËÍÊ§°Ü£¬Ä¿±êÔÚÕ½³¡ÖÐ£¡");
+			return;
+		}
+			
+		if (target->GetMap()->IsDungeon())
+		{
+			player->GetSession()->SendNotification("´«ËÍÊ§°Ü£¬Ä¿±êÔÚ¸±±¾ÖÐ£¡");
+			return;
+		}
+
+		player->TeleportTo(target->GetWorldLocation());
+	}else
+		player->GetSession()->SendNotification("´«ËÍÄ¿±ê²»ÔÚÏß£¡");
+}
+
+
+uint32 Recruit::GetRecReqId()
+{
+	if (!RecruitOrDissVec.empty())
+		return RecruitOrDissVec[0].recruitReqId;
+	return 0;
+}
+uint32 Recruit::GetRewId1()
+{
+	if (!RecruitOrDissVec.empty())
+		return RecruitOrDissVec[0].rewId1;
+	return 0;
+}
+uint32 Recruit::GetRewId2()
+{
+	if (!RecruitOrDissVec.empty())
+		return RecruitOrDissVec[0].rewId2;
+	return 0;
+}
+uint32 Recruit::GetDissReqId1()
+{
+	if (!RecruitOrDissVec.empty())
+		return RecruitOrDissVec[0].disReqId1;
+	return 0;
+}
+uint32 Recruit::GetDissReqId2()
+{
+	if (!RecruitOrDissVec.empty())
+		return RecruitOrDissVec[0].disReqId2;
+	return 0;
+}
+uint32 Recruit::GetPlayersLimit()
+{
+	if (!RecruitOrDissVec.empty())
+		return RecruitOrDissVec[0].playersLimit;
+	return 0;
+}
+bool Recruit::CrossFaction()
+{
+	if (!RecruitOrDissVec.empty())
+		return RecruitOrDissVec[0].crossFaction;
+	return false;
+}
+uint32 Recruit::GetInsLevel()
+{
+	if (!RecruitOrDissVec.empty())
+		return RecruitOrDissVec[0].insLevel;
+	return 0;
+}
+uint32 Recruit::GetTimeForRew1()
+{
+	if (!RecruitOrDissVec.empty())
+		return RecruitOrDissVec[0].timeForRew1;
+	return 0;
+}
+uint32 Recruit::GetTimeForRewId1()
+{
+	if (!RecruitOrDissVec.empty())
+		return RecruitOrDissVec[0].timeForRewId1;
+	return 0;
+}
+
+uint32 Recruit::GetTimeForRew2()
+{
+	if (!RecruitOrDissVec.empty())
+		return RecruitOrDissVec[0].timeForRew2;
+	return 0;
+}
+uint32 Recruit::GetTimeForRewId2()
+{
+	if (!RecruitOrDissVec.empty())
+		return RecruitOrDissVec[0].timeForRewId2;
+	return 0;
+}
+uint32 Recruit::GetTimeForRew3()
+{
+	if (!RecruitOrDissVec.empty())
+		return RecruitOrDissVec[0].timeForRew3;
+	return 0;
+}
+uint32 Recruit::GetTimeForRewId3()
+{
+	if (!RecruitOrDissVec.empty())
+		return RecruitOrDissVec[0].timeForRewId3;
+	return 0;
+}
+
+class RecruitWorldScript : public WorldScript
+{
+public:
+	RecruitWorldScript() : WorldScript("RecruitWorldScript") {}
+
+	void OnAfterConfigLoad(bool /*reload*/)
+	{
+		sRecruit->Load();
+	}
+};
+
+class RecruitPlayerScript : PlayerScript
+{
+public:
+	RecruitPlayerScript() : PlayerScript("RecruitPlayerScript") {}
+	void OnLogin(Player* player) override
+	{
+
+		GlobalPlayerData const* recruiterPlayerData = sRecruit->GetRecruiterData(player);
+
+		if (!recruiterPlayerData)
+			return;
+
+		uint32 playedTime = 0;
+		bool hasReward1 = false;
+		bool hasReward2 = false;
+		bool hasReward3 = false;
+		uint32 recruiterGUIDLow = 0;
+		for (uint32 i = 0; i < RecruitInfo.size(); i++)
+		{
+			if (RecruitInfo[i].friendGUIDLow == player->GetGUIDLow())
+			{
+				playedTime = RecruitInfo[i].friendPlayedTime;
+				hasReward1 = RecruitInfo[i].timeRewarded1;
+				hasReward2 = RecruitInfo[i].timeRewarded2;
+				hasReward3 = RecruitInfo[i].timeRewarded3;
+
+				recruiterGUIDLow = RecruitInfo[i].recruiterGUIDLow;
+
+				break;
+			}
+		}
+		
+		if (!hasReward1 && (player->GetTotalPlayedTime() - playedTime > sRecruit->GetTimeForRew1()) && (sRecruit->GetTimeForRew1() > 0))
+		{	
+			sRecruit->UpdateHasRewad(player, 1);
+			std::ostringstream oss;
+			oss << "\n\nÕâÊÇÀ´×ÔÍæ¼Ò[|cFFFF1717" << player->GetName() << "|r]µÄµÚÒ»´ÎÕÐÄ¼½±Àø\n\n×£ÄãÔÚ°¬ÔóÀ­Ë¹µÄÃ°ÏÕÖ®ÂÃ³äÂúÀÖÈ¤£¡";
+			sRew->MailRew(player, recruiterGUIDLow, sRecruit->GetTimeForRewId1(), "ÕÐÄ¼½±Àø(Ò»)", oss.str());
+		}
+		if (!hasReward2 && (player->GetTotalPlayedTime() - playedTime > sRecruit->GetTimeForRew2()) && (sRecruit->GetTimeForRew2() > 0))
+		{
+			sRecruit->UpdateHasRewad(player, 2);
+			std::ostringstream oss;
+			oss << "\n\nÕâÊÇÀ´×ÔÍæ¼Ò[|cFFFF1717" << player->GetName() << "|r]µÄµÚ¶þ´ÎÕÐÄ¼½±Àø\n\n×£ÄãÔÚ°¬ÔóÀ­Ë¹µÄÃ°ÏÕÖ®ÂÃ³äÂúÀÖÈ¤£¡";		
+			sRew->MailRew(player, recruiterGUIDLow, sRecruit->GetTimeForRewId2(), "ÕÐÄ¼½±Àø(¶þ)", oss.str());
+		}
+		if (!hasReward3 && (player->GetTotalPlayedTime() - playedTime > sRecruit->GetTimeForRew3()) && (sRecruit->GetTimeForRew3() > 0))
+		{
+			sRecruit->UpdateHasRewad(player, 3);
+			std::ostringstream oss;
+			oss << "n\nÕâÊÇÀ´×ÔÍæ¼Ò[|cFFFF1717" << player->GetName() << "|r]µÄµÚÈý´ÎÕÐÄ¼½±Àø\n\n×£ÄãÔÚ°¬ÔóÀ­Ë¹µÄÃ°ÏÕÖ®ÂÃ³äÂúÀÖÈ¤£¡";	
+			sRew->MailRew(player, recruiterGUIDLow, sRecruit->GetTimeForRewId3(), "ÕÐÄ¼½±Àø(Èý)", oss.str());
+		}
+	}
+};
+
+
+void Recruit::UpdateHasRewad(Player* player, uint32 flag)
+{
+	uint32 len = RecruitInfo.size();
+	for (uint32 i = 0; i < len; i++)
+		if (RecruitInfo[i].friendGUIDLow == player->GetGUIDLow())
+		{
+			player->GetSession()->SendNotification("|cFFFF1717[ÕÐÄ¼ÏµÍ³]|rÕÐÄ¼ÄãµÄÈËÒÑ»ñµÃ½±Àø");
+			switch (flag)
+			{
+			case 1:
+				CharacterDatabase.DirectPExecute("UPDATE character_recruit SET timeRewarded1 = %d WHERE friendGUID = %d", 1, player->GetGUIDLow());
+				RecruitInfo[i].timeRewarded1 = true;
+				break;
+			case 2:
+				CharacterDatabase.DirectPExecute("UPDATE character_recruit SET timeRewarded2 = %d WHERE friendGUID = %d", 1, player->GetGUIDLow());
+				RecruitInfo[i].timeRewarded2 = true;
+				break;
+			case 3:
+
+				CharacterDatabase.DirectPExecute("UPDATE character_recruit SET timeRewarded3 = %d WHERE friendGUID = %d", 1, player->GetGUIDLow());
+				RecruitInfo[i].timeRewarded3 = true;
+				break;
+			default:
+				break;
+			}
+		}
+}
+
+void AddSC_RECRUIT()
+{
+	new RecruitWorldScript();
+	new RecruitPlayerScript();
+}
+
+
+void Recruit::AddMainMenu(Player* player, Object* obj)
+{
+	player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "ÕÐÄ¼ÐÂµÄ»ï°é", SENDER_RECRUIT_NEW, GOSSIP_ACTION_INFO_DEF, "", 0, true);
+	player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "½â³ýÕÐÄ¼¹ØÏµ", SENDER_RECRUIT_CHAR_DISS_LIST, GOSSIP_ACTION_INFO_DEF);
+	player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "²é¿´ÕÐÄ¼ÐÅÏ¢", SENDER_RECRUIT_CHAR_INFO_LIST, GOSSIP_ACTION_INFO_DEF);
+	player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Ö§Ô®ÔÚÏß»ï°é", SENDER_RECRUIT_CHAR_TELE_LIST, GOSSIP_ACTION_INFO_DEF);
+	if (obj->ToCreature())
+		player->SEND_GOSSIP_MENU(obj->GetEntry(), obj->GetGUID());
+	else
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+}
+bool Recruit::AddSubMenuOrDoAction(Player* player, Object* obj, uint32 sender, uint32 action)
+{
+	player->PlayerTalkClass->ClearMenus();
+	switch (sender)
+	{
+	case SENDER_RECRUIT_CHAR_INFO_LIST:
+	{
+		if (GetRecruiterData(player))
+		{
+			std::ostringstream oss;
+
+			uint64 recruiterGUID = MAKE_NEW_GUID(GetRecruiterData(player)->guidLow, 0, HIGHGUID_PLAYER);
+
+			if (ObjectAccessor::FindPlayerInOrOutOfWorld(recruiterGUID))
+				oss << "[|cFF0177ECÔÚÏß|r]";
+			else
+				oss << "[|cFFFF1717ÀëÏß|r]";
+			oss << "|cFFFF1717";
+			oss << GetRecruiterData(player)->name;
+			oss << "|r";
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss.str(), SENDER_RECRUIT_CHAR_INFO, GetRecruiterData(player)->guidLow);
+		}
+
+		std::vector<GlobalPlayerData const*> friendsDataList;
+		GetFriendsDataList(friendsDataList, player);
+
+		for (size_t i = 0; i < friendsDataList.size(); i++)
+		{
+			std::ostringstream oss;
+			uint64 friendGUID = MAKE_NEW_GUID(friendsDataList[i]->guidLow, 0, HIGHGUID_PLAYER);
+
+			if (ObjectAccessor::FindPlayerInOrOutOfWorld(friendGUID))
+				oss << "[|cFF0177ECÔÚÏß|r]";
+			else
+				oss << "[|cFFFF1717ÀëÏß|r]";
+
+			oss << "|cFF0177EC";
+			oss << friendsDataList[i]->name;
+			oss << "|r";
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss.str(), SENDER_RECRUIT_CHAR_INFO, friendsDataList[i]->guidLow);
+		}
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+	}
+	break;
+
+	case SENDER_RECRUIT_CHAR_INFO:
+	{
+		GlobalPlayerData const* playerData = sWorld->GetGlobalPlayerData(action);
+
+		if (playerData)
+		{
+			std::ostringstream oss;
+			oss << "Ãû×Ö£º" << playerData->name << "\n";
+			oss << "µÈ¼¶ :" << playerData->level << "\n";;
+			oss << "¹«»á :" << sGuildMgr->GetGuildNameById(playerData->guildId) << "\n";
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss.str(), SENDER_RECRUIT_CHAR_INFO, action);
+		}
+	}
+	break;
+
+	case SENDER_RECRUIT_CHAR_DISS_LIST:
+	{
+		if (GetRecruiterData(player))
+		{
+			std::ostringstream oss;
+
+			uint64 recruiterGUID = MAKE_NEW_GUID(GetRecruiterData(player)->guidLow, 0, HIGHGUID_PLAYER);
+
+			if (ObjectAccessor::FindPlayerInOrOutOfWorld(recruiterGUID))
+				oss << "[|cFF0177ECÔÚÏß|r]";
+			else
+				oss << "[|cFFFF1717ÀëÏß|r]";
+
+			oss << "|cFFFF1717";
+			oss << GetRecruiterData(player)->name;
+			oss << "|r";
+			player->ADD_GOSSIP_ITEM_EXTENDED(0, oss.str(), SENDER_RECRUIT_CHAR_DISMISS, 0, sReq->Notice(player, GetDissReqId2(), "ÒÆ³ý", "ÕÐÄ¼¹ØÏµ"), sReq->Golds(GetDissReqId2()), false);
+		}
+
+		std::vector<GlobalPlayerData const*> friendsDataList;
+
+		GetFriendsDataList(friendsDataList, player);
+
+		for (size_t i = 0; i < friendsDataList.size(); i++)
+		{
+			std::ostringstream oss;
+			uint64 friendGUID = MAKE_NEW_GUID(friendsDataList[i]->guidLow, 0, HIGHGUID_PLAYER);
+
+			if (ObjectAccessor::FindPlayerInOrOutOfWorld(friendGUID))
+				oss << "[|cFF0177ECÔÚÏß|r]";
+			else
+				oss << "[|cFFFF1717ÀëÏß|r]";
+
+			oss << "|cFF0177EC";
+			oss << friendsDataList[i]->name;
+			oss << "|r";
+
+			player->ADD_GOSSIP_ITEM_EXTENDED(0, oss.str(), SENDER_RECRUIT_CHAR_DISMISS, friendsDataList[i]->guidLow, sReq->Notice(player, GetDissReqId1(), "ÒÆ³ý", "ÕÐÄ¼¹ØÏµ"), sReq->Golds(GetDissReqId1()), false);
+		}
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+	}
+	break;
+	case SENDER_RECRUIT_CHAR_DISMISS:
+	{
+		if (action == 0)
+		{
+			if (sReq->Check(player, GetDissReqId2()))
+			{
+				sReq->Des(player, GetDissReqId2());
+				DismissRecruit(GetRecruiterData(player)->guidLow, player->GetGUID());
+			}
+		}
+		else
+		{
+			if (sReq->Check(player, GetDissReqId1()))
+			{
+				sReq->Des(player, GetDissReqId1());
+				DismissRecruit(player->GetGUIDLow(), action);
+			}
+		}
+
+		player->CLOSE_GOSSIP_MENU();
+	}
+	break;
+	case SENDER_RECRUIT_CHAR_TELE_LIST:
+	{
+		if (GetRecruiterData(player))
+		{
+			std::ostringstream oss;
+
+			uint64 recruiterGUID = MAKE_NEW_GUID(GetRecruiterData(player)->guidLow, 0, HIGHGUID_PLAYER);
+
+			if (ObjectAccessor::FindPlayerInOrOutOfWorld(recruiterGUID))
+			{
+				oss << "[|cFF0177ECÔÚÏß|r]";
+				oss << "|cFFFF1717";
+				oss << GetRecruiterData(player)->name;
+				oss << "|r";
+				player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss.str(), SENDER_RECRUIT_TELE, GetRecruiterData(player)->guidLow);
+			}
+		}
+
+		std::vector<GlobalPlayerData const*> friendsDataList;
+		GetFriendsDataList(friendsDataList, player);
+
+		for (size_t i = 0; i < friendsDataList.size(); i++)
+		{
+			std::ostringstream oss;
+			uint64 friendGUID = MAKE_NEW_GUID(friendsDataList[i]->guidLow, 0, HIGHGUID_PLAYER);
+
+			if (ObjectAccessor::FindPlayerInOrOutOfWorld(friendGUID))
+			{
+				oss << "[|cFF0177ECÔÚÏß|r]";
+				oss << "|cFF0177EC";
+				oss << friendsDataList[i]->name;
+				oss << "|r";
+				player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss.str(), SENDER_RECRUIT_TELE, friendsDataList[i]->guidLow);
+			}
+		}
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+	}
+	break;
+	case SENDER_RECRUIT_TELE:
+	{
+		RecruitTelePort(player, action);
+		player->CLOSE_GOSSIP_MENU();
+	}
+	break;
+	default:
+		return false;
+	}
+
+	return true;
+}
+
+bool Recruit::RecruitFriend(Player* player, uint32 sender, const char* name)
+{
+	if (sender != SENDER_RECRUIT_NEW)
+		return false;
+
+	player->PlayerTalkClass->ClearMenus();
+
+	if (!*name)
+		return true;
+
+	player->CLOSE_GOSSIP_MENU();
+
+	std::string pName = name;
+
+	if (!normalizePlayerName(pName))
+	{
+		ChatHandler(player->GetSession()).PSendSysMessage("|cFFFF1717[ÕÐÄ¼ÏµÍ³]|rÊä³öµÄÃû×ÖÓÐÎó");
+		return true;
+	}
+
+	uint32 GUIDLow = sWorld->GetGlobalPlayerGUID(pName);
+	if (!GUIDLow)
+	{
+		ChatHandler(player->GetSession()).PSendSysMessage("|cFFFF1717[ÕÐÄ¼ÏµÍ³]|rÕÐÄ¼µÄÍæ¼Ò²»´æÔÚ");
+		return true;
+	}
+
+	uint64 friendGuid = MAKE_NEW_GUID(GUIDLow, 0, HIGHGUID_PLAYER);
+
+	Player* pFriend = ObjectAccessor::FindPlayerInOrOutOfWorld(friendGuid);
+
+	if (!pFriend)
+	{
+		ChatHandler(player->GetSession()).PSendSysMessage("|cFFFF1717[ÕÐÄ¼ÏµÍ³]|rÕÐÄ¼µÄÍæ¼Ò²»ÔÚÏß");
+		return true;
+	}
+
+	std::string ip1 = pFriend->GetSession()->GetRemoteAddress();
+	std::string ip2 = player->GetSession()->GetRemoteAddress();
+
+	if (strcmp(ip1.c_str(), ip2.c_str()) == 0 && player->GetSession()->GetSecurity() < SEC_ADMINISTRATOR)
+	{
+		ChatHandler(player->GetSession()).PSendSysMessage("|cFFFF1717[ÕÐÄ¼ÏµÍ³]|rÍ¬Ò»IPµÄÍæ¼Ò²»ÄÜÕÐÄ¼");
+		return true;
+	}
+	
+	if (!CrossFaction() && player->GetTeamId() != pFriend->GetTeamId())
+	{
+		ChatHandler(player->GetSession()).PSendSysMessage("|cFFFF1717[ÕÐÄ¼ÏµÍ³]|rÖ»ÄÜÕÐÄ¼Í¬Ò»ÕóÓªÍæ¼Ò");
+		return true;
+	}
+
+	if (IsRecruited(pFriend))
+	{
+		ChatHandler(player->GetSession()).PSendSysMessage("|cFFFF1717[ÕÐÄ¼ÏµÍ³]|r|cFF0177EC%s|rÒÑ±»ÕÐÄ¼", sCF->GetNameLink(pFriend).c_str());
+		return true;
+	}
+
+	if (GetFriendAmount(player) >= GetPlayersLimit())
+	{
+		ChatHandler(player->GetSession()).PSendSysMessage("|cFFFF1717[ÕÐÄ¼ÏµÍ³]|rÄã²»ÄÜÕÐÄ¼¸ü¶àÍæ¼Ò");
+		return true;
+	}
+
+	if (!IsRecruitYourRecruiter(player->GetGUIDLow(), pFriend->GetGUIDLow()))
+	{
+		ChatHandler(player->GetSession()).PSendSysMessage("|cFFFF1717[ÕÐÄ¼ÏµÍ³]|rÄã²»ÄÜÕÐÄ¼ÄãµÄÕÐÄ¼Õß");
+		return true;
+	}
+
+	if (!sReq->Check(player, GetRecReqId()))
+		return true;
+
+	pFriend->recruiterGUIDLow = player->GetGUIDLow();
+
+	std::ostringstream oss;
+	oss << "|cFF0177EC";
+	oss << sCF->GetNameLink(player);
+	oss << "|rÕýÔÚÕÐÄ¼Äã";
+	PopMsg(pFriend, RECRUIT_MENU_ID, oss.str());
+
+	ChatHandler(player->GetSession()).PSendSysMessage("|cFFFF1717[ÕÐÄ¼ÏµÍ³]|rÏò|cFF0177EC%s|r·¢ËÍÕÐÄ¼ÉêÇë³É¹¦£¡",sCF->GetNameLink(pFriend).c_str());
+
+	return true;
+}
diff --git a/src/server/scripts/Custom/Recruit/Recruit.h b/src/server/scripts/Custom/Recruit/Recruit.h
new file mode 100644
index 0000000..7d7b786
--- /dev/null
+++ b/src/server/scripts/Custom/Recruit/Recruit.h
@@ -0,0 +1,110 @@
+#define SENDER_RECRUIT_NEW				6000
+#define SENDER_RECRUIT_CHAR_INFO_LIST	6001
+#define SENDER_RECRUIT_CHAR_DISS_LIST	6002
+#define SENDER_RECRUIT_CHAR_TELE_LIST	6006
+#define SENDER_RECRUIT_CHAR_DISMISS		6003
+#define SENDER_RECRUIT_TELE				6004
+#define SENDER_RECRUIT_CHAR_INFO		6005
+
+//æåä¿¡æ¯ç»æä½
+struct RecruitTemplate
+{
+	uint32 recruiterGUIDLow;
+	uint32 friendGUIDLow;
+	uint32 friendPlayedTime;
+	bool timeRewarded1;
+	bool timeRewarded2;
+	bool timeRewarded3;
+};
+extern std::vector <RecruitTemplate> RecruitInfo;
+
+//æå
+struct RecruitOrDissTemplate
+{
+	uint32 recruitReqId;
+	uint32 rewId1;
+	uint32 rewId2;
+	uint32 disReqId1;
+	uint32 disReqId2;
+	uint32 playersLimit;
+	uint32 crossFaction;
+	uint32 insLevel;
+	uint32 timeForRew1;
+	uint32 timeForRewId1;
+	uint32 timeForRew2;
+	uint32 timeForRewId2;
+	uint32 timeForRew3;
+	uint32 timeForRewId3;
+};
+extern std::vector<RecruitOrDissTemplate> RecruitOrDissVec;
+
+//æåæè½å±äº«
+struct RucruitLootShareTemplate
+{
+	uint32 shareCountLimit;
+	uint32 rewCountLimit;
+	float shareChance;
+	float rewChanceOnShare;
+};
+extern std::unordered_map<uint32, RucruitLootShareTemplate> RecruitLootMap;
+
+class Recruit
+{
+public:
+	static Recruit* instance()
+	{
+		static Recruit instance;
+		return &instance;
+	}
+	void PopMsg(Player* player, uint32 menuId, std::string text);//å¼¹åºç¡®è®¤æ¡
+
+	bool IsRecruited(Player* player); //æ¯å¦è¢«æåè¿
+
+	bool IsRecruitYourRecruiter(uint32 recruiterGUIDLow, uint32 friendGUIDLow);//æ¯å¦å¨æåä½ çæåè
+
+	uint32 GetFriendAmount(Player* recruiter);//è·åæåçç©å®¶æ°é
+
+	GlobalPlayerData const* GetRecruiterData(Player* player);//è·åæåèä¿¡æ¯
+
+	void GetFriendsDataList(std::vector<GlobalPlayerData const*> &friendsDataList, Player* player);//è·åè¢«æåçç©å®¶åè¡¨
+
+	bool RecruitAcceptOrCancel(Player*player, uint32 menuId);//ç¡®è®¤æå
+
+	bool UpdateRecruitDB(uint32 recruiterGUIDLow, uint32 friendGUIDLow);//æ´æ°æ°æ®åº
+
+	void Load();//å è½½æ°æ®åº
+
+	void DismissRecruit(uint32 recruiterGUIDLow, uint32 friendGUIDLow);//è§£é¤æåå³ç³»
+
+	void RecruitItemReward(Player* player, Item* newItem, uint32 count);//æåå¥å±
+	void RecruitMoneyReward(Player* player,uint32 count);//å±äº«éå¸
+	void RecruitXPReward(Player* player, uint32 xp,Unit* _victim = NULL, float _groupRate = 0 ,Group* _group = NULL);//å±äº«ç»éª
+	void RecruitHonorReward(Player* player, uint32 honor);//å±äº«è£èª
+	void GetItemCount(uint32 entry, uint32 count, uint32 &recruiterItemCount, uint32 &followerItemCount);
+
+	void RecruitTelePort(Player* player, uint32 targetGUIDLow);//ä¼ é
+
+	void AddMainMenu(Player* player, Object* obj);
+	bool AddSubMenuOrDoAction(Player* player, Object* obj, uint32 sender, uint32 action);
+	bool RecruitFriend(Player* player, uint32 sender, const char* name);
+
+	uint32 GetRecReqId();
+	uint32 GetRewId1();
+	uint32 GetRewId2();
+	uint32 GetDissReqId1();
+	uint32 GetDissReqId2();
+	uint32 GetPlayersLimit();
+	bool CrossFaction();
+	uint32 GetInsLevel();
+	uint32 GetTimeForRew1();
+	uint32 GetTimeForRewId1();
+	uint32 GetTimeForRew2();
+	uint32 GetTimeForRewId2();
+	uint32 GetTimeForRew3();
+	uint32 GetTimeForRewId3();
+
+	void UpdateHasRewad(Player* player, uint32 flag);
+private:
+	
+};
+#define sRecruit Recruit::instance()
diff --git a/src/server/scripts/Custom/Reincarnation/Reincarnation.cpp b/src/server/scripts/Custom/Reincarnation/Reincarnation.cpp
new file mode 100644
index 0000000..fe4b29b
--- /dev/null
+++ b/src/server/scripts/Custom/Reincarnation/Reincarnation.cpp
@@ -0,0 +1,140 @@
+#pragma execution_character_set("utf-8")
+#include "Reincarnation.h"
+#include "../FunctionCollection/FunctionCollection.h"
+#include "../Reward/Reward.h"
+#include "../Requirement/Requirement.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../String/myString.h"
+
+std::unordered_map<uint32, ReincarnationTemplate> ReincarnationMap;
+
+void Reincarnation::Load()
+{
+	ReincarnationMap.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ×ªÉúµÈ¼¶,ÐèÇóÄ£°åID,½±ÀøÄ£°åID,²Ëµ¥ÎÄ±¾ from __×ªÉú" :
+		"SELECT level,reqId,rewId,gossipText from _reincarnation");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 level = fields[0].GetUInt32();
+			ReincarnationTemplate Temp;
+			Temp.reqId = fields[1].GetUInt32();
+			Temp.rewId = fields[2].GetUInt32();
+			Temp.gossipText = fields[3].GetString();
+			ReincarnationMap.insert(std::make_pair(level, Temp));
+		} while (result->NextRow());
+	}
+}
+
+uint32 Reincarnation::GetMaxLevel()
+{
+	uint32 max = 0;
+
+	if (ReincarnationMap.empty())
+		return max;
+
+	for (auto i = ReincarnationMap.begin(); i != ReincarnationMap.end(); i++)
+		if (max < i->first)
+			max = i->first;
+
+	return max;
+}
+
+std::string Reincarnation::GetGossipText(Player* player)
+{
+	for (auto i = ReincarnationMap.begin(); i != ReincarnationMap.end(); i++)
+		if (player->reincarnationLv == i->first)
+			return i->second.gossipText;
+
+	return "";
+}
+
+void Reincarnation::AddGossip(Player* player, Object* obj)
+{
+	if (!ReincarnationMap.empty())
+	{
+		if (player->reincarnationLv >= GetMaxLevel())
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GetGossipText(player).c_str(), SENDER_REINCARNATION, GOSSIP_ACTION_INFO_DEF);
+		else
+		{
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GetGossipText(player).c_str(), SENDER_REINCARNATION, GOSSIP_ACTION_INFO_DEF);
+
+			uint32 rewId = 0;
+			uint32 reqId = 0;
+			GetParams(player, rewId, reqId);
+			const char* text = sString->Format(sString->GetText(CORE_STR_TYPES(STR_REICARNATION_REQ)), player->reincarnationLv + 1);
+
+			player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, sString->GetText(CORE_STR_TYPES(STR_REICARNATION_CLICK)), SENDER_REINCARNATION, GOSSIP_ACTION_INFO_DEF + 1, sReq->Notice(player, reqId, text, ""), sReq->Golds(reqId), 0);
+		}
+	}
+
+	if (obj->ToCreature())
+		player->SEND_GOSSIP_MENU(obj->GetEntry(), obj->GetGUID());
+	else
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+}
+
+void Reincarnation::GetParams(Player* player, uint32 &rewId, uint32 &reqId)
+{
+	for (auto i = ReincarnationMap.begin(); i != ReincarnationMap.end(); i++)
+		if (player->reincarnationLv + 1 == i->first)
+		{
+			rewId = i->second.rewId;
+			reqId = i->second.reqId;
+		}
+}
+
+void Reincarnation::Save(Player* player)
+{
+	CharacterDatabase.DirectPExecute("UPDATE characters SET reincarnationLv = '%u' WHERE guid = '%u'", player->reincarnationLv,player->GetGUIDLow());
+}
+
+void Reincarnation::Load(Player* player)
+{
+	if (QueryResult result = CharacterDatabase.PQuery("SELECT reincarnationLv FROM characters WHERE guid = '%u'", player->GetGUIDLow()))
+		player->reincarnationLv = result->Fetch()[0].GetUInt32();
+}
+
+void Reincarnation::DoAction(Player* player, Object* obj, uint32 action)
+{
+	if (action == GOSSIP_ACTION_INFO_DEF)
+		AddGossip(player, obj);
+	else if (action == GOSSIP_ACTION_INFO_DEF + 1)
+	{
+		uint32 rewId = 0;
+		uint32 reqId = 0;
+		GetParams(player, rewId, reqId);
+
+		if (sReq->Check(player, reqId))
+		{
+			sRew->Rew(player, rewId);
+			sReq->Des(player, reqId);
+			player->reincarnationLv++;
+			Save(player);
+			const char* text = sString->Format(sString->GetText(CORE_STR_TYPES(STR_REICARNATION_ANNOUNCE)), sCF->GetNameLink(player).c_str(), player->reincarnationLv);
+			sWorld->SendScreenMessage(text);
+		}
+		
+		player->CLOSE_GOSSIP_MENU();
+	}
+}
+
+
+class ReincarnationPlayerScript : PlayerScript
+{
+public:
+	ReincarnationPlayerScript() : PlayerScript("ReincarnationPlayerScript") {}
+
+	void OnLogin(Player* player)
+	{
+		sReincarnation->Load(player);
+	}
+};
+
+void AddSC_Reincarnation()
+{
+	new ReincarnationPlayerScript();
+}
diff --git a/src/server/scripts/Custom/Reincarnation/Reincarnation.h b/src/server/scripts/Custom/Reincarnation/Reincarnation.h
new file mode 100644
index 0000000..4ab8ffd
--- /dev/null
+++ b/src/server/scripts/Custom/Reincarnation/Reincarnation.h
@@ -0,0 +1,30 @@
+struct ReincarnationTemplate
+{
+	uint32 reqId;
+	uint32 rewId;
+	std::string gossipText;
+};
+
+extern std::unordered_map<uint32, ReincarnationTemplate> ReincarnationMap;
+
+class Reincarnation
+{
+public:
+	static Reincarnation* instance()
+	{
+		static Reincarnation instance;
+		return &instance;
+	}
+
+	void Load();
+	uint32 GetMaxLevel();
+	void GetParams(Player* player, uint32 &rewId, uint32 &reqId);
+	std::string GetGossipText(Player* player);
+	void AddGossip(Player* player, Object* obj);
+	void DoAction(Player* player, Object* obj, uint32 action);
+	void Save(Player* player);
+	void Load(Player* player);
+private:
+
+};
+#define sReincarnation Reincarnation::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Requirement/Requirement.cpp b/src/server/scripts/Custom/Requirement/Requirement.cpp
new file mode 100644
index 0000000..c992dc7
--- /dev/null
+++ b/src/server/scripts/Custom/Requirement/Requirement.cpp
@@ -0,0 +1,1139 @@
+#pragma execution_character_set("utf-8")
+#include "../CommonFunc/CommonFunc.h"
+#include "../HonorRank/HonorRank.h"
+#include "../Requirement/Requirement.h"
+#include "../Reward/Reward.h"
+#include "../DataLoader/DataLoader.h"
+#include "Chat.h"
+#include "../VIP/VIP.h"
+#include "../String/myString.h"
+#include <iostream>
+#include <iomanip>
+#include "../Rank/Rank.h"
+#include "../Faction/Faction.h"
+#include "../Command/CustomCommand.h"
+#include "../SpiritPower/SpiritPower.h"
+
+std::unordered_map<uint32, ReqTemplate> ReqMap;
+
+void Req::Load()
+{
+	ReqMap.clear();
+	
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		
+		//			0		1		2		3			4		5		6		7
+		"SELECT ÐèÇóÄ£°åID,»áÔ±µÈ¼¶,¾üÏÎµÈ¼¶,³É¾ÍµãÊý,½ð±ÒÊýÁ¿,»ý·ÖÊýÁ¿,ÈÙÓþµãÊý,¾º¼¼µãÊý,"
+		//	8		9		10		11			12			13		14		15			16		17		18		19			20		21			22		23			24		25			26		27
+		"ÎïÆ·ID1,ÎïÆ·ÊýÁ¿1,ÎïÆ·ID2,ÎïÆ·ÊýÁ¿2,ÎïÆ·ID3,ÎïÆ·ÊýÁ¿3,ÎïÆ·ID4,ÎïÆ·ÊýÁ¿4,ÎïÆ·ID5,ÎïÆ·ÊýÁ¿5,ÎïÆ·ID6,ÎïÆ·ÊýÁ¿6,ÎïÆ·ID7,ÎïÆ·ÊýÁ¿7,ÎïÆ·ID8,ÎïÆ·ÊýÁ¿8,ÎïÆ·ID9,ÎïÆ·ÊýÁ¿9,ÎïÆ·ID10,ÎïÆ·ÊýÁ¿10,"
+		//28		29		30		31			32		33		34		35		36		37			38		39
+		"¾­ÑéÊýÁ¿,ÊÇ·ñÔÚ¸±±¾,µÈ¼¶,×Ô¶¨ÒåµÈ¼¶,×Ô¶¨ÒåÕóÓªID,GMÃüÁî×é,ÁéÁ¦Öµ,×ªÉúµÈ¼¶,µØÍ¼×é,¼¼ÄÜ»ò¹â»·×é,ÈÎÎñ×é,³É¾Í×é FROM _Ä£°å_ÐèÇó" :
+
+		//		0		1		2		3				4			5		6			7
+		"SELECT reqId,vipLevel,hr,achievementPoints,goldCount,tokenCount,hrPoints,arenaPoints,"
+		//	8		9		10		11			12			13		14		15			16		17		18		19			20		21			22		23			24		25			26		27
+		"itemId1,itemCount1,itemId2,itemCount2,itemId3,itemCount3,itemId4,itemCount4,itemId5,itemCount5,itemId6,itemCount6,itemId7,itemCount7,itemId8,itemCount8,itemId9,itemCount9,itemId10,itemCount10,"
+		//28	29		30		31		32		33		34			35				36		37		38			39
+		"xp,inInstance,level,rankLevel,faction,command,spiriptPower,reincarnation,mapData,spellData,questData,achieveData FROM _req");
+
+	if (!result)
+		return;
+
+	do
+	{
+		Field* fields = result->Fetch();
+		uint32 reqId = fields[0].GetUInt32();
+		ReqTemplate ReqTemp;
+		ReqTemp.meetVipLevel			= fields[1].GetInt32();
+		ReqTemp.meetHRRank				= fields[2].GetInt32();
+		ReqTemp.meetAchievementPoints	= fields[3].GetUInt32();
+		ReqTemp.desGoldCount			= fields[4].GetUInt32() * GOLD;
+		ReqTemp.desTokenCount			= fields[5].GetUInt32();
+		ReqTemp.desHRPoints				= fields[6].GetUInt32();
+		ReqTemp.desArenaPoints			= fields[7].GetUInt32();
+
+		for (size_t i = 0; i < REQ_ITEM_MAX; i++)
+		{
+			ReqTemp.desItem[i]			= fields[8 + 2 * i].GetUInt32();
+			ReqTemp.desItemCount[i]		= fields[9 + 2 * i].GetUInt32();
+		}
+
+		ReqTemp.desXp					= fields[28].GetUInt32();
+		ReqTemp.inInstance				= fields[29].GetBool();
+		ReqTemp.meetLevel				= fields[30].GetInt32();
+		ReqTemp.meetRankLevel			= fields[31].GetInt32();
+		ReqTemp.meetFaction				= fields[32].GetInt32();
+
+		Tokenizer commandData(fields[33].GetString(), '#');
+		for (Tokenizer::const_iterator itr = commandData.begin(); itr != commandData.end(); ++itr)
+		{
+			Tokenizer commands(*itr, '$');
+			ReqCommandTemplate temp;
+			if (commands.size() > 0)
+				temp.command = commands[0];
+			else
+				temp.command = "";
+
+			if (commands.size() > 1)
+				temp.icon = commands[1];
+			else
+				temp.icon = "";
+
+			if (commands.size() > 2)
+				temp.des = commands[2];
+			else
+				temp.des = "";
+
+			ReqTemp.CommandDataVec.push_back(temp);
+		}
+
+		ReqTemp.desSpiritPower			= fields[34].GetUInt32();
+		ReqTemp.reincarnation			= fields[35].GetInt32();
+
+		Tokenizer mapData(fields[36].GetString(), '#');
+
+		for (Tokenizer::const_iterator itr = mapData.begin(); itr != mapData.end(); ++itr)
+		{
+			char* map = strtok((char*)(*itr), ",");
+			char* zone = strtok(NULL, ",");
+			char* area = strtok(NULL, ",");
+			
+			if (!map)
+				continue;
+
+			ReqMapData t;
+			t.map = atoi(map);
+			
+			if (zone)
+				t.zone = atoi(zone);
+			else
+				t.zone = 0;
+
+			if (area)
+				t.area = atoi(area);
+
+			else
+				t.area = 0;
+
+			ReqTemp.MapDataVec.push_back(t);
+		}
+
+		Tokenizer spellData(fields[37].GetString(), '#');
+
+		for (Tokenizer::const_iterator itr = spellData.begin(); itr != spellData.end(); ++itr)
+			if (SpellInfo const*  spellInfo = sSpellMgr->GetSpellInfo(abs(atoi(*itr))))
+				ReqTemp.SpellDataVec.push_back(atoi(*itr));
+
+
+		Tokenizer questData(fields[38].GetString(), '#');
+
+		for (Tokenizer::const_iterator itr = questData.begin(); itr != questData.end(); ++itr)
+			if (Quest const* questProto = sObjectMgr->GetQuestTemplate(abs(atoi(*itr))))
+				ReqTemp.QuestDataVec.push_back(atoi(*itr));
+
+		Tokenizer achieveData(fields[39].GetString(), '#');
+		for (Tokenizer::const_iterator itr = achieveData.begin(); itr != achieveData.end(); ++itr)
+			if (AchievementEntry const* achieve = sAchievementStore.LookupEntry(atoi(*itr)))
+				ReqTemp.AchieveDataVec.push_back(atoi(*itr));
+
+		ReqMap.insert(std::make_pair(reqId, ReqTemp));
+
+	} while (result->NextRow());
+}
+
+std::string padRight(std::string &oriStr, int len)
+{
+	int strlen = oriStr.length();
+	if (strlen < len)
+		for (int i = 0; i < len - strlen; i++)
+			oriStr = oriStr + " ";
+
+	return oriStr;
+}
+
+std::string padLeft(std::string &oriStr, int len)
+{
+	int strlen = oriStr.length();
+	if (strlen < len)
+		for (int i = 0; i < len - strlen; i++)
+			oriStr = ' ' + oriStr;
+
+	return oriStr;
+}
+
+
+std::string Req::Notice(Player* player, uint32 reqId, std::string generalText, std::string text, uint32 count, uint32 chance, uint32 vipRateType, uint32 hrRateType)
+{
+	uint32		meetLevel				= 0;
+	int32		meetHRRank				= 0;
+	int32		meetVipLevel			= 0;
+	int32		meetRankLevel			= 0;
+	int32		meetFaction				= 0;
+	uint32		meetAchievementPoints	= 0;
+	uint32		desXp					= 0;
+	uint32		desGoldCount			= 0;
+	uint32		desTokenCount			= 0;
+	uint32		desHRPoints				= 0;
+	uint32		desArenaPoints			= 0;
+	uint32		desItem[REQ_ITEM_MAX];
+	uint32		desItemCount[REQ_ITEM_MAX];
+	uint32		desSpiritPower			= 0;
+	uint32		areaId					= 0;
+	int32		reincarnation			= 0;
+	bool		inInstance				= false;
+	
+
+	std::unordered_map<uint32, ReqTemplate>::iterator iter = ReqMap.find(reqId);
+	if (iter != ReqMap.end())
+	{
+			meetLevel				= iter->second.meetLevel				;
+			meetHRRank				= iter->second.meetHRRank				;
+			meetVipLevel			= iter->second.meetVipLevel				;
+			meetRankLevel			= iter->second.meetRankLevel			;
+			meetFaction				= iter->second.meetFaction				;
+			meetAchievementPoints	= iter->second.meetAchievementPoints	;
+			desXp					= iter->second.desXp					;
+			desGoldCount			= count * iter->second.desGoldCount		;
+			desTokenCount			= count * iter->second.desTokenCount	;
+			desHRPoints				= count * iter->second.desHRPoints		;
+			desArenaPoints			= count * iter->second.desArenaPoints	;
+
+			for (size_t i = 0; i < REQ_ITEM_MAX; i++)
+			{
+				desItem[i] = iter->second.desItem[i];
+				desItemCount[i] = count * iter->second.desItemCount[i];
+			}
+
+			desSpiritPower			= count * iter->second.desSpiritPower	;
+			reincarnation			= iter->second.reincarnation			;
+			inInstance				= iter->second.inInstance				;
+	}
+	else
+		return "";
+
+	
+	std::ostringstream oss;
+	oss << generalText << text;
+	
+	if (abs(meetVipLevel) > 0 || abs(meetHRRank) > 0 || meetAchievementPoints > 0 || meetLevel > 0 || abs(meetRankLevel) > 0 || abs(reincarnation) > 0 || abs(meetFaction) >0)
+	{
+		oss << "\n\n|cFFFF1717ÐèÒªÂú×ã|r\n\n";
+
+		if (meetLevel > 0)
+			oss << "|cFFFFCC00[µÈ¼¶" << meetLevel << "]|r";
+
+		if (abs(meetHRRank) > 0)
+		{
+			uint32 hrRank = player->GetTeamId() == TEAM_ALLIANCE ? abs(meetHRRank) : abs(meetHRRank) + 14;
+			std::string title = "";
+			std::string icon = "";
+			sCF->GetHRTitle(NULL, title, icon, true, hrRank);
+
+			if (meetHRRank > 0)
+				oss << title;
+			else
+				oss << "µ±Ç°ÊÇ" << title;
+		}
+
+		if (abs(meetVipLevel) > 0)
+		{
+			std::string title = "";
+			std::string icon = "";
+			sVIP->GetVIPTitle(NULL, title, icon, true, abs(meetVipLevel));
+
+			if (meetVipLevel > 0)
+				oss << title;
+			else
+				oss << "µ±Ç°ÊÇ" << title;
+		}
+
+		if (abs(meetRankLevel) > 0)
+		{
+			if (meetRankLevel > 0)
+				oss << "|cFFFFCC00" << sRank->GetName(meetRankLevel) << "|r";
+			else
+				oss << "µ±Ç°ÊÇ" << "|cFFFFCC00" << sRank->GetName(abs(meetRankLevel)) << "|r";
+		}
+
+		if (abs(reincarnation) > 0)
+		{
+			if (reincarnation > 0)
+				oss << "|cFFFFCC00" << "×ªÉúµÈ¼¶" << reincarnation << "|r";
+			else
+				oss << "µ±Ç°ÊÇ" << "|cFFFFCC00" << "×ªÉúµÈ¼¶" << abs(reincarnation) << "|r";
+		}
+
+
+		if (abs(meetFaction) > 0)
+		{
+			if (meetFaction > 0)
+				oss << "|cFFFFCC00" << sFaction->GetName(meetFaction) << "|r";
+			else
+				oss << "µ±Ç°ÊÇ|cFFFFCC00" << sFaction->GetName(meetFaction) << "|r";
+		}
+		
+		if (meetAchievementPoints > 0)
+			oss << "|cFFFFCC00[³É¾Íµã" << meetAchievementPoints << "]|r";
+
+		if (inInstance)
+			oss << "|cFFFFCC00[ÔÚ¸±±¾ÖÐ]|r";
+
+		if (AreaTableEntry const* areaEntry = GetAreaEntryByAreaID(areaId))
+			oss << "|cFFFFCC00[ÔÚ" << "areaEntry->area_name[4]" << "ÇøÓòÖÐ]|r";
+
+		oss << "\n";
+	}
+
+	ItemTemplate const* pProto[REQ_ITEM_MAX];
+	for (size_t i = 0; i < REQ_ITEM_MAX; i++)
+		pProto[i] = sObjectMgr->GetItemTemplate(desItem[i]);
+
+	bool reqItem = false;
+
+	for (size_t i = 0; i < REQ_ITEM_MAX; i++)
+		if (pProto[i] && desItemCount[i] > 0)
+			reqItem = true;
+
+	if (desGoldCount > 0 || desXp > 0 || desTokenCount > 0 || desHRPoints > 0 || desArenaPoints > 0 || reqItem)
+	{
+		oss << "\n|cFFFF1717½«ÏûºÄ|r\n\n";
+
+		if (desTokenCount > 0)
+			oss << "|cFF0030FF" << desTokenCount << "|r|cFFFFCC00" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "|r";
+		if (desHRPoints > 0)
+			oss << "|cFF0030FF" << desHRPoints << "|r|cFFFFCC00ÈÙÓþ|r";
+		if (desArenaPoints > 0)
+			oss << "|cFF0030FF" << desArenaPoints << "|r|cFFFFCC00¾º¼¼µã|r";
+		if (desXp > 0)
+			oss << "|cFF0030FF" << desXp << "|r|cFFFFCC00¾­Ñé|r";
+		if (desGoldCount > 0)
+			oss << "|cFF0030FF" << desGoldCount / GOLD << "|r|cFFFFCC00½ð±Ò|r";
+
+
+		if (desXp > 0 || desTokenCount > 0 || desHRPoints > 0 || desArenaPoints > 0 || desGoldCount > 0)
+			oss << "\n\n";
+
+		for (size_t i = 0; i < REQ_ITEM_MAX; i++)
+			if (pProto[i] && desItemCount[i] > 0)
+				oss << sCF->GetItemLink(desItem[i]) << " X |cFFFF1717" << desItemCount[i] << "|r\n\n";
+		
+		if (chance < 100)
+		{
+			oss << "³É¹¦¼¸ÂÊÊÇ" << chance + sVIP->GetRate(player, VIPRateTypes(vipRateType)) + sHR->GetRate(player, HRRateTypes(hrRateType)) << "%";
+			if (sVIP->GetRate(player, VIPRateTypes(vipRateType)) > 0 || sHR->GetRate(player, HRRateTypes(hrRateType)) > 0)
+				oss << "(";
+			if (sVIP->GetRate(player, VIPRateTypes(vipRateType)) > 0)
+				oss << "»áÔ± +" << sVIP->GetRate(player, VIPRateTypes(vipRateType)) << "%";
+			if (sHR->GetRate(player, HRRateTypes(hrRateType)) > 0)
+				oss << "¾üÏÎ + " << sHR->GetRate(player, HRRateTypes(hrRateType)) << "%";
+			if (sVIP->GetRate(player, VIPRateTypes(vipRateType)) > 0 || sHR->GetRate(player, HRRateTypes(hrRateType)) > 0)
+				oss << ")";
+		}
+			
+		oss <<"\n\n";
+	}
+	
+	return oss.str();
+}
+uint32 Req::Golds(uint32 reqId, uint32 count)
+{
+	std::unordered_map<uint32, ReqTemplate>::iterator iter = ReqMap.find(reqId);
+
+	if (iter != ReqMap.end())
+		return count* iter->second.desGoldCount;
+
+	return 0;
+}
+
+bool Req::Check(Player* player, uint32 reqId, uint32 count, bool notice)
+{
+	if (reqId == 0)
+		return true;
+
+	bool		legal					= true;
+	uint32		meetLevel				= 0;
+	int32		meetHRRank				= 0;
+	int32		meetVipLevel			= 0;
+	int32		meetRankLevel			= 0;
+	int32		reincarnation			= 0;
+	int32		meetFaction				= 0;
+	uint32		meetAchievementPoints	= 0;
+	uint32		desXp					= 0;
+	uint32		desGoldCount			= 0;
+	uint32		desTokenCount			= 0;
+	uint32		desHRPoints				= 0;
+	uint32		desArenaPoints			= 0;
+	uint32		desItem[REQ_ITEM_MAX];
+	uint32		desItemCount[REQ_ITEM_MAX];
+	uint32		desSpiritPower			= 0;
+	uint32		areaId					= 0;
+	bool		inInstance				= false;
+
+
+	std::unordered_map<uint32, ReqTemplate>::iterator iter = ReqMap.find(reqId);
+	if (iter != ReqMap.end())
+	{
+		meetLevel = iter->second.meetLevel;
+		meetHRRank = iter->second.meetHRRank;
+		meetVipLevel = iter->second.meetVipLevel;
+		meetRankLevel = iter->second.meetRankLevel;
+		reincarnation = iter->second.reincarnation;
+		meetFaction = iter->second.meetFaction;
+		meetAchievementPoints = iter->second.meetAchievementPoints;
+		desXp = iter->second.desXp;
+		desGoldCount = count * iter->second.desGoldCount;
+		desTokenCount = count * iter->second.desTokenCount;
+		desHRPoints = count * iter->second.desHRPoints;
+		desArenaPoints = count * iter->second.desArenaPoints;
+		for (size_t i = 0; i < REQ_ITEM_MAX; i++)
+		{
+			desItem[i] = iter->second.desItem[i];
+			desItemCount[i] = count * iter->second.desItemCount[i];
+		}
+		desSpiritPower = count * iter->second.desSpiritPower;
+		inInstance = iter->second.inInstance;
+	}
+	else
+	{
+		if (notice)
+			ChatHandler(player->GetSession()).PSendSysMessage("|cFFFF1717Êý¾Ý¿âÎ´Õý³£ÅäÖÃ|r");
+		return false;
+	}
+
+	if (inInstance && !player->GetMap()->IsDungeon())
+	{
+		if (notice)
+			ChatHandler(player->GetSession()).PSendSysMessage(sString->GetText(CORE_STR_TYPES(STR_REQ_INSTANCE)));
+		legal = false;
+	}
+
+	if (areaId != 0 && player->GetAreaId() != areaId)
+	{
+		AreaTableEntry const* area = GetAreaEntryByAreaID(areaId);
+		if (notice)
+			ChatHandler(player->GetSession()).PSendSysMessage(sString->Format(sString->GetText(CORE_STR_TYPES(STR_REQ_ZONE)), area->area_name[player->GetSession()->GetSessionDbcLocale()]));
+		legal = false;
+	}
+
+	if (meetLevel > 0)
+	{
+		if (player->getLevel() < meetLevel)
+		{
+			if (notice)
+				ChatHandler(player->GetSession()).PSendSysMessage(sString->Format(sString->GetText(CORE_STR_TYPES(STR_REQ_LEVEL)), player->getLevel(), meetLevel));
+			legal = false;
+		}
+	}
+
+	if (abs(meetVipLevel) > 0)
+	{
+		if (meetVipLevel > 0)
+		{
+			if (player->vipLevel < meetVipLevel)
+			{
+				if (notice)
+					ChatHandler(player->GetSession()).PSendSysMessage("µ±Ç°%s£¬Ðè´ïµ½%s", sVIP->GetVIPName(player->vipLevel).c_str(), sVIP->GetVIPName(meetVipLevel).c_str());
+				legal = false;
+			}
+		}
+		else
+		{
+			if (player->vipLevel != abs(meetVipLevel))
+			{
+				if (notice)
+					ChatHandler(player->GetSession()).PSendSysMessage("µ±Ç°%s£¬±ØÐëÊÇ%s", sVIP->GetVIPName(player->vipLevel).c_str(), sVIP->GetVIPName(abs(meetVipLevel)).c_str());
+				legal = false;
+			}
+		}
+	}
+
+	if (abs(meetHRRank) > 0)
+	{
+		uint32 hrRank = sHR->GetHRRank(player);
+
+		if (meetHRRank > 0)
+		{
+			if (hrRank < meetHRRank)
+			{
+				std::string title = "[ÎÞ]";
+				std::string icon = "";
+				std::string nextTitle = "";
+
+				if (player->realTeam == TEAM_HORDE)
+				{
+					hrRank += 14;
+					meetHRRank += 14;
+				}
+
+				sCF->GetHRTitle(NULL, title, icon, true, hrRank);
+				sCF->GetHRTitle(NULL, nextTitle, icon, true, meetHRRank);
+
+				if (notice)
+					ChatHandler(player->GetSession()).PSendSysMessage("µ±Ç°%s,Ðè´ïµ½%s", title.c_str(), nextTitle.c_str());
+				legal = false;
+			}
+		}
+		else
+		{
+			if (hrRank != abs(meetHRRank))
+			{
+				meetHRRank = abs(meetHRRank);
+
+				std::string title = "[ÎÞ]";
+				std::string icon = "";
+				std::string nextTitle = "";
+
+				if (player->realTeam == TEAM_HORDE)
+				{
+					hrRank += 14;
+					meetHRRank += 14;
+				}
+
+				sCF->GetHRTitle(NULL, title, icon, true, hrRank);
+				sCF->GetHRTitle(NULL, nextTitle, icon, true, meetHRRank);
+				if (notice)
+					ChatHandler(player->GetSession()).PSendSysMessage("µ±Ç°%s,±ØÐëÊÇ%s", title.c_str(), nextTitle.c_str());
+				legal = false;
+			}
+		}
+	}
+	if (meetAchievementPoints > 0)
+	{
+		if (sCF->GetAchievementPoints(player) < meetAchievementPoints)
+		{
+			if (notice)
+				ChatHandler(player->GetSession()).PSendSysMessage(sString->Format(sString->GetText(CORE_STR_TYPES(STR_REQ_ACHIEVE)), sCF->GetAchievementPoints(player), meetAchievementPoints));
+			legal = false;
+		}
+	}
+
+	if (abs(meetRankLevel) > 0)
+	{
+		if (meetRankLevel > 0)
+		{
+			if (player->rankLevel < meetRankLevel)
+			{
+				if (notice)
+					ChatHandler(player->GetSession()).PSendSysMessage("µ±Ç°%s£¬Ðè´ïµ½%s", sRank->GetName(player->rankLevel).c_str(), sRank->GetName(meetRankLevel).c_str());
+				legal = false;
+			}
+		}
+		else
+		{
+			if (player->rankLevel != abs(meetRankLevel))
+			{
+				{
+					if (notice)
+						ChatHandler(player->GetSession()).PSendSysMessage("µ±Ç°%s£¬±ØÐëÊÇ%s", sRank->GetName(player->rankLevel).c_str(), sRank->GetName(abs(meetRankLevel)).c_str());
+					legal = false;
+				}
+			}
+		}	
+	}
+
+	if (abs(reincarnation) > 0)
+	{
+		if (reincarnation > 0)
+		{
+			if (player->reincarnationLv < reincarnation)
+			{
+				if (notice)
+					ChatHandler(player->GetSession()).PSendSysMessage("µ±Ç°×ªÉúµÈ¼¶%u£¬Ðè´ïµ½%u", player->reincarnationLv, reincarnation);
+				legal = false;
+			}
+		}
+		else
+		{
+			if (player->reincarnationLv != abs(reincarnation))
+			{
+				{
+					if (notice)
+						ChatHandler(player->GetSession()).PSendSysMessage("µ±Ç°×ªÉúµÈ¼¶%u£¬±ØÐëÊÇ%s", player->reincarnationLv, abs(reincarnation));
+					legal = false;
+				}
+			}
+		}
+	}
+
+	if (meetFaction > 0)
+	{
+		if (player->faction != meetFaction)
+		{
+			if (notice)
+				ChatHandler(player->GetSession()).PSendSysMessage("µ±Ç°%s£¬ÐèÒª%s", sFaction->GetName(player->faction).c_str(), sFaction->GetName(meetFaction).c_str());
+			legal = false;
+		}
+	}
+
+	if (desXp > 0)
+	{
+		if (player->GetUInt32Value(PLAYER_XP) < desXp)
+		{
+			if (notice)
+				ChatHandler(player->GetSession()).PSendSysMessage(sString->Format(sString->GetText(CORE_STR_TYPES(STR_REQ_XP)), player->GetUInt32Value(PLAYER_XP), desXp));
+			legal = false;
+		}
+	}
+
+	if (desGoldCount > 0)
+	{
+		if (!player->HasEnoughMoney(desGoldCount))
+		{
+			if (notice)
+				ChatHandler(player->GetSession()).PSendSysMessage(sString->Format(sString->GetText(CORE_STR_TYPES(STR_REQ_GOLD)), player->GetMoney() / GOLD, desGoldCount / GOLD));
+			legal = false;
+		}
+	}
+
+	if (desSpiritPower > 0)
+	{
+		if (player->SpiritPower < desSpiritPower)
+		{
+			if (notice)
+				ChatHandler(player->GetSession()).PSendSysMessage("µ±Ç°[ÁéÁ¦]%u£¬ÐèÏûºÄ[ÁéÁ¦]%u", player->SpiritPower, desSpiritPower);
+			legal = false;
+		}
+	}
+
+	if (desTokenCount > 0)
+	{
+		uint32 tokenAmount = sCF->GetTokenAmount(player);
+		if (tokenAmount < desTokenCount)
+		{
+			if (notice)
+				ChatHandler(player->GetSession()).PSendSysMessage(sString->Format(sString->GetText(CORE_STR_TYPES(STR_REQ_TOKEN)), tokenAmount, desTokenCount));
+			legal = false;
+		}
+	}
+
+	if (desHRPoints > 0 && player->GetHonorPoints() < desHRPoints)
+	{
+		if (notice)
+			ChatHandler(player->GetSession()).PSendSysMessage(sString->Format(sString->GetText(CORE_STR_TYPES(STR_REQ_HONOR)), player->GetHonorPoints(), desHRPoints));
+		legal = false;
+	}
+
+	if (desArenaPoints > 0 && player->GetArenaPoints() < desArenaPoints)
+	{
+		if (notice)
+			ChatHandler(player->GetSession()).PSendSysMessage(sString->Format(sString->GetText(CORE_STR_TYPES(STR_REQ_ARENA)), player->GetArenaPoints(), desArenaPoints));
+		legal = false;
+	}
+
+	ItemTemplate const* pProto[REQ_ITEM_MAX];
+	for (size_t i = 0; i < REQ_ITEM_MAX; i++)
+		pProto[i] = sObjectMgr->GetItemTemplate(desItem[i]);
+
+	for (size_t i = 0; i < REQ_ITEM_MAX; i++)
+		if (pProto[i] && desItemCount[i] > 0)
+			if (player->GetItemCount(desItem[i]) < desItemCount[i])
+			{
+				if (notice)
+					ChatHandler(player->GetSession()).PSendSysMessage(sString->Format(sString->GetText(CORE_STR_TYPES(STR_REQ_ITEM)), sCF->GetItemLink(desItem[i]).c_str(), desItemCount[i] - player->GetItemCount(desItem[i])));
+				legal = false;
+			}
+
+	if (!CheckQuest(player, reqId, notice))
+		legal = false;
+
+	if (!CheckMap(player, reqId, notice))
+		legal = false;
+
+	if (!CheckSpell(player, reqId, notice))
+		legal = false;
+
+	if (!CheckAcheive(player, reqId, notice))
+		legal = false;
+
+	if (!legal && notice)
+		player->GetSession()->SendNotification(sString->GetText(CORE_STR_TYPES(STR_REQ_NOTICE)));
+	return legal;
+}
+
+void Req::Des(Player* player, uint32 reqId, uint32 count, uint32 expItemId)
+{
+	if (reqId == 0)
+		return;
+
+	uint32		meetLevel				= 0;
+	int32		meetHRRank				= 0;
+	int32		meetVipLevel			= 0;
+	int32		meetRankLevel			= 0;
+	int32		meetFaction				= 0;
+	uint32		meetAchievementPoints	= 0;
+	uint32		desXp					= 0;
+	uint32		desGoldCount			= 0;
+	uint32		desTokenCount			= 0;
+	uint32		desHRPoints				= 0;
+	uint32		desArenaPoints			= 0;
+	uint32		desItem[REQ_ITEM_MAX];
+	uint32		desItemCount[REQ_ITEM_MAX];
+	uint32		desSpiritPower			= 0;
+	uint32		areaId					= 0;
+	bool		inInstance				= false;
+
+
+	std::unordered_map<uint32, ReqTemplate>::iterator iter = ReqMap.find(reqId);
+	if (iter != ReqMap.end())
+	{
+		meetLevel = iter->second.meetLevel;
+		meetHRRank = iter->second.meetHRRank;
+		meetVipLevel = iter->second.meetVipLevel;
+		meetRankLevel = iter->second.meetRankLevel;
+		meetFaction = iter->second.meetFaction;
+		meetAchievementPoints = iter->second.meetAchievementPoints;
+		desXp = iter->second.desXp;
+		desGoldCount = count * iter->second.desGoldCount;
+		desTokenCount = count * iter->second.desTokenCount;
+		desHRPoints = count * iter->second.desHRPoints;
+		desArenaPoints = count * iter->second.desArenaPoints;
+		for (size_t i = 0; i < REQ_ITEM_MAX; i++)
+		{
+			desItem[i] = iter->second.desItem[i];
+			desItemCount[i] = count * iter->second.desItemCount[i];
+		}
+		desSpiritPower = count * iter->second.desSpiritPower;
+		inInstance = iter->second.inInstance;
+
+		for (auto itr = iter->second.CommandDataVec.begin(); itr != iter->second.CommandDataVec.end(); itr++)
+			if (!itr->command.empty())
+				sCustomCommand->DoCommand(player, itr->command);
+	}
+	else
+		return;
+
+	if (desXp > 0)	player->SetUInt32Value(PLAYER_XP, player->GetUInt32Value(PLAYER_XP) - desXp);
+
+	if (desTokenCount > 0) sCF->UpdateTokenAmount(player, desTokenCount, false, "[REQ]¿Û³ý");
+
+	if (desHRPoints > 0) player->ModifyHonorPoints(-int32(desHRPoints));
+
+	if (desArenaPoints > 0) player->ModifyArenaPoints(-int32(desArenaPoints));
+
+	if (desSpiritPower > 0) sSpiritPower->Update(player, desSpiritPower, false);
+
+	if (expItemId != 0)
+		for (size_t i = 0; i < REQ_ITEM_MAX; i++)
+			if (expItemId == desItem[i] && desItemCount[i] > 0)
+			{
+				desItemCount[i]--;
+				break;
+			}
+
+	ItemTemplate const* pProto[REQ_ITEM_MAX];
+	for (size_t i = 0; i < REQ_ITEM_MAX; i++)
+		pProto[i] = sObjectMgr->GetItemTemplate(desItem[i]);
+
+	for (size_t i = 0; i < REQ_ITEM_MAX; i++)
+		if (pProto[i] && desItemCount[i] > 0)
+			player->DestroyItemCount(desItem[i], desItemCount[i], true, false);
+
+	if (desGoldCount > 0) player->ModifyMoney(-int32(desGoldCount));
+}
+
+bool IsSpecialChar(char ch){
+	//ÓÐ¼¸¸ö×Ö·ûÓëÊäÈë·¨ÓÐ¹Ø£»    
+	const char *punc="0123456789ABCDEFabcdef|r[]";
+	int len=strlen(punc);    
+	for(int i=0; i<len; i++)        
+		if( *(punc+i)== ch )            
+			return true;    
+	return false;
+}
+
+void RemovePunc(std::string &word)
+{
+	std::string::iterator first, second;
+
+	first = find_if(word.begin(), word.end(), IsSpecialChar);    
+	while (first != word.end())    
+	{	
+		second = word.erase(first, first + 1);       
+		first = find_if(second, word.end(), IsSpecialChar); 
+	} 
+}
+
+std::string Req::GetDescription(uint32 reqId, Player* player, uint32 count)
+{
+	uint32		meetLevel = 0;
+	int32		meetHRRank = 0;
+	int32		meetVipLevel = 0;
+	int32		meetRankLevel = 0;
+	int32		reincarnation = 0;
+	int32		meetFaction = 0;
+	uint32		meetAchievementPoints = 0;
+	uint32		desXp = 0;
+	uint32		desGoldCount = 0;
+	uint32		desTokenCount = 0;
+	uint32		desHRPoints = 0;
+	uint32		desArenaPoints = 0;
+	uint32		desItem[REQ_ITEM_MAX];
+	uint32		desItemCount[REQ_ITEM_MAX];
+	uint32		desSpiritPower = 0;
+	uint32		areaId = 0;
+	bool		inInstance = false;
+
+
+	std::unordered_map<uint32, ReqTemplate>::iterator iter = ReqMap.find(reqId);
+	if (iter != ReqMap.end())
+	{
+		meetLevel = iter->second.meetLevel;
+		meetHRRank = iter->second.meetHRRank;
+		meetVipLevel = iter->second.meetVipLevel;
+		meetRankLevel = iter->second.meetRankLevel;
+		reincarnation = iter->second.reincarnation;
+		meetFaction = iter->second.meetFaction;
+		meetAchievementPoints = iter->second.meetAchievementPoints;
+		desXp = iter->second.desXp;
+		desGoldCount = count * iter->second.desGoldCount;
+		desTokenCount = count * iter->second.desTokenCount;
+		desHRPoints = count * iter->second.desHRPoints;
+		desArenaPoints = count * iter->second.desArenaPoints;
+		for (size_t i = 0; i < REQ_ITEM_MAX; i++)
+		{
+			desItem[i] = iter->second.desItem[i];
+			desItemCount[i] = count * iter->second.desItemCount[i];
+		}
+		desSpiritPower = count * iter->second.desSpiritPower;
+		inInstance = iter->second.inInstance;
+	}
+	else
+		return "";
+
+	std::ostringstream oss;
+
+	if (meetLevel > 0)
+		oss << "    |cFF660066[µÈ¼¶]|r |cFF660066[" << meetLevel << "]|r\n";
+
+	if (abs(meetRankLevel) > 0)
+	{
+		if (meetRankLevel > 0)
+			oss << "    |cFF660066" << sRank->GetName(meetRankLevel) << "|r\n";
+		else
+			oss << "    |cFF660066[ÐÞÁ¶]|r |cFF660066µ±Ç°±ØÐëÊÇ[" << sRank->GetName(abs(meetRankLevel)) << "]|r\n";
+	}
+
+	if (abs(reincarnation) > 0)
+	{
+		if (reincarnation > 0)
+			oss << "    |cFF660066" << "×ªÉúµÈ¼¶" << reincarnation << "|r\n";
+		else
+			oss << "    |cFF660066[ÐÞÁ¶]|r |cFF660066µ±Ç°±ØÐëÊÇ[" << "×ªÉúµÈ¼¶" << abs(reincarnation) << "]|r\n";
+	}
+
+	if (meetFaction > 0)
+		oss << "    |cFF660066" << sFaction->GetName(meetFaction) << "|r\n";
+
+	if (abs(meetVipLevel) > 0)
+	{
+		std::string title = sVIP->GetVIPName(abs(meetVipLevel));
+		RemovePunc(title);
+
+		if (meetVipLevel > 0)
+			oss << "    |cFF660066[»áÔ±]|r |cFF660066[" << title << "]|r\n";
+		else
+			oss << "    |cFF660066[»áÔ±]|r |cFF660066µ±Ç°»áÔ±±ØÐëÊÇ[" << title << "]|r\n";
+	}
+
+	if (abs(meetHRRank) > 0)
+	{
+		std::string title = sHR->GetHRTitle(player, abs(meetHRRank));
+
+		if (meetHRRank > 0)
+			oss << "    |cFF660066[¾üÏÎ]|r |cFF660066[" << title << "]|r\n";
+		else
+			oss << "    |cFF660066[¾üÏÎ]|r |cFF660066µ±Ç°¾üÏÎ±ØÐëÊÇ[" << title << "]|r\n";
+	}
+		
+
+	if (desXp > 0)
+		oss << "    |cFF660066[¾­Ñé]|r x |cFF660066" << desXp << "|r\n";
+	if (desGoldCount > 0)
+		oss << "    |cFF660066[½ð±Ò]|r x |cFF660066" << desGoldCount / GOLD << "|r\n";
+	if (desTokenCount > 0)
+		oss << "    |cFF660066[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "]|r x |cFF660066" << desTokenCount << "|r\n";
+	if (desHRPoints > 0)
+		oss << "    |cFF660066[ÈÙÓþ]|r x |cFF660066" << desHRPoints << "|r\n";
+	if (desArenaPoints)
+		oss << "    |cFF660066[¾º¼¼µã]|r x |cFF660066" << desArenaPoints << "|r\n";
+	if (meetAchievementPoints > 0)
+		oss << "    |cFF660066[³É¾Íµã]|r x |cFF660066" << meetAchievementPoints << "|r\n";
+		
+	ItemTemplate const* pProto[REQ_ITEM_MAX];
+	for (size_t i = 0; i < REQ_ITEM_MAX; i++)
+		pProto[i] = sObjectMgr->GetItemTemplate(desItem[i]);
+
+	for (size_t i = 0; i < REQ_ITEM_MAX; i++)
+		if (pProto[i] && desItemCount[i] > 0)
+			oss << "    |cFF660066[" << pProto[i]->Name1 << "] x |cFF660066" << desItemCount[i] << "|r\n";
+
+	return oss.str();
+}
+
+bool Req::IsExist(uint32 reqId)
+{
+	std::unordered_map<uint32, ReqTemplate>::iterator iter = ReqMap.find(reqId);
+	if (iter != ReqMap.end())
+		return true;
+
+	return false;
+}
+
+std::string Req::GetExtraDes(uint32 reqId, uint32 count)
+{
+	uint32		meetLevel = 0;
+	int32		meetHRRank = 0;
+	int32		meetVipLevel = 0;
+	int32		meetRankLevel = 0;
+	int32		reincarnation = 0;
+	int32		meetFaction = 0;
+	uint32		meetAchievementPoints = 0;
+	uint32		desXp = 0;
+	uint32		desGoldCount = 0;
+	uint32		desTokenCount = 0;
+	uint32		desHRPoints = 0;
+	uint32		desArenaPoints = 0;
+	uint32		desItem[REQ_ITEM_MAX];
+	uint32		desItemCount[REQ_ITEM_MAX];
+	uint32		desSpiritPower = 0;
+	uint32		areaId = 0;
+	bool		inInstance = false;
+
+
+	std::unordered_map<uint32, ReqTemplate>::iterator iter = ReqMap.find(reqId);
+	if (iter != ReqMap.end())
+	{
+		meetLevel = iter->second.meetLevel;
+		meetHRRank = iter->second.meetHRRank;
+		meetVipLevel = iter->second.meetVipLevel;
+		meetRankLevel = iter->second.meetRankLevel;
+		reincarnation = iter->second.reincarnation;
+		meetFaction = iter->second.meetFaction;
+		meetAchievementPoints = iter->second.meetAchievementPoints;
+		desXp = iter->second.desXp;
+		desGoldCount = count * iter->second.desGoldCount;
+		desTokenCount = count * iter->second.desTokenCount;
+		desHRPoints = count * iter->second.desHRPoints;
+		desArenaPoints = count * iter->second.desArenaPoints;
+		for (size_t i = 0; i < REQ_ITEM_MAX; i++)
+		{
+			desItem[i] = iter->second.desItem[i];
+			desItemCount[i] = count * iter->second.desItemCount[i];
+		}
+		desSpiritPower = count * iter->second.desSpiritPower;
+		inInstance = iter->second.inInstance;
+	}
+	else
+		return "";
+
+	std::ostringstream oss;
+
+	if (meetLevel > 0)
+		oss << "|cFFFFCC00[µÈ¼¶" << meetLevel << "]|r";
+
+	if (abs(reincarnation) > 0)
+	{
+		if (reincarnation > 0)
+			oss << "   |cFFFFCC00" << "×ªÉúµÈ¼¶" << reincarnation << "|r\n";
+		else
+			oss << "   |cFFFFCC00µ±Ç°×ªÉúµÈ¼¶±ØÐëÊÇ" << abs(reincarnation) << "|r\n";
+	}
+
+	if (abs(meetVipLevel) > 0)
+	{
+		std::string title = sVIP->GetVIPName(abs(meetVipLevel));
+		RemovePunc(title);
+
+		if (meetVipLevel > 0)
+			oss << "   |cFFFFCC00[" << title << "]|r\n";
+		else
+			oss << "   |cFFFFCC00µ±Ç°»áÔ±±ØÐëÊÇ[" << title << "]|r\n";
+	}
+
+	if (abs(meetHRRank) > 0)
+	{
+		if (meetHRRank > 0)
+			oss << "   |cFFFFCC00[¾üÏÎ" << sCF->GetHRTitle(abs(meetHRRank)) << "]|r\n";
+		else
+			oss << "   |cFFFFCC00µ±Ç°¾üÏÎ±ØÐëÊÇ[" << sCF->GetHRTitle(abs(meetHRRank)) << "]|r\n";
+	}
+
+	if (meetFaction > 0)
+		oss << "   |cFFFFCC00" << sFaction->GetName(meetFaction) << "|r\n";
+	if (desXp > 0)
+		oss << "   |cFFFFCC00[¾­Ñé]|r x |cFFFFCC00" << desXp << "|r\n";
+	if (desGoldCount > 0)
+		oss << "   |cFFFFCC00[½ð±Ò]|r x |cFFFFCC00" << desGoldCount / GOLD << "|r\n";
+	if (desTokenCount > 0)
+		oss << "   |cFFFFCC00[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "]|r x |cFFFFCC00" << desTokenCount << "|r\n";
+	if (desHRPoints > 0)
+		oss << "   |cFFFFCC00[ÈÙÓþ]|r x |cFFFFCC00" << desHRPoints << "|r\n";
+	if (desArenaPoints)
+		oss << "   |cFFFFCC00[¾º¼¼µã]|r x |cFFFFCC00" << desArenaPoints << "|r\n";
+
+	ItemTemplate const* pProto[REQ_ITEM_MAX];
+	for (size_t i = 0; i < REQ_ITEM_MAX; i++)
+		pProto[i] = sObjectMgr->GetItemTemplate(desItem[i]);
+
+	for (size_t i = 0; i < REQ_ITEM_MAX; i++)
+		if (pProto[i] && desItemCount[i] > 0)
+			oss << "   " << sCF->GetItemLink(desItem[i]) << " x |cFFFFCC00" << desItemCount[i] << "|r\n";
+	
+	return oss.str();
+}
+
+
+bool Req::CheckMap(Player* pl, uint32 reqId, bool notice)
+{
+	std::unordered_map<uint32, ReqTemplate>::iterator iter = ReqMap.find(reqId);
+	if (iter == ReqMap.end())
+		return true;
+
+	if (iter->second.MapDataVec.empty())
+		return true;
+
+	uint32 map = pl->GetMapId();
+	uint32 zone = pl->GetZoneId();
+	uint32 area = pl->GetAreaId();
+
+	for (auto itr = iter->second.MapDataVec.begin(); itr != iter->second.MapDataVec.end(); itr++)
+		if (map == itr->map && 0 == itr->zone && 0 == itr->area ||
+			map == itr->map && zone == itr->zone && 0 == itr->area ||
+			map == itr->map && zone == itr->zone && area == itr->area)
+			return true;
+
+	if(notice)
+		ChatHandler(pl->GetSession()).PSendSysMessage(sString->Format(sString->GetText(CORE_STR_TYPES(STR_REQ_ZONE)), "ÕýÈ·µÄÇøÓò"));
+	return false;
+}
+
+bool Req::CheckSpell(Player* pl, uint32 reqId, bool notice)
+{
+	std::unordered_map<uint32, ReqTemplate>::iterator iter = ReqMap.find(reqId);
+	if (iter == ReqMap.end())
+		return true;
+
+	if (iter->second.SpellDataVec.empty())
+		return true;
+
+	for (auto itr = iter->second.SpellDataVec.begin(); itr != iter->second.SpellDataVec.end(); itr++)
+	{
+		int32 spell = *itr;
+
+		SpellInfo const*  spellInfo = sSpellMgr->GetSpellInfo(abs(spell));
+
+		if (!spellInfo)
+			continue;
+
+		if (spell > 0)
+		{
+			if (pl->HasSpell(spell))
+				return true;
+		}
+		else
+		{
+			if (pl->HasAura(abs(spell)))
+				return true;
+		}
+	}
+
+	for (auto itr = iter->second.SpellDataVec.begin(); itr != iter->second.SpellDataVec.end(); itr++)
+	{
+		int32 spell = *itr;
+
+		SpellInfo const*  spellInfo = sSpellMgr->GetSpellInfo(abs(spell));
+
+		if (!spellInfo)
+			continue;
+
+		if (spell > 0)
+		{
+			if (!pl->HasSpell(spell) && notice)
+				ChatHandler(pl->GetSession()).PSendSysMessage("Äã²»ÓµÓÐ¼¼ÄÜ[%s]", spellInfo->SpellName[4]);
+		}
+		else
+		{
+			if (!pl->HasAura(abs(spell)) && notice)
+				ChatHandler(pl->GetSession()).PSendSysMessage("Äã²»ÓµÓÐ¹â»·[%s]", spellInfo->SpellName[4]);
+		}
+	}
+
+	return false;
+}
+
+bool Req::CheckQuest(Player* pl, uint32 reqId, bool notice)
+{
+	std::unordered_map<uint32, ReqTemplate>::iterator iter = ReqMap.find(reqId);
+	if (iter == ReqMap.end())
+		return true;
+
+	if (iter->second.QuestDataVec.empty())
+		return true;
+
+	for (auto itr = iter->second.QuestDataVec.begin(); itr != iter->second.QuestDataVec.end(); itr++)
+	{
+		int32 quest = *itr;
+		Quest const* questProto = sObjectMgr->GetQuestTemplate(abs(quest));
+
+		if (!questProto)
+			continue;
+
+		if (quest > 0)
+		{
+			if (pl->GetQuestStatus(abs(quest)) == QUEST_STATUS_INCOMPLETE)
+				return true;
+		}
+		else
+		{
+			if (pl->GetQuestStatus(abs(quest)) == QUEST_STATUS_REWARDED)
+				return true;
+		}
+	}
+
+	for (auto itr = iter->second.QuestDataVec.begin(); itr != iter->second.QuestDataVec.end(); itr++)
+	{
+		int32 quest = *itr;
+		Quest const* questProto = sObjectMgr->GetQuestTemplate(abs(quest));
+
+		if (!questProto)
+			continue;
+
+		if (quest > 0)
+		{
+			if (!pl->hasQuest(quest) && notice)
+				ChatHandler(pl->GetSession()).PSendSysMessage("Äã²»ÓµÓÐÈÎÎñ[%s]", questProto->GetTitle().c_str());
+		}
+		else
+		{
+			if (pl->GetQuestStatus(abs(quest)) != QUEST_STATUS_REWARDED && notice)
+				ChatHandler(pl->GetSession()).PSendSysMessage("ÄãÎ´Íê³ÉÈÎÎñ[%s]", questProto->GetTitle().c_str());
+		}
+	}
+
+	return false;
+}
+
+bool Req::CheckAcheive(Player* pl, uint32 reqId, bool notice)
+{
+	std::unordered_map<uint32, ReqTemplate>::iterator iter = ReqMap.find(reqId);
+	if (iter == ReqMap.end())
+		return true;
+
+	if (iter->second.AchieveDataVec.empty())
+		return true;
+
+	for (auto itr = iter->second.AchieveDataVec.begin(); itr != iter->second.AchieveDataVec.end(); itr++)
+	{
+		uint32 entryId = *itr;
+		if (AchievementEntry const* achieve = sAchievementStore.LookupEntry(entryId))
+			if (!achieve)
+			continue;
+
+		if (pl->HasAchieved(entryId))
+				return true;
+	}
+
+	if (notice)
+		ChatHandler(pl->GetSession()).PSendSysMessage("ÄãÎ´´ï³ÉÏà¹Ø³É¾Í");
+	return false;
+}
diff --git a/src/server/scripts/Custom/Requirement/Requirement.h b/src/server/scripts/Custom/Requirement/Requirement.h
new file mode 100644
index 0000000..806709b
--- /dev/null
+++ b/src/server/scripts/Custom/Requirement/Requirement.h
@@ -0,0 +1,70 @@
+////æéæ¡ä»¶åå¥å±æ¨¡æ¿////
+struct ReqMapData
+{
+	uint32 map;
+	uint32 zone;
+	uint32 area;
+};
+
+struct ReqCommandTemplate
+{
+	std::string command;
+	std::string des;
+	std::string icon;
+};
+
+#define REQ_ITEM_MAX 10
+
+struct ReqTemplate
+{
+	uint32		meetLevel				;
+	int32		meetHRRank				;
+	int32		meetVipLevel			;
+	int32		meetRankLevel			;
+	int32		meetFaction				;
+	uint32		meetAchievementPoints	;
+	uint32		desXp					;
+	uint32		desGoldCount			;
+	uint32		desTokenCount			;
+	uint32		desHRPoints				;
+	uint32		desArenaPoints			;
+	uint32		desSpiritPower			;
+	bool		inInstance				;
+	std::vector<ReqCommandTemplate> CommandDataVec;
+	int32		reincarnation			;
+
+	uint32 desItem[REQ_ITEM_MAX];
+	uint32 desItemCount[REQ_ITEM_MAX];
+	std::vector<ReqMapData> MapDataVec;
+	std::vector<int32> SpellDataVec;
+	std::vector<int32> QuestDataVec;
+	std::vector<uint32> AchieveDataVec;
+};
+
+extern std::unordered_map<uint32, ReqTemplate> ReqMap;
+
+class Req
+{
+public:
+	static Req* instance()
+	{
+		static Req instance;
+		return &instance;
+	}
+	void Load();
+	bool Check(Player* player, uint32 reqId, uint32 count = 1, bool notice = true);
+	void Des(Player* player, uint32 reqId, uint32 count = 1, uint32 expItemId = 0);
+	std::string Notice(Player* player, uint32 reqId, std::string generalText, std::string text, uint32 count = 1, uint32 chance = 100, uint32 vipRateType = 0,uint32 hrRateType = 0);
+	uint32 Golds(uint32 reqId, uint32 count = 1);
+	std::string GetDescription(uint32 reqId, Player* player, uint32 count = 1);
+	bool IsExist(uint32 reqId);
+	std::string GetExtraDes(uint32 reqId, uint32 count = 1);
+
+	bool CheckMap(Player* pl, uint32 reqId, bool notice = true);
+	bool CheckSpell(Player* pl, uint32 reqId, bool notice = true);
+	bool CheckQuest(Player* pl, uint32 reqId, bool notice = true);
+	bool CheckAcheive(Player* pl, uint32 reqId, bool notice = true);
+private:
+
+};
+#define sReq Req::instance()
diff --git a/src/server/scripts/Custom/ResetInstance/ResetInstance.cpp b/src/server/scripts/Custom/ResetInstance/ResetInstance.cpp
new file mode 100644
index 0000000..af3c480
--- /dev/null
+++ b/src/server/scripts/Custom/ResetInstance/ResetInstance.cpp
@@ -0,0 +1,190 @@
+#pragma execution_character_set("utf-8")
+#include "ResetInstance.h"
+#include "../Requirement/Requirement.h"
+#include "../FunctionCollection/FunctionCollection.h"
+
+std::vector<ResetInsTemplate> ResetInsVec;
+
+uint8 ResetIns::getDiff(uint32 action) {
+	return (uint8)((action) >> 24);
+}
+
+uint32 ResetIns::getMapId(uint32 action) {
+	return (uint32)((action) & 0xFFFFFF);
+}
+
+uint32 ResetIns::actionValue(uint8 diff, uint32 mapid) {
+	return (uint32)((diff << 24) | (mapid & 0xFFFFFF));
+}
+
+
+void ResetIns::Load()
+{
+	ResetInsVec.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT µØÍ¼ID,ÄÑ¶È,ÐèÇóÄ£°åID from _¸±±¾_ÖØÖÃÐèÇó" :
+		"SELECT mapid,diff,reqId from _instance_reset");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			ResetInsTemplate Temp;
+			Temp.mapid = fields[0].GetUInt32();
+			Temp.diff = fields[1].GetUInt8();
+			Temp.reqId = fields[2].GetUInt32();
+			ResetInsVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+}
+
+uint32 ResetIns::GetReqId(uint32 mapid, uint8 diff)
+{
+	uint32 len = ResetInsVec.size();
+	for (size_t i = 0; i < len; i++)
+	{
+		if (mapid == ResetInsVec[i].mapid && diff == ResetInsVec[i].diff)
+			return ResetInsVec[i].reqId;
+	}
+
+	return 0;
+}
+
+std::string ResetIns::GetGossipText(uint32 mapid, uint8 diff)
+{
+	uint32 len = ResetInsVec.size();
+	for (size_t i = 0; i < len; i++)
+		if (mapid == ResetInsVec[i].mapid && diff == ResetInsVec[i].diff)
+			if (MapEntry const* mapEntry = sMapStore.LookupEntry(mapid))
+			{
+				std::string text = "";
+				text = mapEntry->name[4];
+				switch (diff)
+				{
+				case 0:
+					//text += "[ÆÕÍ¨]";
+					break;
+				case 1:
+					mapEntry->IsRaid() ? text += "[25]" : text += "[5H]";
+					break;
+				case 2:
+					text += "[10H]";
+					break;
+				case 3:
+					text += "[25H]";
+					break;
+				default:
+					break;
+				}
+
+				
+
+				return text;
+			}
+
+	return "";
+}
+
+void ResetIns::AddGossip(Player* player, Object* obj)
+{
+	uint32 count = 0;
+
+	for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
+	{
+		BoundInstancesMap const& m_boundInstances = sInstanceSaveMgr->PlayerGetBoundInstances(player->GetGUIDLow(), Difficulty(i));
+		for (BoundInstancesMap::const_iterator itr = m_boundInstances.begin(); itr != m_boundInstances.end(); ++itr)
+		{
+			if (MapEntry const* mapEntry = sMapStore.LookupEntry(itr->first))
+			{
+				std::string text = GetGossipText(mapEntry->MapID, i);
+				uint32 reqId = GetReqId(mapEntry->MapID, i);
+				if (!text.empty())
+				{
+					if (count > 25)
+						continue;
+					count++;
+					player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, text, SENDER_RESET_INS, actionValue(i, mapEntry->MapID), sReq->Notice(player, reqId, "ÖØÖÃ", text), sReq->Golds(reqId), false);
+				}
+			}
+		}
+	}
+
+	if (obj->ToCreature())
+		player->SEND_GOSSIP_MENU(obj->GetEntry(), obj->GetGUID());
+	else
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+
+	//if (count == 1)
+	//	player->PlayerTalkClass->ClearMenus();
+}
+
+void ResetIns::Action(Player* player, uint32 action)
+{
+	
+
+	Difficulty diff = Difficulty(sResetIns->getDiff(action));
+	uint32 mapid = sResetIns->getMapId(action);
+	uint32 reqId = sResetIns->GetReqId(mapid, diff);
+
+	if (player->GetMapId() == mapid)
+	{
+		player->GetSession()->SendNotification("ÇëÏÈÀë¿ª¸±±¾£¡");
+		return;
+	}
+
+	if (sReq->Check(player, reqId))
+	{
+		sReq->Des(player, reqId);
+		sResetIns->ResetInstance(player, diff, mapid);
+	}
+}
+
+void ResetIns::ResetInstance(Player* player, Difficulty diff, uint32 mapId)
+{
+
+	for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
+	{
+		BoundInstancesMap const& m_boundInstances = sInstanceSaveMgr->PlayerGetBoundInstances(player->GetGUIDLow(), Difficulty(i));
+		for (BoundInstancesMap::const_iterator itr = m_boundInstances.begin(); itr != m_boundInstances.end();)
+		{
+			InstanceSave* save = itr->second.save;
+			MapEntry const* mapEntry = sMapStore.LookupEntry(itr->first);
+			if (mapEntry && itr->first != player->GetMapId() && (!mapId || mapId == itr->first) && (diff == -1 || diff == save->GetDifficulty()))
+			{
+				std::ostringstream oss;
+				oss << GetGossipText(mapEntry->MapID, i) << "ÒÑÖØÖÃ";
+				ChatHandler(player->GetSession()).PSendSysMessage(oss.str().c_str());
+				sInstanceSaveMgr->PlayerUnbindInstance(player->GetGUIDLow(), itr->first, diff, true, player);
+				itr = m_boundInstances.begin();
+			}
+			else
+				++itr;
+		}
+	}
+}
+
+
+class ResetInsNPC : public CreatureScript
+{
+public:
+	ResetInsNPC() : CreatureScript("ResetInsNPC") { }
+
+	bool OnGossipHello(Player* player, Creature* creature) override
+	{
+		player->PlayerTalkClass->ClearMenus();
+		sResetIns->AddGossip(player, creature);
+		return true;
+	}
+
+	bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action) override
+	{
+		player->PlayerTalkClass->ClearMenus();
+		sResetIns->Action(player, action);
+		return true;
+	}
+};
+
+void AddSC_ResetInsNPC()
+{
+	new ResetInsNPC();
+}
diff --git a/src/server/scripts/Custom/ResetInstance/ResetInstance.h b/src/server/scripts/Custom/ResetInstance/ResetInstance.h
new file mode 100644
index 0000000..1b14925
--- /dev/null
+++ b/src/server/scripts/Custom/ResetInstance/ResetInstance.h
@@ -0,0 +1,34 @@
+struct ResetInsTemplate
+{
+	uint32 mapid;
+	uint8 diff;
+	uint32 reqId;
+};
+
+
+extern std::vector<ResetInsTemplate> ResetInsVec;
+
+class ResetIns
+{
+public:
+	static ResetIns* instance()
+	{
+		static ResetIns instance;
+		return &instance;
+	}
+
+	uint8 getDiff(uint32 action);
+	uint32 getMapId(uint32 action);
+	uint32 actionValue(uint8 diff, uint32 mapid);
+
+	void Load();
+	uint32 GetReqId(uint32 mapid, uint8 diff);
+	std::string GetGossipText(uint32 maipid, uint8 diff);
+
+	void AddGossip(Player* player, Object* obj);
+	void Action(Player* player, uint32 action);
+	void ResetInstance(Player* player, Difficulty diff, uint32 mapId);
+private:
+
+};
+#define sResetIns ResetIns::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Reward/Reward.cpp b/src/server/scripts/Custom/Reward/Reward.cpp
new file mode 100644
index 0000000..855ca5c
--- /dev/null
+++ b/src/server/scripts/Custom/Reward/Reward.cpp
@@ -0,0 +1,594 @@
+#pragma once
+#pragma execution_character_set("utf-8")
+#include "../CommonFunc/CommonFunc.h"
+#include "../Requirement/Requirement.h"
+#include "Reward.h"
+#include "../DataLoader/DataLoader.h"
+#include "../Command/CustomCommand.h"
+#include "../Switch/Switch.h"
+#include "../StatPoints/StatPoints.h"
+#include "../String/myString.h"
+
+std::unordered_map<uint32, RewTemplate> RewMap;
+
+void Reward::Load()
+{
+	RewMap.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		
+		"SELECT ½±ÀøÄ£°åID,½ð±ÒÊýÁ¿,»ý·ÖÊýÁ¿,¾­ÑéÊýÁ¿,ÈÙÓþµãÊý,¾º¼¼µãÊý,¶·ÆøµãÊý,¼¼ÄÜ»ò¹â»·×é,GMÃüÁî×é,"
+		"ÎïÆ·ID1,ÎïÆ·ÊýÁ¿1,ÎïÆ·ID2,ÎïÆ·ÊýÁ¿2,ÎïÆ·ID3,ÎïÆ·ÊýÁ¿3,ÎïÆ·ID4,ÎïÆ·ÊýÁ¿4,ÎïÆ·ID5,ÎïÆ·ÊýÁ¿5,"
+		"ÎïÆ·ID6,ÎïÆ·ÊýÁ¿6,ÎïÆ·ID7,ÎïÆ·ÊýÁ¿7,ÎïÆ·ID8,ÎïÆ·ÊýÁ¿8,ÎïÆ·ID9,ÎïÆ·ÊýÁ¿9,ÎïÆ·ID10,ÎïÆ·ÊýÁ¿10 FROM _Ä£°å_½±Àø" :
+
+		"SELECT rewId,goldCount,tokenCount,xp,hrPoints,arenaPoints,statPoints,spellData,commandData,"
+		"itemId1,itemCount1,itemId2,itemCount2,itemId3,itemCount3,itemId4,itemCount4,itemId5,itemCount5,"
+		"itemId6,itemCount6,itemId7,itemCount7,itemId8,itemCount8,itemId9,itemCount9,itemId10,itemCount10 FROM _rew");
+	if (!result)
+		return;
+	do
+	{
+		Field* fields = result->Fetch();
+		uint32 rewId				= fields[0].GetUInt32();
+		RewTemplate RewTemp;
+		RewTemp.goldCount			= fields[1].GetUInt32() * GOLD;
+		RewTemp.tokenCount			= fields[2].GetUInt32();
+		RewTemp.xp					= fields[3].GetUInt32();
+		RewTemp.hrPoints			= fields[4].GetUInt32();
+		RewTemp.arenaPoints			= fields[5].GetUInt32();
+		RewTemp.statPoints			= fields[6].GetUInt32();
+
+		Tokenizer spellData(fields[7].GetString(), '#');
+
+		for (Tokenizer::const_iterator itr = spellData.begin(); itr != spellData.end(); ++itr)
+			if (SpellInfo const*  spellInfo = sSpellMgr->GetSpellInfo(abs(atoi(*itr))))
+				RewTemp.SpellDataVec.push_back(atoi(*itr));
+
+		Tokenizer commandData(fields[8].GetString(), '#');
+		for (Tokenizer::const_iterator itr = commandData.begin(); itr != commandData.end(); ++itr)
+		{
+			Tokenizer commands(*itr, '$');
+			RewCommandTemplate temp;
+			if (commands.size() > 0)
+				temp.command = commands[0];
+			else
+				temp.command = "";
+
+			if (commands.size() > 1)
+				temp.icon = commands[1];
+			else
+				temp.icon = "";
+
+			if (commands.size() > 2)
+				temp.des = commands[2];
+			else
+				temp.des = "";
+
+			RewTemp.CommandDataVec.push_back(temp);
+		}
+
+		for (size_t i = 0; i < REW_ITEM_MAX; i++)
+		{
+			uint32 entry = fields[9 + 2 * i].GetUInt32();
+			uint32 count = fields[10 + 2 * i].GetUInt32();
+
+			ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(entry);
+
+			if (pProto && count > 0)
+			{
+				RewItemTemplate temp;
+				temp.itemId = entry;
+				temp.itemCount = count;
+				RewTemp.ItemDataVec.push_back(temp);
+			}
+		}
+		
+		RewMap.insert(std::make_pair(rewId, RewTemp));
+	} while (result->NextRow());
+}
+
+void Reward::LoadDamCreToSend()
+{
+	VCreatureDamageSend.clear();
+	QueryResult itemup = WorldDatabase.PQuery("select ÉúÎï±àºÅ,×îµÍÉËº¦Á¿,ÅÅÐÐ½±Àø,ÅÅÐÐµ¯´° from _ÉúÎï_ÉËº¦½±Àø");
+	if (itemup)
+	{
+		int nCount = 0;
+		do
+		{
+			CreatureDamageSend  tmpItem;
+			tmpItem.creatureid = itemup->Fetch()[0].GetUInt32();
+			tmpItem.mindamage = itemup->Fetch()[1].GetUInt32();
+			Tokenizer senditems(itemup->Fetch()[2].GetString(), '#');
+			tmpItem.sendgossipcount = itemup->Fetch()[3].GetUInt32();
+
+			tmpItem.maxsend = senditems.size();
+			if (tmpItem.maxsend)
+			{
+				for (uint32 i = 0; i < tmpItem.maxsend; i++)
+				{
+					tmpItem.itemsends[i] = atoi(senditems[i] ? senditems[i] : 0);
+				}
+			}
+
+			VCreatureDamageSend.insert(CreatureDamageSend_t::value_type(tmpItem.creatureid, tmpItem));
+			nCount++;
+
+		} while (itemup->NextRow());
+		sLog->outString(">> ¶ÁÈ¡×Ô¶¨Òå¹¦ÄÜÊý¾Ý±í _ÉúÎï_ÉËº¦½±Àø,¹²%uÌõÊý¾Ý¶ÁÈ¡¼ÓÔØ...", nCount);
+	}
+	else
+		sLog->outString(">> ¶ÁÈ¡×Ô¶¨Òå¹¦ÄÜÊý¾Ý±í _ÉúÎï_ÉËº¦½±Àø,¹²0ÌõÊý¾Ý¶ÁÈ¡¼ÓÔØ...");
+
+}
+
+void Reward::Rew(Player* player, uint32 rewId,uint32 muilt)
+{
+	if (rewId == 0)
+		return;
+
+	std::unordered_map<uint32, RewTemplate>::iterator iter = RewMap.find(rewId);
+	if (iter != RewMap.end())
+	{
+		uint32 xp = muilt * iter->second.xp;
+		uint32 goldCount = muilt * iter->second.goldCount;
+		uint32 tokenCount = muilt * iter->second.tokenCount;
+		uint32 hrPoints = muilt * iter->second.hrPoints;
+		uint32 arenaPoints = muilt * iter->second.arenaPoints;
+		uint32 statPoints = muilt * iter->second.statPoints;
+
+		if (xp > 0)
+		{
+
+			uint32 curXP = player->GetUInt32Value(PLAYER_XP);
+			uint32 nextLvlXP = player->GetUInt32Value(PLAYER_NEXT_LEVEL_XP);
+			uint32 newXP = curXP + xp;
+			uint32 level = player->getLevel();
+
+			bool flag = false;
+
+			while (newXP >= nextLvlXP && level < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+			{
+				newXP -= nextLvlXP;
+
+				if (level < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+				{
+					if (level < sSwitch->GetValue(ST_XP_MAX_LV))
+						player->GiveLevel(level + 1);
+					else
+						flag = true;
+				}
+
+				level = player->getLevel();
+				nextLvlXP = player->GetUInt32Value(PLAYER_NEXT_LEVEL_XP);
+			}
+
+			player->SetUInt32Value(PLAYER_XP, newXP);
+
+			if (flag)
+				player->SetUInt32Value(PLAYER_XP, player->GetUInt32Value(PLAYER_NEXT_LEVEL_XP));
+
+			std::ostringstream oss;
+			oss << "»ñµÃ" << "|cFFFFCC00[¾­Ñé]|r X " << xp;
+			player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+		}
+
+		if (goldCount > 0)
+		{
+			player->ModifyMoney(goldCount);
+			std::ostringstream oss;
+			oss << "»ñµÃ" << "|cFFFFCC00[½ð±Ò]|r" << " X " << goldCount / GOLD;
+			player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+		}
+
+		if (tokenCount > 0)
+		{
+			sCF->UpdateTokenAmount(player, tokenCount, true, "[REW]½±Àø");
+			std::ostringstream oss;
+			oss << "»ñµÃ" << "|cFFFFCC00[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "]|r" << " X " << tokenCount;
+			player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+		}
+
+		if (hrPoints > 0)
+		{
+			player->ModifyHonorPoints(hrPoints);
+			std::ostringstream oss;
+			oss << "»ñµÃ" << "|cFFFFCC00[ÈÙÓþ]|r" << " X " << hrPoints;
+			player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+		}
+
+		if (arenaPoints > 0)
+		{
+			player->ModifyArenaPoints(arenaPoints);
+			std::ostringstream oss;
+			oss << "»ñµÃ" << "|cFFFFCC00[¾º¼¼µã]|r" << " X " << arenaPoints;
+			player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+		}
+
+		if (statPoints > 0)
+		{
+			uint32 total = 0;
+
+			for (size_t i = 0; i < MAX_STAT_POINTS_TYPE; i++)
+				total += player->stat_points[i];
+
+			if (total < sSwitch->GetValue(ST_SPS_LIMIT))
+			{
+				player->stat_points[SPT_TOTLAL] += statPoints;
+				std::ostringstream oss;
+				oss << "»ñµÃ" << "|cFFFFCC00[¶·Æøµã]|r" << " X " << statPoints;
+				player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+				sStatPoints->UpdateDB(player);
+			}
+		}
+
+
+		for (auto itr = iter->second.ItemDataVec.begin(); itr != iter->second.ItemDataVec.end(); itr++)
+			//player->AddItem(itr->itemId, itr->itemCount);
+			RewItem(player, itr->itemId, itr->itemCount);
+
+		for (auto itr = iter->second.SpellDataVec.begin(); itr != iter->second.SpellDataVec.end(); itr++)
+		{
+			if (*itr < 0)
+				continue;
+
+			uint32 spellId = *itr;
+
+			SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+			if (spellInfo)
+			{
+				uint32 firstSpellId = sSpellMgr->GetFirstSpellInChain(spellId);
+
+				PlayerSpellMap spellMap = player->GetSpellMap();
+
+				for (PlayerSpellMap::const_iterator iter = spellMap.begin(); iter != spellMap.end(); ++iter)
+					if (firstSpellId == sSpellMgr->GetFirstSpellInChain(iter->first))
+						player->removeSpell(iter->first, SPEC_MASK_ALL, false);
+
+				player->learnSpell(spellId);
+			}
+		}
+
+		for (auto itr = iter->second.SpellDataVec.begin(); itr != iter->second.SpellDataVec.end(); itr++)
+		{
+			if (*itr > 0)
+				continue;
+
+			player->CastSpell(player, abs(*itr), false);
+		}
+
+		for (auto itr = iter->second.CommandDataVec.begin(); itr != iter->second.CommandDataVec.end(); itr++)
+			if (!itr->command.empty())
+				sCustomCommand->DoCommand(player, itr->command);
+	}
+	else
+		sWorld->SendServerMessage(SERVER_MSG_STRING, sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? "Êý¾Ý±í[_rew]Î´Õý³£ÅäÖÃ" : "Êý¾Ý±í[_Ä£°å_½±Àø]Î´Õý³£ÅäÖÃ");
+}
+
+void Reward::RewItem(Player* player, uint32 itemId, uint32 itemCount)
+{
+	uint32 count = itemCount;
+	uint32 noSpaceForCount = 0;
+	ItemPosCountVec dest;
+	InventoryResult msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, count, &noSpaceForCount);
+	if (msg != EQUIP_ERR_OK)
+		count -= noSpaceForCount;
+
+	if (count == 0 || dest.empty())
+	{}
+	else
+	{
+		Item* item = player->StoreNewItem(dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId));
+		if (item)
+			player->SendNewItem(item, count, true, false);
+	}
+
+	//bool add = player->AddItem(itemId, itemCount);
+
+	itemCount -= count;
+
+	if (itemCount > 0)
+	{
+		if (ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(itemId))
+		{
+			ChatHandler(player->GetSession()).PSendSysMessage("ÄãÊÕµ½ÐÂÓÊ¼þ:%s X %u", sCF->GetItemLink(itemId).c_str(), itemCount);
+			MailSender sender(MAIL_NORMAL, 0, MAIL_STATIONERY_GM);
+			MailDraft draft("ÒÅÊ§µÄÎïÆ·", "Ðé¿ÕÖÐ·¢ÏÖÁËÄãÒÅÊ§µÄÎïÆ·£¬ÇëÊÕºÃ¡£");
+			SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+			uint32 stack = pProto->Stackable > 0 ? pProto->Stackable : 1;
+
+			while (itemCount > stack)
+			{
+				if (Item* item = Item::CreateItem(itemId, stack))
+				{
+					item->SaveToDB(trans);
+					draft.AddItem(item);
+				}
+				itemCount -= stack;
+			}
+
+			if (Item* item = Item::CreateItem(itemId, itemCount))
+			{
+				item->SaveToDB(trans);
+				draft.AddItem(item);
+			}
+
+			draft.SendMailTo(trans, MailReceiver(NULL, player->GetGUIDLow()), sender);
+			CharacterDatabase.CommitTransaction(trans);
+		}
+	}
+}
+
+void Reward::MailRew(Player* senderPlayer, uint32 receiverGuidLow, uint32 rewId, std::string titleText, std::string content)
+{
+
+	GlobalPlayerData const* receiverData = sWorld->GetGlobalPlayerData(receiverGuidLow);
+
+	if (!receiverData)
+		return;
+
+	uint32 receiverAccId = receiverData->accountId;
+	uint64 receiverGuid = MAKE_NEW_GUID(receiverGuidLow, 0, HIGHGUID_PLAYER);
+
+	Player* receiver = ObjectAccessor::FindPlayerInOrOutOfWorld(receiverGuid);
+
+	if (rewId == 0)
+		return;
+
+	std::unordered_map<uint32, RewTemplate>::iterator iter = RewMap.find(rewId);
+	if (iter != RewMap.end())
+	{
+		uint32 xp = iter->second.xp;
+		uint32 goldCount = iter->second.goldCount;
+		uint32 tokenCount = iter->second.tokenCount;
+		uint32 hrPoints = iter->second.hrPoints;
+		uint32 arenaPoints = iter->second.arenaPoints;
+		uint32 statPoints = iter->second.statPoints;
+
+		if (tokenCount > 0)
+		{
+			if (receiver)
+				sCF->UpdateTokenAmount(receiver, tokenCount, true, "ÕÐÄ¼½±Àø");
+			else
+				LoginDatabase.DirectPExecute("UPDATE account SET tokenAmount = tokenAmount +'%u' WHERE id = '%u'", tokenCount, receiverData->accountId);
+		}
+		if (arenaPoints > 0)
+		{
+			if (receiver)
+				receiver->ModifyArenaPoints(arenaPoints);
+			else
+				CharacterDatabase.DirectPExecute("UPDATE characters SET arenaPoints = arenaPoints +'%u' WHERE guid = '%u'", arenaPoints, receiverGuidLow);
+		}
+		if (hrPoints > 0)
+		{
+			if (receiver)
+				receiver->ModifyHonorPoints(hrPoints);
+			else
+				CharacterDatabase.DirectPExecute("UPDATE characters SET totalHonorPoints = totalHonorPoints +'%u' WHERE guid = '%u'", hrPoints, receiverGuidLow);
+		}
+
+		if (statPoints > 0)
+		{
+			if (receiver)
+				receiver->stat_points[SPT_TOTLAL] += statPoints;
+			else
+				sStatPoints->UpdateDB(receiverGuidLow, statPoints);
+		}
+
+		MailSender sender(MAIL_NORMAL, senderPlayer->GetSession() ? senderPlayer->GetGUIDLow() : 0, MAIL_STATIONERY_GM);
+		MailDraft draft(titleText, content);
+		SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+		if (goldCount > 0)
+		{
+			if (receiver)
+				receiver->ModifyMoney(goldCount);
+			else
+				draft.AddMoney(goldCount);
+		}
+
+		for (auto itr = iter->second.ItemDataVec.begin(); itr != iter->second.ItemDataVec.end(); itr++)
+		{
+			ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(itr->itemId);
+			uint32 itemCount = itr->itemCount;
+
+			if (pProto && itemCount > 0)
+			{
+				uint32 stack = pProto->Stackable > 0 ? pProto->Stackable : 1;
+
+				while (itemCount > stack)
+				{
+					if (Item* item = Item::CreateItem(itr->itemId, stack))
+					{
+						item->SaveToDB(trans);
+						draft.AddItem(item);
+					}
+					itemCount -= stack;
+				}
+
+				if (Item* item = Item::CreateItem(itr->itemId, itemCount))
+				{
+					item->SaveToDB(trans);
+					draft.AddItem(item);
+				}
+			}
+		}
+
+		draft.SendMailTo(trans, MailReceiver(NULL, receiverGuidLow), sender);
+		CharacterDatabase.CommitTransaction(trans);
+
+		if (receiver)
+		{
+			for (auto itr = iter->second.SpellDataVec.begin(); itr != iter->second.SpellDataVec.end(); itr++)
+			{
+				if (*itr < 0)
+					continue;
+
+				uint32 spellId = *itr;
+
+				SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+				if (spellInfo)
+				{
+					uint32 firstSpellId = sSpellMgr->GetFirstSpellInChain(spellId);
+
+					PlayerSpellMap spellMap = receiver->GetSpellMap();
+
+					for (PlayerSpellMap::const_iterator iter = spellMap.begin(); iter != spellMap.end(); ++iter)
+						if (firstSpellId == sSpellMgr->GetFirstSpellInChain(iter->first))
+							receiver->removeSpell(iter->first, SPEC_MASK_ALL, false);
+
+					receiver->learnSpell(spellId);
+				}
+			}
+
+			for (auto itr = iter->second.SpellDataVec.begin(); itr != iter->second.SpellDataVec.end(); itr++)
+			{
+				if (*itr > 0)
+					continue;
+
+				receiver->CastSpell(receiver, abs(*itr), false);
+			}
+
+			for (auto itr = iter->second.CommandDataVec.begin(); itr != iter->second.CommandDataVec.end(); itr++)
+				if (!itr->command.empty())
+					sCustomCommand->DoCommand(receiver, itr->command);
+
+			std::ostringstream oss;
+			oss << "ÄãÊÕµ½ÐÂÓÊ¼þ£º" << titleText;
+			receiver->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+		}
+	}
+	else
+		sWorld->SendServerMessage(SERVER_MSG_STRING, sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? "Êý¾Ý±í[_Ä£°å_ÐèÇó]Î´Õý³£ÅäÖÃ" : "Êý¾Ý±í[_req]Î´Õý³£ÅäÖÃ");
+}
+
+std::string Reward::GetDescription(uint32 rewId,bool quest)
+{
+	std::unordered_map<uint32, RewTemplate>::iterator iter = RewMap.find(rewId);
+	if (iter != RewMap.end())
+	{
+		uint32 xp = iter->second.xp;
+		uint32 goldCount = iter->second.goldCount;
+		uint32 tokenCount = iter->second.tokenCount;
+		uint32 hrPoints = iter->second.hrPoints;
+		uint32 arenaPoints = iter->second.arenaPoints;
+		uint32 statPoints = iter->second.statPoints;
+
+		std::ostringstream oss;
+
+		if (xp > 0)
+			oss << "    |cFF0000FF[¾­Ñé]|r x |cFF0000FF" << xp << "|r\n";
+
+		if (goldCount > 0)
+			oss << "    |cFF0000FF[½ð±Ò]|r x |cFF0000FF" << goldCount / GOLD << "|r\n";
+
+		if (tokenCount > 0)
+			oss << "    |cFF0000FF[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "]|r x |cFF0000FF" << tokenCount << "|r\n";
+
+		if (hrPoints > 0)
+			oss << "    |cFF0000FF[ÈÙÓþ]|r x |cFF0000FF" << hrPoints << "|r\n";
+
+		if (arenaPoints > 0)
+			oss << "    |cFF0000FF[¾º¼¼µã]|r x |cFF0000FF" << arenaPoints << "|r\n";
+
+		if (statPoints > 0)
+			oss << "    |cFF0000FF[¶·Æøµã]|r x |cFF0000FF" << statPoints << "|r\n";
+
+
+		for (auto itr = iter->second.ItemDataVec.begin(); itr != iter->second.ItemDataVec.end(); itr++)
+			if(ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(itr->itemId))
+				oss << "    |cFF0000FF[" << pProto->Name1 << "]|r x |cFF0000FF" << itr->itemCount << "|r\n";
+
+		for (auto itr = iter->second.SpellDataVec.begin(); itr != iter->second.SpellDataVec.end(); itr++)
+		{
+			if (*itr < 0)
+				continue;
+
+			uint32 spellId = *itr;
+
+			SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+			if (spellInfo)
+				oss << "    |cFF0000FF[¼¼ÄÜ] [" << spellInfo->SpellName[4] << "]|r\n";
+		}
+
+		for (auto itr = iter->second.SpellDataVec.begin(); itr != iter->second.SpellDataVec.end(); itr++)
+		{
+			if (*itr > 0)
+				continue;
+
+			SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(abs(*itr));
+			if (spellInfo)
+				oss << "    |cFF0000FF[ÔöÒæ] [" << spellInfo->SpellName[4] << "]|r\n";
+		}
+
+		for (auto itr = iter->second.CommandDataVec.begin(); itr != iter->second.CommandDataVec.end(); itr++)
+			if (!itr->command.empty())
+				oss << "    |cFF0000FF[ÆäËû] " << itr->des << "\n";
+
+		return oss.str();
+	}
+
+	return "";
+}
+
+
+bool Reward::IsExist(uint32 rewId)
+{
+	std::unordered_map<uint32, RewTemplate>::iterator iter = RewMap.find(rewId);
+	if (iter != RewMap.end())
+		return true;
+	return false;
+}
+
+std::string Reward::GetAnounceText(uint32 rewId)
+{
+	std::unordered_map<uint32, RewTemplate>::iterator iter = RewMap.find(rewId);
+	if (iter != RewMap.end())
+	{
+
+		std::ostringstream oss;
+
+		if (iter->second.goldCount > 0)
+			oss << "|cFFFFCC00[½ð±Ò]|rx|cFFFFCC00" << iter->second.goldCount << " ";
+		if (iter->second.tokenCount > 0)
+			oss << "|cFFFFCC00[" << sString->GetText(CORE_STR_TYPES(STR_TOKEN)) << "]|rx|cFFFFCC00" << iter->second.tokenCount << " ";
+		if (iter->second.xp > 0)
+			oss << "|cFFFFCC00[¾­Ñé]|rx|cFFFFCC00" << iter->second.xp << " ";
+		if (iter->second.hrPoints > 0)
+			oss << "|cFFFFCC00[ÈÙÓþ]|rx|cFFFFCC00" << iter->second.hrPoints << " ";
+
+		if (iter->second.arenaPoints > 0)
+			oss << "|cFFFFCC00[¾º¼¼µã]|rx|cFFFFCC00" << iter->second.arenaPoints << " ";
+
+		if (iter->second.statPoints > 0)
+			oss << "|cFFFFCC00[¶·Æøµã]|rx|cFFFFCC00" << iter->second.statPoints << " ";
+
+		for (auto itr = iter->second.ItemDataVec.begin(); itr != iter->second.ItemDataVec.end(); itr++)
+			oss << "" << sCF->GetItemLink(itr->itemId) << "x|cFFFFCC00" << itr->itemCount << " ";
+		
+		for (auto itr = iter->second.SpellDataVec.begin(); itr != iter->second.SpellDataVec.end(); itr++)
+		{
+			int32 id = *itr;
+			if (id < 0)
+				continue;
+
+			oss << "Ñ§»á¼¼ÄÜ|cFFFFCC00[" << sSpellMgr->GetSpellInfo(abs(id))->SpellName[4] << "] ";
+		}
+
+		for (auto itr = iter->second.SpellDataVec.begin(); itr != iter->second.SpellDataVec.end(); itr++)
+		{
+			int32 id = *itr;
+			if (id > 0)
+				continue;
+
+			oss << "»ñµÃÔöÒæ|cFFFFCC00[" << sSpellMgr->GetSpellInfo(abs(id))->SpellName[4] << "] ";
+		}
+
+		oss << "|r";
+
+		return oss.str();
+	}
+	
+	
+	return "";
+}
diff --git a/src/server/scripts/Custom/Reward/Reward.h b/src/server/scripts/Custom/Reward/Reward.h
new file mode 100644
index 0000000..ead5190
--- /dev/null
+++ b/src/server/scripts/Custom/Reward/Reward.h
@@ -0,0 +1,74 @@
+////æéæ¡ä»¶åå¥å±æ¨¡æ¿////
+
+#define REW_ITEM_MAX 10
+
+struct RewCommandTemplate
+{
+	std::string command;
+	std::string des;
+	std::string icon;
+};
+
+struct RewItemTemplate
+{
+	uint32 itemId;
+	uint32 itemCount;
+};
+
+
+struct RewTemplate
+{
+	uint32		xp			;
+	uint32		goldCount	;
+	uint32		tokenCount	;
+	uint32		hrPoints	;
+	uint32		arenaPoints	;
+	uint32		statPoints	;
+	std::vector<RewItemTemplate> ItemDataVec;
+	std::vector<int32> SpellDataVec;
+	std::vector<RewCommandTemplate> CommandDataVec;
+};
+extern std::unordered_map<uint32, RewTemplate> RewMap;
+
+struct CreatureDamageSend
+{
+	uint32 creatureid;
+	uint32 mindamage;
+	std::map<uint32, uint32> itemsends;
+	uint32 sendgossipcount;
+	uint32 maxsend;
+};
+
+class Reward
+{
+public:
+	static Reward* instance()
+	{
+		static Reward instance;
+		return &instance;
+	}
+	void Load();
+	void Rew(Player* player, uint32 rewId, uint32 muilt = 1);
+	void RewItem(Player* player, uint32 item, uint32 count);
+	void MailRew(Player* senderPlayer, uint32 receiverGuidLow, uint32 rewId, std::string titleText, std::string content);
+	std::string GetDescription(uint32 rewId, bool quest = false);
+	bool IsExist(uint32 rewId);
+	std::string GetAnounceText(uint32 rewId);
+
+	typedef std::map<uint32, CreatureDamageSend> CreatureDamageSend_t;
+	CreatureDamageSend_t VCreatureDamageSend;
+
+	CreatureDamageSend *  FindCreatureDamageSend(uint32 entry)
+	{
+		CreatureDamageSend_t::iterator It = VCreatureDamageSend.find(entry);
+		if (It != VCreatureDamageSend.end())
+			return &It->second;
+
+		return NULL;
+	}
+	void LoadDamCreToSend();
+
+private:
+
+};
+#define sRew Reward::instance()
diff --git a/src/server/scripts/Custom/Scripts/CreatureScripts.cpp b/src/server/scripts/Custom/Scripts/CreatureScripts.cpp
new file mode 100644
index 0000000..87f70ff
--- /dev/null
+++ b/src/server/scripts/Custom/Scripts/CreatureScripts.cpp
@@ -0,0 +1,524 @@
+/*
+
+ALTER TABLE _ai_creature CHANGE actionType actionType ENUM('¼¤»î»òÊ¹Ê§»î','Éè¶¨½×¶Î','ÊÍ·Å¼¼ÄÜ','ÒÆ¶¯·¶Î§','ÕÙ»½','Ëµ»°','ÒÆ³ý') CHARSET utf8 COLLATE utf8_general_ci NOT NULL;
+ALTER TABLE _ai_creature ADD COLUMN actionParam3 INT(11) DEFAULT 0 NOT NULL AFTER actionParam2, DROP PRIMARY KEY, ADD PRIMARY KEY (entry, eventType, eventPhase, delayTime, repeatMinTime, repeatMaxTime, actionType, actionParam1, actionParam2, actionParam3);
+*/
+
+#pragma execution_character_set("utf-8")
+#include "CustomScripts.h"
+#include "ObjectMgr.h"
+#include "../CustomEvent/Event.h"
+#include <random>
+#include <algorithm>
+#include <vector>
+std::vector<CreatureScriptTemplate> CreatureScriptVec;
+std::vector<AIRandSpellTemplate> AIRandSpellVec;
+
+void CustomScript::LoadCreautreScripts()
+{
+	QueryResult result;
+
+	CreatureScriptVec.clear();
+	
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+		"SELECT ÉúÎïID,ÊÂ¼þÀàÐÍ,ÊÂ¼þ½×¶ÎID,×îÐ¡ÖØ¸´Ê±¼ä,×î´óÖØ¸´Ê±¼ä,¶¯×÷ÀàÐÍ,¶¯×÷²ÎÊý1,¶¯×÷²ÎÊý2,ÑÓ³ÙÊ±¼ä,¶¯×÷²ÎÊý3 FROM _×Ô¶¨ÒåAI_ÉúÎï" :
+		"SELECT entry,eventType,eventPhase,repeatMinTime,repeatMaxTime,actionType,actionParam1,actionParam2,delayTime,actionParam3 FROM _ai_creature"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			CreatureScriptTemplate Temp;
+
+			Temp.entry = fields[0].GetUInt32();
+
+			const char*  str1 = fields[1].GetCString();
+
+			if (strcmp("½øÈëÕ½¶·", str1) == 0)
+				Temp.eventType = EVENT_TYPE_COMBAT;
+			else if (strcmp("É±ËÀÍæ¼Ò", str1) == 0)
+				Temp.eventType = EVENT_TYPE_KILL;
+			else if (strcmp("¹ÖÎïËÀÍö", str1) == 0)
+				Temp.eventType = EVENT_TYPE_DIED;
+			else if (strcmp("ÑªÁ¿µÍÓÚ90%", str1) == 0)
+				Temp.eventType = EVENT_TYPE_HP_90;
+			else if (strcmp("ÑªÁ¿µÍÓÚ75%", str1) == 0)
+				Temp.eventType = EVENT_TYPE_HP_75;
+			else if (strcmp("ÑªÁ¿µÍÓÚ50%", str1) == 0)
+				Temp.eventType = EVENT_TYPE_HP_50;
+			else if (strcmp("ÑªÁ¿µÍÓÚ25%", str1) == 0)
+				Temp.eventType = EVENT_TYPE_HP_25;
+			else if (strcmp("ÑªÁ¿µÍÓÚ10%", str1) == 0)
+				Temp.eventType = EVENT_TYPE_HP_10;
+			else if (strcmp("ÖØÖÃAI", str1) == 0)
+				Temp.eventType = EVENT_TYPE_RESET;
+			else
+				Temp.eventType = EVENT_TYPE_NONE;
+
+			//Temp.eventType		= CreatureEventTypes(fields[1].GetUInt32());
+			Temp.eventPhase = fields[2].GetUInt32();
+			Temp.repeatMinTime = fields[3].GetUInt32() * 1000;
+			Temp.repeatMaxTime = fields[4].GetUInt32() * 1000;
+
+			const char* str2 = fields[5].GetCString();
+
+			if (strcmp("ÊÍ·Å¼¼ÄÜ", str2) == 0)
+				Temp.actionType = ACTION_TYPE_CAST_SPELL;
+			else if (strcmp("¼¤»î»òÊ¹Ê§»î", str2) == 0)
+				Temp.actionType = ACTION_TYPE_ACTIVE_OR_DEACTIVE_OBJECT;
+			else if (strcmp("Éè¶¨½×¶Î", str2) == 0)
+				Temp.actionType = ACTION_TYPE_ALT_PHASE;
+			else if (strcmp("Ëµ»°", str2) == 0)
+				Temp.actionType = ACTION_TYPE_TALK;
+			else if (strcmp("ÕÙ»½", str2) == 0)
+				Temp.actionType = ACTION_TYPE_SUMMON;
+			else if (strcmp("×ª»»", str2) == 0)
+				Temp.actionType = ACTION_TYPE_ALT_GOB;
+			else if (strcmp("ÒÆ¶¯·¶Î§", str2) == 0)
+				Temp.actionType = ACTION_TYPE_MOVE_RANDOM;
+			else
+				Temp.actionType = ACTION_TYPE_NONE;
+
+			//Temp.actionType		= CreatureActionTypes(fields[5].GetUInt32());
+			Temp.actionParam1 = fields[6].GetString();
+			Temp.actionParam2 = fields[7].GetInt32();
+			Temp.actionFlags = 0;//fields[8].GetUInt32();
+
+			Temp.delayTime = fields[8].GetUInt32() * 1000;
+			Temp.actionParam3 = fields[9].GetInt32();
+			CreatureScriptVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+	
+
+	for (uint32 i = 0; i < CreatureScriptVec.size(); i++)
+	{
+		uint32 entry = CreatureScriptVec[i].entry;
+
+		CreatureTemplateContainer  *creatureTemplateStore = sObjectMgr->GetCreatureTemplatesStore();
+
+		CreatureTemplateContainer::iterator itr = creatureTemplateStore->find(entry);
+
+		if (itr != creatureTemplateStore->end())
+		{
+			itr->second.AIName = "";
+			itr->second.ScriptID = sObjectMgr->GetScriptId("CustomCreatureScript");
+		}
+	}
+
+	AIRandSpellVec.clear();
+
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT Ëæ»ú¼¼ÄÜ×éID,¼¼ÄÜID,ÊÍ·ÅÏÂÒ»¼¼ÄÜ×îÐ¡ÑÓ³Ù,ÊÍ·ÅÏÂÒ»¼¼ÄÜ×î´óÑÓ³Ù FROM _Ä£°å_Ëæ»ú¼¼ÄÜ×é" :
+		"SELECT GroupId,SpellId,MinDelayTime,MaxDelayTime FROM _ai_random_spell_group"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			AIRandSpellTemplate Temp;
+			Temp.GroupId		= fields[0].GetUInt32();
+			Temp.SpellId		= fields[1].GetUInt32();
+			Temp.MinDelayTime	= fields[2].GetUInt32() * IN_MILLISECONDS;
+			Temp.MaxDelayTime	= fields[3].GetUInt32() * IN_MILLISECONDS;
+
+			if (Temp.MaxDelayTime < Temp.MinDelayTime)
+				Temp.MaxDelayTime = Temp.MinDelayTime;
+
+			AIRandSpellVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+}
+
+void CustomScript::CastRandSpell(Creature* creautre, uint32 diff)
+{
+	if (creautre->RandSpellGroupId == 0)
+		return;
+
+	if (AIRandSpellVec.empty())
+		return;
+
+	if (creautre->IsInCombat())
+	{
+		creautre->RandSpellTimer -= diff;
+
+		if (creautre->RandSpellTimer < 0)
+		{
+			std::vector<AIRandSpellTemplate> v;
+
+			for (auto itr = AIRandSpellVec.begin(); itr != AIRandSpellVec.end(); itr++)
+				if (itr->GroupId == creautre->RandSpellGroupId)
+					v.push_back(*itr);
+
+			if (!v.empty())
+			{
+				//std::random_shuffle(v.begin(), v.end());
+                std::default_random_engine generator{ std::random_device{}() };
+                std::shuffle(std::begin(v), std::end(v), generator);
+
+				creautre->RandSpellTimer = urand(v[0].MinDelayTime, v[0].MaxDelayTime);
+				if (creautre->GetVictim())
+					creautre->CastSpell(creautre->GetVictim(), v[0].SpellId);
+			}
+			else
+				creautre->RandSpellTimer = 0;		
+		}		
+	}
+	else
+		creautre->RandSpellTimer = 0;
+}
+
+enum EVENT_IDS
+{
+	EVENT_CHECK_HEALTH = 1,
+};
+
+class CustomCreatureScript : public CreatureScript
+{
+public:
+	CustomCreatureScript() : CreatureScript("CustomCreatureScript") { }
+
+	struct CustomCreatureScriptAI : public ScriptedAI
+	{
+		CustomCreatureScriptAI(Creature* creature) : ScriptedAI(creature), Summons(me){}
+
+		SummonList Summons;
+
+		std::vector<ActionTemplate> ActionVec;
+
+		bool hp_90_active;
+		bool hp_75_active;
+		bool hp_50_active;
+		bool hp_25_active;
+		bool hp_10_active;
+
+		// EVENT_TYPE_RESET
+		void Reset() override
+		{
+			events.Reset();
+			Summons.DespawnAll();
+
+			hp_90_active	= false;
+			hp_75_active	= false;
+			hp_50_active	= false;
+			hp_25_active	= false;
+			hp_10_active	= false;
+
+			ActionVec.clear();
+
+			uint32 count = 2;
+
+			for (std::vector<CreatureScriptTemplate>::iterator itr = CreatureScriptVec.begin(); itr != CreatureScriptVec.end(); itr++)
+			{
+				if (itr->entry == me->GetEntry())
+				{
+					ActionTemplate Temp;
+					Temp.eventID = count;
+					Temp.eventType = itr->eventType;
+					Temp.eventPhase = itr->eventPhase;
+					Temp.delayTime = itr->delayTime;
+					Temp.repeatMinTime = itr->repeatMinTime;
+					Temp.repeatMaxTime = itr->repeatMaxTime;
+					Temp.actionType = itr->actionType;
+					Temp.actionParam1 = itr->actionParam1;
+					Temp.actionParam2 = itr->actionParam2;
+					Temp.actionFlags = itr->actionFlags;
+					Temp.actionParam3 = itr->actionParam3;
+					ActionVec.push_back(Temp);
+
+					count++;
+				}
+			}
+
+			SetPhase(0);
+
+			TriggerEvent(EVENT_TYPE_RESET, me);
+		}
+
+
+		void AddEvent(CreatureEventTypes eventType)
+		{
+			for (std::vector<ActionTemplate>::iterator itr = ActionVec.begin(); itr != ActionVec.end(); itr++)
+			{
+				if (itr->eventType == eventType)
+					events.ScheduleEvent(itr->eventID, itr->delayTime);		
+			}
+		}
+
+		void TriggerEvent(uint32 eventID)
+		{
+			for (std::vector<ActionTemplate>::iterator itr = ActionVec.begin(); itr != ActionVec.end(); itr++)
+			{
+				if (itr->eventID != eventID)
+					continue;
+
+				if (itr->repeatMinTime > 0 && itr->repeatMaxTime == itr->repeatMinTime)
+					events.ScheduleEvent(itr->eventID, itr->repeatMinTime);
+
+				if (itr->repeatMinTime > 0 && itr->repeatMaxTime > itr->repeatMinTime)
+					events.ScheduleEvent(itr->eventID, urand(itr->repeatMinTime, itr->repeatMaxTime));
+
+				if (itr->eventPhase == 0 || itr->eventPhase == GetPhase())
+					Action(itr->actionType, itr->actionParam1, itr->actionParam2, itr->actionFlags,itr->actionParam3, me);
+			}
+		}
+
+		void TriggerEvent(CreatureEventTypes eventType, Unit* unit)
+		{
+			for (std::vector<ActionTemplate>::iterator itr = ActionVec.begin(); itr != ActionVec.end(); itr++)
+				if (itr->eventType == eventType && itr->eventPhase == GetPhase())
+					Action(itr->actionType, itr->actionParam1, itr->actionParam2, itr->actionFlags, itr->actionParam3, unit);
+		}
+
+
+		void UpdateAI(uint32 diff)
+		{
+			if (!UpdateVictim())
+				return;
+
+			events.Update(diff);
+
+			if (me->HasUnitState(UNIT_STATE_CASTING))
+				return;
+
+
+			while (uint32 eventId = events.ExecuteEvent())
+			{
+
+				if (eventId == EVENT_CHECK_HEALTH)
+				{
+					if (!hp_90_active && me->HealthBelowPct(90))
+					{
+						hp_90_active = true;
+						TriggerEvent(EVENT_TYPE_HP_90, me);
+					}
+					
+					if (!hp_75_active && me->HealthBelowPct(75))
+					{
+						hp_75_active = true;
+						TriggerEvent(EVENT_TYPE_HP_75, me);
+					}
+
+					if (!hp_50_active && me->HealthBelowPct(50))
+					{
+						hp_50_active = true;
+						TriggerEvent(EVENT_TYPE_HP_50, me);
+					}
+
+					if (!hp_25_active && me->HealthBelowPct(25))
+					{
+						hp_25_active = true;
+						TriggerEvent(EVENT_TYPE_HP_25, me);
+					}
+
+					if (!hp_10_active && me->HealthBelowPct(10))
+					{
+						hp_10_active = true;
+						TriggerEvent(EVENT_TYPE_HP_10, me);
+					}
+
+					events.ScheduleEvent(EVENT_CHECK_HEALTH, 1000);
+				}
+
+				TriggerEvent(eventId);
+			}
+
+			DoMeleeAttackIfReady();
+		}
+
+
+		// EVENT_TYPE_COMBAT
+		void EnterCombat(Unit* /*victim*/) override
+		{
+			AddEvent(EVENT_TYPE_COMBAT);
+			events.ScheduleEvent(EVENT_CHECK_HEALTH, 1000);
+		}
+
+		//EVENT_TYPE_KILL
+		void KilledUnit(Unit* /*victim*/) override
+		{
+			AddEvent(EVENT_TYPE_KILL);
+		}
+
+		//EVENT_TYPE_DIED
+		void JustDied(Unit* killer) override
+		{
+			TriggerEvent(EVENT_TYPE_DIED, killer);
+			Summons.DespawnAll();
+		}
+
+		void JustSummoned(Creature* summoned) override
+		{
+			summoned->GetMotionMaster()->MoveRandom(5.0f);
+			Summons.Summon(summoned);
+		}
+
+		void SummonedCreatureDies(Creature* summoned, Unit* /*killer*/) override
+		{
+
+			Summons.Despawn(summoned);
+		}
+
+
+		void SummonedCreatureDespawn(Creature* summoned) override
+		{
+			Summons.Despawn(summoned);
+		}
+
+		void Action(CreatureActionTypes actionType, std::string actionParam1, int32 actionParam2, uint32 actionFlags, int32 actionParam3, Unit* unit)
+		{
+			switch (actionType)
+			{
+			case ACTION_TYPE_CAST_SPELL:
+				{
+					if (!me->IsAlive())
+						break;
+
+					uint32 spellid1 = atoi(actionParam1.c_str());
+					uint32 spellid2 = actionParam2;
+
+					if (spellid1 != 0 && spellid2 != 0)
+						urand(0, 1) == 0 ? DoCast(spellid1) : DoCast(spellid2);
+					else if (spellid1 != 0)
+						DoCast(spellid1);
+					else if (spellid2 != 0)
+						DoCast(spellid2);
+				}
+				break;
+			case ACTION_TYPE_TALK:
+				switch (actionParam2)
+				{
+				case 1:
+					me->MonsterSay(actionParam1.c_str(), LANG_UNIVERSAL, NULL);
+					break;
+				case 2:
+					me->MonsterYell(actionParam1.c_str(), LANG_UNIVERSAL, NULL);
+					break;
+				case 3:
+					if (Unit* victim = me->GetVictim())
+						if (Player* v = victim->ToPlayer())
+							me->MonsterWhisper(actionParam1.c_str(), v);
+					break;
+				case 4:
+					sWorld->SendZoneText(me->GetZoneId(), actionParam1.c_str());
+					break;
+				case 5:
+				{
+					SessionMap m_sessions = sWorld->GetAllSessions();
+					for (SessionMap::iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+					{
+						if (!itr->second || !itr->second->GetPlayer() || !itr->second->GetPlayer()->IsInWorld() || itr->second->GetPlayer()->GetZoneId() != me->GetZoneId())
+							continue;
+						itr->second->SendAreaTriggerMessage(actionParam1.c_str());
+					}
+				}
+					break;
+				case 6:
+				{
+					SessionMap m_sessions = sWorld->GetAllSessions();
+					for (SessionMap::iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+					{
+						if (!itr->second || !itr->second->GetPlayer() || !itr->second->GetPlayer()->IsInWorld() || itr->second->GetPlayer()->GetZoneId() != me->GetZoneId())
+							continue;
+						itr->second->SendAreaTriggerMessage(actionParam1.c_str());
+					}
+					sWorld->SendZoneText(me->GetZoneId(), actionParam1.c_str());
+				}
+					break;
+				case 7:
+					sWorld->SendScreenMessage(actionParam1.c_str());
+					break;
+				}
+				break;
+			case ACTION_TYPE_ACTIVE_OR_DEACTIVE_OBJECT:
+			{
+				int32 param1 = atoi(actionParam1.c_str());
+				bool isCreature = actionParam2 == 0 ? true : false;
+				bool active = param1 > 0 ? true : false;
+
+				if (actionParam3 < 0)
+				{
+					uint32 entry = abs(param1);
+					if (isCreature)
+					{
+						if (Creature* creature = unit->FindNearestCreature(entry, 500.0f))
+							creature->RemoveFromWorld();
+					}
+					else
+					{
+						if (GameObject* gob = unit->FindNearestGameObject(entry, 500.0f))
+							gob->RemoveFromWorld();
+					}		
+				}
+				else
+				{
+					
+					uint32 guid = abs(param1);		
+					
+					if (isCreature)
+					{
+						if (CreatureData const* data = sObjectMgr->GetCreatureData(guid))
+							if (Creature* target = ObjectAccessor::GetObjectInWorld(MAKE_NEW_GUID(guid, data->id, HIGHGUID_UNIT), (Creature*)NULL))
+								active ? target->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE) : target->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
+					}
+					else
+					{
+						if (GameObjectData const* data = sObjectMgr->GetGOData(guid))
+							if (GameObject* target = ObjectAccessor::GetObjectInWorld(MAKE_NEW_GUID(guid, data->id, HIGHGUID_GAMEOBJECT), (GameObject*)NULL))
+								active ? target->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_NOT_SELECTABLE) : target->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_NOT_SELECTABLE);
+					}
+				}
+			}
+			
+				break;
+			case ACTION_TYPE_SUMMON:
+			{
+				int32 entry = atoi(actionParam1.c_str());
+
+				uint32 map = me->GetMapId();
+				float x = me->GetPositionX();
+				float y = me->GetPositionY();
+				float z = me->GetPositionZ();
+				float o = me->GetOrientation(); 
+
+				sEvent->GetTelePos(actionParam3, map, x, y, z, o);
+
+				if (unit)
+				{
+					if (entry > 0)
+						unit->SummonCreature(entry, x, y, z, o, TEMPSUMMON_TIMED_DESPAWN, actionParam2 * IN_MILLISECONDS);
+					else
+						unit->SummonGameObject(abs(entry), x, y, z, o, 0, 0, 0, 0, actionParam2);
+				}	
+			}
+				break;
+			case ACTION_TYPE_ALT_GOB:
+				if (GameObject* gob = me->FindNearestGameObject(abs(atoi(actionParam1.c_str())), actionParam2))
+					gob->SetGoState(GO_STATE_ACTIVE_ALTERNATIVE);
+			break;
+			case ACTION_TYPE_ALT_PHASE:
+				SetPhase(atoi(actionParam1.c_str()));
+				break;
+			case ACTION_TYPE_MOVE_RANDOM:
+				me->GetMotionMaster()->MoveRandom(atoi(actionParam1.c_str()));
+				break;
+			default:
+				break;
+			}
+		}
+
+		void SetPhase(uint32 phase){ m_phase = phase; }
+		uint32 GetPhase(){ return m_phase; }
+	private:
+		EventMap events;
+		uint32 m_phase;	
+	};
+
+	CreatureAI* GetAI(Creature* creature) const
+	{
+		return new CustomCreatureScriptAI(creature);
+	}
+};
+
+void AddSC_CustomCreatureScript()
+{
+	new CustomCreatureScript();
+}
diff --git a/src/server/scripts/Custom/Scripts/CustomScripts.h b/src/server/scripts/Custom/Scripts/CustomScripts.h
new file mode 100644
index 0000000..ef05864
--- /dev/null
+++ b/src/server/scripts/Custom/Scripts/CustomScripts.h
@@ -0,0 +1,163 @@
+
+enum GobActionTypes
+{
+	gob_ACTION_TYPE_NONE,
+	gob_ACTION_TYPE_AURA,							//ÊÍ·Å¼¼ÄÜ				AuraID1,						AuraID2,			
+	gob_ACTION_TYPE_TELE,							//´«ËÍÍæ¼Ò				TelePosId						TeleAura				
+	gob_ACTION_TYPE_ACTIVE_OR_DEACTIVE_OBJECT,		//¼¤»î»òÊ¹Ê§»î			CreatureEntry					GameObjectEntry		
+	gob_ACTION_TALK,
+	gob_ACTION_SUMMON,
+};
+
+
+struct GobScriptTemplate
+{
+	int32 ID;
+	GobActionTypes gobActionType;
+	std::string actionParam1;
+	int32 actionParam2;
+};
+
+extern std::vector<GobScriptTemplate> GobScriptVec;
+
+enum CreatureEventTypes
+{								//						eventPhase			delayTime			repeatMinTime					repeatMaxTime	
+	EVENT_TYPE_NONE,
+	EVENT_TYPE_COMBAT,			//½øÈëÕ½¶·									Ê×´Î´¥·¢ÑÓÊ±			×îÐ¡ÖØ¸´Ê±¼ä						×î´óÖØ¸´Ê±¼ä	
+	EVENT_TYPE_KILL,			//É±ËÀÍæ¼Ò									Ê×´Î´¥·¢ÑÓÊ±			×îÐ¡ÖØ¸´Ê±¼ä						×î´óÖØ¸´Ê±¼ä	
+	EVENT_TYPE_HP_90,			//ÑªÁ¿µÍÓÚ90%(Ö±½Ó´¥·¢£©		-					-					-								-			
+	EVENT_TYPE_HP_75,			//ÑªÁ¿µÍÓÚ75%(Ö±½Ó´¥·¢)		-					-					-								-			
+	EVENT_TYPE_HP_50,			//ÑªÁ¿µÍÓÚ50%(Ö±½Ó´¥·¢)		-					-					-								-			
+	EVENT_TYPE_HP_25,			//ÑªÁ¿µÍÓÚ25%(Ö±½Ó´¥·¢)		-					-					-								-			
+	EVENT_TYPE_HP_10,			//ÑªÁ¿µÍÓÚ10%(Ö±½Ó´¥·¢)		-					-					-								-				
+	EVENT_TYPE_DIED,			//ËÀÍö(Ö±½Ó´¥·¢)				-					-					-								-	
+	EVENT_TYPE_RESET,			//ÖØÖÃ(Ö±½Ó´¥·¢)				-					-					-								-
+};
+
+enum CreatureActionTypes
+{												//						actionParam1					actionParam2			actionParam3
+	ACTION_TYPE_NONE,
+	ACTION_TYPE_CAST_SPELL,						//ÊÍ·Å¼¼ÄÜ				SPELL_ID_1,						SPELL_ID_2,				-
+	ACTION_TYPE_TALK,							//Ëµ»°					Ëµ»°ÄÚÈÝ								-				
+	ACTION_TYPE_ACTIVE_OR_DEACTIVE_OBJECT,		//¼¤»î					CreatureEntry					GameObjectEntry			-
+	ACTION_TYPE_SUMMON,							//ÕÙ»½ÉúÎï»òÎïÌå			CreatureEntry»ò-	GameObjectEntry	³ÖÐøÊ±¼ä					×ø±êID
+	ACTION_TYPE_ALT_PHASE,						//Éè¶¨½×¶Î				eventPhase							-		
+	ACTION_TYPE_ALT_GOB,						//´ò¿ª»ò¹Ø±ÕÎïÌå			GameObjectEntry»ò-	GameObjectEntry	·¶Î§		
+	ACTION_TYPE_MOVE_RANDOM
+};
+
+struct CreatureScriptTemplate
+{
+	uint32 entry;
+	CreatureEventTypes eventType;
+	uint32 eventPhase;
+	uint32 delayTime;
+	uint32 repeatMinTime;
+	uint32 repeatMaxTime;
+	CreatureActionTypes actionType;
+	std::string actionParam1;
+	int32 actionParam2;
+	uint32 actionFlags;
+	int32 actionParam3;
+};
+
+extern std::vector<CreatureScriptTemplate> CreatureScriptVec;
+
+
+struct ActionTemplate
+{
+	uint32 eventID;
+	CreatureEventTypes eventType;
+	uint32 eventPhase;
+	uint32 delayTime;
+	uint32 repeatMinTime;
+	uint32 repeatMaxTime;
+	CreatureActionTypes actionType;
+	std::string actionParam1;
+	int32 actionParam2;
+	uint32 actionFlags;
+	uint32 actionParam3;
+};
+
+struct CircleTemplate
+{
+	uint32 respawnTime;
+	float range;
+	uint32 creatureId;
+	float creatureScale;
+	float creatureOffsetZ;
+	uint32 creatureCount;
+	float creatureRadius;
+	uint32 gameobjectId;
+	float gameobjectScale;
+	float gameobjectOffsetZ;
+	uint32 gameobjectCount;
+	float gameobjectRadius;
+	uint32 spellId1;
+	uint32 spellInterval1;
+	uint32 spellDelay1;
+	bool spellFriendly1;
+	uint32 spellId2;
+	uint32 spellInterval2;
+	uint32 spellDelay2;
+	bool spellFriendly2;
+	uint32 spellId3;
+	uint32 spellInterval3;
+	uint32 spellDelay3;
+	bool spellFriendly3;
+};
+
+extern std::unordered_map<uint32,CircleTemplate> CircleDataMap;
+
+enum SpellModTypes
+{
+	SMT_DIRECT_DMG,					//Ö±½ÓÉËº¦Ôö¼Ó
+	SMT_DIRECT_HEAL,				//Ö±½ÓÖÎÁÆÔö¼Ó
+	SMT_MOVE_SPEED_INS,				//ÒÆ¶¯ËÙ¶ÈÔö¼Ó
+	SMT_MOVE_SPEED_DES,				//ÒÆ¶¯ËÙ¶È¼õÉÙ
+	SMT_DMG_PCT,					//Ôì³ÉµÄÉËº¦°Ù·Ö±ÈÔö¼õ
+	SMT_HEAL_PCT,					//Ôì³ÉµÄÖÎÁÆ°Ù·Ö±ÈÔö¼õ
+	SMT_DMG_PCT_TAKEN,				//ÊÜµ½µÄÉËº¦°Ù·Ö±ÈÔö¼õ
+	SMT_HEAL_PCT_TAKEN,				//ÊÜµ½µÄÖÎÁÆ°Ù·Ö±ÈÔö¼õ
+	SMT_ATTACK_SPEED,				//¹¥»÷¡¢Ê©·¨ËÙ¶È°Ù·Ö±ÈÔö¼õ
+	SMT_STUN,						//»èÃÔ
+	SMT_STUN_BREAKABLE,				//ÊÜµ½ÉËº¦¿É´ò¶Ï»èÃÔ
+};
+
+struct AIRandSpellTemplate
+{
+	uint32 GroupId;
+	uint32 SpellId;
+	uint32 MinDelayTime;
+	uint32 MaxDelayTime;
+};
+
+extern std::vector<AIRandSpellTemplate> AIRandSpellVec;
+
+class CustomScript
+{
+public:
+	static CustomScript* instance()
+	{
+		static CustomScript instance;
+		return &instance;
+	}
+
+	void LoadGobScripts();
+	void LoadCreautreScripts();
+	void LoadCircleData();
+
+	std::string GetCreatureScript(uint32 entry);
+
+	void GetSpellInfo(SpellModTypes type, uint32 &spellId, SpellValueMod &spellValueMod);
+	void Cast(Unit* caster, Unit* target, SpellModTypes type, int value);
+	void Cast(Unit* caster, Unit* target, SpellModTypes type);
+	void CastSpellToNearbyPlayers(Unit* caster, uint32 e_spellId, uint32 f_spellId, float range);
+	void CastSpellToNearbyUnits(Unit* caster, uint32 e_spellId, uint32 f_spellId, float range);
+
+
+	void CastRandSpell(Creature* creautre, uint32 diff);
+private:
+
+};
+#define sCustomScript CustomScript::instance()
diff --git a/src/server/scripts/Custom/Scripts/GameObjectScripts.cpp b/src/server/scripts/Custom/Scripts/GameObjectScripts.cpp
new file mode 100644
index 0000000..b1bd6e1
--- /dev/null
+++ b/src/server/scripts/Custom/Scripts/GameObjectScripts.cpp
@@ -0,0 +1,204 @@
+#pragma execution_character_set("utf-8")
+#include "CustomScripts.h"
+#include "../CustomEvent/Event.h"
+
+std::vector<GobScriptTemplate> GobScriptVec;
+
+void CustomScript::LoadGobScripts()
+{
+	GobScriptVec.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÎïÌåID,¶¯×÷ÀàÐÍ,¶¯×÷²ÎÊý1,¶¯×÷²ÎÊý2 FROM _×Ô¶¨ÒåAI_ÎïÌå" :
+		"SELECT ID,actionType,param1,param2 FROM _ai_gameobject");
+	if (!result) return;
+	do
+	{
+		Field* fields = result->Fetch();
+		GobScriptTemplate Temp;
+		Temp.ID = fields[0].GetInt32();
+
+		const char* str2 = fields[1].GetCString();
+
+		if (strcmp("´«ËÍÍæ¼Ò", str2) == 0)
+			Temp.gobActionType = gob_ACTION_TYPE_TELE;
+		else if (strcmp("¼¤»î»òÊ¹Ê§»î", str2) == 0)
+			Temp.gobActionType = gob_ACTION_TYPE_ACTIVE_OR_DEACTIVE_OBJECT;
+		else if (strcmp("ÊÍ·Å¼¼ÄÜ", str2) == 0)
+			Temp.gobActionType = gob_ACTION_TYPE_AURA;
+		else if (strcmp("Ëµ»°", str2) == 0)
+			Temp.gobActionType = gob_ACTION_TALK;
+		else if (strcmp("ÕÙ»½", str2) == 0)
+			Temp.gobActionType = gob_ACTION_SUMMON;
+		else
+			Temp.gobActionType = gob_ACTION_TYPE_NONE;
+
+		Temp.actionParam1 = fields[2].GetString();
+		Temp.actionParam2 = fields[3].GetInt32();
+
+		GobScriptVec.push_back(Temp);
+	} while (result->NextRow());
+}
+
+
+class CustomGameObject : PlayerScript
+{
+public:
+	CustomGameObject() : PlayerScript("CustomGameObject") {}
+
+	void OnUseGameObject(Player* player, GameObject* gob)
+	{
+		uint32 entry = gob->GetEntry();
+		int32 guid = gob->GetGUIDLow();
+
+		for (std::vector<GobScriptTemplate>::iterator itr = GobScriptVec.begin(); itr != GobScriptVec.end(); ++itr)
+		{
+			int32 ID = itr->ID;
+
+			if (ID != entry && guid != abs(ID))
+				continue;
+
+			int32 i_actionParam1 = atoi(itr->actionParam1.c_str());
+			std::string s_actionParam1 = itr->actionParam1;
+			int32 i_actionParam2 = itr->actionParam2;
+
+			GobActionTypes gobActionType = itr->gobActionType;
+			switch (gobActionType)
+			{
+			case gob_ACTION_TYPE_AURA:
+				player->AddAura(i_actionParam1, player);
+				player->AddAura(i_actionParam2, player);
+				break;
+			case gob_ACTION_TYPE_TELE:
+				if (!player->HasAura(i_actionParam2))
+				{
+					player->AddAura(i_actionParam2, player);
+					Tele(player, i_actionParam1);
+				}
+				else
+				{
+					std::ostringstream oss;
+					oss << "|cFFFF1717[" << gob->GetName() << "]|rÕý´¦ÓÚÀäÈ´ÖÐ£¬´«ËÍÊ§°Ü...";
+					player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+				}
+				break;
+			case gob_ACTION_TYPE_ACTIVE_OR_DEACTIVE_OBJECT:
+			{
+				uint32 guid = abs(i_actionParam1);
+				bool isCreature = i_actionParam2 == 0 ? true : false;
+				bool active = i_actionParam1 > 0 ? true : false;
+
+				if (isCreature)
+				{
+					if (CreatureData const* data = sObjectMgr->GetCreatureData(guid))
+						if (Creature* target = ObjectAccessor::GetObjectInWorld(MAKE_NEW_GUID(guid, data->id, HIGHGUID_UNIT), (Creature*)NULL))
+							active ? target->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE) : target->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE);
+				}
+				else
+				{
+					if (GameObjectData const* data = sObjectMgr->GetGOData(guid))
+						if (GameObject* target = ObjectAccessor::GetObjectInWorld(MAKE_NEW_GUID(guid, data->id, HIGHGUID_GAMEOBJECT), (GameObject*)NULL))
+							active ? target->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_NOT_SELECTABLE) : target->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_NOT_SELECTABLE);
+				}
+			}
+				break;
+			case gob_ACTION_TALK:
+
+				switch (i_actionParam2)
+				{
+					// 1zone text 2 ÖÐ¼äË¢ÆÁ 3 Á½Õß¶¼ÓÐ
+				case 1:
+					sWorld->SendZoneText(player->GetZoneId(),s_actionParam1.c_str());
+					break;
+				case 2:
+				{
+					SessionMap m_sessions = sWorld->GetAllSessions();
+					for (SessionMap::iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+					{
+						if (!itr->second || !itr->second->GetPlayer() || !itr->second->GetPlayer()->IsInWorld() || itr->second->GetPlayer()->GetZoneId() != gob->GetZoneId())
+							continue;
+						itr->second->SendAreaTriggerMessage(s_actionParam1.c_str());
+					}
+				}
+					break;
+				case 3:
+				{
+					SessionMap m_sessions = sWorld->GetAllSessions();
+					for (SessionMap::iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+					{
+						if (!itr->second || !itr->second->GetPlayer() || !itr->second->GetPlayer()->IsInWorld() || itr->second->GetPlayer()->GetZoneId() != gob->GetZoneId())
+							continue;
+						itr->second->SendAreaTriggerMessage(s_actionParam1.c_str());
+					}
+
+					sWorld->SendZoneText(player->GetZoneId(), s_actionParam1.c_str());
+				}
+					break;
+				case 4:
+					sWorld->SendScreenMessage(s_actionParam1.c_str());
+					break;
+				default:
+					break;
+				}
+				break;
+			case gob_ACTION_SUMMON:
+			{
+				bool isCreature = i_actionParam1 > 0 ? true : false;
+				uint32 entry = abs(i_actionParam1);
+				uint32 despawntime = i_actionParam2 * MINUTE * IN_MILLISECONDS;
+
+				if (isCreature)
+					gob->SummonCreature(entry, gob->GetPositionX(), gob->GetPositionY(), gob->GetPositionZ(), gob->GetOrientation(), TEMPSUMMON_TIMED_DESPAWN, despawntime);
+				else
+					gob->SummonGameObject(entry, gob->GetPositionX(), gob->GetPositionY(), gob->GetPositionZ(), gob->GetOrientation(), 0, 0, 0, 0, despawntime);
+
+			}		
+				break;
+			default:
+				break;
+			}
+		}
+	}
+
+
+	void Tele(Player* player, uint32 telePosId)
+	{
+		std::unordered_map<uint32, PosTemplate>::iterator it = PosMap.find(telePosId);
+
+		if (it != PosMap.end())
+			player->TeleportTo(it->second.map, it->second.x, it->second.y, it->second.z, it->second.o);
+	}
+};
+
+
+class KeyStone :public GameObjectScript
+{
+public:
+	KeyStone() : GameObjectScript("KeyStone") { }
+
+	bool OnGossipHello(Player* player, GameObject* go) override
+	{
+		if (Creature* target = go->FindNearestCreature(1, 5.0f))
+		{
+			go->CastSpell(target, 64986);
+			target->SetVisible(true);
+		}
+			
+		return true;
+	}
+
+	bool OnGossipSelect(Player* player, GameObject* go, uint32 sender, uint32 action) override
+	{
+		
+		return true;
+	}
+
+	
+};
+
+
+
+void AddSC_CustomGameObjectScript()
+{
+	new KeyStone();
+	new CustomGameObject();
+}
diff --git a/src/server/scripts/Custom/Scripts/SpellScripts.cpp b/src/server/scripts/Custom/Scripts/SpellScripts.cpp
new file mode 100644
index 0000000..c8de123
--- /dev/null
+++ b/src/server/scripts/Custom/Scripts/SpellScripts.cpp
@@ -0,0 +1,1373 @@
+#pragma execution_character_set("utf-8")
+#include "CustomScripts.h"
+#include "../CommonFunc/CommonFunc.h"
+
+void CustomScript::Cast(Unit* caster, Unit* target, SpellModTypes type, int value)
+{
+	uint32 spellId;
+	SpellValueMod spellValueMod;
+	GetSpellInfo(type, spellId, spellValueMod);
+
+	caster->CastCustomSpell(spellId, spellValueMod, value, target);
+}
+
+void CustomScript::Cast(Unit* caster, Unit* target, SpellModTypes type)
+{
+	uint32 spellId = 0;
+
+	switch (type)
+	{
+	case SMT_STUN:
+		spellId = 80106;
+		break;
+	case SMT_STUN_BREAKABLE:
+		spellId = 80107;
+	default:
+		break;
+	}
+
+	caster->CastSpell(target, spellId, TRIGGERED_FULL_MASK);
+}
+
+void CustomScript::GetSpellInfo(SpellModTypes type, uint32 &spellId, SpellValueMod &spellValueMod)
+{
+	switch (type)
+	{
+	case SMT_DIRECT_DMG:
+		spellId = 80101;
+		spellValueMod = SPELLVALUE_BASE_POINT0;
+		break;
+	case SMT_DIRECT_HEAL:
+		spellId = 80101;
+		spellValueMod = SPELLVALUE_BASE_POINT1;
+		break;
+	case SMT_MOVE_SPEED_INS:
+		spellId = 80102;
+		spellValueMod = SPELLVALUE_BASE_POINT0;
+		break;
+	case SMT_MOVE_SPEED_DES:
+		spellId = 80102;
+		spellValueMod = SPELLVALUE_BASE_POINT1;
+		break;
+	case SMT_DMG_PCT:
+		spellId = 80103;
+		spellValueMod = SPELLVALUE_BASE_POINT0;
+		break;
+	case SMT_HEAL_PCT:
+		spellId = 80103;
+		spellValueMod = SPELLVALUE_BASE_POINT1;
+		break;
+	case SMT_DMG_PCT_TAKEN:
+		spellId = 80104;
+		spellValueMod = SPELLVALUE_BASE_POINT0;
+		break;
+	case SMT_HEAL_PCT_TAKEN:
+		spellId = 80104;
+		spellValueMod = SPELLVALUE_BASE_POINT1;
+		break;
+	case SMT_ATTACK_SPEED:
+		spellId = 80105;
+		spellValueMod = SPELLVALUE_BASE_POINT0;
+		break;
+	default:
+		break;
+	}
+}
+
+
+class spell_dmg_target : public SpellScriptLoader
+{
+public:
+	spell_dmg_target() : SpellScriptLoader("spell_dmg_target") { }
+
+	class spell_dmg_target_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_dmg_target_SpellScript);
+
+		void HandleScriptEffect(SpellEffIndex /*effIndex*/)
+		{
+			if (Unit* target = GetHitUnit())
+			{
+				sCustomScript->Cast(GetCaster(), target, SMT_DIRECT_DMG, 10000);
+			}
+		}
+
+		void Register()
+		{
+			OnEffectHitTarget += SpellEffectFn(spell_dmg_target_SpellScript::HandleScriptEffect, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+		}
+	};
+
+	SpellScript* GetSpellScript() const
+	{
+		return new spell_dmg_target_SpellScript();
+	}
+};
+
+//×î´óÉúÃüÖµ°Ù·Ö±ÈÉËº¦
+class spell_dmg_maxhealth_pct : public SpellScriptLoader
+{
+public:
+	spell_dmg_maxhealth_pct() : SpellScriptLoader("spell_dmg_maxhealth_pct") { }
+
+	class spell_dmg_maxhealth_pct_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_dmg_maxhealth_pct_SpellScript);
+
+		void HandleScriptEffect(SpellEffIndex /*effIndex*/)
+		{
+			if (Unit* target = GetHitUnit())
+			{
+				float multi = 0.0f;
+
+				switch (m_scriptSpellId)
+				{
+				
+				default:
+					break;
+				}
+
+				int32 damage = int32(target->GetMaxHealth() * multi);
+
+				if (damage <= 0)
+					return;
+
+				sCustomScript->Cast(GetCaster(), target, SMT_DIRECT_DMG, damage);
+			}
+		}
+
+		void Register()
+		{
+			OnEffectHitTarget += SpellEffectFn(spell_dmg_maxhealth_pct_SpellScript::HandleScriptEffect, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+		}
+	};
+
+	SpellScript* GetSpellScript() const
+	{
+		return new spell_dmg_maxhealth_pct_SpellScript();
+	}
+};
+
+//µ±Ç°ÉúÃüÖµ°Ù·Ö±ÈÉËº¦
+class spell_dmg_health_pct : public SpellScriptLoader
+{
+public:
+	spell_dmg_health_pct() : SpellScriptLoader("spell_dmg_health_pct") { }
+
+	class spell_dmg_health_pct_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_dmg_health_pct_SpellScript);
+
+		void HandleScriptEffect(SpellEffIndex /*effIndex*/)
+		{
+			if (Unit* target = GetHitUnit())
+			{
+				if (target->GetTypeId() == TYPEID_UNIT)
+					if (target->ToCreature()->isWorldBoss() || target->ToCreature()->IsDungeonBoss())
+						return;
+
+				float multi = 0.0f;
+
+				switch (m_scriptSpellId)
+				{
+				case 113011:
+					multi = 0.05f;
+					break;
+				case 113012:
+					multi = 0.1f;
+					break;
+				case 113013:
+					multi = 0.15f;
+					break;
+				case 113014:
+					multi = 0.2f;
+					break;
+				default:
+					break;
+				}
+
+				const int32 damage = int32(target->GetHealth() * multi);
+
+				const int32 selfHp = GetCaster()->GetMaxHealth();
+
+				int32 value = int32(std::min(damage, selfHp) * multi);
+
+				if (value <= 0)
+					return;
+
+				sCustomScript->Cast(GetCaster(), target, SMT_DIRECT_DMG, value);
+			}
+		}
+
+		void Register()
+		{
+			OnEffectHitTarget += SpellEffectFn(spell_dmg_health_pct_SpellScript::HandleScriptEffect, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+		}
+	};
+
+	SpellScript* GetSpellScript() const
+	{
+		return new spell_dmg_health_pct_SpellScript();
+	}
+};
+
+//ËðÊ§ÉúÃüÖµ°Ù·Ö±ÈÉËº¦
+class spell_dmg_los_health_pct : public SpellScriptLoader
+{
+public:
+	spell_dmg_los_health_pct() : SpellScriptLoader("spell_dmg_los_health_pct") { }
+
+	class spell_dmg_los_health_pct_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_dmg_los_health_pct_SpellScript);
+
+		void HandleScriptEffect(SpellEffIndex /*effIndex*/)
+		{
+			if (Unit* target = GetHitUnit())
+			{
+				if (target->GetTypeId() == TYPEID_UNIT)
+					if (target->ToCreature()->isWorldBoss() || target->ToCreature()->IsDungeonBoss())
+						return;
+
+				float multi = 0.0f;
+
+				switch (m_scriptSpellId)
+				{
+				case 111011:
+					multi = 0.2f;
+					break;
+				case 111012:
+					multi = 0.3f;
+					break;
+				case 111013:
+					multi = 0.4f;
+					break;
+				case 111014:
+					multi = 0.5f;
+					break;
+				default:
+					break;
+				}
+
+				const int32 losHp = target->GetMaxHealth() - target->GetHealth();
+				const int32 selfHp = GetCaster()->GetMaxHealth();
+
+				int32 damage = int32(std::min(losHp, selfHp) * multi);
+
+				if (damage <= 0)
+					return;
+
+				sCustomScript->Cast(GetCaster(), target, SMT_DIRECT_DMG, damage);
+			}
+		}
+
+		void Register()
+		{
+			OnEffectHitTarget += SpellEffectFn(spell_dmg_los_health_pct_SpellScript::HandleScriptEffect, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+		}
+	};
+
+	SpellScript* GetSpellScript() const
+	{
+		return new spell_dmg_los_health_pct_SpellScript();
+	}
+};
+
+
+//×î´óÉúÃüÖµ°Ù·Ö±ÈÖÎÁÆ
+class spell_heal_maxhealth_pct : public SpellScriptLoader
+{
+public:
+	spell_heal_maxhealth_pct() : SpellScriptLoader("spell_heal_maxhealth_pct") { }
+
+	class spell_heal_maxhealth_pct_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_heal_maxhealth_pct_SpellScript);
+
+		void HandleScriptEffect(SpellEffIndex /*effIndex*/)
+		{
+			if (Unit* target = GetHitUnit())
+			{
+				float multi = 0.0f;
+
+				switch (m_scriptSpellId)
+				{
+				
+				default:
+					break;
+				}
+
+				int32 heal = int32(target->GetMaxHealth() * multi);
+
+				if (heal <= 0)
+					return;
+
+				sCustomScript->Cast(GetCaster(), target, SMT_DIRECT_HEAL, heal);
+			}
+		}
+
+		void Register()
+		{
+			OnEffectHitTarget += SpellEffectFn(spell_heal_maxhealth_pct_SpellScript::HandleScriptEffect, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+		}
+	};
+
+	SpellScript* GetSpellScript() const
+	{
+		return new spell_heal_maxhealth_pct_SpellScript();
+	}
+};
+
+//µ±Ç°ÉúÃüÖµ°Ù·Ö±ÈÖÎÁÆ
+class spell_heal_health_pct : public SpellScriptLoader
+{
+public:
+	spell_heal_health_pct() : SpellScriptLoader("spell_heal_health_pct") { }
+
+	class spell_heal_health_pct_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_heal_health_pct_SpellScript);
+
+		void HandleScriptEffect(SpellEffIndex /*effIndex*/)
+		{
+			if (Unit* target = GetHitUnit())
+			{
+				float multi = 0.0f;
+
+				switch (m_scriptSpellId)
+				{
+				
+				default:
+					break;
+				}
+
+				int32 heal = int32(target->GetHealth() * multi);
+
+				if (heal <= 0)
+					return;
+
+				sCustomScript->Cast(GetCaster(), target, SMT_DIRECT_HEAL, heal);
+			}
+		}
+
+		void Register()
+		{
+			OnEffectHitTarget += SpellEffectFn(spell_heal_health_pct_SpellScript::HandleScriptEffect, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+		}
+	};
+
+	SpellScript* GetSpellScript() const
+	{
+		return new spell_heal_health_pct_SpellScript();
+	}
+};
+
+//ËðÊ§ÉúÃüÖµ°Ù·Ö±ÈÖÎÁÆ
+class spell_heal_los_health_pct : public SpellScriptLoader
+{
+public:
+	spell_heal_los_health_pct() : SpellScriptLoader("spell_heal_los_health_pct") { }
+
+	class spell_heal_los_health_pct_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_heal_los_health_pct_SpellScript);
+
+		void HandleScriptEffect(SpellEffIndex /*effIndex*/)
+		{
+			if (Unit* target = GetHitUnit())
+			{
+				float multi = 0.0f;
+
+				switch (m_scriptSpellId)
+				{
+				
+				default:
+					break;
+				}
+
+				int32 heal = int32((target->GetMaxHealth() - target->GetHealth()) * multi);
+
+				if (heal <= 0)
+					return;
+
+				sCustomScript->Cast(GetCaster(), target, SMT_DIRECT_HEAL, heal);
+			}
+		}
+
+		void Register()
+		{
+			OnEffectHitTarget += SpellEffectFn(spell_heal_los_health_pct_SpellScript::HandleScriptEffect, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+		}
+	};
+
+	SpellScript* GetSpellScript() const
+	{
+		return new spell_heal_los_health_pct_SpellScript();
+	}
+};
+
+
+class spell_speed_des : public SpellScriptLoader
+{
+public:
+	spell_speed_des() : SpellScriptLoader("spell_speed_des") { }
+
+	class spell_speed_des_AuraScript : public AuraScript
+	{
+		PrepareAuraScript(spell_speed_des_AuraScript);
+
+		void OnApply(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*handle*/)
+		{
+			sCustomScript->Cast(GetCaster(), GetTarget(), SMT_MOVE_SPEED_INS, 100);
+		}
+
+		void OnRemove(AuraEffect const* /*aurEff*/, AuraEffectHandleModes /*handle*/)
+		{
+			GetTarget()->RemoveAura(80102);
+		}
+
+		void Register()
+		{
+			OnEffectApply += AuraEffectApplyFn(spell_speed_des_AuraScript::OnApply, EFFECT_0, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL);
+			OnEffectRemove += AuraEffectRemoveFn(spell_speed_des_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL);
+		}
+	};
+
+	AuraScript* GetAuraScript() const
+	{
+		return new spell_speed_des_AuraScript();
+	}
+};
+
+
+Creature* GetNearestSummon(Player* player, SummonList Summons, Creature* summoner)
+{
+	for (SummonList::const_iterator itr = Summons.begin(); itr != Summons.end(); ++itr)
+	{
+		if (Creature* summon = ObjectAccessor::GetCreature(*summoner, *itr))
+		{
+			bool flag = true;
+
+			for (SummonList::const_iterator ii = Summons.begin(); ii != Summons.end(); ++ii)
+			{
+				if (Creature* summon_ii = ObjectAccessor::GetCreature(*summoner, *ii))
+				{
+					if (summon->GetDistance(player) > summon_ii->GetDistance(player))
+						flag = false;
+				}
+			}
+
+			if (flag)
+				return summon;
+		}
+	}
+
+	return NULL;
+}
+
+class spell_dest_dest : public SpellScriptLoader
+{
+public:
+	spell_dest_dest() : SpellScriptLoader("spell_dest_dest") { }
+
+	class spell_dest_dest_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_dest_dest_SpellScript);
+
+		void HandleScriptEffect(SpellEffIndex /*effIndex*/)
+		{
+			WorldLocation const* dest = GetHitDest();
+
+			if (!dest)
+				return;
+
+			Unit* caster = GetCaster();
+
+			if (!caster)
+				return;
+
+			uint32 entry = 970000 + GetSpell()->GetSpellInfo()->GetRank();
+
+			if (Creature* trigger = caster->SummonCreature(entry, *dest, TEMPSUMMON_TIMED_DESPAWN, 20000))
+			{
+				trigger->SetCreatorGUID(caster->GetGUID());
+				trigger->setFaction(caster->getFaction());
+			}
+				
+		}
+
+		void Register()
+		{
+			OnEffectHit += SpellEffectFn(spell_dest_dest_SpellScript::HandleScriptEffect, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+		}
+	};
+
+	SpellScript* GetSpellScript() const
+	{
+		return new spell_dest_dest_SpellScript();
+	}
+};
+
+
+
+class zhenfa_leiyun_trigger : public CreatureScript
+{
+public:
+	zhenfa_leiyun_trigger() : CreatureScript("zhenfa_leiyun_trigger") { }
+	struct zhenfa_leiyun_triggerAI : public ScriptedAI
+	{
+		zhenfa_leiyun_triggerAI(Creature* creature) : ScriptedAI(creature), Summons(me)
+		{}
+
+		SummonList Summons;
+		uint32 Timer = 0;
+		uint32 map = me->GetMapId();
+		float x = me->GetPositionX();
+		float y = me->GetPositionY();
+		float z = me->GetPositionZ();
+		uint32 respanTime = 20000;
+
+		void Summon()
+		{
+			uint8 max_i = 15;
+
+			for (uint8 i = 0; i < max_i; i++)
+			{
+				float x1 = x + 10 * cos(2 * M_PI * i / max_i);
+				float y1 = y + 10 * sin(2 * M_PI * i / max_i);
+				float z1 = z;
+				if (Creature* summon = me->SummonCreature(960059, x1, y1, z1, 0, TEMPSUMMON_TIMED_DESPAWN, respanTime))
+				{
+					summon->SetCanFly(true);
+					summon->SetDisableGravity(true);
+					summon->SetHover(true);
+					summon->SendMovementFlagUpdate();
+				}
+			}
+		}
+
+		void JustSummoned(Creature *summon) override
+		{
+			if (Player* creator = ObjectAccessor::FindPlayer(me->GetCreatorGUID()))
+				summon->setFaction(creator->getFaction());
+
+			Summons.Summon(summon);
+		}
+
+
+		void AttackPlayer()
+		{
+			Player* creator = ObjectAccessor::FindPlayer(me->GetCreatorGUID());
+
+			if (!creator)
+				return;
+
+			std::list<Player*> playersNearby;
+			me->GetPlayerListInGrid(playersNearby, 15.0f, true);
+
+			if (!playersNearby.empty())
+				for (std::list<Player*>::iterator iter = playersNearby.begin(); iter != playersNearby.end(); ++iter)
+				{
+					Player* player = *iter;
+
+					if (!player)
+						continue;
+
+					if (!player->IsHostileTo(creator))
+						continue;
+
+					if (Creature* attacker = GetNearestSummon(player, Summons, me))
+						attacker->CastSpell(player, 53072, TRIGGERED_FULL_MASK);
+								
+				}
+		}
+
+		void Reset() override
+		{
+			Summons.DespawnAll();
+			Summon();
+			Timer = 0;
+		}
+
+		void UpdateAI(uint32 diff) override
+		{
+			Timer += diff;
+
+			if (Timer > 1000)
+			{
+				Timer = 0;
+				AttackPlayer();
+			}
+		}		
+	};
+
+	CreatureAI* GetAI(Creature* creature) const override
+	{
+		return new zhenfa_leiyun_triggerAI(creature);
+	}
+};
+
+class zhenfa_xuanguang_trigger : public CreatureScript
+{
+public:
+	zhenfa_xuanguang_trigger() : CreatureScript("zhenfa_xuanguang_trigger") { }
+	struct zhenfa_xuanguang_triggerAI : public ScriptedAI
+	{
+		zhenfa_xuanguang_triggerAI(Creature* creature) : ScriptedAI(creature), Summons(me)
+		{}
+
+		SummonList Summons;
+		uint32 Timer = 0;
+		uint32 map = me->GetMapId();
+		float x = me->GetPositionX();
+		float y = me->GetPositionY();
+		float z = me->GetPositionZ();
+		uint32 respanTime = 20000;
+
+		void Summon()
+		{
+			uint8 max_i = 15;
+
+			for (uint8 i = 0; i < max_i; i++)
+			{
+				float x1 = x + 8 * cos(2 * M_PI * i / max_i);
+				float y1 = y + 8 * sin(2 * M_PI * i / max_i);
+				float z1 = z;
+				//if (Creature* summon = me->SummonCreature(1, x1, y1, z1, 0, TEMPSUMMON_TIMED_DESPAWN, respanTime))
+				//{
+				//	summon->SetCanFly(true);
+				//	summon->SetDisableGravity(true);
+				//	summon->SetHover(true);
+				//	summon->SendMovementFlagUpdate();
+					me->SummonGameObject(400001, x1, y1, z1 - 5, 0, 0, 0, 0, 0, respanTime / IN_MILLISECONDS);
+				//}
+			}
+		}
+
+		void JustSummoned(Creature *summon) override
+		{
+			if (Player* creator = ObjectAccessor::FindPlayer(me->GetCreatorGUID()))
+				summon->setFaction(creator->getFaction());
+
+			Summons.Summon(summon);
+		}
+
+		void AttackPlayer()
+		{
+			Player* creator = ObjectAccessor::FindPlayer(me->GetCreatorGUID());
+
+			if (!creator)
+				return;
+
+			std::list<Player*> playersNearby;
+			me->GetPlayerListInGrid(playersNearby, 8.0f, true);
+
+			if (!playersNearby.empty())
+				for (std::list<Player*>::iterator iter = playersNearby.begin(); iter != playersNearby.end(); ++iter)
+				{
+					Player* player = *iter;
+
+					if (!player)
+						continue;
+
+					if (!player->IsHostileTo(creator))
+						continue;
+
+					me->CastSpell(player, 26108, TRIGGERED_FULL_MASK);
+				}
+		}
+
+		void Reset() override
+		{
+			Summons.DespawnAll();
+			Summon();
+			Timer = 6000;
+		}
+
+		void UpdateAI(uint32 diff) override
+		{
+			Timer += diff;
+
+			if (Timer > 6000)
+			{
+				Timer = 0;
+				AttackPlayer();
+			}
+		}
+	};
+
+	CreatureAI* GetAI(Creature* creature) const override
+	{
+		return new zhenfa_xuanguang_triggerAI(creature);
+	}
+};
+
+std::unordered_map<uint32, CircleTemplate> CircleDataMap;
+
+void CustomScript::LoadCircleData()
+{
+	CircleDataMap.clear();
+	//QueryResult result = WorldDatabase.PQuery("SELECT entry,respawnTime,searchRange,creatureId,creatureCount,creatureRadius,gameobjectId,gameobjectCount,gameobjectRadius,"
+	//	"spellId1,spellInterval1,spellFriendly1,spellId2,spellInterval2,spellFriendly2,spellId3,spellInterval3,spellFriendly3,spellDelay1,spellDelay2,spellDelay3,"
+	//	"creatureOffsetZ,gameobjectOffsetZ,creatureScale,gameobjectScale FROM _circle_script");
+	//
+	//if (!result) 
+	//	return;
+	//do
+	//{
+	//	Field* fields = result->Fetch();
+	//	uint32 entry = fields[0].GetUInt32();
+	//
+	//	CircleTemplate Temp;
+	//	Temp.respawnTime		= fields[1].GetUInt32();
+	//	Temp.range				= fields[2].GetFloat();
+	//	Temp.creatureId			= fields[3].GetUInt32();
+	//	Temp.creatureCount		= fields[4].GetUInt32();
+	//	Temp.creatureRadius		= fields[5].GetFloat();
+	//	Temp.gameobjectId		= fields[6].GetUInt32();
+	//	Temp.gameobjectCount	= fields[7].GetUInt32();
+	//	Temp.gameobjectRadius	= fields[8].GetFloat();
+	//	Temp.spellId1			= fields[9].GetUInt32();
+	//	Temp.spellInterval1		= fields[10].GetUInt32();
+	//	Temp.spellFriendly1		= fields[11].GetBool();
+	//	Temp.spellId2			= fields[12].GetUInt32();
+	//	Temp.spellInterval2		= fields[13].GetUInt32();
+	//	Temp.spellFriendly2		= fields[14].GetBool();
+	//	Temp.spellId3			= fields[15].GetUInt32();
+	//	Temp.spellInterval3		= fields[16].GetUInt32();
+	//	Temp.spellFriendly3		= fields[17].GetBool();
+	//	Temp.spellDelay1		= fields[18].GetUInt32();
+	//	Temp.spellDelay2		= fields[19].GetUInt32();
+	//	Temp.spellDelay3		= fields[20].GetUInt32();
+	//	Temp.creatureOffsetZ	= fields[21].GetFloat();
+	//	Temp.gameobjectOffsetZ	= fields[22].GetFloat();
+	//	Temp.creatureScale		= fields[23].GetFloat();
+	//	Temp.gameobjectScale	= fields[24].GetFloat();
+	//	CircleDataMap.insert(std::make_pair(entry, Temp));
+	//} while (result->NextRow());
+}
+
+class CircleTrigger : public CreatureScript
+{
+public:
+	CircleTrigger() : CreatureScript("CircleTrigger") { }
+	struct CircleTriggerAI : public ScriptedAI
+	{
+		CircleTriggerAI(Creature* creature) : ScriptedAI(creature), Summons(me)
+		{}
+
+		SummonList Summons;
+		uint32 map = me->GetMapId();
+		float x = me->GetPositionX();
+		float y = me->GetPositionY();
+		float z = me->GetPositionZ();
+		int32 spellTimer1 = 0;
+		int32 spellTimer2 = 0;
+		int32 spellTimer3 = 0;
+
+		float range = 0;
+		uint32 spellId1 = 0;
+		bool spellFriendly1 = false;
+		uint32 spellInterval1 = 0;
+		uint32 spellDelay1 = 0;
+		uint32 spellId2 = 0;
+		bool spellFriendly2 = false;
+		uint32 spellInterval2 = 0;
+		uint32 spellDelay2 = 0;
+		uint32 spellId3 = 0;
+		bool spellFriendly3 = false;
+		uint32 spellInterval3 = 0;
+		uint32 spellDelay3 = 0;
+
+
+
+		void Summon()
+		{
+			std::unordered_map<uint32, CircleTemplate>::iterator iter = CircleDataMap.find(me->GetEntry());
+
+			if (iter != CircleDataMap.end())
+			{
+				for (uint8 i = 0; i < iter->second.creatureCount; i++)
+				{
+					float x1 = x + iter->second.creatureRadius * cos(2 * M_PI * i / iter->second.creatureCount);
+					float y1 = y + iter->second.creatureRadius * sin(2 * M_PI * i / iter->second.creatureCount);
+					float z1 = z + iter->second.creatureOffsetZ;
+
+					if (Creature* summon = me->SummonCreature(iter->second.creatureId, x1, y1, z1, 0, TEMPSUMMON_TIMED_DESPAWN, iter->second.respawnTime))
+					{
+						summon->SetOrientation(summon->GetAngle(me));
+						summon->SetObjectScale(iter->second.creatureScale);
+						summon->SetCanFly(true);
+						summon->SetDisableGravity(true);
+						summon->SetHover(true);
+						summon->SendMovementFlagUpdate();
+					}
+				}
+
+				for (uint8 i = 0; i < iter->second.gameobjectCount; i++)
+				{
+					float x1 = x;
+					float y1 = y;
+					float z1 = z + iter->second.gameobjectOffsetZ;
+
+					if (iter->second.creatureCount == 0)
+					{
+						x1 += iter->second.gameobjectRadius * cos(2 * M_PI * i / iter->second.gameobjectCount);
+						y1 += iter->second.gameobjectRadius * sin(2 * M_PI * i / iter->second.gameobjectCount);
+
+						if (GameObject* gob = me->SummonGameObject(iter->second.gameobjectId, x1, y1, z1, 2 * M_PI * i / iter->second.gameobjectCount, 0, 0, 0, 0, iter->second.respawnTime / IN_MILLISECONDS))
+						{
+							gob->SetOrientation(gob->GetAngle(me));
+							gob->SetObjectScale(iter->second.gameobjectScale);
+						}
+					}
+					else
+					{
+						x1 += iter->second.gameobjectRadius * cos(M_PI / iter->second.creatureCount + 2 * M_PI * i / iter->second.gameobjectCount);
+						y1 += iter->second.gameobjectRadius * sin(M_PI / iter->second.creatureCount + 2 * M_PI * i / iter->second.gameobjectCount);
+
+						if (GameObject* gob = me->SummonGameObject(iter->second.gameobjectId, x1, y1, z1, M_PI / iter->second.creatureCount + 2 * M_PI * i / iter->second.gameobjectCount, 0, 0, 0, 0, iter->second.respawnTime / IN_MILLISECONDS))
+						{
+							gob->SetOrientation(gob->GetAngle(me));
+							gob->SetObjectScale(iter->second.gameobjectScale);
+						}
+					}
+				}
+			}
+		}
+
+		void JustSummoned(Creature *summon) override
+		{
+			if (Player* creator = ObjectAccessor::FindPlayer(me->GetCreatorGUID()))
+				summon->setFaction(creator->getFaction());
+
+			Summons.Summon(summon);
+		}
+
+		void CastSpell(uint32 index)
+		{
+			Player* creator = ObjectAccessor::FindPlayer(me->GetCreatorGUID());
+
+			if (!creator)
+				return;
+
+			uint32 spellId = 0;
+			bool spellFriendly = false;
+
+			switch (index)
+			{
+			case 1:
+				spellId = spellId1;
+				spellFriendly = spellFriendly1;
+				break;
+			case 2:
+				spellId = spellId2;
+				spellFriendly = spellFriendly2;
+				break;
+			case 3:
+				spellId = spellId3;
+				spellFriendly = spellFriendly3;
+				break;
+			default:
+				break;
+			}
+
+			std::list<Player*> playersNearby;
+			me->GetPlayerListInGrid(playersNearby, range, true);
+
+			if (!playersNearby.empty())
+			{
+				for (std::list<Player*>::iterator ii = playersNearby.begin(); ii != playersNearby.end(); ++ii)
+				{
+					Player* player = *ii;
+
+					if (!player)
+						continue;
+
+					if (player->IsHostileTo(creator) && !spellFriendly)
+						me->CastSpell(player, spellId, TRIGGERED_FULL_MASK);
+
+					if (player->IsFriendlyTo(creator) && spellFriendly)
+						me->CastSpell(player, spellId, TRIGGERED_FULL_MASK);
+				}
+			}		
+		}
+
+		void Reset() override
+		{
+			std::unordered_map<uint32, CircleTemplate>::iterator iter = CircleDataMap.find(me->GetEntry());
+
+			if (iter != CircleDataMap.end())
+			{
+				range = iter->second.range;
+
+				spellId1 = iter->second.spellId1;
+				spellFriendly1 = iter->second.spellFriendly1;
+				spellInterval1 = iter->second.spellInterval1;
+				spellDelay1 = iter->second.spellDelay1;
+
+				spellId2 = iter->second.spellId2;
+				spellFriendly2 = iter->second.spellFriendly2;
+				spellInterval2 = iter->second.spellInterval2;
+				spellDelay2 = iter->second.spellDelay2;
+
+				spellId3 = iter->second.spellId3;
+				spellFriendly3 = iter->second.spellFriendly3;
+				spellInterval3 = iter->second.spellInterval3;
+				spellDelay3 = iter->second.spellDelay3;
+
+				spellTimer1 = spellInterval1 - spellDelay1;
+				spellTimer2 = spellInterval2 - spellDelay2;
+				spellTimer3 = spellInterval3 - spellDelay3;
+			}
+
+			Summons.DespawnAll();
+			Summon();
+		}
+
+		void UpdateAI(uint32 diff) override
+		{
+			if (spellInterval1 > 0)
+			{
+				spellTimer1 += diff;
+
+				if (spellTimer1 > spellInterval1)
+				{
+					spellTimer1 = 0;
+					CastSpell(1);
+				}
+			}
+			
+			if (spellInterval2 > 0)
+			{
+				spellTimer2 += diff;
+
+				if (spellTimer2 > spellInterval2)
+				{
+					spellTimer2 = 0;
+					CastSpell(2);
+				}
+			}
+
+			if (spellInterval3 > 0)
+			{
+				spellTimer3 += diff;
+
+				if (spellTimer3 > spellInterval3)
+				{
+					spellTimer3 = 0;
+					CastSpell(3);
+				}
+			}
+		}
+	};
+
+	CreatureAI* GetAI(Creature* creature) const override
+	{
+		return new CircleTriggerAI(creature);
+	}
+};
+
+
+void CustomScript::CastSpellToNearbyPlayers(Unit* caster, uint32 e_spellId, uint32 f_spellId, float range)
+{
+	std::list<Player*> playersNearby;
+	caster->GetPlayerListInGrid(playersNearby, range, true);
+	if (!playersNearby.empty())
+		for (std::list<Player*>::iterator itr = playersNearby.begin(); itr != playersNearby.end(); ++itr)
+		{
+			Player* pl = *itr;
+
+			if (!pl->IsInWorld())
+				continue;
+
+			if (caster->IsFriendlyTo(pl))
+			{
+				if (pl->HasAura(f_spellId))
+					pl->RemoveAura(f_spellId);
+				caster->CastSpell(pl, f_spellId, true);
+			}
+			else
+			{
+				if (pl->HasAura(e_spellId))
+					pl->RemoveAura(e_spellId);
+				caster->CastSpell(pl, e_spellId, true);
+			}
+		}
+}
+
+void CustomScript::CastSpellToNearbyUnits(Unit* caster, uint32 e_spellId, uint32 f_spellId, float range)
+{
+	std::list<Creature*> creaturesNearby;
+	caster->GetCreatureListInGrid(creaturesNearby, range);
+	if (!creaturesNearby.empty())
+		for (std::list<Creature*>::iterator itr = creaturesNearby.begin(); itr != creaturesNearby.end(); ++itr)
+		{
+			Creature* creature = *itr;
+
+			if (!creature->IsInWorld())
+				continue;
+
+			if (!creature->IsAlive())
+				continue;
+
+			if (creature->isWorldBoss() || creature->IsDungeonBoss())
+				continue;
+
+			if (caster->IsFriendlyTo(creature))
+			{
+				if (creature->HasAura(f_spellId))
+					creature->RemoveAura(f_spellId);
+				caster->CastSpell(creature, f_spellId, true);
+			}
+			else
+			{
+				if (creature->HasAura(e_spellId))
+					creature->RemoveAura(e_spellId);
+				caster->CastSpell(creature, e_spellId, true);
+			}
+		}
+}
+
+class spell_liangqiping : public SpellScriptLoader
+{
+public:
+	spell_liangqiping() : SpellScriptLoader("spell_liangqiping") { }
+
+	class spell_liangqiping_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_liangqiping_SpellScript);
+
+		void Action()
+		{
+			Unit* caster = GetCaster();
+			if (!caster)
+				return;
+			uint32 e_spellId = 0;
+			uint32 f_spellId = 0;
+
+			switch (m_scriptSpellId)
+			{
+			case 117001:
+				e_spellId = 117031;
+				f_spellId = 117021;
+				break;
+			case 117002:
+				e_spellId = 117032;
+				f_spellId = 117022;
+				break;
+			case 117003:
+				e_spellId = 117033;
+				f_spellId = 117023;
+				break;
+			case 117004:
+				e_spellId = 117034;
+				f_spellId = 117024;
+				break;
+			default:
+				break;
+			}
+
+			sCustomScript->CastSpellToNearbyPlayers(caster, e_spellId, f_spellId, 8);
+			sCustomScript->CastSpellToNearbyUnits(caster, e_spellId, f_spellId, 8);
+		}
+
+		void Register()
+		{
+			OnCast += SpellCastFn(spell_liangqiping_SpellScript::Action);
+		}
+	};
+
+	SpellScript* GetSpellScript() const
+	{
+		return new spell_liangqiping_SpellScript();
+	}
+};
+
+class spell_liangyihuan : public SpellScriptLoader
+{
+public:
+	spell_liangyihuan() : SpellScriptLoader("spell_liangyihuan") { }
+
+	class spell_liangyihuan_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_liangyihuan_SpellScript);
+
+		void Action()
+		{
+			Unit* caster = GetCaster();
+			if (!caster)
+				return;
+
+			sCustomScript->CastSpellToNearbyPlayers(caster, 81123, 81124, 8);
+		}
+
+		void Register()
+		{
+			OnCast += SpellCastFn(spell_liangyihuan_SpellScript::Action);
+		}
+	};
+
+	SpellScript* GetSpellScript() const
+	{
+		return new spell_liangyihuan_SpellScript();
+	}
+};
+
+
+class spell_leihuogong : public SpellScriptLoader
+{
+public:
+	spell_leihuogong() : SpellScriptLoader("spell_leihuogong") { }
+
+	class spell_leihuogong_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_leihuogong_SpellScript);
+
+		void HandleScriptEffect(SpellEffIndex /*effIndex*/)
+		{
+			if (Unit* target = GetHitUnit())
+			{
+				float mul = 0;
+
+				switch (m_scriptSpellId)
+				{
+				case 125001:
+					mul = 0.1;
+					break;
+				case 125002:
+					mul = 0.2;
+					break;
+				case 125003:
+					mul = 0.3;
+					break;
+				case 125004:
+					mul = 0.4;
+					break;
+				default:
+					break;
+				}
+
+				int32 dmg = int32(target->GetHealth() * mul);
+
+				if (dmg <= 0)
+					return;
+
+				sCustomScript->Cast(GetCaster(), target, SMT_DIRECT_DMG, dmg);
+			}
+		}
+
+		void Register()
+		{
+			OnEffectHitTarget += SpellEffectFn(spell_leihuogong_SpellScript::HandleScriptEffect, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+		}
+	};
+
+	SpellScript* GetSpellScript() const
+	{
+		return new spell_leihuogong_SpellScript();
+	}
+};
+
+
+class spell_absorb_max_hp_pct_damage : public SpellScriptLoader
+{
+public:
+	spell_absorb_max_hp_pct_damage() : SpellScriptLoader("spell_absorb_max_hp_pct_damage") { }
+
+	class spell_absorb_max_hp_pct_damage_AuraScript : public AuraScript
+	{
+		PrepareAuraScript(spell_absorb_max_hp_pct_damage_AuraScript);
+
+		void CalculateAmount(AuraEffect const* aurEff, int32& amount, bool& canBeRecalculated)
+		{
+			canBeRecalculated = false;
+			if (Unit* caster = GetCaster())
+			{
+				float muil = 0;
+				switch (m_scriptSpellId)
+				{
+				case 89580: muil = 0.05; break;
+				case 89581: muil = 0.10; break;
+				case 89582: muil = 0.15; break;
+				case 89583: muil = 0.20; break;
+				case 89584: muil = 0.25; break;
+				case 89585: muil = 0.30; break;
+				case 89586: muil = 0.35; break;
+				case 89587: muil = 0.40; break;
+				case 89588: muil = 0.45; break;
+				case 89589: muil = 0.50; break;
+				default: break;
+				}
+
+				amount = caster->GetMaxHealth() * muil;
+			}
+				
+		}
+		void Register()
+		{
+			DoEffectCalcAmount += AuraEffectCalcAmountFn(spell_absorb_max_hp_pct_damage_AuraScript::CalculateAmount, EFFECT_0, SPELL_AURA_SCHOOL_ABSORB);
+		}
+	};
+
+	AuraScript* GetAuraScript() const
+	{
+		return new spell_absorb_max_hp_pct_damage_AuraScript();
+	}
+
+};
+
+
+class spell_item_socket : public SpellScriptLoader
+{
+public:
+	spell_item_socket() : SpellScriptLoader("spell_item_socket") { }
+
+	class spell_item_socket_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_item_socket_SpellScript);
+
+		SpellCastResult CheckCast()
+		{
+			Player* owner = GetCaster()->ToPlayer();
+			Item* targetItem = GetExplTargetItem();
+			Item* castItem = GetCastItem();
+
+			if (!owner || !targetItem || !castItem || targetItem->GetGUID() == castItem->GetGUID())
+				return SPELL_FAILED_BAD_TARGETS;
+
+			uint32 count = 0;
+			const ItemTemplate* proto = targetItem->GetTemplate();
+
+			for (size_t i = 0; i < MAX_ITEM_PROTO_SOCKETS; i++)
+				if (proto->Socket[i].Color != 0)
+					count++;
+
+			if (count == MAX_ITEM_PROTO_SOCKETS || targetItem->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT))
+				return SPELL_FAILED_MAX_SOCKETS;
+
+			owner->ApplyEnchantment(targetItem, PRISMATIC_ENCHANTMENT_SLOT, false);
+			targetItem->SetEnchantment(PRISMATIC_ENCHANTMENT_SLOT, 3729, 0, 0, owner->GetGUID());
+			owner->ApplyEnchantment(targetItem, PRISMATIC_ENCHANTMENT_SLOT, true);
+
+			return SPELL_CAST_OK;
+		}
+
+		void Register() override
+		{
+			OnCheckCast += SpellCheckCastFn(spell_item_socket_SpellScript::CheckCast);
+		}
+	};
+
+	SpellScript* GetSpellScript() const override
+	{
+		return new spell_item_socket_SpellScript();
+	}
+};
+/*
+#define PRISMATIC_ENCHANTMENT_1 4555
+#define PRISMATIC_ENCHANTMENT_2 4556
+#define PRISMATIC_ENCHANTMENT_3 4557
+
+class spell_item_socket : public SpellScriptLoader
+{
+public:
+	spell_item_socket() : SpellScriptLoader("spell_item_socket") { }
+
+	class spell_item_socket_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_item_socket_SpellScript);
+
+		SpellCastResult CheckCast()
+		{
+			Player* owner = GetCaster()->ToPlayer();
+			Item* targetItem = GetExplTargetItem();
+			Item* castItem = GetCastItem();
+
+			if (!owner || !targetItem || !castItem || targetItem->GetGUID() == castItem->GetGUID())
+				return SPELL_FAILED_BAD_TARGETS;
+
+			uint32 count = 0;
+			const ItemTemplate* proto = targetItem->GetTemplate();
+
+			for (size_t i = 0; i < MAX_ITEM_PROTO_SOCKETS; i++)
+				if (proto->Socket[i].Color != 0)
+					count++;
+
+			uint32 prismaticCount = 0;
+			uint32 prismatic = targetItem->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT);
+
+			if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(prismatic))
+				for (uint8 s = 0; s < MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+					if (enchantEntry->type[s] == ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET)
+						prismaticCount += enchantEntry->amount[s];
+
+			if (count + prismaticCount >= MAX_ITEM_PROTO_SOCKETS)
+				return SPELL_FAILED_MAX_SOCKETS;
+
+			owner->ApplyEnchantment(targetItem, PRISMATIC_ENCHANTMENT_SLOT, false);
+
+			switch (prismaticCount)
+			{
+			case 0:
+				targetItem->SetEnchantment(PRISMATIC_ENCHANTMENT_SLOT, PRISMATIC_ENCHANTMENT_1, 0, 0, owner->GetGUID());
+				break;
+			case 1:
+				targetItem->SetEnchantment(PRISMATIC_ENCHANTMENT_SLOT, PRISMATIC_ENCHANTMENT_2, 0, 0, owner->GetGUID());
+				break;
+			case 2:
+				targetItem->SetEnchantment(PRISMATIC_ENCHANTMENT_SLOT, PRISMATIC_ENCHANTMENT_3, 0, 0, owner->GetGUID());
+				break;
+			}
+
+			owner->ApplyEnchantment(targetItem, PRISMATIC_ENCHANTMENT_SLOT, true);
+
+			owner->GetSession()->SendAreaTriggerMessage("%s»ñµÃ¶îÍâÒ»¸ö²å²Û", sCF->GetItemLink(targetItem->GetEntry()).c_str());
+			ChatHandler(owner->GetSession()).PSendSysMessage("%s»ñµÃ¶îÍâÒ»¸ö²å²Û", sCF->GetItemLink(targetItem->GetEntry()).c_str());
+
+			return SPELL_CAST_OK;
+		}
+
+		void Register() override
+		{
+			OnCheckCast += SpellCheckCastFn(spell_item_socket_SpellScript::CheckCast);
+		}
+	};
+
+	SpellScript* GetSpellScript() const override
+	{
+		return new spell_item_socket_SpellScript();
+	}
+};
+*/
+void AddSC_SpellScripts()
+{
+	//new spell_dmg_maxhealth_pct();
+	//new spell_dmg_health_pct();
+	//new spell_dmg_los_health_pct();
+	//new spell_heal_maxhealth_pct();
+	//new spell_heal_health_pct();
+	//new spell_heal_los_health_pct();
+	//
+	//new spell_speed_des();
+	//
+	//
+	//new spell_dest_dest();
+	//new zhenfa_leiyun_trigger();
+	//new zhenfa_xuanguang_trigger();
+	//new CircleTrigger();
+	//
+	//new spell_dmg_target();
+	//
+	//new spell_liangqiping();
+	//new spell_liangyihuan();
+	//new spell_leihuogong();
+	//
+	//new spell_absorb_max_hp_pct_damage();
+
+	new spell_item_socket();
+}
+
+
+
+
diff --git a/src/server/scripts/Custom/Scripts/VMProtectSDK.h b/src/server/scripts/Custom/Scripts/VMProtectSDK.h
new file mode 100644
index 0000000..3368dda
--- /dev/null
+++ b/src/server/scripts/Custom/Scripts/VMProtectSDK.h
@@ -0,0 +1,102 @@
+#pragma once
+
+#if defined(__APPLE__) || defined(__unix__)
+#define VMP_IMPORT 
+#define VMP_API
+#define VMP_WCHAR unsigned short
+#else
+#define VMP_IMPORT __declspec(dllimport)
+#define VMP_API __stdcall
+#define VMP_WCHAR wchar_t
+#ifdef _WIN64
+	#pragma comment(lib, "VMProtectSDK64.lib")
+#else
+	#pragma comment(lib, "VMProtectSDK32.lib")
+#endif // _WIN64
+#endif // __APPLE__ || __unix__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// protection
+VMP_IMPORT void VMP_API VMProtectBegin(const char *);
+VMP_IMPORT void VMP_API VMProtectBeginVirtualization(const char *);
+VMP_IMPORT void VMP_API VMProtectBeginMutation(const char *);
+VMP_IMPORT void VMP_API VMProtectBeginUltra(const char *);
+VMP_IMPORT void VMP_API VMProtectBeginVirtualizationLockByKey(const char *);
+VMP_IMPORT void VMP_API VMProtectBeginUltraLockByKey(const char *);
+VMP_IMPORT void VMP_API VMProtectEnd(void);
+
+// utils
+VMP_IMPORT bool VMP_API VMProtectIsProtected();
+VMP_IMPORT bool VMP_API VMProtectIsDebuggerPresent(bool);
+VMP_IMPORT bool VMP_API VMProtectIsVirtualMachinePresent(void);
+VMP_IMPORT bool VMP_API VMProtectIsValidImageCRC(void);
+VMP_IMPORT const char * VMP_API VMProtectDecryptStringA(const char *value);
+VMP_IMPORT const VMP_WCHAR * VMP_API VMProtectDecryptStringW(const VMP_WCHAR *value);
+VMP_IMPORT bool VMP_API VMProtectFreeString(const void *value);
+
+// licensing
+enum VMProtectSerialStateFlags
+{
+	SERIAL_STATE_SUCCESS				= 0,
+	SERIAL_STATE_FLAG_CORRUPTED			= 0x00000001,
+	SERIAL_STATE_FLAG_INVALID			= 0x00000002,
+	SERIAL_STATE_FLAG_BLACKLISTED		= 0x00000004,
+	SERIAL_STATE_FLAG_DATE_EXPIRED		= 0x00000008,
+	SERIAL_STATE_FLAG_RUNNING_TIME_OVER	= 0x00000010,
+	SERIAL_STATE_FLAG_BAD_HWID			= 0x00000020,
+	SERIAL_STATE_FLAG_MAX_BUILD_EXPIRED	= 0x00000040,
+};
+
+#pragma pack(push, 1)
+typedef struct
+{
+	unsigned short	wYear;
+	unsigned char	bMonth;
+	unsigned char	bDay;
+} VMProtectDate;
+
+typedef struct
+{
+	int				nState;				// VMProtectSerialStateFlags
+	VMP_WCHAR		wUserName[256];		// user name
+	VMP_WCHAR		wEMail[256];		// email
+	VMProtectDate	dtExpire;			// date of serial number expiration
+	VMProtectDate	dtMaxBuild;			// max date of build, that will accept this key
+	int				bRunningTime;		// running time in minutes
+	unsigned char	nUserDataLength;	// length of user data in bUserData
+	unsigned char	bUserData[255];		// up to 255 bytes of user data
+} VMProtectSerialNumberData;
+#pragma pack(pop)
+
+VMP_IMPORT int VMP_API VMProtectSetSerialNumber(const char *serial);
+VMP_IMPORT int VMP_API VMProtectGetSerialNumberState();
+VMP_IMPORT bool VMP_API VMProtectGetSerialNumberData(VMProtectSerialNumberData *data, int size);
+VMP_IMPORT int VMP_API VMProtectGetCurrentHWID(char *hwid, int size);
+
+// activation
+enum VMProtectActivationFlags
+{
+	ACTIVATION_OK = 0,
+	ACTIVATION_SMALL_BUFFER,
+	ACTIVATION_NO_CONNECTION,
+	ACTIVATION_BAD_REPLY,
+	ACTIVATION_BANNED,
+	ACTIVATION_CORRUPTED,
+	ACTIVATION_BAD_CODE,
+	ACTIVATION_ALREADY_USED,
+	ACTIVATION_SERIAL_UNKNOWN,
+	ACTIVATION_EXPIRED,
+	ACTIVATION_NOT_AVAILABLE
+};
+
+VMP_IMPORT int VMP_API VMProtectActivateLicense(const char *code, char *serial, int size);
+VMP_IMPORT int VMP_API VMProtectDeactivateLicense(const char *serial);
+VMP_IMPORT int VMP_API VMProtectGetOfflineActivationString(const char *code, char *buf, int size);
+VMP_IMPORT int VMP_API VMProtectGetOfflineDeactivationString(const char *serial, char *buf, int size);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/src/server/scripts/Custom/SellReward/SellReward.cpp b/src/server/scripts/Custom/SellReward/SellReward.cpp
new file mode 100644
index 0000000..9a56476
--- /dev/null
+++ b/src/server/scripts/Custom/SellReward/SellReward.cpp
@@ -0,0 +1,70 @@
+#pragma execution_character_set("utf-8")
+#include "SellReward.h"
+#include "../Custom/Reward/Reward.h"
+#include "../ItemMod/ItemMod.h"
+#include "../Requirement/Requirement.h"
+#include "../Command/CustomCommand.h"
+#include "../ItemMod/NoPatchItem.h"
+
+//ÊÛÂôÎïÆ·Ê±¸øÓèËæ»ú½±Àø
+void SellReward::Reward(Player* player, Item* pItem)
+{
+	uint32 rewId = sNoPatchItem->GetSellRewId(pItem);
+
+	if (rewId != 0)
+	{
+		sRew->Rew(player, rewId, pItem->GetCount());
+		return;
+	}
+	
+	uint32 chance = 0;
+	std::string command = "";
+
+	sItemMod->GetSaleInfo(pItem->GetEntry(), rewId, chance, command);
+
+	if (urand(1, 100) <= chance)
+		sRew->Rew(player, rewId, pItem->GetCount());
+
+	sCustomCommand->DoCommand(player, command);
+}
+//¿É»ñµÃËæ»úÊÛÂô½±ÀøµÄÎïÆ·²»ÄÜÍË»¹
+bool SellReward::CanRefund(Player* player, Item* pItem)
+{
+	if (sNoPatchItem->GetSellRewId(pItem) != 0)
+	{
+		player->GetSession()->SendNotification("¿É»ñµÃËæ»úÊÛÂô½±ÀøµÄÎïÆ·²»ÄÜÍË»¹£¡");
+		return false;
+	}
+
+	uint32 len = ItemSaleVec.size();
+
+	for (uint32 i = 0; i < len; i++)
+	{
+		if (ItemSaleVec[i].entry == pItem->GetEntry())
+		{
+			player->GetSession()->SendNotification("¿É»ñµÃËæ»úÊÛÂô½±ÀøµÄÎïÆ·²»ÄÜÍË»¹£¡");
+			return false;
+		}
+	}
+	return true;
+}
+
+//ÎïÆ·Ôö¼ÓÃèÊö
+std::string SellReward::GetSellDes(uint32 entry)
+{
+	uint32 rewId = 0;
+	uint32 chance = 0;
+	std::string command = "";
+
+	sItemMod->GetSaleInfo(entry, rewId, chance, command);
+
+	if (rewId == 0)
+		return "";
+
+	std::ostringstream oss;
+	oss << "|cFF00FF00¡¸ÊÛÂô |cFFFFCC00";
+	oss << chance;
+	oss << "%|r |cFF00FF00¼¸ÂÊ»ñµÃ¡¹|r\n";
+	oss << sRew->GetDescription(rewId);
+	return oss.str();
+}
diff --git a/src/server/scripts/Custom/SellReward/SellReward.h b/src/server/scripts/Custom/SellReward/SellReward.h
new file mode 100644
index 0000000..894fa76
--- /dev/null
+++ b/src/server/scripts/Custom/SellReward/SellReward.h
@@ -0,0 +1,16 @@
+class SellReward
+{
+public:
+	static SellReward* instance()
+	{
+		static SellReward instance;
+		return &instance;
+	}
+	void Load();
+	void Reward(Player* player, Item* pItem);
+	bool CanRefund(Player* player, Item* pItem);
+	std::string GetSellDes(uint32 entry);
+private:
+
+};
+#define sSellReward SellReward::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/ServerAnnounce/ServerAnnounce.cpp b/src/server/scripts/Custom/ServerAnnounce/ServerAnnounce.cpp
new file mode 100644
index 0000000..ec7ab5b
--- /dev/null
+++ b/src/server/scripts/Custom/ServerAnnounce/ServerAnnounce.cpp
@@ -0,0 +1,153 @@
+#pragma execution_character_set("utf-8")
+#include "../CommonFunc/CommonFunc.h"
+#include "ServerAnnounce.h"
+#include "../String/myString.h"
+#include "../Switch/Switch.h"
+
+std::vector<ServerAnnounceTemplate> ServerAnnounceVec;
+
+void ServerAnnounce::Load()
+{
+	ServerAnnounceVec.clear();
+
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÎïÆ·»òÎïÌåID,¶¯×÷ÀàÐÍ,ÌáÊ¾Î»ÖÃ,ÌáÊ¾ÎÄ±¾ FROM __È«·þÌáÊ¾" :
+		"SELECT entry,flag,announceType,text FROM _server_announce");
+	if (!result)
+		return;
+	do
+	{
+		Field* fields = result->Fetch();
+		ServerAnnounceTemplate Temp;
+		Temp.entry			= fields[0].GetUInt32();
+		Temp.flag			= fields[1].GetUInt8();
+		Temp.announceType	= fields[2].GetUInt8();
+		Temp.text			= fields[3].GetString();		
+		ServerAnnounceVec.push_back(Temp);
+	} while (result->NextRow());
+}
+
+const char* ServerAnnounce::Format(const char *format, ...)
+{
+	va_list ap;
+	char str[2048];
+	va_start(ap, format);
+	vsnprintf(str, 2048, format, ap);
+	va_end(ap);
+	const char* c_str = str;
+	return c_str;
+}
+
+std::string ServerAnnounce::GetNameLink(Player* player)
+{
+	return sCF->GetPlayerTotalName(player, sSwitch->GetFlag(ST_SEVER_ANNOUNCE));
+}
+
+std::string ServerAnnounce::GetItemLink(uint32 entry)
+{
+	const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+	if (!temp) return "";
+
+	std::string name = temp->Name1;
+
+	std::ostringstream oss;
+	oss << "|c" << std::hex << ItemQualityColors[temp->Quality] << std::dec <<
+		"|Hitem:" << entry << ":0:0:0:0:0:0:0:0:0|h[" << name << "]|h|r";
+
+	return oss.str();
+
+}
+
+void ServerAnnounce::Announce(Player* announcer, uint32 entry, uint8 flag)
+{
+	uint32 len = ServerAnnounceVec.size();
+
+	for (size_t i = 0; i < len; i++)
+		if (entry == ServerAnnounceVec[i].entry && flag == ServerAnnounceVec[i].flag)
+		{
+			uint8 announceType = ServerAnnounceVec[i].announceType;
+			std::string name; 
+
+			//0 ´ò¿ªgameobject 1 ´ò¿ªÎïÆ· 2»ñµÃÎïÆ· 3ÉúÎïË¢ÐÂ
+			switch (flag)
+			{
+			case 0:
+				name = sObjectMgr->GetGameObjectTemplate(entry)->name;
+				break;
+			case 1:
+			case 2:
+				name = GetItemLink(entry);
+				break;
+			default:
+				break;
+			}
+
+			//0 ×óÏÂ½ÇÌáÊ¾ 1 ×óÏÂºÍÖÐ¼ä
+			switch (announceType)
+			{
+			case 0:
+				sWorld->SendServerMessage(SERVER_MSG_STRING, Format(ServerAnnounceVec[i].text.c_str(), GetNameLink(announcer).c_str(), name.c_str()));
+				break;
+			case 1:
+				sWorld->SendScreenMessage(Format(ServerAnnounceVec[i].text.c_str(), GetNameLink(announcer).c_str(), name.c_str()));
+				break;
+			}
+		}
+}
+
+
+void ServerAnnounce::CreatureRespawn(Creature* creature)
+{
+	if (!creature)
+		return;
+
+	uint32 len = ServerAnnounceVec.size();
+
+	for (size_t i = 0; i < len; i++)
+	{
+		if (creature->GetEntry() == ServerAnnounceVec[i].entry && 3 == ServerAnnounceVec[i].flag)
+		{
+			std::ostringstream oss;
+
+			if (AreaTableEntry const* area = GetAreaEntryByAreaID(creature->GetAreaId()))
+				oss << "[" << area->area_name[4] << "]";
+
+			oss << "[" << creature->GetCreatureTemplate()->Name << "]";
+			oss << ServerAnnounceVec[i].text;
+
+			switch (ServerAnnounceVec[i].announceType)
+			{
+			case 0:
+				sWorld->SendGlobalText(oss.str().c_str(), NULL);
+				break;
+			case 1:
+			{
+				SessionMap const& smap = sWorld->GetAllSessions();
+				for (SessionMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+					if (Player* player = iter->second->GetPlayer())
+						if (player->GetSession())
+						{
+							if (player->IsSpectator() || !player->IsInWorld())
+								continue;
+							player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+						}
+			}
+			break;
+			case 3:
+			{
+				sWorld->SendGlobalText(oss.str().c_str(), NULL);
+				SessionMap const& smap = sWorld->GetAllSessions();
+				for (SessionMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
+					if (Player* player = iter->second->GetPlayer())
+						if (player->GetSession())
+						{
+							if (player->IsSpectator() || !player->IsInWorld())
+								continue;
+							player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+						}
+			}
+			break;
+			}
+		}
+	}	
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/ServerAnnounce/ServerAnnounce.h b/src/server/scripts/Custom/ServerAnnounce/ServerAnnounce.h
new file mode 100644
index 0000000..98cb6ef
--- /dev/null
+++ b/src/server/scripts/Custom/ServerAnnounce/ServerAnnounce.h
@@ -0,0 +1,25 @@
+struct ServerAnnounceTemplate
+{
+	uint32 entry;
+	uint8 flag;
+	uint8 announceType;
+	std::string text;
+};
+extern std::vector<ServerAnnounceTemplate> ServerAnnounceVec;
+
+class ServerAnnounce
+{
+public:
+	static ServerAnnounce* instance()
+	{
+		static ServerAnnounce instance;
+		return &instance;
+	}
+	void Load();
+	const char* Format(const char *format, ...);
+	std::string GetItemLink(uint32 entry);
+	std::string GetNameLink(Player* player);
+	void Announce(Player* announcer,uint32 entry, uint8 flag);
+	void CreatureRespawn(Creature* creature);
+};
+#define sServerAnnounce ServerAnnounce::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/SignIn/SignIn.cpp b/src/server/scripts/Custom/SignIn/SignIn.cpp
new file mode 100644
index 0000000..5159d38
--- /dev/null
+++ b/src/server/scripts/Custom/SignIn/SignIn.cpp
@@ -0,0 +1,171 @@
+#pragma execution_character_set("utf-8")
+#include "SignIn.h"
+#include "../Reward/Reward.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../GCAddon/GCAddon.h"
+
+std::unordered_map<uint32, uint32> SignInMap;
+
+void SignIn::Load()
+{
+	SignInMap.clear();
+	//QueryResult result = WorldDatabase.PQuery("SELECT day,rewId from _signin");
+	//if (!result)
+	//	return;
+	//do
+	//{
+	//	Field* fields = result->Fetch();
+	//	uint32 day		= fields[0].GetUInt32();
+	//	uint32 rewId	= fields[1].GetUInt32();
+	//	SignInMap.insert(std::make_pair(day, rewId));
+	//} while (result->NextRow());
+}
+
+uint32 SignIn::GetRewId(uint32 day)
+{
+	std::unordered_map<uint32, uint32>::iterator iter = SignInMap.find(day);
+
+	if (iter != SignInMap.end())
+		return iter->second;
+
+	uint32 maxday = 0;
+
+	for (std::unordered_map<uint32, uint32>::iterator iter = SignInMap.begin(); iter != SignInMap.end(); iter++)
+		if (maxday < iter->first)
+			maxday = iter->first;
+
+	iter = SignInMap.find(maxday);
+
+	if (iter != SignInMap.end())
+		return iter->second;
+
+	return 0;
+}
+
+void SignIn::GetInfo(Player* player, time_t &signinTime, uint32 &signinDays)
+{
+	QueryResult result = CharacterDatabase.PQuery("SELECT signin_time,signin_days FROM characters WHERE guid = '%u'", player->GetGUIDLow());
+	if (!result)
+		return;
+
+	Field* fields = result->Fetch();
+
+	signinTime = time_t(fields[0].GetUInt32());
+	signinDays = fields[1].GetUInt32();
+}
+
+bool SignIn::CanSignIn(Player* player)
+{
+	return GetDiffDay(time(NULL), player->signinTime) != 0;
+}
+
+void SignIn::SendPacket(Player* player)
+{
+	std::string lastSignIn = "---";
+	if (player->signinTime != 0)
+		lastSignIn = sSignIn->GetTimeString(player->signinTime);
+
+	if (sSignIn->GetDiffDay(player->signinTime, time(NULL)) > 1)
+		player->signinDays = 0;
+
+	uint32 canSignIn = CanSignIn(player) ? 1 : 0;
+
+	std::ostringstream oss;
+	oss << "GC_SMSG_OPC_SIGN_IN@" << lastSignIn << "#" << sSignIn->GetTimeString(time(NULL)) << "#" << player->signinDays << "#" << canSignIn << "#" << sGCAddon->GetRewString(player, GetRewId(player->signinDays + 1));;
+
+	//sGCAddon->SendPacket(player, oss.str());
+}
+
+void SignIn::DoAction(Player* player)
+{
+	if (!CanSignIn(player))
+		return;
+
+	//Ç©µ½¼ä¸ô´óÓÚ1Ê±
+	if (GetDiffDay(player->signinTime, time(NULL)) > 1)
+		player->signinDays = 0;
+
+	player->signinTime = time(NULL);
+	player->signinDays++;
+
+	sRew->Rew(player, GetRewId(player->signinDays));
+
+	SQLTransaction trans = CharacterDatabase.BeginTransaction();
+	PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_SIGN_IN);
+	stmt->setUInt32(0, player->signinTime);
+	stmt->setUInt32(1, player->signinDays);
+	stmt->setUInt32(2, player->GetGUIDLow());
+	trans->Append(stmt);
+	CharacterDatabase.CommitTransaction(trans);
+}
+
+void SignIn::OpenPanel(Player* player)
+{
+	SendPacket(player);
+	player->CLOSE_GOSSIP_MENU();
+}
+
+uint32 SignIn::GetDiffDay(time_t  time1, time_t  time2)
+{
+	uint32 nDaySec = 3600 * 24;
+	//uint32 nDaySec = 60;
+
+	int32 day1 = time1 / nDaySec;
+	int32 day2 = time2 / nDaySec;
+
+	return abs(day2 - day1);
+}
+
+std::string SignIn::GetTimeString(time_t time)
+{
+	tm localTime;
+	localtime_r(&time, &localTime);
+
+	int year = localTime.tm_year % 100;
+	int month = localTime.tm_mon + 1;
+	int day = localTime.tm_mday;
+	int hour = localTime.tm_hour;
+	int min = localTime.tm_min;
+	int sec = localTime.tm_sec;
+
+	std::ostringstream oss;
+
+	oss << "20" << year << "-";
+	
+	if (month < 10)
+		oss << "0" << month << "-";
+	else
+		oss << month << "-";
+
+	if (day < 10)
+		oss << "0" << day;
+	else
+		oss << day;
+
+	return oss.str();
+}
+
+class SignInPlayerScript : PlayerScript
+{
+public:
+	SignInPlayerScript() : PlayerScript("SignInPlayerScript") {}
+	void OnLogin(Player* player) override
+	{
+		time_t signinTime = 0;
+		uint32 signinDays = 0;
+
+		sSignIn->GetInfo(player, signinTime, signinDays);
+
+		//Î´Á¬ÐøÇ©µ½
+		if (sSignIn->GetDiffDay(signinTime, time(NULL)) > 1)
+			signinDays = 0;
+
+		player->signinTime = signinTime;
+		player->signinDays = signinDays;
+	}
+};
+
+void AddSC_SignIn()
+{
+	//new SignInPlayerScript();
+}
diff --git a/src/server/scripts/Custom/SignIn/SignIn.h b/src/server/scripts/Custom/SignIn/SignIn.h
new file mode 100644
index 0000000..6be0fd3
--- /dev/null
+++ b/src/server/scripts/Custom/SignIn/SignIn.h
@@ -0,0 +1,24 @@
+extern std::unordered_map<uint32, uint32> SignInMap;
+
+
+class SignIn
+{
+public:
+	static SignIn* instance()
+	{
+		static SignIn instance;
+		return &instance;
+	}
+	void Load();
+	uint32 GetRewId(uint32 day);
+	void GetInfo(Player* player, time_t &signinTime, uint32 &signinDays);
+	bool CanSignIn(Player* player);
+	void DoAction(Player* player);
+	uint32 GetDiffDay(time_t  time1, time_t  time2);
+	std::string GetTimeString(time_t time);
+	void SendPacket(Player* player);
+	void OpenPanel(Player* player);
+private:
+
+};
+#define sSignIn SignIn::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Skill/Skill.cpp b/src/server/scripts/Custom/Skill/Skill.cpp
new file mode 100644
index 0000000..819c524
--- /dev/null
+++ b/src/server/scripts/Custom/Skill/Skill.cpp
@@ -0,0 +1,268 @@
+#pragma execution_character_set("utf-8")
+#include "Skill.h"
+#include "../Reward/Reward.h"
+#include "../Requirement/Requirement.h"
+#include "../FunctionCollection/FunctionCollection.h"
+#include "../CommonFunc/CommonFunc.h"
+
+std::vector<CustomSkillTemplate> CustomSkillVec;
+std::vector<CustomSkillCategoryTemplate> CustomSkillCategoryVec;
+
+bool CategorySort(CustomSkillCategoryTemplate a, CustomSkillCategoryTemplate b) { return (a.categoryId < b.categoryId); }
+bool SkillSort(CustomSkillTemplate a, CustomSkillTemplate b) { return (a.skillId < b.skillId); }
+
+void CustomSkill::Load()
+{
+	CustomSkillCategoryVec.clear();
+	//QueryResult result1 = WorldDatabase.PQuery("SELECT categoryId,categoryName,categoryIcon FROM _skill_category");
+	//if (!result1)
+	//	return;
+	//do
+	//{
+	//	Field* fields = result1->Fetch();
+	//	CustomSkillCategoryTemplate Temp;
+	//	Temp.categoryId		= fields[0].GetUInt32();
+	//	Temp.categoryName	= fields[1].GetString();
+	//	Temp.icategoryIcon	= fields[2].GetString();
+	//	CustomSkillCategoryVec.push_back(Temp);
+	//} while (result1->NextRow());
+
+	CustomSkillVec.clear();
+	//QueryResult result = WorldDatabase.PQuery("SELECT skillId,skillName,categoryId,reqId,rewId,skillIcon FROM _skill");
+	//if (!result)
+	//	return;
+	//do
+	//{
+	//	Field* fields = result->Fetch();
+	//	CustomSkillTemplate Temp;
+	//	Temp.skillId	= fields[0].GetUInt32();
+	//	Temp.skillName	= fields[1].GetString();
+	//	Temp.categoryId = fields[2].GetUInt32();
+	//	Temp.reqId		= fields[3].GetUInt32();
+	//	Temp.rewId		= fields[4].GetUInt32();
+	//	Temp.skillIcon	= fields[5].GetString();
+	//	CustomSkillVec.push_back(Temp);
+	//} while (result->NextRow());
+	//
+	//sort(CustomSkillCategoryVec.begin(), CustomSkillCategoryVec.end(), CategorySort);//ÉýÐòÅÅÁÐ
+	//sort(CustomSkillVec.begin(), CustomSkillVec.end(), SkillSort);//ÉýÐòÅÅÁÐ
+}
+
+std::string CustomSkill::GetSkillName(uint32 skillId)
+{
+	for (std::vector<CustomSkillTemplate>::iterator itr = CustomSkillVec.begin(); itr != CustomSkillVec.end(); itr++)
+		if (skillId == itr->skillId)
+			return itr->skillName;
+
+	return "";
+}
+
+uint32 CustomSkill::GetReqId(uint32 skillId)
+{
+	for (std::vector<CustomSkillTemplate>::iterator itr = CustomSkillVec.begin(); itr != CustomSkillVec.end(); itr++)
+		if (skillId == itr->skillId)
+			return itr->reqId;
+
+	return 0;
+}
+
+uint32 CustomSkill::GetRewId(uint32 skillId)
+{
+	for (std::vector<CustomSkillTemplate>::iterator itr = CustomSkillVec.begin(); itr != CustomSkillVec.end(); itr++)
+		if (skillId == itr->skillId)
+			return itr->rewId;
+
+	return 0;
+}
+
+std::string CustomSkill::GetSkillIcon(uint32 skillId)
+{
+	for (std::vector<CustomSkillTemplate>::iterator itr = CustomSkillVec.begin(); itr != CustomSkillVec.end(); itr++)
+		if (skillId == itr->skillId)
+			return itr->skillIcon;
+
+	return "";
+}
+
+std::string CustomSkill::GetCategoryName(uint32 skillId)
+{
+	for (std::vector<CustomSkillTemplate>::iterator itr = CustomSkillVec.begin(); itr != CustomSkillVec.end(); itr++)
+		if (skillId == itr->skillId)
+		{
+			for (std::vector<CustomSkillCategoryTemplate>::iterator i = CustomSkillCategoryVec.begin(); i != CustomSkillCategoryVec.end(); i++)
+				if (i->categoryId == itr->categoryId)
+					return i->categoryName;
+		}
+
+	return "";
+}
+
+uint32 CustomSkill::GetCategoryId(uint32 skillId)
+{
+	for (std::vector<CustomSkillTemplate>::iterator itr = CustomSkillVec.begin(); itr != CustomSkillVec.end(); itr++)
+		if (skillId == itr->skillId)
+		{
+			for (std::vector<CustomSkillCategoryTemplate>::iterator i = CustomSkillCategoryVec.begin(); i != CustomSkillCategoryVec.end(); i++)
+				if (i->categoryId == itr->categoryId)
+					return i->categoryId;
+		}
+
+	return 0;
+}
+
+void CustomSkill::LearnSkill(Player* player, uint32 skillId, bool learn)
+{
+	if (!learn)
+	{
+		std::vector<uint32>::iterator it;
+
+		for (it = player->PCustomSkillVec.begin(); it != player->PCustomSkillVec.end();)
+		{
+			if (*it == skillId)
+				it = player->PCustomSkillVec.erase(it);
+		    else
+		       ++it;
+		}
+
+		ChatHandler(player->GetSession()).PSendSysMessage("Íü¼Ç%s", GetSkillName(skillId).c_str());
+		CharacterDatabase.PQuery("DELETE FROM character_custom_skill WHERE guid = %u AND skill = %u", player->GetGUIDLow(), skillId);
+	}
+	else
+	{
+		if (std::find(player->PCustomSkillVec.begin(), player->PCustomSkillVec.end(), skillId) != player->PCustomSkillVec.end())
+		{
+			ChatHandler(player->GetSession()).PSendSysMessage("ÄãÒÑ¾­Ñ§»á%s", GetSkillName(skillId).c_str());
+			return;
+		}
+
+		for (std::vector<CustomSkillTemplate>::iterator itr = CustomSkillVec.begin(); itr != CustomSkillVec.end(); itr++)
+			if (skillId == itr->skillId)
+			{
+				PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CUSTOM_SKILL);
+				stmt->setUInt32(0, player->GetGUIDLow());
+				stmt->setUInt32(1, skillId);
+				CharacterDatabase.Execute(stmt);
+
+				player->PCustomSkillVec.push_back(skillId);
+				ChatHandler(player->GetSession()).PSendSysMessage("Ñ§»á%s", GetSkillName(skillId).c_str());
+				return;
+			}
+
+		ChatHandler(player->GetSession()).PSendSysMessage("Id%u²»´æÔÚ", skillId);
+	}
+}
+
+void CustomSkill::CharLoadSkill(Player* player)
+{
+	player->PCustomSkillVec.clear();
+
+	QueryResult result = CharacterDatabase.PQuery("SELECT skill FROM character_custom_skill WHERE guid = '%u'", player->GetGUIDLow());
+	if (!result)
+		return;
+	do
+	{
+		Field* fields = result->Fetch();
+		uint32 skillId = fields[0].GetUInt32();
+		
+		for (std::vector<CustomSkillTemplate>::iterator itr = CustomSkillVec.begin(); itr != CustomSkillVec.end(); itr++)
+			if (skillId == itr->skillId)
+				player->PCustomSkillVec.push_back(skillId);
+
+	} while (result->NextRow());
+}
+
+void CustomSkill::AddGossip(Player* player, Object* obj)
+{
+	for (std::vector<CustomSkillCategoryTemplate>::iterator i = CustomSkillCategoryVec.begin(); i != CustomSkillCategoryVec.end(); i++)
+	{
+		std::string categoryName = "|TInterface/ICONS/" + i->icategoryIcon + ":28:28:0:0|t" + i->categoryName;
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, categoryName.c_str(), SENDER_CUSTOM_SKILL, sCF->joinXY(250, i->categoryId));
+	}
+		
+
+	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+}
+
+void CustomSkill::Action(Player* player, uint32 action, Object* obj)
+{
+	//Ìí¼ÓÀà±ðÏÂµÄskill²Ëµ¥
+	if (sCF->getX(action) == 250)
+	{
+		
+		uint32 categoryId = sCF->getY(action);
+		bool flag = false;
+		for (std::vector<CustomSkillTemplate>::iterator itr = CustomSkillVec.begin(); itr != CustomSkillVec.end(); itr++)
+		{
+			uint32 skillId = itr->skillId;
+
+			if (categoryId == itr->categoryId && std::find(player->PCustomSkillVec.begin(), player->PCustomSkillVec.end(), skillId) != player->PCustomSkillVec.end())
+			{
+				std::string gossipText = "|TInterface/ICONS/" + sCustomSkill->GetSkillIcon(skillId) + ":25:25:0:0|t" + sCustomSkill->GetSkillName(skillId);
+
+				uint32 reqId = sCustomSkill->GetReqId(skillId);
+				std::string generalText = "|cFFFFCC00" + sCustomSkill->GetCategoryName(skillId) + "|r\n\n";
+				std::string text = "|TInterface/ICONS/" + sCustomSkill->GetSkillIcon(skillId) + ":20:20:0:-17|t|cFFFFCC00" + sCustomSkill->GetSkillName(skillId) + "|r\n";
+				
+				
+				std::ostringstream oss;
+				oss << sReq->Notice(player, reqId, generalText, text);
+
+				player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, gossipText.c_str(), SENDER_CUSTOM_SKILL, sCF->joinXY(250 + 1, skillId), oss.str().c_str(), sReq->Golds(reqId), 0);
+				flag = true;
+			}
+		}
+		if (flag)
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "\n                 <<·µ»Ø>>\n  ", SENDER_CUSTOM_SKILL, sCF->joinXY(250 + 2, 1));
+		else
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "\n             <<Î´¿ªÆôÏà¹ØÄÚÈÝ>>\n  ", SENDER_CUSTOM_SKILL, sCF->joinXY(250 + 2, 1));
+
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+	}
+
+	//µã»÷²Ëµ¥¶¯×÷
+	if (sCF->getX(action) == 250 + 1)
+	{
+		uint32 skillId = sCF->getY(action);
+		uint32 reqId = sCustomSkill->GetReqId(skillId);
+		uint32 rewId = sCustomSkill->GetRewId(skillId);
+
+		if (sReq->Check(player, reqId))
+		{
+			player->CastSpell(player, 61456, true, NULL, NULL, player->GetGUID());
+			sReq->Des(player, reqId);
+			sRew->Rew(player, rewId);
+		}
+
+		//player->CLOSE_GOSSIP_MENU();
+
+		AddGossip(player, obj);
+	}
+
+	//·µ»ØÖ÷²Ëµ¥
+	if (sCF->getX(action) == 250 + 2)
+	{
+		for (std::vector<CustomSkillCategoryTemplate>::iterator i = CustomSkillCategoryVec.begin(); i != CustomSkillCategoryVec.end(); i++)
+		{
+			std::string categoryName = "|TInterface/ICONS/" + i->icategoryIcon + ":28:28:0:0|t" + i->categoryName;
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, categoryName.c_str(), SENDER_CUSTOM_SKILL, sCF->joinXY(250, i->categoryId));
+		}
+
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+	}
+}
+
+class custom_skill_char : public PlayerScript
+{
+public:
+	custom_skill_char() : PlayerScript("custom_skill_char") {}
+
+	void OnLogin(Player* player) override
+	{
+		sCustomSkill->CharLoadSkill(player);
+	}
+};
+
+void AddSC_CUSTOM_SKILL()
+{
+	new custom_skill_char();
+}
diff --git a/src/server/scripts/Custom/Skill/Skill.h b/src/server/scripts/Custom/Skill/Skill.h
new file mode 100644
index 0000000..c7e8563
--- /dev/null
+++ b/src/server/scripts/Custom/Skill/Skill.h
@@ -0,0 +1,50 @@
+struct CustomSkillTemplate
+{
+	uint32 skillId;
+	std::string skillName;
+	uint32 categoryId;
+	uint32 reqId;
+	uint32 rewId;
+	std::string skillIcon;
+};
+
+extern std::vector<CustomSkillTemplate> CustomSkillVec;
+
+struct CustomSkillCategoryTemplate
+{
+	uint32 categoryId;
+	std::string categoryName;
+	std::string icategoryIcon;
+};
+
+extern std::vector<CustomSkillCategoryTemplate> CustomSkillCategoryVec;
+
+class CustomSkill
+{
+public:
+	static CustomSkill* instance()
+	{
+		static CustomSkill instance;
+		return &instance;
+	}
+
+	void Load();
+	void LearnSkill(Player* player, uint32 skillId, bool learn = true);
+
+	std::string GetSkillName(uint32 skillId);
+
+	uint32 GetReqId(uint32 skillId);
+	uint32 GetRewId(uint32 skillId);
+	uint32 GetCategoryId(uint32 skillId);
+	std::string GetCategoryName(uint32 skillId);
+	std::string GetSkillIcon(uint32 skillId);
+
+	void CharLoadSkill(Player* player);
+
+	void AddGossip(Player* player, Object* obj);
+	void Action(Player* player, uint32 action, Object* obj);
+
+private:
+
+};
+#define sCustomSkill CustomSkill::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/SoulStone/SoulStone.cpp b/src/server/scripts/Custom/SoulStone/SoulStone.cpp
new file mode 100644
index 0000000..4c9113c
--- /dev/null
+++ b/src/server/scripts/Custom/SoulStone/SoulStone.cpp
@@ -0,0 +1,1672 @@
+
+#include "SoulStone.h"
+#include "Object.h"
+#include "../GCAddon/GCAddon.h"
+#include "../CommonFunc/CommonFunc.h"
+
+
+#pragma execution_character_set("UTF-8")
+
+
+void SoulStone::Load()
+{
+    _SoulStonePlayerDataMap.clear();
+
+    QueryResult result = WorldDatabase.PQuery("SELECT Íæ¼ÒGUID,Ò³Ãæ,²å²Û1ÎïÆ·ID,²å²Û2ÎïÆ·ID,²å²Û3ÎïÆ·ID,²å²Û4ÎïÆ·ID,²å²Û5ÎïÆ·ID,²å²Û6ÎïÆ·ID,ÊÇ·ñ¼¤»îÒ³ÃæÊôÐÔ FROM Íæ¼Ò»êÓñ¼ÇÂ¼±í");
+
+    if (result)
+    {
+        uint32 count = 0;
+        do
+        {
+            Field * fields = result->Fetch();
+
+            SoulStonePlayerData td;
+
+            td.guid = fields[0].GetUInt32();
+            td.page = fields[1].GetUInt32();
+            td.itemid1 = fields[2].GetUInt32();
+            td.itemid2 = fields[3].GetUInt32();
+            td.itemid3 = fields[4].GetUInt32();
+            td.itemid4 = fields[5].GetUInt32();
+            td.itemid5 = fields[6].GetUInt32();
+            td.itemid6 = fields[7].GetUInt32();
+            td.itemid7 = fields[8].GetUInt32();
+
+            _SoulStonePlayerDataMap.insert({td.guid,td});
+            ++count;
+
+        } while (result->NextRow());
+        sLog->outString("======¼ÓÔØÍæ¼Ò»êÓñ¼ÇÂ¼±í %u ÌõÊý¾Ý======", count);
+    }
+
+    _SoulStoneBuyReqDataMap.clear();
+
+    QueryResult results = WorldDatabase.PQuery("SELECT Ò³Ãæ,ÐèÇóÎïÆ·1,ÊýÁ¿1,ÐèÇóÎïÆ·2,ÊýÁ¿2,ÐèÇóÎïÆ·3,ÊýÁ¿3,ÐèÇóÎïÆ·4,ÊýÁ¿4,ÐèÇóÎïÆ·5,ÊýÁ¿5,VIP,¾üÏÎ,×ªÉú,¶·ÆøÖµ,½ð±Ò,¼¤»î¸øÓèBUFFµÄÎïÆ·ID FROM »êÓñÒ³Ãæ¹ºÂòÐèÇó¼¤»î±í");
+
+    if (results)
+    {
+        uint32 count = 0;
+        do
+        {
+            Field * fields = results->Fetch();
+
+            SoulStoneBuyReqData td;
+
+            td.page = fields[0].GetUInt32();
+            td.itemid1 = fields[1].GetUInt32();
+            td.val1 = fields[2].GetUInt32();
+            td.itemid2 = fields[3].GetUInt32();
+            td.val2 = fields[4].GetUInt32();
+            td.itemid3 = fields[5].GetUInt32();
+            td.val3 = fields[6].GetUInt32();
+            td.itemid4 = fields[7].GetUInt32();
+            td.val4 = fields[8].GetUInt32();
+            td.itemid5 = fields[9].GetUInt32();
+            td.val5 = fields[10].GetUInt32();
+            td.vip = fields[11].GetUInt32();
+            td.junxian = fields[12].GetUInt32();
+            td.zhuansheng = fields[13].GetUInt32();
+            td.douqival = fields[14].GetUInt32();
+            td.money = fields[15].GetUInt32() * GOLD;
+            td.jihuoshuxingid = fields[16].GetUInt32();
+
+            _SoulStoneBuyReqDataMap.insert({td.page,td});
+            
+            ++count;
+
+        } while (results->NextRow());
+        sLog->outString("======¼ÓÔØ»êÓñÒ³Ãæ¹ºÂòÐèÇó¼¤»î±í %u ÌõÊý¾Ý======", count);
+    }
+
+    _SoulStoneItemTypeMap.clear();
+
+	QueryResult resultss = WorldDatabase.PQuery("SELECT ÎïÆ·ID,ÎïÆ·ÀàÐÍID,Ò³Êý FROM »êÓñÀàÐÍ±í");
+
+	if (resultss)
+	{
+		uint32 count = 0;
+		do
+		{
+			Field * fields = resultss->Fetch();
+
+			SoulStoneItemType td;
+
+			uint32 itemid = fields[0].GetUInt32();
+			td.type = fields[1].GetInt32();
+			td.page = fields[2].GetInt32();
+
+			_SoulStoneItemTypeMap.insert({ itemid, td });
+
+			++count;
+
+		} while (resultss->NextRow());
+		sLog->outString("======¼ÓÔØ»êÓñÀàÐÍ±í %u ÌõÊý¾Ý======", count);
+	}
+
+	QueryResult resultssss = WorldDatabase.PQuery("SELECT ²ÎÊý FROM __Í¨ÓÃÅäÖÃ WHERE ID = 100");
+
+	if (resultssss)
+	{
+
+		Field * fields = resultssss->Fetch();
+		limitpageval = uint32(atoi(fields[0].GetString().c_str()));
+
+		sLog->outString("=======»êÓñ£¨¹Ì¶¨¼¤»î°æ£©³õÊ¼»¯Ò³ÃæÊýÁ¿Îª£º%d", limitpageval);
+	}
+
+}
+
+//ÖØÔØ 
+void SoulStone::ReLoad()
+{
+    Load();
+
+    SessionMap const& sessions = sWorld->GetAllSessions();
+    for (SessionMap::const_iterator it = sessions.begin(); it != sessions.end(); ++it)
+        if (Player* player = it->second->GetPlayer())
+        {
+            SendMutualData(player);
+        }
+}
+
+void SoulStone::SendMutualData(Player * player)
+{
+    if (!player)
+        return;
+
+	uint32 p = limitpageval;
+
+	if (!p)
+	{
+		sGCAddon->SendPacketTo(player, "SSS_LIMIT_VAL", std::to_string(p));
+		return;
+	}
+
+    uint32 num = sSoulStone->GetPlayerMaxPage(player);
+
+    //std::string val = std::to_string(sSoulStone->GetPlayerMaxPage(player));
+	std::string val = std::to_string(num);
+	sLog->outString("num = %d  val = %s",num,val.c_str());
+	sGCAddon->SendPacketTo(player, "SSS_LIMIT_VAL", val);
+
+    for (uint8 i = 1; i< num + 1; ++i)
+    {
+        SendPlayerDataForPage(player, i);
+    }
+   
+}
+
+void SoulStone::SendPlayerDataForPage(Player * player, uint32 page)
+{
+    if (!player)
+        return;
+
+    uint32 guid = player->GetGUIDLow();
+
+    for (auto itr = _SoulStonePlayerDataMap.begin(); itr != _SoulStonePlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            if (itr->second.page == page)
+            {
+                std::ostringstream ss1;
+                std::ostringstream ss2;
+                std::ostringstream ss3;
+                std::ostringstream ss4;
+                std::ostringstream ss5;
+                std::ostringstream ss6;
+
+				ss1 << itr->second.page << "#1#" << itr->second.itemid1 << "#" << sCF->GetItemLink(itr->second.itemid1);
+				ss2 << itr->second.page << "#2#" << itr->second.itemid2 << "#" << sCF->GetItemLink(itr->second.itemid2);
+				ss3 << itr->second.page << "#3#" << itr->second.itemid3 << "#" << sCF->GetItemLink(itr->second.itemid3);
+				ss4 << itr->second.page << "#4#" << itr->second.itemid4 << "#" << sCF->GetItemLink(itr->second.itemid4);
+				ss5 << itr->second.page << "#5#" << itr->second.itemid5 << "#" << sCF->GetItemLink(itr->second.itemid5);
+				ss6 << itr->second.page << "#6#" << itr->second.itemid6 << "#" << sCF->GetItemLink(itr->second.itemid6);
+
+				sGCAddon->SendPacketTo(player, "SSS_XQ_FG", ss1.str());
+				sGCAddon->SendPacketTo(player, "SSS_XQ_FG", ss2.str());
+				sGCAddon->SendPacketTo(player, "SSS_XQ_FG", ss3.str());
+				sGCAddon->SendPacketTo(player, "SSS_XQ_FG", ss4.str());
+				sGCAddon->SendPacketTo(player, "SSS_XQ_FG", ss5.str());
+				sGCAddon->SendPacketTo(player, "SSS_XQ_FG", ss6.str());
+            }
+        }
+    }
+}
+
+void SoulStone::SavePlayerAllDate(Player * player)
+{
+    if (!player)
+        return;
+
+    uint32 guid = player->GetGUIDLow();
+
+    for (auto itr = _SoulStonePlayerDataMap.begin(); itr != _SoulStonePlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+			if (itr->second.page == 0)
+				continue;
+
+            WorldDatabase.PExecute("REPLACE INTO Íæ¼Ò»êÓñ¼ÇÂ¼±í(Íæ¼ÒGUID,Ò³Ãæ,²å²Û1ÎïÆ·ID,²å²Û2ÎïÆ·ID,²å²Û3ÎïÆ·ID,²å²Û4ÎïÆ·ID,²å²Û5ÎïÆ·ID,²å²Û6ÎïÆ·ID,ÊÇ·ñ¼¤»îÒ³ÃæÊôÐÔ)VALUES(%u,%u,%u,%u,%u,%u,%u,%u,%u)", itr->second.guid, itr->second.page, itr->second.itemid1, itr->second.itemid2, itr->second.itemid3, itr->second.itemid4, itr->second.itemid5, itr->second.itemid6, itr->second.itemid7);
+        }
+    }
+}
+
+void SoulStone::CreatePlayerDate(Player * player)
+{
+    if (!player)
+        return;
+
+	for (uint32 i = 1; i < limitpageval + 1; ++i)
+    {
+        SoulStonePlayerData td;
+        td.guid = player->GetGUIDLow();
+        td.page = i;
+        td.itemid1 = 0;
+        td.itemid2 = 0;
+        td.itemid3 = 0;
+        td.itemid4 = 0;
+        td.itemid5 = 0;
+        td.itemid6 = 0;
+        td.itemid7 = 0;
+
+        _SoulStonePlayerDataMap.insert({ td.guid,td });
+    }
+
+    SavePlayerAllDate(player);
+}
+
+void SoulStone::SavePlayerSlotToSTL(Player * player, uint32 page, uint32 slot, uint32 itemid)
+{
+    if (!player)
+        return;
+
+    if (slot > 6)
+        return;
+
+    uint32 guid = player->GetGUIDLow();
+
+    for (auto itr = _SoulStonePlayerDataMap.begin(); itr != _SoulStonePlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            if (itr->second.page == page)
+            {
+                switch (slot)
+                {
+                case 1:
+                    itr->second.itemid1 = itemid;
+                    return;
+                case 2:
+                    itr->second.itemid2 = itemid;
+                    return;
+                case 3:
+                    itr->second.itemid3 = itemid;
+                    return;
+                case 4:
+                    itr->second.itemid4 = itemid;
+                    return;
+                case 5:
+                    itr->second.itemid5 = itemid;
+                    return;
+                case 6:
+                    itr->second.itemid6 = itemid;
+                    return;
+                default:
+                    return;
+                }
+            }
+        }
+    }
+
+    //SavePlayerSlotToBase(player, page, slot,itemid);
+    //SavePlayerAllDate(player);
+}
+
+void SoulStone::SavePlayerSlotToBase(Player * player, uint32 page, uint32 slot, uint32 itemid)
+{
+    if (!player)
+        return;
+
+    if (slot > 6)
+        return;
+
+	if (page == 0)
+		return;
+
+    uint32 guid = player->GetGUIDLow();
+
+    for (auto itr = _SoulStonePlayerDataMap.begin(); itr != _SoulStonePlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            if (itr->second.page == page)
+            {
+                switch (slot)
+                {
+                case 1:
+                    WorldDatabase.PExecute("REPLACE INTO Íæ¼Ò»êÓñ¼ÇÂ¼±í(Íæ¼ÒGUID,Ò³Ãæ,²å²Û1ÎïÆ·ID)VALUES(%u,%u,%u)", guid, page, itemid);
+                    return;
+                case 2:
+                    WorldDatabase.PExecute("REPLACE INTO Íæ¼Ò»êÓñ¼ÇÂ¼±í(Íæ¼ÒGUID,Ò³Ãæ,²å²Û2ÎïÆ·ID)VALUES(%u,%u,%u)", guid, page, itemid);
+                    return;
+                case 3:
+                    WorldDatabase.PExecute("REPLACE INTO Íæ¼Ò»êÓñ¼ÇÂ¼±í(Íæ¼ÒGUID,Ò³Ãæ,²å²Û3ÎïÆ·ID)VALUES(%u,%u,%u)", guid, page, itemid);
+                    return;
+                case 4:
+                    WorldDatabase.PExecute("REPLACE INTO Íæ¼Ò»êÓñ¼ÇÂ¼±í(Íæ¼ÒGUID,Ò³Ãæ,²å²Û4ÎïÆ·ID)VALUES(%u,%u,%u)", guid, page, itemid);
+                    return;
+                case 5:
+                    WorldDatabase.PExecute("REPLACE INTO Íæ¼Ò»êÓñ¼ÇÂ¼±í(Íæ¼ÒGUID,Ò³Ãæ,²å²Û5ÎïÆ·ID)VALUES(%u,%u,%u)", guid, page, itemid);
+                    return;
+                case 6:
+                    WorldDatabase.PExecute("REPLACE INTO Íæ¼Ò»êÓñ¼ÇÂ¼±í(Íæ¼ÒGUID,Ò³Ãæ,²å²Û6ÎïÆ·ID)VALUES(%u,%u,%u)", guid, page, itemid);
+                    return;
+                default:
+                    break;
+                }
+            }
+        }
+    }
+}
+
+void SoulStone::AddOrRemovePlayerBuff(Player * player, uint32 itemid, uint32 olditemid, SoulStoneSlotType t)
+{
+    sLog->outString("olditemid = %u", olditemid);
+
+    ItemTemplate const * pProto = sObjectMgr->GetItemTemplate(itemid);
+
+    ItemTemplate const * pProts = sObjectMgr->GetItemTemplate(olditemid);
+
+    if (itemid != 0 && !pProto)
+        return;
+
+    if (olditemid != 0 && !pProts)
+        return;
+
+    if (t == SS_FG)
+    {
+        if (olditemid == 0)
+            return;
+
+        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+        {
+            _Spell const& spellData = pProto->Spells[i];
+            _Spell const& spellDatas = pProts->Spells[i];
+
+            // no spell
+            if (!spellData.SpellId)
+                continue;
+            if (Aura * aura = player->GetAura(spellDatas.SpellId))
+            {
+                player->RemoveAura(aura);
+            }
+
+            player->CastSpell(player, spellData.SpellId);
+        }
+    }
+
+    if (t == SS_XQ)
+    {
+        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+        {
+            _Spell const& spellData = pProto->Spells[i];
+
+            // no spell
+            if (!spellData.SpellId)
+                continue;
+
+            player->CastSpell(player, spellData.SpellId);
+        }
+    }
+
+    if (t == SS_CX)
+    {
+        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+        {
+            _Spell const& spellDatas = pProts->Spells[i];
+
+            if (Aura * aura = player->GetAura(spellDatas.SpellId))
+            {
+                player->RemoveAura(aura);
+            }
+        }
+    }
+}
+
+void SoulStone::PlayerBuyPage(Player * player, uint32 page)
+{
+    //Õâ¸öºÃÏñ²»ÄÜ·Åµ½ÕâÀï Òª·Åµ½ÅÐ¶¨ÊÇ·ñÓÐ¹ºÂòÐèÇóÄÇÀï Ê×Î»  È»ºóÕâÀï×îµ×ÏÂ »òÐíÒª·Å¸ö ·¢ËÍ¼¤»î²Ù×÷Âëµ½¿Í»§¶Ë
+    if (page > GetPlayerMaxPage(player) + 1)
+    {
+        //ÌáÊ¾Òª°´Ë³Ðò¹ºÂòÒ³Ãæ
+        return;
+    }
+
+
+    RemoveReq(player, page);
+
+    SoulStonePlayerData td;
+    td.guid = player->GetGUIDLow();
+    td.page = page;
+    td.itemid1 = 0;
+    td.itemid2 = 0;
+    td.itemid3 = 0;
+    td.itemid4 = 0;
+    td.itemid5 = 0;
+    td.itemid6 = 0;
+    td.itemid7 = 0;
+
+    _SoulStonePlayerDataMap.insert({ td.guid,td });
+
+    //SavePlayerAllDate(player);
+
+    SendBuyIsOkPage(player,page);
+}
+
+uint32 SoulStone::GetPlayerMaxPage(Player * player)
+{
+    uint32 guid = player->GetGUIDLow();
+
+    uint32 count = 0;
+
+    for (auto itr = _SoulStonePlayerDataMap.begin(); itr != _SoulStonePlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            ++count;
+			sLog->outString("¶ÁÈ¡Íæ¼ÒÒ³ÃæÊý¾Ý %d", itr->second.page);
+        }
+    }
+
+    return count;
+}
+
+//uint32 SoulStone::GetItemType(uint32 itemid)
+//{
+//    auto itr = _SoulStoneItemTypeMap.find(itemid);
+//
+//    if (itr != _SoulStoneItemTypeMap.end())
+//        return itr->second;
+//
+//    return 0;
+//}
+
+
+uint32 SoulStone::GetItemType(uint32 itemid)
+{
+	auto itr = _SoulStoneItemTypeMap.find(itemid);
+
+	if (itr != _SoulStoneItemTypeMap.end())
+		return itr->second.type;
+
+	return 0;
+}
+
+
+int32 SoulStone::GetItemPage(uint32 itemid)
+{
+	auto itr = _SoulStoneItemTypeMap.find(itemid);
+
+	if (itr != _SoulStoneItemTypeMap.end())
+		return itr->second.page;
+
+	return -1;
+}
+
+
+uint32 SoulStone::GetPageActi(uint32 page)
+{
+    auto itr = _SoulStoneBuyReqDataMap.find(page);
+
+    if (itr != _SoulStoneBuyReqDataMap.end())
+        return itr->second.jihuoshuxingid;
+
+    return 0;
+}
+
+uint32 SoulStone::GetOldItemId(Player * player, uint32 page, uint32 slot)
+{
+    uint32 guid = player->GetGUID();
+
+    for (auto itr = _SoulStonePlayerDataMap.begin(); itr != _SoulStonePlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            if (itr->second.page == page)
+            {
+                switch (slot)
+                {
+                case 1:
+                    return itr->second.itemid1;
+                case 2:
+                    return itr->second.itemid2;
+                case 3:
+                    return itr->second.itemid3;
+                case 4:
+                    return itr->second.itemid4;
+                case 5:
+                    return itr->second.itemid5;
+                case 6:
+                    return itr->second.itemid6;
+                default:
+                    break;
+                }
+            }
+        }
+    }
+
+    return 0;
+}
+
+void SoulStone::SendAllActiData(Player * player)
+{
+	uint32 maxpage = GetPlayerMaxPage(player);
+
+	if (maxpage < limitpageval)
+		maxpage = limitpageval;
+
+	for (uint32 i = 1; i < maxpage + 1; ++i)
+    {
+        if (sSoulStone->IsActi(player, i))
+        {
+            SendActiDataToClient(player, i);
+        }
+    }
+}
+
+void SoulStone::SendActiDataToClient(Player * player, uint32 page)
+{
+    std::ostringstream ss;
+
+    uint32 itemid = GetPageActi(page);
+    //uint32 itemid = GetExActiId(player, page);
+
+    
+    std::string itemlink = sCF->GetItemLink(itemid);
+
+    ss << page << "#" << itemid << "#" << itemlink;
+   
+    //player->SendAddonMessage("SSS_ACTI_VAL",ss.str(), 7, player);
+	sGCAddon->SendPacketTo(player, "SSS_ACTI_VAL", ss.str());
+
+}
+
+
+void SoulStone::SendUnActiDataToClient(Player * player, uint32 page)
+{
+	sGCAddon->SendPacketTo(player, "SSS_ACTI_UN", std::to_string(page));
+}
+
+
+void SoulStone::SetActi(Player * player, uint32 page)
+{
+    if (!player)
+        return;
+
+    uint32 Actiid = GetPageActi(page);
+    //uint32 Actiid = GetExActiId(player,page);
+    //³¢ÊÔÔÚÕâ»ñµÃÀ©Õ¹ÐÔÒ³Ãæ¼¤»îID ¶ÔÓ¦Íæ¼Òguid  Ò³Ãæ ÒÔ¼° Ò³ÃæÄÚËùÓÐ1~6µÄÎïÆ·ID µÃµ½¼¤»îID
+
+    if (Actiid != 0)
+    {
+        ItemTemplate const * pProto = sObjectMgr->GetItemTemplate(Actiid);
+
+        if (!pProto)
+        {
+            //¿ÉÒÔÐ´ÌáÊ¾Óï¾ä
+            return;
+        }
+
+        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+        {
+            _Spell const& spellData = pProto->Spells[i];
+
+            // no spell
+            if (!spellData.SpellId)
+                continue;
+
+            player->CastSpell(player, spellData.SpellId);
+        }
+
+        uint32 itemid7 = GetPageActi(page);
+        //uint32 itemid7 = GetExActiId(player,page);
+
+        SetActiId(player, page, itemid7);
+
+        SendActiDataToClient(player, page);
+    }
+}
+
+void SoulStone::RemoveActi(Player * player, uint32 page)
+{
+    if (!player)
+        return;
+
+    uint32 Actiid = GetPageActi(page);
+    //uint32 Actiid = GetExActiId(player,page);
+
+    if (Actiid != 0)
+    {
+        ItemTemplate const * pProto = sObjectMgr->GetItemTemplate(Actiid);
+
+        if (!pProto)
+        {
+            //¿ÉÒÔÐ´ÌáÊ¾Óï¾ä
+            return;
+        }
+
+        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+        {
+            _Spell const& spellData = pProto->Spells[i];
+
+            // no spell
+            if (!spellData.SpellId)
+                continue;
+
+            if (Aura * aura = player->GetAura(spellData.SpellId))
+            {
+                player->RemoveAura(aura);
+            }
+        }
+
+        SetActiId(player, page, 0);
+
+        SendUnActiDataToClient(player, page);
+    }
+}
+
+
+bool SoulStone::CanSetActi(Player * player, uint32 page)
+{
+    uint32 guid = player->GetGUIDLow();
+
+    for (auto itr = _SoulStonePlayerDataMap.begin(); itr != _SoulStonePlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            if (itr->second.page == page)
+            {
+                if (itr->second.itemid1 > 0 && itr->second.itemid2 > 0 && itr->second.itemid3 > 0 && itr->second.itemid4 > 0 && itr->second.itemid5 > 0 && itr->second.itemid6 > 0)
+                {
+                    return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
+
+
+bool SoulStone::IsActi(Player * player, uint32 page)
+{
+
+    uint32 guid = player->GetGUIDLow();
+
+    for (auto itr = _SoulStonePlayerDataMap.begin(); itr != _SoulStonePlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            if (itr->second.page == page)
+            {
+                if (itr->second.itemid7 == 0)
+                {
+                    return false;
+                }
+            }
+        }
+    }
+
+    return true;
+}
+
+
+//void SoulStone::CanInSetToSlot(Player * player, uint32 page, uint32 slot, uint32 itemid, std::string msg)
+//{
+//    if (page > GetPlayerMaxPage(player))
+//        return;
+//
+//    ItemTemplate const * pProto = sObjectMgr->GetItemTemplate(itemid);
+//
+//    if (!player || !pProto || !IfSoulStoneItem(itemid))
+//    {
+//        //ÌáÊ¾Î´ÖªÎÊÌâ 
+//        return;
+//    }
+//
+//	uint32 maxpage = GetPlayerMaxPage(player);
+//
+//	if (page > maxpage)
+//	{
+//		//ÌáÊ¾ÇëÎð·Ç·¨Ê¹ÓÃ²å¼þ,²»ÄÜÊ¹ÓÃÎ´¹ºÂòµÄ»êÓñÒ³Ãæ
+//		return;
+//	}
+//
+//    uint32 guid = player->GetGUIDLow();
+//
+//    uint32 newitemtype = GetItemType(itemid);
+//
+//    uint32 olditemtype = 0;
+//
+//    uint32 olditemid = 0;
+//
+//    player->PlayerTalkClass->ClearMenus();
+//
+//    std::ostringstream ss;
+//
+//    for (auto itr = _SoulStonePlayerDataMap.begin(); itr != _SoulStonePlayerDataMap.end(); ++itr)
+//    {
+//        if (itr->first == guid)
+//        {
+//            if (itr->second.page == page)
+//            {
+//                switch (slot)
+//                {
+//                case 1:
+//                    olditemtype = GetItemType(itr->second.itemid1);
+//                    olditemid = itr->second.itemid1;
+//                    break;
+//                case 2:
+//                    olditemtype = GetItemType(itr->second.itemid2);
+//                    olditemid = itr->second.itemid2;
+//                    break;
+//                case 3:
+//                    olditemtype = GetItemType(itr->second.itemid3);
+//                    olditemid = itr->second.itemid3;
+//                    break;
+//                case 4:
+//                    olditemtype = GetItemType(itr->second.itemid4);
+//                    olditemid = itr->second.itemid4;
+//                    break;
+//                case 5:
+//                    olditemtype = GetItemType(itr->second.itemid5);
+//                    olditemid = itr->second.itemid5;
+//                    break;
+//                case 6:
+//                    olditemtype = GetItemType(itr->second.itemid6);
+//                    olditemid = itr->second.itemid6;
+//                    break;
+//                default:
+//                    break;
+//                }
+//            }
+//        }
+//    }
+//
+//    
+//    if (olditemid == 0)
+//    {
+//        ss << sCF->GetItemLink(itemid) << pProto->Name1.c_str() << "ÊÇ·ñÏâÇ¶µ½´Ë²å²Û?";
+//        player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_VENDOR, "", GOSSIP_SENDER_SEC_SS, GOSSIP_ACTION_SS + 1, ss.str().c_str(), 0, false);
+//        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+//    }
+//    else
+//    {
+//        if (ItemTemplate const * pProt = sObjectMgr->GetItemTemplate(olditemid))
+//        {
+//            ss << sCF->GetItemLink(itemid) << pProto->Name1.c_str() << "ÊÇ·ñÌæ»»²å²ÛÄÚµÄ" <<sCF->GetItemLink(olditemid) << pProt->Name1.c_str();
+//            player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_VENDOR, "", GOSSIP_SENDER_SEC_SS, GOSSIP_ACTION_SS + 2, ss.str().c_str(), 0, false);
+//            player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+//        }
+//    }
+//
+//    std::ostringstream str;
+//
+//    str << msg << "#" << sCF->GetItemLink(itemid);
+//
+//    SetPlayerMsg(player, str.str());
+//}
+
+
+void SoulStone::CanInSetToSlot(Player * player, uint32 page, uint32 slot, uint32 itemid, std::string msg)
+{
+	if (page > GetPlayerMaxPage(player))
+		return;
+
+
+	player->PlayerTalkClass->ClearMenus();
+
+	ItemTemplate const * pProto = sObjectMgr->GetItemTemplate(itemid);
+
+	if (!player || !pProto || !IfSoulStoneItem(itemid))
+	{
+		//ÌáÊ¾Î´ÖªÎÊÌâ 
+		return;
+	}
+
+	uint32 maxpage = GetPlayerMaxPage(player);
+
+	if (page > maxpage)
+	{
+		//ÌáÊ¾ÇëÎð·Ç·¨Ê¹ÓÃ²å¼þ,²»ÄÜÊ¹ÓÃÎ´¹ºÂòµÄ»êÓñÒ³Ãæ
+		return;
+	}
+
+	uint32 guid = player->GetGUIDLow();
+
+	uint32 newitemtype = GetItemType(itemid);
+	uint32 newitempage = GetItemPage(itemid);
+
+	if (newitempage == -1 || newitemtype == 0)
+		return;
+
+	if (newitempage != page && newitempage != 0)
+	{
+		std::ostringstream sstr;
+		sstr << sCF->GetItemLink(itemid) << "´Ë»êÓñÖ»ÄÜÏâÇ¶ÔÚµÚ" << newitempage << "Ò³";
+		player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_VENDOR, "", GOSSIP_SENDER_SEC_SS_ERR, GOSSIP_ACTION_SS_ERR, sstr.str(), 0, false);
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+		return;
+	}
+
+	uint32 olditemid = 0;
+
+
+	std::ostringstream ss;
+
+	for (auto itr = _SoulStonePlayerDataMap.begin(); itr != _SoulStonePlayerDataMap.end(); ++itr)
+	{
+		if (itr->first == guid)
+		{
+			bool send = false;
+
+			if (itr->second.page == page)
+			{
+				if (slot == 1)
+				{
+					if (newitemtype == GetItemType(itr->second.itemid2) || newitemtype == GetItemType(itr->second.itemid3) || newitemtype == GetItemType(itr->second.itemid4) || newitemtype == GetItemType(itr->second.itemid5) || newitemtype == GetItemType(itr->second.itemid6))
+					{
+						send = true;
+					}
+				}
+
+				if (slot == 2)
+				{
+					if (newitemtype == GetItemType(itr->second.itemid1) || newitemtype == GetItemType(itr->second.itemid3) || newitemtype == GetItemType(itr->second.itemid4) || newitemtype == GetItemType(itr->second.itemid5) || newitemtype == GetItemType(itr->second.itemid6))
+					{
+						send = true;
+					}
+				}
+
+				if (slot == 3)
+				{
+					if (newitemtype == GetItemType(itr->second.itemid2) || newitemtype == GetItemType(itr->second.itemid1) || newitemtype == GetItemType(itr->second.itemid4) || newitemtype == GetItemType(itr->second.itemid5) || newitemtype == GetItemType(itr->second.itemid6))
+					{
+						send = true;
+					}
+				}
+
+				if (slot == 4)
+				{
+					if (newitemtype == GetItemType(itr->second.itemid2) || newitemtype == GetItemType(itr->second.itemid3) || newitemtype == GetItemType(itr->second.itemid1) || newitemtype == GetItemType(itr->second.itemid5) || newitemtype == GetItemType(itr->second.itemid6))
+					{
+						send = true;
+					}
+				}
+
+				if (slot == 5)
+				{
+					if (newitemtype == GetItemType(itr->second.itemid2) || newitemtype == GetItemType(itr->second.itemid3) || newitemtype == GetItemType(itr->second.itemid4) || newitemtype == GetItemType(itr->second.itemid1) || newitemtype == GetItemType(itr->second.itemid6))
+					{
+						send = true;
+					}
+				}
+
+				if (slot == 6)
+				{
+					if (newitemtype == GetItemType(itr->second.itemid2) || newitemtype == GetItemType(itr->second.itemid3) || newitemtype == GetItemType(itr->second.itemid4) || newitemtype == GetItemType(itr->second.itemid5) || newitemtype == GetItemType(itr->second.itemid1))
+					{
+						send = true;
+					}
+				}
+			}
+
+
+			if (send)
+			{
+				player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_VENDOR, "", GOSSIP_SENDER_SEC_SS_ERR, GOSSIP_ACTION_SS_ERR, "µ±Ç°Ò³ÃæÖ»ÄÜÏâÇ¶Ò»¸ö´ËÀàÐÍ»êÓñ", 0, false);
+				player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+				return;
+			}
+
+			switch (slot)
+			{
+			case 1:
+				olditemid = itr->second.itemid1;
+				break;
+			case 2:
+				olditemid = itr->second.itemid2;
+				break;
+			case 3:
+				olditemid = itr->second.itemid3;
+				break;
+			case 4:
+				olditemid = itr->second.itemid4;
+				break;
+			case 5:
+				olditemid = itr->second.itemid5;
+				break;
+			case 6:
+				olditemid = itr->second.itemid6;
+				break;
+			default:
+				break;
+			}
+		}
+	}
+
+
+	if (olditemid == 0)
+	{
+		ss << sCF->GetItemLink(itemid) << pProto->Name1.c_str() << "ÊÇ·ñÏâÇ¶µ½´Ë²å²Û?";
+		player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_VENDOR, "", GOSSIP_SENDER_SEC_SS, GOSSIP_ACTION_SS + 1, ss.str().c_str(), 0, false);
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+	}
+	else
+	{
+		if (ItemTemplate const * pProt = sObjectMgr->GetItemTemplate(olditemid))
+		{
+			ss << sCF->GetItemLink(itemid) << pProto->Name1.c_str() << "ÊÇ·ñÌæ»»²å²ÛÄÚµÄ" << sCF->GetItemLink(olditemid) << pProt->Name1.c_str();
+			player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_VENDOR, "", GOSSIP_SENDER_SEC_SS, GOSSIP_ACTION_SS + 2, ss.str().c_str(), 0, false);
+			player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+		}
+	}
+
+	std::ostringstream str;
+
+	str << msg << "#" << sCF->GetItemLink(itemid);
+
+	SetPlayerMsg(player, str.str());
+}
+
+
+void SoulStone::CanRemoveSlot(Player * player, uint32 page, uint32 slot, std::string msg)
+{
+    if (!player)
+        return;
+	sLog->outString(" page = %d, slot = %d", page, slot);
+	uint32 maxpage = GetPlayerMaxPage(player);
+
+	if (page > maxpage)
+	{
+		//ÌáÊ¾ÇëÎð·Ç·¨Ê¹ÓÃ²å¼þ,²»ÄÜÊ¹ÓÃÎ´¹ºÂòµÄ»êÓñÒ³Ãæ
+		return;
+	}
+
+    player->PlayerTalkClass->ClearMenus();
+
+    uint32 guid = player->GetGUIDLow();
+
+    uint32 olditemid = 0;
+
+    std::ostringstream ss;
+
+    for (auto itr = _SoulStonePlayerDataMap.begin(); itr != _SoulStonePlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            if (itr->second.page == page)
+            {
+                switch (slot)
+                {
+                case 1:
+                    olditemid = itr->second.itemid1;
+                    break;
+                case 2:
+                    olditemid = itr->second.itemid2;
+                    break;
+                case 3:
+                    olditemid = itr->second.itemid3;
+                    break;
+                case 4:
+                    olditemid = itr->second.itemid4;
+                    break;
+                case 5:
+                    olditemid = itr->second.itemid5;
+                    break;
+                case 6:
+                    olditemid = itr->second.itemid6;
+                    break;
+                default:
+                    break;
+                } 
+            }
+        }
+    }
+
+    ItemTemplate const * pProt = sObjectMgr->GetItemTemplate(olditemid);
+
+    if (!pProt)
+        return;
+
+    ss << "ÊÇ·ñ²ðÐ¶´Ë²å²ÛÖÐµÄ" << sCF->GetItemLink(olditemid) << pProt->Name1.c_str();
+
+    player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_VENDOR, "", GOSSIP_SENDER_SEC_SS, GOSSIP_ACTION_SS + 3, ss.str().c_str(), 0, false);
+
+    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+
+    std::ostringstream str;
+
+    str << msg << "#" << std::to_string(olditemid);
+
+    SetPlayerMsg(player, str.str());
+}
+
+
+bool SoulStone::IsData(Player * player)
+{
+
+    uint32 guid = player->GetGUIDLow();
+
+    uint32 count = 0;
+
+    for (auto itr = _SoulStonePlayerDataMap.begin(); itr != _SoulStonePlayerDataMap.end(); ++itr)
+    {
+        if (itr->second.guid == guid)
+            ++count;
+    }
+
+    if (count == 0)
+    {
+        return false;
+    }
+
+    return true;
+
+}
+
+bool SoulStone::IsBuyPageReq(Player * player, uint32 page)
+{
+    if (!player)
+        return false;
+
+    auto itr = _SoulStoneBuyReqDataMap.find(page);
+    if (itr == _SoulStoneBuyReqDataMap.end())
+        return false;
+
+	bool send = false;
+
+	std::ostringstream oss;
+
+	oss << "¹ºÂò»êÓñµÚ" << page << "Ò³£º\n";
+
+    if (itr->second.itemid1 > 0 && itr->second.val1 > 0)
+    {
+        if (!player->HasItemCount(itr->second.itemid1, itr->second.val1))
+        {
+			//ChatHandler(player->GetSession()).PSendSysMessage("ÐèÒªÎïÆ·£º%s * %d ¸ö",sCF->GetItemLink(itr->second.itemid1).c_str(),itr->second.val1);
+            //return false;
+			oss << "ÐèÒªÎïÆ·£º" << sCF->GetItemLink(itr->second.itemid1) << " * " << itr->second.val1 << "¸ö\n";
+			send = true;
+        }
+    }
+
+    if (itr->second.itemid2 > 0 && itr->second.val2 > 0)
+    {
+        if (!player->HasItemCount(itr->second.itemid2, itr->second.val2))
+        {
+			//ChatHandler(player->GetSession()).PSendSysMessage("ÐèÒªÎïÆ·£º%s * %d ¸ö", sCF->GetItemLink(itr->second.itemid2), itr->second.val2);
+            //return false;
+			oss << "ÐèÒªÎïÆ·£º" << sCF->GetItemLink(itr->second.itemid2) << " * " << itr->second.val2 << "¸ö\n";
+			send = true;
+        }
+    }
+
+    if (itr->second.itemid3 > 0 && itr->second.val3 > 0)
+    {
+        if (!player->HasItemCount(itr->second.itemid3, itr->second.val3))
+        {
+			//ChatHandler(player->GetSession()).PSendSysMessage("ÐèÒªÎïÆ·£º%s * %d ¸ö", sCF->GetItemLink(itr->second.itemid3), itr->second.val3);
+            //return false;
+			oss << "ÐèÒªÎïÆ·£º" << sCF->GetItemLink(itr->second.itemid3) << " * " << itr->second.val3 << "¸ö\n";
+			send = true;
+        }
+    }
+    
+    if (itr->second.itemid4 > 0 && itr->second.val4 > 0)
+    {
+        if (!player->HasItemCount(itr->second.itemid4, itr->second.val4))
+        {
+			//ChatHandler(player->GetSession()).PSendSysMessage("ÐèÒªÎïÆ·£º%s * %d ¸ö", sCF->GetItemLink(itr->second.itemid4), itr->second.val4);
+            //return false;
+			oss << "ÐèÒªÎïÆ·£º" << sCF->GetItemLink(itr->second.itemid4) << " * " << itr->second.val4 << "¸ö\n";
+			send = true;
+        }
+    }
+    
+    if (itr->second.itemid5 > 0 && itr->second.val5 > 0)
+    {
+        if (!player->HasItemCount(itr->second.itemid5, itr->second.val5))
+        {
+			//ChatHandler(player->GetSession()).PSendSysMessage("ÐèÒªÎïÆ·£º%s * %d ¸ö", sCF->GetItemLink(itr->second.itemid5), itr->second.val5);
+            //return false;
+			oss << "ÐèÒªÎïÆ·£º" << sCF->GetItemLink(itr->second.itemid5) << " * " << itr->second.val5 << "¸ö\n";
+			send = true;
+        }
+    }
+    
+
+    if (player->GetMoney() < itr->second.money)
+    {
+		//ChatHandler(player->GetSession()).PSendSysMessage("ÐèÒª½ð±Ò£º%d", uint32(itr->second.money / GOLD));
+		//return false;
+		oss << "ÐèÒª½ð±Ò£º" << uint32(itr->second.money / GOLD);
+		send = true;
+    }
+
+	if (send)
+	{
+		ChatHandler(player->GetSession()).PSendSysMessage(oss.str().c_str());
+		return false;
+	}
+
+    player->PlayerTalkClass->ClearMenus();
+
+    player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_VENDOR, "", GOSSIP_SENDER_SEC_SS_BUY, GOSSIP_ACTION_SS_BUY + page, "ÊÇ·ñÐèÒª¹ºÂòµÚ"+std::to_string(page)+"Ò³", 0, false);
+
+    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+
+    return true;
+
+}
+
+void SoulStone::RemoveReq(Player * player, uint32 page)
+{
+    if (!player)
+        return;
+
+    auto itr = _SoulStoneBuyReqDataMap.find(page);
+    if (itr == _SoulStoneBuyReqDataMap.end())
+        return;
+
+    player->DestroyItemCount(itr->second.itemid1, itr->second.val1,true);
+
+    player->DestroyItemCount(itr->second.itemid2, itr->second.val2,true);
+
+    player->DestroyItemCount(itr->second.itemid3, itr->second.val3,true);
+
+    player->DestroyItemCount(itr->second.itemid4, itr->second.val4,true);
+
+    player->DestroyItemCount(itr->second.itemid5, itr->second.val5,true);
+
+    player->SetMoney(player->GetMoney() - (itr->second.money));
+
+}
+
+void SoulStone::SendBuyIsOkPage(Player * player, uint32 page)
+{
+    std::string p = std::to_string(page);
+
+	sGCAddon->SendPacketTo(player, "SSS_BUY_PAGE", p);
+
+}
+
+void SoulStone::SetActiId(Player * player, uint32 page,uint32 itemid)
+{
+    uint32 guid = player->GetGUIDLow();
+
+    for (auto itr = _SoulStonePlayerDataMap.begin(); itr != _SoulStonePlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            if (itr->second.page == page)
+            {
+                itr->second.itemid7 = itemid;
+            }
+        }
+    }
+
+    //SavePlayerAllDate(player);	//ÒÔ·À³öÏÖ¸´ÖÆÎïÆ·BUG
+}
+
+void SoulStone::AgainAddLoseBuff(Player * player)
+{
+    uint32 maxpage = GetPlayerMaxPage(player);
+
+    uint32 guid = player->GetGUIDLow();
+
+    for (auto itr = _SoulStonePlayerDataMap.begin(); itr != _SoulStonePlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            ItemTemplate const * p1 = sObjectMgr->GetItemTemplate(itr->second.itemid1);
+            ItemTemplate const * p2 = sObjectMgr->GetItemTemplate(itr->second.itemid2);
+            ItemTemplate const * p3 = sObjectMgr->GetItemTemplate(itr->second.itemid3);
+            ItemTemplate const * p4 = sObjectMgr->GetItemTemplate(itr->second.itemid4);
+            ItemTemplate const * p5 = sObjectMgr->GetItemTemplate(itr->second.itemid5);
+            ItemTemplate const * p6 = sObjectMgr->GetItemTemplate(itr->second.itemid6);
+            ItemTemplate const * p7 = sObjectMgr->GetItemTemplate(itr->second.itemid7);
+
+            if (p1)
+            {
+                for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                {
+                    _Spell const& spellData = p1->Spells[i];
+
+                    // no spell
+                    if (!spellData.SpellId)
+                        continue;
+
+                    player->CastSpell(player, spellData.SpellId);
+                }
+            }
+
+            if (p2)
+            {
+                for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                {
+                    _Spell const& spellData = p2->Spells[i];
+
+                    // no spell
+                    if (!spellData.SpellId)
+                        continue;
+
+                    player->CastSpell(player, spellData.SpellId);
+                }
+            }
+
+            if (p3)
+            {
+                for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                {
+                    _Spell const& spellData = p3->Spells[i];
+
+                    // no spell
+                    if (!spellData.SpellId)
+                        continue;
+
+                    player->CastSpell(player, spellData.SpellId);
+                }
+            }
+
+            if (p4)
+            {
+                for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                {
+                    _Spell const& spellData = p4->Spells[i];
+
+                    // no spell
+                    if (!spellData.SpellId)
+                        continue;
+
+                    player->CastSpell(player, spellData.SpellId);
+                }
+            }
+
+            if (p5)
+            {
+                for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                {
+                    _Spell const& spellData = p5->Spells[i];
+
+                    // no spell
+                    if (!spellData.SpellId)
+                        continue;
+
+                    player->CastSpell(player, spellData.SpellId);
+                }
+            }
+
+            if (p6)
+            {
+                for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                {
+                    _Spell const& spellData = p6->Spells[i];
+
+                    // no spell
+                    if (!spellData.SpellId)
+                        continue;
+
+                    player->CastSpell(player, spellData.SpellId);
+                }
+            }
+
+            if (p7)
+            {
+                for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                {
+                    _Spell const& spellData = p7->Spells[i];
+
+                    // no spell
+                    if (!spellData.SpellId)
+                        continue;
+
+                    player->CastSpell(player, spellData.SpellId);
+                }
+            }
+        }
+    }
+}
+
+void SoulStone::UpdatePlayerDate(Player * player)
+{
+	uint32 guid = player->GetGUIDLow();
+
+	uint32 count = 0;
+
+	for (auto itr = _SoulStonePlayerDataMap.begin(); itr != _SoulStonePlayerDataMap.end(); ++itr)
+	{
+		if (itr->second.guid == guid)
+			++count;
+	}
+
+	if (limitpageval <= count)
+		return;
+
+	//uint32 i = limitpageval - count;
+
+	for (uint32 i = limitpageval - count; i < limitpageval + 1; ++i)
+	{
+		SoulStonePlayerData td;
+		td.guid = player->GetGUIDLow();
+		td.page = i;
+		td.itemid1 = 0;
+		td.itemid2 = 0;
+		td.itemid3 = 0;
+		td.itemid4 = 0;
+		td.itemid5 = 0;
+		td.itemid6 = 0;
+		td.itemid7 = 0;
+
+		_SoulStonePlayerDataMap.insert({ td.guid, td });
+	}
+
+	SavePlayerAllDate(player);
+
+}
+
+std::vector<std::string> SoulStone::split(std::string str, std::string pattern)
+{
+	std::string::size_type pos;
+	std::vector<std::string> result;
+	str += pattern;
+	int size = str.size();
+
+	for (int i = 0; i < size; i++)
+	{
+		pos = str.find(pattern, i);
+		if (pos < size)
+		{
+			std::string s = str.substr(i, pos - i);
+			result.push_back(s);
+			i = pos + pattern.size() - 1;
+		}
+	}
+	return result;
+}
+
+class SoulStonePlayerScript : public PlayerScript
+{
+public:
+    SoulStonePlayerScript() : PlayerScript("SoulStonePlayerScript") {}
+
+    void OnPlayerChatAddon(std::string header, std::string msg, uint8 chn, Player* player)
+    {
+        if (chn == 4) //CHAT_MSG_GUILD = 4
+        {
+            if (header == "SSC_ITEM_TO_SLOT")
+            {
+                std::vector<std::string> vec = sSoulStone->split(msg, "#");
+
+                uint32 page = atoi(vec[0].c_str());
+                uint32 slot = atoi(vec[1].c_str());
+                uint32 item = atoi(vec[2].c_str());
+
+                sSoulStone->CanInSetToSlot(player, page, slot, item, msg);
+
+            }
+
+            if (header == "SSC_REMOVE_SLOT_ITEM")
+            {
+                std::vector<std::string> vec = sSoulStone->split(msg, "#");
+
+                uint32 page = atoi(vec[0].c_str());
+                uint32 slot = atoi(vec[1].c_str());
+
+                sSoulStone->CanRemoveSlot(player, page, slot, msg);
+            }
+
+            if (header == "SSC_LIMIT" && msg == "VAL")
+            {
+                sSoulStone->SendMutualData(player);
+            }
+
+            if (header == "SSC_ACTI" && msg == "ISOK")
+            {
+                sSoulStone->SendAllActiData(player);
+            }
+
+            if (header == "SSC_BUY_PAGE")
+            {
+                uint32 page = atoi(msg.c_str());
+
+                if (!sSoulStone->IsBuyPageReq(player, page))
+                {
+                    return;
+                }
+
+            }
+        }
+    }
+
+    void OnGossipSelect(Player* player, uint32 menu_id, uint32 sender, uint32 action)
+    {
+        
+        if (sender == GOSSIP_SENDER_SEC_SS)
+        {
+
+            if (action == GOSSIP_ACTION_SS + 1)
+            {
+                std::string msg = sSoulStone->GetPlayerMsg(player);
+				sLog->outString("msg = %s",msg.c_str());
+
+				sGCAddon->SendPacketTo(player, "SSS_XQ_FG", msg);
+
+                std::vector<std::string> vec = sSoulStone->split(msg, "#");
+
+                uint32 page = atoi(vec[0].c_str());
+                uint32 slot = atoi(vec[1].c_str());
+                uint32 itemid = atoi(vec[2].c_str());
+
+                sSoulStone->SavePlayerSlotToSTL(player, page, slot, itemid);
+
+                sSoulStone->AddOrRemovePlayerBuff(player, itemid);
+
+                player->DestroyItemCount(itemid, 1,true);
+
+                if (sSoulStone->CanSetActi(player, page))
+                {
+                    sSoulStone->SetActi(player, page);
+                }
+            }
+
+            if (action == GOSSIP_ACTION_SS + 2)
+            {
+                std::string msg = sSoulStone->GetPlayerMsg(player);
+
+				sGCAddon->SendPacketTo(player, "SSS_XQ_FG", msg);
+
+                std::vector<std::string> vec = sSoulStone->split(msg, "#");
+
+                uint32 page = atoi(vec[0].c_str());
+                uint32 slot = atoi(vec[1].c_str());
+                uint32 itemid = atoi(vec[2].c_str());
+
+                uint32 olditemid = sSoulStone->GetOldItemId(player, page, slot);
+
+                sSoulStone->SavePlayerSlotToSTL(player, page, slot, itemid);
+
+                sSoulStone->AddOrRemovePlayerBuff(player, itemid,olditemid,SS_FG);
+
+                player->DestroyItemCount(itemid, 1, true);
+
+                if (sSoulStone->CanSetActi(player, page))
+                {
+                    sSoulStone->SetActi(player, page);
+                }
+            }
+
+
+            if (action == GOSSIP_ACTION_SS + 3)
+            {
+                std::string msg = sSoulStone->GetPlayerMsg(player);
+
+				sGCAddon->SendPacketTo(player,"SSS_CX",msg);
+
+                std::vector<std::string> vec = sSoulStone->split(msg, "#");
+
+                uint32 page = atoi(vec[0].c_str());
+                uint32 slot = atoi(vec[1].c_str());
+
+                uint32 olditemid = sSoulStone->GetOldItemId(player, page, slot);
+
+                sSoulStone->SavePlayerSlotToSTL(player, page, slot, 0);
+
+                sSoulStone->AddOrRemovePlayerBuff(player, 0, olditemid, SS_CX);
+
+                player->AddItem(olditemid, 1);
+
+                if (sSoulStone->IsActi(player, page))
+                {
+                    sSoulStone->RemoveActi(player, page);
+                }
+            }
+
+        }
+
+        if (sender == GOSSIP_SENDER_SEC_SS_BUY)
+        {
+            if (action > GOSSIP_ACTION_SS_BUY)
+            {
+                uint32 page = action - GOSSIP_ACTION_SS_BUY;
+
+                sSoulStone->PlayerBuyPage(player, page);
+            }
+        }
+
+    }
+
+	void OnLogin(Player* player)
+    {
+        //³õÊ¼»¯»êÓñÐÅÏ¢
+        if (!sSoulStone->IsData(player))
+        {
+            sSoulStone->CreatePlayerDate(player);
+        }
+		else
+		{
+			sSoulStone->UpdatePlayerDate(player);
+		}
+        sSoulStone->setPlayerDataForPage(player);
+    }
+};
+
+void SoulStone::setPlayerDataForPage(Player * player)
+{
+    if (!player)
+        return;
+
+    uint32 guid = player->GetGUIDLow();
+
+    for (auto itr = _SoulStonePlayerDataMap.begin(); itr != _SoulStonePlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            if (itr->second.itemid1)
+            {
+                if (ItemTemplate const * pProto = sObjectMgr->GetItemTemplate(itr->second.itemid1))
+                {
+                    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                    {
+                        if (const SpellInfo* info = sSpellMgr->GetSpellInfo(pProto->Spells[i].SpellId))
+                        {
+                            if (player->HasAura(info->Id))
+                                continue;
+
+                            player->CastSpell(player, info->Id);
+                        }
+                    }
+                }
+            }
+            if (itr->second.itemid2)
+            {
+                if (ItemTemplate const * pProto = sObjectMgr->GetItemTemplate(itr->second.itemid2))
+                {
+                    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                    {
+                        if (const SpellInfo* info = sSpellMgr->GetSpellInfo(pProto->Spells[i].SpellId))
+                        {
+                            if (player->HasAura(info->Id))
+                                continue;
+
+                            player->CastSpell(player, info->Id);
+                        }
+                    }
+                }
+            }
+            if (itr->second.itemid3)
+            {
+                if (ItemTemplate const * pProto = sObjectMgr->GetItemTemplate(itr->second.itemid3))
+                {
+                    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                    {
+                        if (const SpellInfo* info = sSpellMgr->GetSpellInfo(pProto->Spells[i].SpellId))
+                        {
+                            if (player->HasAura(info->Id))
+                                continue;
+
+                            player->CastSpell(player, info->Id);
+                        }
+                    }
+                }
+            }
+            if (itr->second.itemid4)
+            {
+                if (ItemTemplate const * pProto = sObjectMgr->GetItemTemplate(itr->second.itemid4))
+                {
+                    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                    {
+                        if (const SpellInfo* info = sSpellMgr->GetSpellInfo(pProto->Spells[i].SpellId))
+                        {
+                            if (player->HasAura(info->Id))
+                                continue;
+
+                            player->CastSpell(player, info->Id);
+                        }
+                    }
+                }
+            }
+            if (itr->second.itemid5)
+            {
+                if (ItemTemplate const * pProto = sObjectMgr->GetItemTemplate(itr->second.itemid5))
+                {
+                    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                    {
+                        if (const SpellInfo* info = sSpellMgr->GetSpellInfo(pProto->Spells[i].SpellId))
+                        {
+                            if (player->HasAura(info->Id))
+                                continue;
+
+                            player->CastSpell(player, info->Id);
+                        }
+                    }
+                }
+            }
+            if (itr->second.itemid6)
+            {
+                if (ItemTemplate const * pProto = sObjectMgr->GetItemTemplate(itr->second.itemid6))
+                {
+                    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                    {
+                        if (const SpellInfo* info = sSpellMgr->GetSpellInfo(pProto->Spells[i].SpellId))
+                        {
+                            if (player->HasAura(info->Id))
+                                continue;
+
+                            player->CastSpell(player, info->Id);
+                        }
+                    }
+                }
+            }
+            if (itr->second.itemid7)
+            {
+                if (ItemTemplate const * pProto = sObjectMgr->GetItemTemplate(itr->second.itemid7))
+                {
+                    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                    {
+                        if (const SpellInfo* info = sSpellMgr->GetSpellInfo(pProto->Spells[i].SpellId))
+                        {
+                            if (player->HasAura(info->Id))
+                                continue;
+
+                            player->CastSpell(player, info->Id);
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+
+
+class SoulStoneWorldScript : public WorldScript
+{
+public:
+	SoulStoneWorldScript() : WorldScript("SoulStoneWorldScript") {}
+
+	void OnAfterConfigLoad(bool /*reload*/)
+	{
+		sSoulStone->Load();
+	}
+};
+
+void AddSC_SoulStoneScripts()
+{
+    new SoulStonePlayerScript();
+	new SoulStoneWorldScript();
+}
+
+
diff --git a/src/server/scripts/Custom/SoulStone/SoulStone.h b/src/server/scripts/Custom/SoulStone/SoulStone.h
new file mode 100644
index 0000000..17f3062
--- /dev/null
+++ b/src/server/scripts/Custom/SoulStone/SoulStone.h
@@ -0,0 +1,155 @@
+ï»¿#include "Chat.h"
+#include "ScriptMgr.h"
+#include "AccountMgr.h"
+#include "ArenaTeamMgr.h"
+#include "CellImpl.h"
+#include "GridNotifiers.h"
+#include "Group.h"
+#include "GuildMgr.h"
+#include "InstanceSaveMgr.h"
+#include "Language.h"
+#include "MovementGenerator.h"
+#include "ObjectAccessor.h"
+#include "Opcodes.h"
+#include "SpellAuras.h"
+#include "TargetedMovementGenerator.h"
+#include "WeatherMgr.h"
+#include "ace/INET_Addr.h"
+#include "Player.h"
+#include "Pet.h"
+#include "LFG.h"
+#include "GroupMgr.h"
+#include "BattlegroundMgr.h"
+#include "MapManager.h"
+
+
+
+enum SoulStoneSlotType
+{
+    SS_XQ = 1,
+    SS_FG = 2,
+    SS_CX = 3,
+};
+
+//struct SoulStoneExDate
+//{
+//    uint32 page;
+//    uint32 itemid1;
+//    uint32 itemid2;
+//    uint32 itemid3;
+//    uint32 itemid4;
+//    uint32 itemid5;
+//    uint32 itemid6;
+//    uint32 itemid7;
+//};
+
+struct SoulStoneItemType
+{
+	uint32 page;
+	uint32 type;
+};
+
+
+struct SoulStonePlayerData
+{
+    uint32 guid;
+    uint32 page;
+    uint32 itemid1;
+    uint32 itemid2;
+    uint32 itemid3;
+    uint32 itemid4;
+    uint32 itemid5;
+    uint32 itemid6;
+    uint32 itemid7;
+};
+
+
+struct SoulStoneBuyReqData
+{
+    uint32 page;
+    uint32 itemid1;
+    uint32 val1;
+    uint32 itemid2;
+    uint32 val2;
+    uint32 itemid3;
+    uint32 val3;
+    uint32 itemid4;
+    uint32 val4;
+    uint32 itemid5;
+    uint32 val5;
+    uint32 vip;
+    uint32 junxian;
+    uint32 zhuansheng;
+    uint32 douqival;
+    uint32 money;
+    uint32 jihuoshuxingid;
+};
+
+class SoulStone
+{
+public:
+    static SoulStone * instance()
+    {
+        static SoulStone instance;
+        return &instance;
+    }
+
+    void setPlayerDataForPage(Player * player);
+    void Load();
+    void ReLoad();
+    void SendMutualData(Player * player);
+    void SendPlayerDataForPage(Player * player, uint32 page);
+    void SavePlayerAllDate(Player * player);
+    void CreatePlayerDate(Player * player);
+    void SavePlayerSlotToSTL(Player * player, uint32 page, uint32 slot,uint32 itemid);
+    void SavePlayerSlotToBase(Player * player, uint32 page, uint32 slot,uint32 itemid);
+    void AddOrRemovePlayerBuff(Player * player, uint32 itemid,uint32 olditemid = 0, SoulStoneSlotType t = SS_XQ);
+    void PlayerBuyPage(Player * player, uint32 page);
+    uint32 GetPlayerMaxPage(Player * player);
+    //uint32 GetItemType(uint32 itemid);
+	uint32 GetItemType(uint32 itemid);
+	int32 GetItemPage(uint32 itemid);
+
+    uint32 GetPageActi(uint32 page);
+    uint32 GetOldItemId(Player * player, uint32 page, uint32 slot);
+    void SetPlayerMsg(Player * player, std::string msg) { if (!player) return; uint32 guid = player->GetGUIDLow(); _SoulStonePlayerMsgMap[guid] = msg; }
+    std::string GetPlayerMsg(Player * player) { if (!player) return ""; uint32 guid = player->GetGUIDLow(); return _SoulStonePlayerMsgMap[guid]; }
+    void SendAllActiData(Player * player);
+    void SendActiDataToClient(Player * player, uint32 page);
+    void SendUnActiDataToClient(Player * player, uint32 page);
+    void SetActi(Player * player, uint32 page);
+    void RemoveActi(Player * player, uint32 page);
+    void CanInSetToSlot(Player * player, uint32 page, uint32 slot, uint32 itemid, std::string msg);
+    void CanRemoveSlot(Player * player, uint32 page, uint32 slot, std::string msg);
+    bool IfSoulStoneItem(uint32 item) { auto itr = _SoulStoneItemTypeMap.find(item);  if (itr == _SoulStoneItemTypeMap.end())return false; else return true; }
+    bool CanSetActi(Player * player, uint32 page);
+    bool IsActi(Player * player,uint32 page);
+    bool IsData(Player * player);
+    bool IsBuyPageReq(Player * player,uint32 page);
+    void RemoveReq(Player * player, uint32 page);
+    void SendBuyIsOkPage(Player * player, uint32 page);
+    void SetActiId(Player * player, uint32 page, uint32 itemid);
+    void AgainAddLoseBuff(Player * player);
+	void UpdatePlayerDate(Player * player);
+
+	std::vector<std::string> split(std::string str, std::string pattern);
+    uint32 GetExActiId(Player * player, uint32 page);
+
+
+    typedef std::multimap<uint32, SoulStonePlayerData> SoulStonePlayerDataMap;
+    typedef std::map<uint32, SoulStoneBuyReqData>  SoulStoneBuyReqDataMap;
+	typedef std::map<uint32, SoulStoneItemType> SoulStoneItemTypeMap;
+    typedef std::map<uint32, std::string> SoulStonePlayerMsgMap;
+    //typedef std::multimap<uint32, SoulStoneExDate> SoulStoneExDateMap;
+
+private:
+
+    SoulStonePlayerDataMap _SoulStonePlayerDataMap;
+    SoulStoneBuyReqDataMap _SoulStoneBuyReqDataMap;
+    SoulStoneItemTypeMap _SoulStoneItemTypeMap;
+    SoulStonePlayerMsgMap _SoulStonePlayerMsgMap;
+    //SoulStoneExDateMap _SoulStoneExDateMap;
+	uint32 limitpageval;
+};
+
+#define sSoulStone SoulStone::instance()
diff --git a/src/server/scripts/Custom/SoulStoneEx/SoulStoneEx.cpp b/src/server/scripts/Custom/SoulStoneEx/SoulStoneEx.cpp
new file mode 100644
index 0000000..2c9efe5
--- /dev/null
+++ b/src/server/scripts/Custom/SoulStoneEx/SoulStoneEx.cpp
@@ -0,0 +1,1609 @@
+
+#include "SoulStoneEx.h"
+#include "Object.h"
+#include "../GCAddon/GCAddon.h"
+#include "../CommonFunc/CommonFunc.h"
+
+
+#pragma execution_character_set("UTF-8")
+
+
+void SoulStoneEx::Load()
+{
+    _SoulStoneExPlayerDataMap.clear();
+
+    QueryResult result = WorldDatabase.PQuery("SELECT Íæ¼ÒGUID,Ò³Ãæ,²å²Û1ÎïÆ·ID,²å²Û2ÎïÆ·ID,²å²Û3ÎïÆ·ID,²å²Û4ÎïÆ·ID,²å²Û5ÎïÆ·ID,²å²Û6ÎïÆ·ID,ÊÇ·ñ¼¤»îÒ³ÃæÊôÐÔ FROM Íæ¼Ò»êÓñÀ©Õ¹¼ÇÂ¼±í");
+
+    if (result)
+    {
+        uint32 count = 0;
+        do
+        {
+            Field * fields = result->Fetch();
+
+            SoulStoneExPlayerData td;
+
+            td.guid = fields[0].GetUInt32();
+            td.page = fields[1].GetUInt32();
+            td.itemid1 = fields[2].GetUInt32();
+            td.itemid2 = fields[3].GetUInt32();
+            td.itemid3 = fields[4].GetUInt32();
+            td.itemid4 = fields[5].GetUInt32();
+            td.itemid5 = fields[6].GetUInt32();
+            td.itemid6 = fields[7].GetUInt32();
+            td.itemid7 = fields[8].GetUInt32();
+
+            _SoulStoneExPlayerDataMap.insert({td.guid,td});
+            ++count;
+
+        } while (result->NextRow());
+        sLog->outString("======¼ÓÔØÍæ¼Ò»êÓñÀ©Õ¹¼ÇÂ¼±í %u ÌõÊý¾Ý======", count);
+    }
+
+    _SoulStoneExBuyReqDataMap.clear();
+
+    QueryResult results = WorldDatabase.PQuery("SELECT Ò³Ãæ,ÐèÇóÎïÆ·1,ÊýÁ¿1,ÐèÇóÎïÆ·2,ÊýÁ¿2,ÐèÇóÎïÆ·3,ÊýÁ¿3,ÐèÇóÎïÆ·4,ÊýÁ¿4,ÐèÇóÎïÆ·5,ÊýÁ¿5,VIP,¾üÏÎ,×ªÉú,¶·ÆøÖµ,½ð±Ò,¼¤»î¸øÓèBUFFµÄÎïÆ·ID FROM »êÓñÒ³Ãæ¹ºÂòÐèÇó¼¤»î±í");
+
+    if (results)
+    {
+        uint32 count = 0;
+        do
+        {
+            Field * fields = results->Fetch();
+
+            SoulStoneExBuyReqData td;
+
+            td.page = fields[0].GetUInt32();
+            td.itemid1 = fields[1].GetUInt32();
+            td.val1 = fields[2].GetUInt32();
+            td.itemid2 = fields[3].GetUInt32();
+            td.val2 = fields[4].GetUInt32();
+            td.itemid3 = fields[5].GetUInt32();
+            td.val3 = fields[6].GetUInt32();
+            td.itemid4 = fields[7].GetUInt32();
+            td.val4 = fields[8].GetUInt32();
+            td.itemid5 = fields[9].GetUInt32();
+            td.val5 = fields[10].GetUInt32();
+            td.vip = fields[11].GetUInt32();
+            td.junxian = fields[12].GetUInt32();
+            td.zhuansheng = fields[13].GetUInt32();
+            td.douqival = fields[14].GetUInt32();
+            td.money = fields[15].GetUInt32() * GOLD;
+            td.jihuoshuxingid = fields[16].GetUInt32();
+
+            _SoulStoneExBuyReqDataMap.insert({td.page,td});
+            
+            ++count;
+
+        } while (results->NextRow());
+        sLog->outString("======¼ÓÔØ»êÓñÒ³Ãæ¹ºÂòÐèÇó¼¤»î±í %u ÌõÊý¾Ý======", count);
+    }
+
+	_SoulStoneExItemTypeMap.clear();
+
+	QueryResult resultss = WorldDatabase.PQuery("SELECT ÎïÆ·ID,ÎïÆ·ÀàÐÍID,Ò³Êý FROM »êÓñÀ©Õ¹ÀàÐÍ±í");
+
+	if (resultss)
+	{
+		uint32 count = 0;
+		do
+		{
+			Field * fields = resultss->Fetch();
+
+			SoulStoneExItemType td;
+
+			uint32 itemid = fields[0].GetUInt32();
+			td.type = fields[1].GetInt32();
+			td.page = fields[2].GetInt32();
+
+			_SoulStoneExItemTypeMap.insert({ itemid, td });
+
+			++count;
+
+		} while (resultss->NextRow());
+		sLog->outString("======¼ÓÔØ»êÓñÀ©Õ¹ÀàÐÍ±í %u ÌõÊý¾Ý======", count);
+	}
+
+	QueryResult resultssss = WorldDatabase.PQuery("SELECT ²ÎÊý FROM __Í¨ÓÃÅäÖÃ WHERE ID = 101");
+
+	if (resultssss)
+	{
+
+		Field * fields = resultssss->Fetch();
+		limitpageval = uint32(atoi(fields[0].GetString().c_str()));
+
+		sLog->outString("=======»êÓñ£¨×éºÏ¼¤»î°æ£©³õÊ¼»¯Ò³ÃæÊýÁ¿Îª£º%d", limitpageval);
+	}
+
+    _SoulStoneExExDateMap.clear();
+
+    QueryResult resultsss = WorldDatabase.PQuery("SELECT Ò³Ãæ,²å²Û1ÎïÆ·ID,²å²Û2ÎïÆ·ID,²å²Û3ÎïÆ·ID,²å²Û4ÎïÆ·ID,²å²Û5ÎïÆ·ID,²å²Û6ÎïÆ·ID,¼¤»îÎïÆ·ID FROM »êÓñ×éºÏÅäÖÃ±í");
+
+    if (resultsss)
+    {
+        uint32 count = 0;
+        do
+        {
+            Field * fields = resultsss->Fetch();
+            SoulStoneExDate td;
+
+            td.page = fields[0].GetUInt32();
+            td.itemid1 = fields[1].GetUInt32();
+            td.itemid2 = fields[2].GetUInt32();
+            td.itemid3 = fields[3].GetUInt32();
+            td.itemid4 = fields[4].GetUInt32();
+            td.itemid5 = fields[5].GetUInt32();
+            td.itemid6 = fields[6].GetUInt32();
+            td.itemid7 = fields[7].GetUInt32();
+
+            _SoulStoneExExDateMap.insert({td.page,td});
+
+            ++count;
+
+        } while (resultsss->NextRow());
+
+        sLog->outString("======¼ÓÔØ»êÓñ×éºÏÅäÖÃ±í %u ÌõÊý¾Ý======", count);
+    }
+}
+
+//ÖØÔØ 
+void SoulStoneEx::ReLoad()
+{
+    Load();
+
+    SessionMap const& sessions = sWorld->GetAllSessions();
+    for (SessionMap::const_iterator it = sessions.begin(); it != sessions.end(); ++it)
+        if (Player* player = it->second->GetPlayer())
+        {
+            SendMutualData(player);
+        }
+}
+
+void SoulStoneEx::SendMutualData(Player * player)
+{
+    if (!player)
+        return;
+
+	uint32 p = limitpageval;
+
+	if (!p)
+	{
+		sGCAddon->SendPacketTo(player, "SSSEX_LIMIT_VAL", std::to_string(p));
+		return;
+	}
+
+    uint32 num = sSoulStoneEx->GetPlayerMaxPage(player);
+
+    std::string val = std::to_string(sSoulStoneEx->GetPlayerMaxPage(player));
+
+	sGCAddon->SendPacketTo(player, "SSSEX_LIMIT_VAL", val);
+
+    for (uint8 i = 1; i< num + 1; ++i)
+    {
+        SendPlayerDataForPage(player, i);
+    }
+   
+}
+
+void SoulStoneEx::SendPlayerDataForPage(Player * player, uint32 page)
+{
+    if (!player)
+        return;
+
+    uint32 guid = player->GetGUIDLow();
+
+    for (auto itr = _SoulStoneExPlayerDataMap.begin(); itr != _SoulStoneExPlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            if (itr->second.page == page)
+            {
+                std::ostringstream ss1;
+                std::ostringstream ss2;
+                std::ostringstream ss3;
+                std::ostringstream ss4;
+                std::ostringstream ss5;
+                std::ostringstream ss6;
+
+				ss1 << itr->second.page << "#1#" << itr->second.itemid1 << "#" << sCF->GetItemLink(itr->second.itemid1);
+				ss2 << itr->second.page << "#2#" << itr->second.itemid2 << "#" << sCF->GetItemLink(itr->second.itemid2);
+				ss3 << itr->second.page << "#3#" << itr->second.itemid3 << "#" << sCF->GetItemLink(itr->second.itemid3);
+				ss4 << itr->second.page << "#4#" << itr->second.itemid4 << "#" << sCF->GetItemLink(itr->second.itemid4);
+				ss5 << itr->second.page << "#5#" << itr->second.itemid5 << "#" << sCF->GetItemLink(itr->second.itemid5);
+				ss6 << itr->second.page << "#6#" << itr->second.itemid6 << "#" << sCF->GetItemLink(itr->second.itemid6);
+
+				sGCAddon->SendPacketTo(player, "SSSEX_XQ_FG", ss1.str());
+				sGCAddon->SendPacketTo(player, "SSSEX_XQ_FG", ss2.str());
+				sGCAddon->SendPacketTo(player, "SSSEX_XQ_FG", ss3.str());
+				sGCAddon->SendPacketTo(player, "SSSEX_XQ_FG", ss4.str());
+				sGCAddon->SendPacketTo(player, "SSSEX_XQ_FG", ss5.str());
+				sGCAddon->SendPacketTo(player, "SSSEX_XQ_FG", ss6.str());
+            }
+        }
+    }
+}
+
+void SoulStoneEx::SavePlayerAllDate(Player * player)
+{
+    if (!player)
+        return;
+
+    uint32 guid = player->GetGUIDLow();
+
+    for (auto itr = _SoulStoneExPlayerDataMap.begin(); itr != _SoulStoneExPlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+
+			if (itr->second.page == 0)
+				continue;
+
+            WorldDatabase.PExecute("REPLACE INTO Íæ¼Ò»êÓñÀ©Õ¹¼ÇÂ¼±í(Íæ¼ÒGUID,Ò³Ãæ,²å²Û1ÎïÆ·ID,²å²Û2ÎïÆ·ID,²å²Û3ÎïÆ·ID,²å²Û4ÎïÆ·ID,²å²Û5ÎïÆ·ID,²å²Û6ÎïÆ·ID,ÊÇ·ñ¼¤»îÒ³ÃæÊôÐÔ)VALUES(%u,%u,%u,%u,%u,%u,%u,%u,%u)", itr->second.guid, itr->second.page, itr->second.itemid1, itr->second.itemid2, itr->second.itemid3, itr->second.itemid4, itr->second.itemid5, itr->second.itemid6, itr->second.itemid7);
+        }
+    }
+}
+
+void SoulStoneEx::CreatePlayerDate(Player * player)
+{
+    if (!player)
+        return;
+
+	for (uint32 i = 1; i < limitpageval + 1; ++i)
+    {
+        SoulStoneExPlayerData td;
+        td.guid = player->GetGUIDLow();
+        td.page = i;
+        td.itemid1 = 0;
+        td.itemid2 = 0;
+        td.itemid3 = 0;
+        td.itemid4 = 0;
+        td.itemid5 = 0;
+        td.itemid6 = 0;
+        td.itemid7 = 0;
+
+        _SoulStoneExPlayerDataMap.insert({ td.guid,td });
+    }
+
+    SavePlayerAllDate(player);
+}
+
+void SoulStoneEx::SavePlayerSlotToSTL(Player * player, uint32 page, uint32 slot, uint32 itemid)
+{
+    if (!player)
+        return;
+
+    if (slot > 6)
+        return;
+
+    uint32 guid = player->GetGUIDLow();
+
+    for (auto itr = _SoulStoneExPlayerDataMap.begin(); itr != _SoulStoneExPlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            if (itr->second.page == page)
+            {
+                switch (slot)
+                {
+                case 1:
+                    itr->second.itemid1 = itemid;
+                    return;
+                case 2:
+                    itr->second.itemid2 = itemid;
+                    return;
+                case 3:
+                    itr->second.itemid3 = itemid;
+                    return;
+                case 4:
+                    itr->second.itemid4 = itemid;
+                    return;
+                case 5:
+                    itr->second.itemid5 = itemid;
+                    return;
+                case 6:
+                    itr->second.itemid6 = itemid;
+                    return;
+                default:
+                    return;
+                }
+            }
+        }
+    }
+
+    //SavePlayerSlotToBase(player, page, slot,itemid);
+    //SavePlayerAllDate(player);
+}
+
+void SoulStoneEx::SavePlayerSlotToBase(Player * player, uint32 page, uint32 slot, uint32 itemid)
+{
+    if (!player)
+        return;
+
+    if (slot > 6)
+        return;
+
+	if (page == 0)
+		return;
+
+    uint32 guid = player->GetGUIDLow();
+
+    for (auto itr = _SoulStoneExPlayerDataMap.begin(); itr != _SoulStoneExPlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            if (itr->second.page == page)
+            {
+                switch (slot)
+                {
+                case 1:
+                    WorldDatabase.PExecute("REPLACE INTO Íæ¼Ò»êÓñÀ©Õ¹¼ÇÂ¼±í(Íæ¼ÒGUID,Ò³Ãæ,²å²Û1ÎïÆ·ID)VALUES(%u,%u,%u)", guid, page, itemid);
+                    return;
+                case 2:
+                    WorldDatabase.PExecute("REPLACE INTO Íæ¼Ò»êÓñÀ©Õ¹¼ÇÂ¼±í(Íæ¼ÒGUID,Ò³Ãæ,²å²Û2ÎïÆ·ID)VALUES(%u,%u,%u)", guid, page, itemid);
+                    return;
+                case 3:
+                    WorldDatabase.PExecute("REPLACE INTO Íæ¼Ò»êÓñÀ©Õ¹¼ÇÂ¼±í(Íæ¼ÒGUID,Ò³Ãæ,²å²Û3ÎïÆ·ID)VALUES(%u,%u,%u)", guid, page, itemid);
+                    return;
+                case 4:
+                    WorldDatabase.PExecute("REPLACE INTO Íæ¼Ò»êÓñÀ©Õ¹¼ÇÂ¼±í(Íæ¼ÒGUID,Ò³Ãæ,²å²Û4ÎïÆ·ID)VALUES(%u,%u,%u)", guid, page, itemid);
+                    return;
+                case 5:
+                    WorldDatabase.PExecute("REPLACE INTO Íæ¼Ò»êÓñÀ©Õ¹¼ÇÂ¼±í(Íæ¼ÒGUID,Ò³Ãæ,²å²Û5ÎïÆ·ID)VALUES(%u,%u,%u)", guid, page, itemid);
+                    return;
+                case 6:
+                    WorldDatabase.PExecute("REPLACE INTO Íæ¼Ò»êÓñÀ©Õ¹¼ÇÂ¼±í(Íæ¼ÒGUID,Ò³Ãæ,²å²Û6ÎïÆ·ID)VALUES(%u,%u,%u)", guid, page, itemid);
+                    return;
+                default:
+                    break;
+                }
+            }
+        }
+    }
+}
+
+void SoulStoneEx::AddOrRemovePlayerBuff(Player * player, uint32 itemid, uint32 olditemid, SoulStoneExSlotType t)
+{
+    sLog->outString("olditemid = %u", olditemid);
+
+    ItemTemplate const * pProto = sObjectMgr->GetItemTemplate(itemid);
+
+    ItemTemplate const * pProts = sObjectMgr->GetItemTemplate(olditemid);
+
+    if (itemid != 0 && !pProto)
+        return;
+
+    if (olditemid != 0 && !pProts)
+        return;
+
+    if (t == SSEX_FG)
+    {
+        if (olditemid == 0)
+            return;
+
+        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+        {
+            _Spell const& spellData = pProto->Spells[i];
+            _Spell const& spellDatas = pProts->Spells[i];
+
+            // no spell
+            if (!spellData.SpellId)
+                continue;
+            if (Aura * aura = player->GetAura(spellDatas.SpellId))
+            {
+                player->RemoveAura(aura);
+            }
+
+            player->CastSpell(player, spellData.SpellId);
+        }
+    }
+
+    if (t == SSEX_XQ)
+    {
+        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+        {
+            _Spell const& spellData = pProto->Spells[i];
+
+            // no spell
+            if (!spellData.SpellId)
+                continue;
+
+            player->CastSpell(player, spellData.SpellId);
+        }
+    }
+
+    if (t == SSEX_CX)
+    {
+        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+        {
+            _Spell const& spellDatas = pProts->Spells[i];
+
+            if (Aura * aura = player->GetAura(spellDatas.SpellId))
+            {
+                player->RemoveAura(aura);
+            }
+        }
+    }
+}
+
+void SoulStoneEx::PlayerBuyPage(Player * player, uint32 page)
+{
+    //Õâ¸öºÃÏñ²»ÄÜ·Åµ½ÕâÀï Òª·Åµ½ÅÐ¶¨ÊÇ·ñÓÐ¹ºÂòÐèÇóÄÇÀï Ê×Î»  È»ºóÕâÀï×îµ×ÏÂ »òÐíÒª·Å¸ö ·¢ËÍ¼¤»î²Ù×÷Âëµ½¿Í»§¶Ë
+    if (page > GetPlayerMaxPage(player) + 1)
+    {
+        //ÌáÊ¾Òª°´Ë³Ðò¹ºÂòÒ³Ãæ
+        return;
+    }
+
+
+    RemoveReq(player, page);
+
+    SoulStoneExPlayerData td;
+    td.guid = player->GetGUIDLow();
+    td.page = page;
+    td.itemid1 = 0;
+    td.itemid2 = 0;
+    td.itemid3 = 0;
+    td.itemid4 = 0;
+    td.itemid5 = 0;
+    td.itemid6 = 0;
+    td.itemid7 = 0;
+
+    _SoulStoneExPlayerDataMap.insert({ td.guid,td });
+
+    //SavePlayerAllDate(player);
+
+    SendBuyIsOkPage(player,page);
+}
+
+uint32 SoulStoneEx::GetPlayerMaxPage(Player * player)
+{
+    uint32 guid = player->GetGUIDLow();
+
+    uint32 count = 0;
+
+    for (auto itr = _SoulStoneExPlayerDataMap.begin(); itr != _SoulStoneExPlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            ++count;
+        }
+    }
+
+    return count;
+}
+
+
+uint32 SoulStoneEx::GetItemType(uint32 itemid)
+{
+	auto itr = _SoulStoneExItemTypeMap.find(itemid);
+
+	if (itr != _SoulStoneExItemTypeMap.end())
+		return itr->second.type;
+
+	return 0;
+}
+
+int32 SoulStoneEx::GetItemPage(uint32 itemid)
+{
+	auto itr = _SoulStoneExItemTypeMap.find(itemid);
+
+	if (itr != _SoulStoneExItemTypeMap.end())
+		return itr->second.page;
+
+	return -1;
+}
+
+//uint32 SoulStoneEx::GetItemType(uint32 itemid)
+//{
+//    auto itr = _SoulStoneExItemTypeMap.find(itemid);
+//
+//    if (itr != _SoulStoneExItemTypeMap.end())
+//        return itr->second;
+//
+//    return 0;
+//}
+
+uint32 SoulStoneEx::GetPageActi(uint32 page)
+{
+    auto itr = _SoulStoneExBuyReqDataMap.find(page);
+
+    if (itr != _SoulStoneExBuyReqDataMap.end())
+        return itr->second.jihuoshuxingid;
+
+    return 0;
+}
+
+uint32 SoulStoneEx::GetOldItemId(Player * player, uint32 page, uint32 slot)
+{
+    uint32 guid = player->GetGUID();
+
+    for (auto itr = _SoulStoneExPlayerDataMap.begin(); itr != _SoulStoneExPlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            if (itr->second.page == page)
+            {
+                switch (slot)
+                {
+                case 1:
+                    return itr->second.itemid1;
+                case 2:
+                    return itr->second.itemid2;
+                case 3:
+                    return itr->second.itemid3;
+                case 4:
+                    return itr->second.itemid4;
+                case 5:
+                    return itr->second.itemid5;
+                case 6:
+                    return itr->second.itemid6;
+                default:
+                    break;
+                }
+            }
+        }
+    }
+
+    return 0;
+}
+
+void SoulStoneEx::SendAllActiData(Player * player)
+{
+
+	uint32 maxpage = GetPlayerMaxPage(player);
+
+	if (maxpage < limitpageval)
+		maxpage = limitpageval;
+
+	for (uint32 i = 1; i < maxpage + 1; ++i)
+    {
+        if (sSoulStoneEx->IsActi(player, i))
+        {
+            SendActiDataToClient(player, i);
+        }
+    }
+}
+
+void SoulStoneEx::SendActiDataToClient(Player * player, uint32 page)
+{
+    std::ostringstream ss;
+
+    //uint32 itemid = GetPageActi(page);
+    uint32 itemid = GetExActiId(player, page);
+
+    
+    std::string itemlink = sCF->GetItemLink(itemid);
+
+    ss << page << "#" << itemid << "#" << itemlink;
+   
+	sGCAddon->SendPacketTo(player, "SSSEX_ACTI_VAL", ss.str());
+
+}
+
+
+void SoulStoneEx::SendUnActiDataToClient(Player * player, uint32 page)
+{
+	sGCAddon->SendPacketTo(player, "SSSEX_ACTI_UN", std::to_string(page));
+}
+
+
+void SoulStoneEx::SetActi(Player * player, uint32 page)
+{
+    if (!player)
+        return;
+
+    //uint32 Actiid = GetPageActi(page);
+    uint32 Actiid = GetExActiId(player,page);
+    //³¢ÊÔÔÚÕâ»ñµÃÀ©Õ¹ÐÔÒ³Ãæ¼¤»îID ¶ÔÓ¦Íæ¼Òguid  Ò³Ãæ ÒÔ¼° Ò³ÃæÄÚËùÓÐ1~6µÄÎïÆ·ID µÃµ½¼¤»îID
+
+    if (Actiid != 0)
+    {
+        ItemTemplate const * pProto = sObjectMgr->GetItemTemplate(Actiid);
+
+        if (!pProto)
+        {
+            //¿ÉÒÔÐ´ÌáÊ¾Óï¾ä
+            return;
+        }
+
+        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+        {
+            _Spell const& spellData = pProto->Spells[i];
+
+            // no spell
+            if (!spellData.SpellId)
+                continue;
+
+            player->CastSpell(player, spellData.SpellId);
+        }
+
+        //uint32 itemid7 = GetPageActi(page);
+        uint32 itemid7 = GetExActiId(player,page);
+
+        SetActiId(player, page, itemid7);
+
+        SendActiDataToClient(player, page);
+    }
+}
+
+void SoulStoneEx::RemoveActi(Player * player, uint32 page)
+{
+    if (!player)
+        return;
+
+    //uint32 Actiid = GetPageActi(page);
+    uint32 Actiid = GetExActiId(player,page);
+
+    if (Actiid != 0)
+    {
+        ItemTemplate const * pProto = sObjectMgr->GetItemTemplate(Actiid);
+
+        if (!pProto)
+        {
+            //¿ÉÒÔÐ´ÌáÊ¾Óï¾ä
+            return;
+        }
+
+        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+        {
+            _Spell const& spellData = pProto->Spells[i];
+
+            // no spell
+            if (!spellData.SpellId)
+                continue;
+
+            if (Aura * aura = player->GetAura(spellData.SpellId))
+            {
+                player->RemoveAura(aura);
+            }
+        }
+
+        SetActiId(player, page, 0);
+
+        SendUnActiDataToClient(player, page);
+    }
+}
+
+
+bool SoulStoneEx::CanSetActi(Player * player, uint32 page)
+{
+    uint32 guid = player->GetGUIDLow();
+
+    for (auto itr = _SoulStoneExPlayerDataMap.begin(); itr != _SoulStoneExPlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            if (itr->second.page == page)
+            {
+                if (itr->second.itemid1 > 0 && itr->second.itemid2 > 0 && itr->second.itemid3 > 0 && itr->second.itemid4 > 0 && itr->second.itemid5 > 0 && itr->second.itemid6 > 0)
+                {
+                    return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
+
+
+bool SoulStoneEx::IsActi(Player * player, uint32 page)
+{
+
+    uint32 guid = player->GetGUIDLow();
+
+    for (auto itr = _SoulStoneExPlayerDataMap.begin(); itr != _SoulStoneExPlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            if (itr->second.page == page)
+            {
+                if (itr->second.itemid7 == 0)
+                {
+                    return false;
+                }
+            }
+        }
+    }
+
+    return true;
+}
+
+
+//void SoulStoneEx::CanInSetToSlot(Player * player, uint32 page, uint32 slot, uint32 itemid, std::string msg)
+//{
+//    if (page > GetPlayerMaxPage(player))
+//        return;
+//
+//    ItemTemplate const * pProto = sObjectMgr->GetItemTemplate(itemid);
+//
+//    if (!player || !pProto || !IfSoulStoneItem(itemid))
+//    {
+//        //ÌáÊ¾Î´ÖªÎÊÌâ 
+//        return;
+//    }
+//
+//	uint32 maxpage = GetPlayerMaxPage(player);
+//
+//	if (page > maxpage)
+//	{
+//		//ÌáÊ¾ÇëÎð·Ç·¨Ê¹ÓÃ²å¼þ,²»ÄÜÊ¹ÓÃÎ´¹ºÂòµÄ»êÓñÒ³Ãæ
+//		return;
+//	}
+//
+//    uint32 guid = player->GetGUIDLow();
+//
+//    uint32 newitemtype = GetItemType(itemid);
+//
+//    uint32 olditemtype = 0;
+//
+//    uint32 olditemid = 0;
+//
+//    player->PlayerTalkClass->ClearMenus();
+//
+//    std::ostringstream ss;
+//
+//    for (auto itr = _SoulStoneExPlayerDataMap.begin(); itr != _SoulStoneExPlayerDataMap.end(); ++itr)
+//    {
+//        if (itr->first == guid)
+//        {
+//            if (itr->second.page == page)
+//            {
+//                switch (slot)
+//                {
+//                case 1:
+//                    olditemtype = GetItemType(itr->second.itemid1);
+//                    olditemid = itr->second.itemid1;
+//                    break;
+//                case 2:
+//                    olditemtype = GetItemType(itr->second.itemid2);
+//                    olditemid = itr->second.itemid2;
+//                    break;
+//                case 3:
+//                    olditemtype = GetItemType(itr->second.itemid3);
+//                    olditemid = itr->second.itemid3;
+//                    break;
+//                case 4:
+//                    olditemtype = GetItemType(itr->second.itemid4);
+//                    olditemid = itr->second.itemid4;
+//                    break;
+//                case 5:
+//                    olditemtype = GetItemType(itr->second.itemid5);
+//                    olditemid = itr->second.itemid5;
+//                    break;
+//                case 6:
+//                    olditemtype = GetItemType(itr->second.itemid6);
+//                    olditemid = itr->second.itemid6;
+//                    break;
+//                default:
+//                    break;
+//                }
+//            }
+//        }
+//    }
+//
+//    
+//    if (olditemid == 0)
+//    {
+//        ss << sCF->GetItemLink(itemid) << pProto->Name1.c_str() << "ÊÇ·ñÏâÇ¶µ½´Ë²å²Û?";
+//        player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_VENDOR, "", GOSSIP_SENDER_SEC_SS, GOSSIP_ACTION_SSEX + 1, ss.str().c_str(), 0, false);
+//        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+//    }
+//    else
+//    {
+//        if (ItemTemplate const * pProt = sObjectMgr->GetItemTemplate(olditemid))
+//        {
+//            ss << sCF->GetItemLink(itemid) << pProto->Name1.c_str() << "ÊÇ·ñÌæ»»²å²ÛÄÚµÄ" <<sCF->GetItemLink(olditemid) << pProt->Name1.c_str();
+//            player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_VENDOR, "", GOSSIP_SENDER_SEC_SS, GOSSIP_ACTION_SSEX + 2, ss.str().c_str(), 0, false);
+//            player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+//        }
+//    }
+//
+//    std::ostringstream str;
+//
+//    str << msg << "#" << sCF->GetItemLink(itemid);
+//
+//    SetPlayerMsg(player, str.str());
+//}
+
+void SoulStoneEx::CanInSetToSlot(Player * player, uint32 page, uint32 slot, uint32 itemid, std::string msg)
+{
+	if (page > GetPlayerMaxPage(player))
+		return;
+
+	player->PlayerTalkClass->ClearMenus();
+
+	ItemTemplate const * pProto = sObjectMgr->GetItemTemplate(itemid);
+
+	if (!player || !pProto || !IfSoulStoneItem(itemid))
+	{
+		//ÌáÊ¾Î´ÖªÎÊÌâ 
+		return;
+	}
+
+	uint32 maxpage = GetPlayerMaxPage(player);
+
+	if (page > maxpage)
+	{
+		//ÌáÊ¾ÇëÎð·Ç·¨Ê¹ÓÃ²å¼þ,²»ÄÜÊ¹ÓÃÎ´¹ºÂòµÄ»êÓñÒ³Ãæ
+		return;
+	}
+
+	uint32 guid = player->GetGUIDLow();
+
+	uint32 newitemtype = GetItemType(itemid);
+	uint32 newitempage = GetItemPage(itemid);
+
+	if (newitempage == -1 || newitemtype == 0)
+		return;
+
+	if (newitempage != page && newitempage != 0)
+	{
+		std::ostringstream sstr;
+		sstr << sCF->GetItemLink(itemid) << "´Ë»êÓñÖ»ÄÜÏâÇ¶ÔÚµÚ" << newitempage << "Ò³";
+		player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_VENDOR, "", GOSSIP_SENDER_SEC_SS_ERR, GOSSIP_ACTION_SS_ERR, sstr.str(), 0, false);
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+		return;
+	}
+
+	uint32 olditemid = 0;
+
+	std::ostringstream ss;
+
+	for (auto itr = _SoulStoneExPlayerDataMap.begin(); itr != _SoulStoneExPlayerDataMap.end(); ++itr)
+	{
+		if (itr->first == guid)
+		{
+			bool send = false;
+
+			if (itr->second.page == page)
+			{
+				if (slot == 1)
+				{
+					if (newitemtype == GetItemType(itr->second.itemid2) || newitemtype == GetItemType(itr->second.itemid3) || newitemtype == GetItemType(itr->second.itemid4) || newitemtype == GetItemType(itr->second.itemid5) || newitemtype == GetItemType(itr->second.itemid6))
+					{
+						send = true;
+					}
+				}
+
+				if (slot == 2)
+				{
+					if (newitemtype == GetItemType(itr->second.itemid1) || newitemtype == GetItemType(itr->second.itemid3) || newitemtype == GetItemType(itr->second.itemid4) || newitemtype == GetItemType(itr->second.itemid5) || newitemtype == GetItemType(itr->second.itemid6))
+					{
+						send = true;
+					}
+				}
+
+				if (slot == 3)
+				{
+					if (newitemtype == GetItemType(itr->second.itemid2) || newitemtype == GetItemType(itr->second.itemid1) || newitemtype == GetItemType(itr->second.itemid4) || newitemtype == GetItemType(itr->second.itemid5) || newitemtype == GetItemType(itr->second.itemid6))
+					{
+						send = true;
+					}
+				}
+
+				if (slot == 4)
+				{
+					if (newitemtype == GetItemType(itr->second.itemid2) || newitemtype == GetItemType(itr->second.itemid3) || newitemtype == GetItemType(itr->second.itemid1) || newitemtype == GetItemType(itr->second.itemid5) || newitemtype == GetItemType(itr->second.itemid6))
+					{
+						send = true;
+					}
+				}
+
+				if (slot == 5)
+				{
+					if (newitemtype == GetItemType(itr->second.itemid2) || newitemtype == GetItemType(itr->second.itemid3) || newitemtype == GetItemType(itr->second.itemid4) || newitemtype == GetItemType(itr->second.itemid1) || newitemtype == GetItemType(itr->second.itemid6))
+					{
+						send = true;
+					}
+				}
+
+				if (slot == 6)
+				{
+					if (newitemtype == GetItemType(itr->second.itemid2) || newitemtype == GetItemType(itr->second.itemid3) || newitemtype == GetItemType(itr->second.itemid4) || newitemtype == GetItemType(itr->second.itemid5) || newitemtype == GetItemType(itr->second.itemid1))
+					{
+						send = true;
+					}
+				}
+			}
+
+			if (send)
+			{
+				player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_VENDOR, "", GOSSIP_SENDER_SEC_SSEX_ERR, GOSSIP_ACTION_SSEX_ERR, "µ±Ç°Ò³ÃæÖ»ÄÜÏâÇ¶Ò»¸ö´ËÀàÐÍ»êÓñ", 0, false);
+				player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+				return;
+			}
+
+			switch (slot)
+			{
+			case 1:
+				olditemid = itr->second.itemid1;
+				break;
+			case 2:
+				olditemid = itr->second.itemid2;
+				break;
+			case 3:
+				olditemid = itr->second.itemid3;
+				break;
+			case 4:
+				olditemid = itr->second.itemid4;
+				break;
+			case 5:
+				olditemid = itr->second.itemid5;
+				break;
+			case 6:
+				olditemid = itr->second.itemid6;
+				break;
+			default:
+				break;
+			}
+
+		}
+	}
+
+
+	if (olditemid == 0)
+	{
+		ss << sCF->GetItemLink(itemid) << pProto->Name1.c_str() << "ÊÇ·ñÏâÇ¶µ½´Ë²å²Û?";
+		player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_VENDOR, "", GOSSIP_SENDER_SEC_SS, GOSSIP_ACTION_SSEX + 1, ss.str().c_str(), 0, false);
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+	}
+	else
+	{
+		if (ItemTemplate const * pProt = sObjectMgr->GetItemTemplate(olditemid))
+		{
+			ss << sCF->GetItemLink(itemid) << pProto->Name1.c_str() << "ÊÇ·ñÌæ»»²å²ÛÄÚµÄ" << sCF->GetItemLink(olditemid) << pProt->Name1.c_str();
+			player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_VENDOR, "", GOSSIP_SENDER_SEC_SS, GOSSIP_ACTION_SSEX + 2, ss.str().c_str(), 0, false);
+			player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+		}
+	}
+
+	std::ostringstream str;
+
+	str << msg << "#" << sCF->GetItemLink(itemid);
+
+	SetPlayerMsg(player, str.str());
+}
+
+void SoulStoneEx::CanRemoveSlot(Player * player, uint32 page, uint32 slot, std::string msg)
+{
+    if (!player)
+        return;
+
+	uint32 maxpage = GetPlayerMaxPage(player);
+
+	if (page > maxpage)
+	{
+		//ÌáÊ¾ÇëÎð·Ç·¨Ê¹ÓÃ²å¼þ,²»ÄÜÊ¹ÓÃÎ´¹ºÂòµÄ»êÓñÒ³Ãæ
+		return;
+	}
+
+    player->PlayerTalkClass->ClearMenus();
+
+    uint32 guid = player->GetGUIDLow();
+
+    uint32 olditemid = 0;
+
+    std::ostringstream ss;
+
+    for (auto itr = _SoulStoneExPlayerDataMap.begin(); itr != _SoulStoneExPlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            if (itr->second.page == page)
+            {
+                switch (slot)
+                {
+                case 1:
+                    olditemid = itr->second.itemid1;
+                    break;
+                case 2:
+                    olditemid = itr->second.itemid2;
+                    break;
+                case 3:
+                    olditemid = itr->second.itemid3;
+                    break;
+                case 4:
+                    olditemid = itr->second.itemid4;
+                    break;
+                case 5:
+                    olditemid = itr->second.itemid5;
+                    break;
+                case 6:
+                    olditemid = itr->second.itemid6;
+                    break;
+                default:
+                    break;
+                } 
+            }
+        }
+    }
+
+    ItemTemplate const * pProt = sObjectMgr->GetItemTemplate(olditemid);
+
+    if (!pProt)
+        return;
+
+    ss << "ÊÇ·ñ²ðÐ¶´Ë²å²ÛÖÐµÄ" << sCF->GetItemLink(olditemid) << pProt->Name1.c_str();
+
+    player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_VENDOR, "", GOSSIP_SENDER_SEC_SS, GOSSIP_ACTION_SSEX + 3, ss.str().c_str(), 0, false);
+
+    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+
+    std::ostringstream str;
+
+    str << msg << "#" << std::to_string(olditemid);
+
+    SetPlayerMsg(player, str.str());
+}
+
+
+bool SoulStoneEx::IsData(Player * player)
+{
+
+    uint32 guid = player->GetGUIDLow();
+
+    uint32 count = 0;
+
+    for (auto itr = _SoulStoneExPlayerDataMap.begin(); itr != _SoulStoneExPlayerDataMap.end(); ++itr)
+    {
+        if (itr->second.guid == guid)
+            ++count;
+    }
+
+    if (count == 0)
+    {
+        return false;
+    }
+
+    return true;
+
+}
+
+bool SoulStoneEx::IsBuyPageReq(Player * player, uint32 page)
+{
+    if (!player)
+        return false;
+
+    auto itr = _SoulStoneExBuyReqDataMap.find(page);
+    if (itr == _SoulStoneExBuyReqDataMap.end())
+        return false;
+
+	bool send = false;
+
+	std::ostringstream oss;
+
+	oss << "¹ºÂò»êÓñµÚ" << page << "Ò³£º\n";
+
+    if (itr->second.itemid1 > 0 && itr->second.val1 > 0)
+    {
+        if (!player->HasItemCount(itr->second.itemid1, itr->second.val1))
+        {
+			//ChatHandler(player->GetSession()).PSendSysMessage("ÐèÒªÎïÆ·£º%s * %d ¸ö",sCF->GetItemLink(itr->second.itemid1).c_str(),itr->second.val1);
+            //return false;
+			oss << "ÐèÒªÎïÆ·£º" << sCF->GetItemLink(itr->second.itemid1) << " * " << itr->second.val1 << "¸ö\n";
+			send = true;
+        }
+    }
+
+    if (itr->second.itemid2 > 0 && itr->second.val2 > 0)
+    {
+        if (!player->HasItemCount(itr->second.itemid2, itr->second.val2))
+        {
+			//ChatHandler(player->GetSession()).PSendSysMessage("ÐèÒªÎïÆ·£º%s * %d ¸ö", sCF->GetItemLink(itr->second.itemid2), itr->second.val2);
+            //return false;
+			oss << "ÐèÒªÎïÆ·£º" << sCF->GetItemLink(itr->second.itemid2) << " * " << itr->second.val2 << "¸ö\n";
+			send = true;
+        }
+    }
+
+    if (itr->second.itemid3 > 0 && itr->second.val3 > 0)
+    {
+        if (!player->HasItemCount(itr->second.itemid3, itr->second.val3))
+        {
+			//ChatHandler(player->GetSession()).PSendSysMessage("ÐèÒªÎïÆ·£º%s * %d ¸ö", sCF->GetItemLink(itr->second.itemid3), itr->second.val3);
+            //return false;
+			oss << "ÐèÒªÎïÆ·£º" << sCF->GetItemLink(itr->second.itemid3) << " * " << itr->second.val3 << "¸ö\n";
+			send = true;
+        }
+    }
+    
+    if (itr->second.itemid4 > 0 && itr->second.val4 > 0)
+    {
+        if (!player->HasItemCount(itr->second.itemid4, itr->second.val4))
+        {
+			//ChatHandler(player->GetSession()).PSendSysMessage("ÐèÒªÎïÆ·£º%s * %d ¸ö", sCF->GetItemLink(itr->second.itemid4), itr->second.val4);
+            //return false;
+			oss << "ÐèÒªÎïÆ·£º" << sCF->GetItemLink(itr->second.itemid4) << " * " << itr->second.val4 << "¸ö\n";
+			send = true;
+        }
+    }
+    
+    if (itr->second.itemid5 > 0 && itr->second.val5 > 0)
+    {
+        if (!player->HasItemCount(itr->second.itemid5, itr->second.val5))
+        {
+			//ChatHandler(player->GetSession()).PSendSysMessage("ÐèÒªÎïÆ·£º%s * %d ¸ö", sCF->GetItemLink(itr->second.itemid5), itr->second.val5);
+            //return false;
+			oss << "ÐèÒªÎïÆ·£º" << sCF->GetItemLink(itr->second.itemid5) << " * " << itr->second.val5 << "¸ö\n";
+			send = true;
+        }
+    }
+    
+
+    if (player->GetMoney() < itr->second.money)
+    {
+		//ChatHandler(player->GetSession()).PSendSysMessage("ÐèÒª½ð±Ò£º%d", uint32(itr->second.money / GOLD));
+		//return false;
+		oss << "ÐèÒª½ð±Ò£º" << uint32(itr->second.money / GOLD);
+		send = true;
+    }
+
+	if (send)
+	{
+		ChatHandler(player->GetSession()).PSendSysMessage(oss.str().c_str());
+		return false;
+	}
+
+    player->PlayerTalkClass->ClearMenus();
+
+    player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_VENDOR, "", GOSSIP_SENDER_SEC_SS_BUY, GOSSIP_ACTION_SSEX_BUY + page, "ÊÇ·ñÐèÒª¹ºÂòµÚ"+std::to_string(page)+"Ò³", 0, false);
+
+    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, player->GetGUID());
+
+    return true;
+
+}
+
+void SoulStoneEx::RemoveReq(Player * player, uint32 page)
+{
+    if (!player)
+        return;
+
+    auto itr = _SoulStoneExBuyReqDataMap.find(page);
+    if (itr == _SoulStoneExBuyReqDataMap.end())
+        return;
+
+    player->DestroyItemCount(itr->second.itemid1, itr->second.val1,true);
+
+    player->DestroyItemCount(itr->second.itemid2, itr->second.val2,true);
+
+    player->DestroyItemCount(itr->second.itemid3, itr->second.val3,true);
+
+    player->DestroyItemCount(itr->second.itemid4, itr->second.val4,true);
+
+    player->DestroyItemCount(itr->second.itemid5, itr->second.val5,true);
+
+    player->SetMoney(player->GetMoney() - (itr->second.money));
+
+}
+
+void SoulStoneEx::SendBuyIsOkPage(Player * player, uint32 page)
+{
+    std::string p = std::to_string(page);
+
+	sGCAddon->SendPacketTo(player, "SSSEX_BUY_PAGE", p);
+
+}
+
+void SoulStoneEx::SetActiId(Player * player, uint32 page,uint32 itemid)
+{
+    uint32 guid = player->GetGUIDLow();
+
+    for (auto itr = _SoulStoneExPlayerDataMap.begin(); itr != _SoulStoneExPlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            if (itr->second.page == page)
+            {
+                itr->second.itemid7 = itemid;
+            }
+        }
+    }
+
+    //SavePlayerAllDate(player);
+}
+
+void SoulStoneEx::AgainAddLoseBuff(Player * player)
+{
+    uint32 maxpage = GetPlayerMaxPage(player);
+
+    uint32 guid = player->GetGUIDLow();
+
+    for (auto itr = _SoulStoneExPlayerDataMap.begin(); itr != _SoulStoneExPlayerDataMap.end(); ++itr)
+    {
+        if (itr->first == guid)
+        {
+            ItemTemplate const * p1 = sObjectMgr->GetItemTemplate(itr->second.itemid1);
+            ItemTemplate const * p2 = sObjectMgr->GetItemTemplate(itr->second.itemid2);
+            ItemTemplate const * p3 = sObjectMgr->GetItemTemplate(itr->second.itemid3);
+            ItemTemplate const * p4 = sObjectMgr->GetItemTemplate(itr->second.itemid4);
+            ItemTemplate const * p5 = sObjectMgr->GetItemTemplate(itr->second.itemid5);
+            ItemTemplate const * p6 = sObjectMgr->GetItemTemplate(itr->second.itemid6);
+            ItemTemplate const * p7 = sObjectMgr->GetItemTemplate(itr->second.itemid7);
+
+            if (p1)
+            {
+                for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                {
+                    _Spell const& spellData = p1->Spells[i];
+
+                    // no spell
+                    if (!spellData.SpellId)
+                        continue;
+
+                    player->CastSpell(player, spellData.SpellId);
+                }
+            }
+
+            if (p2)
+            {
+                for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                {
+                    _Spell const& spellData = p2->Spells[i];
+
+                    // no spell
+                    if (!spellData.SpellId)
+                        continue;
+
+                    player->CastSpell(player, spellData.SpellId);
+                }
+            }
+
+            if (p3)
+            {
+                for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                {
+                    _Spell const& spellData = p3->Spells[i];
+
+                    // no spell
+                    if (!spellData.SpellId)
+                        continue;
+
+                    player->CastSpell(player, spellData.SpellId);
+                }
+            }
+
+            if (p4)
+            {
+                for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                {
+                    _Spell const& spellData = p4->Spells[i];
+
+                    // no spell
+                    if (!spellData.SpellId)
+                        continue;
+
+                    player->CastSpell(player, spellData.SpellId);
+                }
+            }
+
+            if (p5)
+            {
+                for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                {
+                    _Spell const& spellData = p5->Spells[i];
+
+                    // no spell
+                    if (!spellData.SpellId)
+                        continue;
+
+                    player->CastSpell(player, spellData.SpellId);
+                }
+            }
+
+            if (p6)
+            {
+                for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                {
+                    _Spell const& spellData = p6->Spells[i];
+
+                    // no spell
+                    if (!spellData.SpellId)
+                        continue;
+
+                    player->CastSpell(player, spellData.SpellId);
+                }
+            }
+
+            if (p7)
+            {
+                for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                {
+                    _Spell const& spellData = p7->Spells[i];
+
+                    // no spell
+                    if (!spellData.SpellId)
+                        continue;
+
+                    player->CastSpell(player, spellData.SpellId);
+                }
+            }
+        }
+    }
+}
+
+void SoulStoneEx::UpdatePlayerDate(Player * player)
+{
+	uint32 guid = player->GetGUIDLow();
+
+	uint32 count = 0;
+
+	for (auto itr = _SoulStoneExPlayerDataMap.begin(); itr != _SoulStoneExPlayerDataMap.end(); ++itr)
+	{
+		if (itr->second.guid == guid)
+			++count;
+	}
+
+	if (limitpageval <= count)
+		return;
+
+	uint32 i = limitpageval - count;
+
+	for (; i < limitpageval + 1; ++i)
+	{
+		SoulStoneExPlayerData td;
+		td.guid = player->GetGUIDLow();
+		td.page = i;
+		td.itemid1 = 0;
+		td.itemid2 = 0;
+		td.itemid3 = 0;
+		td.itemid4 = 0;
+		td.itemid5 = 0;
+		td.itemid6 = 0;
+		td.itemid7 = 0;
+
+		_SoulStoneExPlayerDataMap.insert({ td.guid, td });
+	}
+
+	SavePlayerAllDate(player);
+
+}
+
+uint32 SoulStoneEx::GetExActiId(Player * player, uint32 page)
+{
+    uint32 guid = player->GetGUIDLow(); 
+
+    uint32 _itemid[6] = {0,0,0,0,0,0};
+
+    for (auto itr = _SoulStoneExPlayerDataMap.begin(); itr != _SoulStoneExPlayerDataMap.end(); ++itr)
+    {
+        if (itr->second.page == page)
+        {
+            if (itr->second.itemid1 > 0 && itr->second.itemid2 > 0 && itr->second.itemid3 > 0 && itr->second.itemid4 > 0 && itr->second.itemid5 > 0 && itr->second.itemid6 > 0)
+            {
+                _itemid[0] = itr->second.itemid1;
+                _itemid[1] = itr->second.itemid2;
+                _itemid[2] = itr->second.itemid3;
+                _itemid[3] = itr->second.itemid4;
+                _itemid[4] = itr->second.itemid5;
+                _itemid[5] = itr->second.itemid6;
+            }
+        }
+    }
+
+    for (uint8 i = 0; i < 6; ++i)
+    {
+        if (_itemid[i] == 0)
+            return 0;
+    }
+
+    
+    for (auto its = _SoulStoneExExDateMap.begin(); its != _SoulStoneExExDateMap.end(); ++its)
+    {
+        if (its->second.page == page)
+        {
+            if (_itemid[0] == its->second.itemid1 && _itemid[1] == its->second.itemid2 && _itemid[2] == its->second.itemid3 && _itemid[3] == its->second.itemid4 && _itemid[4] == its->second.itemid5 && _itemid[5] == its->second.itemid6)
+            {
+                return its->second.itemid7;
+            }
+        }
+    }
+
+    return 0;
+}
+
+std::vector<std::string> SoulStoneEx::split(std::string str, std::string pattern)
+{
+	std::string::size_type pos;
+	std::vector<std::string> result;
+	str += pattern;
+	int size = str.size();
+
+	for (int i = 0; i < size; i++)
+	{
+		pos = str.find(pattern, i);
+		if (pos < size)
+		{
+			std::string s = str.substr(i, pos - i);
+			result.push_back(s);
+			i = pos + pattern.size() - 1;
+		}
+	}
+	return result;
+}
+
+class SoulStoneExPlayerScript : public PlayerScript
+{
+public:
+    SoulStoneExPlayerScript() : PlayerScript("SoulStonePlayerScript") {}
+
+    void OnPlayerChatAddon(std::string header, std::string msg, uint8 chn, Player* player)
+    {
+        if (chn == 4) //CHAT_MSG_GUILD = 4
+        {
+            if (header == "SSC_ITEM_TO_SLOT")
+            {
+                std::vector<std::string> vec = sSoulStoneEx->split(msg, "#");
+
+                uint32 page = atoi(vec[0].c_str());
+                uint32 slot = atoi(vec[1].c_str());
+                uint32 item = atoi(vec[2].c_str());
+
+                sSoulStoneEx->CanInSetToSlot(player, page, slot, item, msg);
+
+            }
+
+            if (header == "SSC_REMOVE_SLOT_ITEM")
+            {
+                std::vector<std::string> vec = sSoulStoneEx->split(msg, "#");
+
+                uint32 page = atoi(vec[0].c_str());
+                uint32 slot = atoi(vec[1].c_str());
+
+                sSoulStoneEx->CanRemoveSlot(player, page, slot, msg);
+            }
+
+            if (header == "SSC_LIMIT" && msg == "VAL")
+            {
+                sSoulStoneEx->SendMutualData(player);
+            }
+
+            if (header == "SSC_ACTI" && msg == "ISOK")
+            {
+                sSoulStoneEx->SendAllActiData(player);
+            }
+
+            if (header == "SSC_BUY_PAGE")
+            {
+                uint32 page = atoi(msg.c_str());
+
+                if (!sSoulStoneEx->IsBuyPageReq(player, page))
+                {
+                    return;
+                }
+
+            }
+        }
+    }
+
+    void OnGossipSelect(Player* player, uint32 menu_id, uint32 sender, uint32 action)
+    {
+        
+        if (sender == GOSSIP_SENDER_SEC_SS)
+        {
+
+            if (action == GOSSIP_ACTION_SSEX + 1)
+            {
+                std::string msg = sSoulStoneEx->GetPlayerMsg(player);
+				sLog->outString("msg = %s",msg.c_str());
+
+				sGCAddon->SendPacketTo(player, "SSSEX_XQ_FG", msg);
+
+                std::vector<std::string> vec = sSoulStoneEx->split(msg, "#");
+
+                uint32 page = atoi(vec[0].c_str());
+                uint32 slot = atoi(vec[1].c_str());
+                uint32 itemid = atoi(vec[2].c_str());
+
+                sSoulStoneEx->SavePlayerSlotToSTL(player, page, slot, itemid);
+
+                sSoulStoneEx->AddOrRemovePlayerBuff(player, itemid);
+
+                player->DestroyItemCount(itemid, 1,true);
+
+                if (sSoulStoneEx->CanSetActi(player, page))
+                {
+                    sSoulStoneEx->SetActi(player, page);
+                }
+            }
+
+            if (action == GOSSIP_ACTION_SSEX + 2)
+            {
+                std::string msg = sSoulStoneEx->GetPlayerMsg(player);
+
+				sGCAddon->SendPacketTo(player, "SSSEX_XQ_FG", msg);
+
+                std::vector<std::string> vec = sSoulStoneEx->split(msg, "#");
+
+                uint32 page = atoi(vec[0].c_str());
+                uint32 slot = atoi(vec[1].c_str());
+                uint32 itemid = atoi(vec[2].c_str());
+
+                uint32 olditemid = sSoulStoneEx->GetOldItemId(player, page, slot);
+
+                sSoulStoneEx->SavePlayerSlotToSTL(player, page, slot, itemid);
+
+                sSoulStoneEx->AddOrRemovePlayerBuff(player, itemid,olditemid,SSEX_FG);
+
+                player->DestroyItemCount(itemid, 1, true);
+
+                if (sSoulStoneEx->CanSetActi(player, page))
+                {
+                    sSoulStoneEx->SetActi(player, page);
+                }
+            }
+
+
+            if (action == GOSSIP_ACTION_SSEX + 3)
+            {
+                std::string msg = sSoulStoneEx->GetPlayerMsg(player);
+
+				sGCAddon->SendPacketTo(player,"SSSEX_CX",msg);
+
+                std::vector<std::string> vec = sSoulStoneEx->split(msg, "#");
+
+                uint32 page = atoi(vec[0].c_str());
+                uint32 slot = atoi(vec[1].c_str());
+
+                uint32 olditemid = sSoulStoneEx->GetOldItemId(player, page, slot);
+
+                sSoulStoneEx->SavePlayerSlotToSTL(player, page, slot, 0);
+
+                sSoulStoneEx->AddOrRemovePlayerBuff(player, 0, olditemid, SSEX_CX);
+
+                player->AddItem(olditemid, 1);
+
+                if (sSoulStoneEx->IsActi(player, page))
+                {
+                    sSoulStoneEx->RemoveActi(player, page);
+                }
+            }
+
+        }
+
+        if (sender == GOSSIP_SENDER_SEC_SS_BUY)
+        {
+            if (action > GOSSIP_ACTION_SSEX_BUY)
+            {
+                uint32 page = action - GOSSIP_ACTION_SSEX_BUY;
+
+                sSoulStoneEx->PlayerBuyPage(player, page);
+            }
+        }
+
+    }
+
+	void OnLogin(Player* player)
+    {
+        //³õÊ¼»¯»êÓñÐÅÏ¢
+        if (!sSoulStoneEx->IsData(player))
+        {
+            sSoulStoneEx->CreatePlayerDate(player);
+        }
+		else
+		{
+			sSoulStoneEx->UpdatePlayerDate(player);
+		}
+    }
+};
+
+
+class SoulStoneExWorldScript : public WorldScript
+{
+public:
+	SoulStoneExWorldScript() : WorldScript("SoulStoneWorldScript") {}
+
+	void OnAfterConfigLoad(bool /*reload*/)
+	{
+		sSoulStoneEx->Load();
+	}
+};
+
+void AddSC_SoulStoneExScripts()
+{
+    new SoulStoneExPlayerScript();
+	new SoulStoneExWorldScript();
+}
+
+
diff --git a/src/server/scripts/Custom/SoulStoneEx/SoulStoneEx.h b/src/server/scripts/Custom/SoulStoneEx/SoulStoneEx.h
new file mode 100644
index 0000000..50acb4a
--- /dev/null
+++ b/src/server/scripts/Custom/SoulStoneEx/SoulStoneEx.h
@@ -0,0 +1,153 @@
+ï»¿#include "Chat.h"
+#include "ScriptMgr.h"
+#include "AccountMgr.h"
+#include "ArenaTeamMgr.h"
+#include "CellImpl.h"
+#include "GridNotifiers.h"
+#include "Group.h"
+#include "GuildMgr.h"
+#include "InstanceSaveMgr.h"
+#include "Language.h"
+#include "MovementGenerator.h"
+#include "ObjectAccessor.h"
+#include "Opcodes.h"
+#include "SpellAuras.h"
+#include "TargetedMovementGenerator.h"
+#include "WeatherMgr.h"
+#include "ace/INET_Addr.h"
+#include "Player.h"
+#include "Pet.h"
+#include "LFG.h"
+#include "GroupMgr.h"
+#include "BattlegroundMgr.h"
+#include "MapManager.h"
+
+
+
+enum SoulStoneExSlotType
+{
+    SSEX_XQ = 1,
+    SSEX_FG = 2,
+    SSEX_CX = 3,
+};
+
+struct SoulStoneExDate
+{
+    uint32 page;
+    uint32 itemid1;
+    uint32 itemid2;
+    uint32 itemid3;
+    uint32 itemid4;
+    uint32 itemid5;
+    uint32 itemid6;
+    uint32 itemid7;
+};
+
+struct SoulStoneExItemType
+{
+	uint32 page;
+	uint32 type;
+};
+
+struct SoulStoneExPlayerData
+{
+    uint32 guid;
+    uint32 page;
+    uint32 itemid1;
+    uint32 itemid2;
+    uint32 itemid3;
+    uint32 itemid4;
+    uint32 itemid5;
+    uint32 itemid6;
+    uint32 itemid7;
+};
+
+
+struct SoulStoneExBuyReqData
+{
+    uint32 page;
+    uint32 itemid1;
+    uint32 val1;
+    uint32 itemid2;
+    uint32 val2;
+    uint32 itemid3;
+    uint32 val3;
+    uint32 itemid4;
+    uint32 val4;
+    uint32 itemid5;
+    uint32 val5;
+    uint32 vip;
+    uint32 junxian;
+    uint32 zhuansheng;
+    uint32 douqival;
+    uint32 money;
+    uint32 jihuoshuxingid;
+};
+
+class SoulStoneEx
+{
+public:
+    static SoulStoneEx * instance()
+    {
+        static SoulStoneEx instance;
+        return &instance;
+    }
+
+    void Load();
+    void ReLoad();
+    void SendMutualData(Player * player);
+    void SendPlayerDataForPage(Player * player, uint32 page);
+    void SavePlayerAllDate(Player * player);
+    void CreatePlayerDate(Player * player);
+    void SavePlayerSlotToSTL(Player * player, uint32 page, uint32 slot,uint32 itemid);
+    void SavePlayerSlotToBase(Player * player, uint32 page, uint32 slot,uint32 itemid);
+    void AddOrRemovePlayerBuff(Player * player, uint32 itemid,uint32 olditemid = 0, SoulStoneExSlotType t = SSEX_XQ);
+    void PlayerBuyPage(Player * player, uint32 page);
+    uint32 GetPlayerMaxPage(Player * player);
+    //uint32 GetItemType(uint32 itemid);
+	uint32 GetItemType(uint32 itemid);
+	int32 GetItemPage(uint32 itemid);
+
+    uint32 GetPageActi(uint32 page);
+    uint32 GetOldItemId(Player * player, uint32 page, uint32 slot);
+    void SetPlayerMsg(Player * player, std::string msg) { if (!player) return; uint32 guid = player->GetGUIDLow(); _SoulStoneExPlayerMsgMap[guid] = msg; }
+    std::string GetPlayerMsg(Player * player) { if (!player) return ""; uint32 guid = player->GetGUIDLow(); return _SoulStoneExPlayerMsgMap[guid]; }
+    void SendAllActiData(Player * player);
+    void SendActiDataToClient(Player * player, uint32 page);
+    void SendUnActiDataToClient(Player * player, uint32 page);
+    void SetActi(Player * player, uint32 page);
+    void RemoveActi(Player * player, uint32 page);
+    void CanInSetToSlot(Player * player, uint32 page, uint32 slot, uint32 itemid, std::string msg);
+    void CanRemoveSlot(Player * player, uint32 page, uint32 slot, std::string msg);
+    bool IfSoulStoneItem(uint32 item) { auto itr = _SoulStoneExItemTypeMap.find(item);  if (itr == _SoulStoneExItemTypeMap.end())return false; else return true; }
+    bool CanSetActi(Player * player, uint32 page);
+    bool IsActi(Player * player,uint32 page);
+    bool IsData(Player * player);
+    bool IsBuyPageReq(Player * player,uint32 page);
+    void RemoveReq(Player * player, uint32 page);
+    void SendBuyIsOkPage(Player * player, uint32 page);
+    void SetActiId(Player * player, uint32 page, uint32 itemid);
+    void AgainAddLoseBuff(Player * player);
+	void UpdatePlayerDate(Player * player);
+
+	std::vector<std::string> split(std::string str, std::string pattern);
+    uint32 GetExActiId(Player * player, uint32 page);
+
+
+    typedef std::multimap<uint32, SoulStoneExPlayerData> SoulStonePlayerDataMap;
+    typedef std::map<uint32, SoulStoneExBuyReqData>  SoulStoneBuyReqDataMap;
+	typedef std::map<uint32, SoulStoneExItemType> SoulStoneItemTypeMap;
+    typedef std::map<uint32, std::string> SoulStonePlayerMsgMap;
+    typedef std::multimap<uint32, SoulStoneExDate> SoulStoneExDateMap;
+
+private:
+
+    SoulStonePlayerDataMap _SoulStoneExPlayerDataMap;
+    SoulStoneBuyReqDataMap _SoulStoneExBuyReqDataMap;
+    SoulStoneItemTypeMap _SoulStoneExItemTypeMap;
+    SoulStonePlayerMsgMap _SoulStoneExPlayerMsgMap;
+    SoulStoneExDateMap _SoulStoneExExDateMap;
+	uint32 limitpageval;
+};
+
+#define sSoulStoneEx SoulStoneEx::instance()
diff --git a/src/server/scripts/Custom/SpellMod/SpellMod.cpp b/src/server/scripts/Custom/SpellMod/SpellMod.cpp
index 866b7c3..a66803f 100644
--- a/src/server/scripts/Custom/SpellMod/SpellMod.cpp
+++ b/src/server/scripts/Custom/SpellMod/SpellMod.cpp
@@ -1,441 +1,1305 @@
-ï»¿#pragma execution_character_set("utf-8")
+#pragma execution_character_set("utf-8")
 #include "SpellMod.h"
+#include "../Requirement/Requirement.h"
+#include "Battlefield.h"
+#include "BattlefieldMgr.h"
+#include "Battleground.h"
+#include "BattlegroundMgr.h"
 
+std::unordered_map<uint32, SpellModTemplate> SpellModMap;
+std::unordered_map<uint32, SpellModBaseTemplate> SpellModBaseMap;
+std::vector<AccountSpellTemplate> AccountSpellVec;
+std::unordered_map<uint32, AuraTriggerSpellTemplate> AuraTriggerSpellMap;
+std::vector<SpellLeechTemplate> SpellLeechVec;
+std::unordered_map<uint32, AuraLeechTemplate> AuraLeechMap;
+std::vector<AuraModSpellTemplate> AuraModSpellVec;
+std::unordered_map<uint32, AuraModStatTemplate> AuraModStatMap;
+std::unordered_map<uint32, AuraPctTemplate> AuraPctMap;
+std::unordered_map<uint32, AuraModClassSpellTemplate> AuraModClassSpellMap;
+std::unordered_map<uint32, std::string> OnRemoveSpellMap;
+std::unordered_map<uint32, std::string> OnLearnSpellMap;
+std::unordered_map<uint32, uint32> SpellCusTargetMaskMap;
+std::unordered_map<uint32, MountSpellTemplate> MountSpellMap;
+std::unordered_map<uint32, AuraStackTriggerTemplate> AuraStackTriggerMap;
+std::unordered_map<uint32, AuraTriggerOnDeathTemplate> AuraTriggerOnDeathMap;
 
-SpellModMgr::SpellModMgr()
+void SpellMod::Load()
 {
-    m_spellmods.clear();
-    m_spellmodlearns.clear();
-    m_spellmodunlearns.clear();
-    m_spellmodxxspell.clear();
-    m_spellmodxxaura.clear();
-    m_spellmodfsaura.clear();
-    m_AuraStackTriggers.clear();
-    m_AuraOnDeath.clear();
+	QueryResult result;
+
+	SpellModMap.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ¼¼ÄÜID, ÊÍ·Å¼¼ÄÜÐèÇóÄ£°åID,ÉËº¦±¶ÂÊ,ÖÎÁÆ±¶ÂÊ,ÊÇ·ñÕËºÅ°ó¶¨,ÊÇ·ñ½ûÓÃ,Ê©·¨Ê±¼ä,³ÖÐøÊ±¼ä,ÀäÈ´Ê±¼ä,´¥·¢»úÂÊ,ÖÜÆÚÊ±¼ä1,ÖÜÆÚÊ±¼ä2,ÖÜÆÚÊ±¼ä3 FROM _¼¼ÄÜ" :
+		"SELECT spellId, reqId,dmgMod,healMod,accountBind,disable,castingtime,duration,cooldown,procChance,Periodic1,Periodic2,Periodic3 FROM _spellmod"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 spellId = fields[0].GetUInt32();
+			SpellModTemplate Temp;
+			Temp.reqId = fields[1].GetUInt32();
+			Temp.dmgMod = fields[2].GetFloat();
+			Temp.healMod = fields[3].GetFloat();
+			Temp.accountBind = fields[4].GetBool();
+
+			Temp.disable		= fields[5].GetBool();
+			Temp.castingtime	= fields[6].GetUInt32();
+			Temp.duration		= fields[7].GetUInt32();
+			Temp.cooldown		= fields[8].GetUInt32();
+			Temp.procChance		= fields[9].GetUInt32();
+
+			for (size_t i = 0; i < MAX_SPELL_EFFECTS; i++)
+				Temp.Periodic[i] = fields[10 + i].GetUInt32();
+
+			SpellModMap.insert(std::make_pair(spellId, Temp));
+		} while (result->NextRow());
+	}
+
+	AccountSpellVec.clear();
+	if (result = LoginDatabase.PQuery("SELECT account, spell FROM account_spells"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			AccountSpellTemplate Temp;
+			Temp.accountId = fields[0].GetUInt32();
+			Temp.spellId = fields[1].GetFloat();
+			AccountSpellVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	SpellModBaseMap.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT spellId,"
+		"Effect1,Effect2,Effect3,"
+		"AuraName1,AuraName2,AuraName3,MiscValue1,MiscValue2,MiscValue3,"
+		"BasePoints1,BasePoints2,BasePoints3,"
+		"SpellMaskA1,SpellMaskA2,SpellMaskA3,"
+		"SpellMaskB1,SpellMaskB2,SpellMaskB3,"
+		"SpellMaskC1,SpellMaskC2,SpellMaskC3,"
+		"EffectTarget1,EffectTarget2,EffectTarget3,"
+		"targetspell1,targetspell2,targetspell3,"
+		"cooldown,targetflag,chance,charges,SpellFamilyName FROM _¼¼ÄÜ_Êý¾Ý¿âÐÞ¸Ä" :
+		"SELECT spellId,"
+		"Effect1,Effect2,Effect3,"
+		"AuraName1,AuraName2,AuraName3,MiscValue1,MiscValue2,MiscValue3,"
+		"BasePoints1,BasePoints2,BasePoints3,"
+		"SpellMaskA1,SpellMaskA2,SpellMaskA3,"
+		"SpellMaskB1,SpellMaskB2,SpellMaskB3,"
+		"SpellMaskC1,SpellMaskC2,SpellMaskC3,"
+		"EffectTarget1,EffectTarget2,EffectTarget3,"
+		"targetspell1,targetspell2,targetspell3,"
+		"cooldown,targetflag,chance,charges,SpellFamilyName FROM _spellmod_base"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 spellId = fields[0].GetUInt32();
+			SpellModBaseTemplate Temp;
+			Temp.Effect[0] = fields[1].GetUInt32();
+			Temp.Effect[1] = fields[2].GetUInt32();
+			Temp.Effect[2] = fields[3].GetUInt32();
+			Temp.EffectApplyAuraName[0] = fields[4].GetUInt32();
+			Temp.EffectApplyAuraName[1] = fields[5].GetUInt32();
+			Temp.EffectApplyAuraName[2] = fields[6].GetUInt32();
+			Temp.EffectMiscValue[0] = fields[7].GetInt32();
+			Temp.EffectMiscValue[1] = fields[8].GetInt32();
+			Temp.EffectMiscValue[2] = fields[9].GetInt32();
+			Temp.EffectBasePoints[0] = fields[10].GetInt32();
+			Temp.EffectBasePoints[1] = fields[11].GetInt32();
+			Temp.EffectBasePoints[2] = fields[12].GetInt32();
+			Temp.EffectSpellClassMask[0] = flag96(fields[13].GetUInt32(), fields[14].GetUInt32(), fields[15].GetUInt32());
+			Temp.EffectSpellClassMask[1] = flag96(fields[16].GetUInt32(), fields[17].GetUInt32(), fields[18].GetUInt32());
+			Temp.EffectSpellClassMask[2] = flag96(fields[19].GetUInt32(), fields[20].GetUInt32(), fields[21].GetUInt32());
+			Temp.EffectImplicitTargetA[0] = fields[22].GetUInt32();
+			Temp.EffectImplicitTargetA[1] = fields[23].GetUInt32();
+			Temp.EffectImplicitTargetA[2] = fields[24].GetUInt32();
+			Temp.EffectTriggerSpell[0] = fields[25].GetUInt32();
+			Temp.EffectTriggerSpell[1] = fields[26].GetUInt32();
+			Temp.EffectTriggerSpell[2] = fields[27].GetUInt32();
+			Temp.RecoveryTime = fields[28].GetInt32();
+			uint32 procFlags = fields[29].GetUInt32();
+
+			switch (procFlags)
+			{
+			case 1:Temp.procFlags = 20;					break;//ÎïÀí
+			case 2:Temp.procFlags = 320;				break;//Ô¶³Ì
+			case 4:Temp.procFlags = 81920;				break;//·¨Êõ
+			case 7:Temp.procFlags = 20 + 320 + 81920;	break;//ËùÓÐ
+			case 3:Temp.procFlags = 20 + 320;			break;
+			case 5:Temp.procFlags = 20 + 81920;			break;
+			case 6:Temp.procFlags = 320 + 81920;		break;
+			default:Temp.procFlags = 0;					break;
+			}
+
+			Temp.procChance = fields[30].GetFloat();
+			Temp.procCharges = fields[31].GetInt32();
+			Temp.SpellFamilyName = fields[32].GetUInt32();
+
+			SpellModBaseMap.insert(std::make_pair(spellId, Temp));
+		} while (result->NextRow());
+	}
+
+	SpellCusTargetMaskMap.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ¼¼ÄÜID,Ä¿±êÑÚÂë FROM _¼¼ÄÜ_Ä¿±êÏÞÖÆ" :
+		"SELECT spellId,targetMask FROM _spellmod_target"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			SpellCusTargetMaskMap.insert(std::make_pair(fields[0].GetUInt32(), fields[1].GetUInt32()));
+		} while (result->NextRow());
+	}
+
+	OnRemoveSpellMap.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ¼¼ÄÜID, GMÃüÁî×é FROM _¼¼ÄÜ_µ±ÒÅÍüÊ±" :
+		"SELECT spellId, command FROM _spellmod_on_remove"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			OnRemoveSpellMap.insert(std::make_pair(fields[0].GetUInt32(), fields[1].GetString()));
+		} while (result->NextRow());
+	}
+
+	OnLearnSpellMap.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ¼¼ÄÜID, GMÃüÁî×é FROM _¼¼ÄÜ_µ±Ñ§Ï°Ê±" :
+		"SELECT spellId, command FROM _spellmod_on_learn"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			OnLearnSpellMap.insert(std::make_pair(fields[0].GetUInt32(), fields[1].GetString()));
+		} while (result->NextRow());
+	}
+
+	AuraTriggerSpellMap.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ¹â»·ID,¹¥Ç¿°Ù·Ö±ÈÔö¼Ó»ù´¡Öµ1,¹¥Ç¿°Ù·Ö±ÈÔö¼Ó»ù´¡Öµ2,¹¥Ç¿°Ù·Ö±ÈÔö¼Ó»ù´¡Öµ3,·¨ÉË°Ù·Ö±ÈÔö¼Ó»ù´¡Öµ1,·¨ÉË°Ù·Ö±ÈÔö¼Ó»ù´¡Öµ2,·¨ÉË°Ù·Ö±ÈÔö¼Ó»ù´¡Öµ3,Á´½Ó¼¼ÄÜ×é,´¥·¢¼¸ÂÊ,´¥·¢¼¼ÄÜ×é,ÀäÈ´Ê±¼ä,ºöÂÔÄ¿±êÀàÐÍ,Ä¿±ê×î´óÊýÁ¿,Ä¿±ê·¶Î§,´¥·¢ÀàÐÍ  FROM _¼¼ÄÜ_¹â»·´¥·¢" :
+		"SELECT aura,bp0ApPct,bp1ApPct,bp2ApPct,bp0SpPct,bp1SpPct,bp2SpPct,linkSpellData,procChance,triggerSpell,cooldown,ignoreMask,MaxTargets,TargetsRange,procFlags  FROM _spellmod_aura_trigger"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 auraId = fields[0].GetUInt32();
+			AuraTriggerSpellTemplate Temp;
+			Temp.bp0ApPct = fields[1].GetFloat();
+			Temp.bp1ApPct = fields[2].GetFloat();
+			Temp.bp2ApPct = fields[3].GetFloat();
+			Temp.bp0SpPct = fields[4].GetFloat();
+			Temp.bp1SpPct = fields[5].GetFloat();
+			Temp.bp2SpPct = fields[6].GetFloat();
+			Tokenizer tokens(fields[7].GetString(), ' ');
+			for (Tokenizer::const_iterator itr = tokens.begin(); itr != tokens.end(); ++itr)
+				Temp.linkSpellData.push_back(uint32(atol(*itr)));
+			Temp.procChance = fields[8].GetUInt32();
+			//Temp.triggerSpell = fields[9].GetUInt32();
+			Tokenizer tokens1(fields[9].GetString(), ' ');
+			for (Tokenizer::const_iterator itr = tokens1.begin(); itr != tokens1.end(); ++itr)
+				Temp.triggerSpellData.push_back(uint32(atol(*itr)));
+			Temp.cooldown = fields[10].GetUInt32();
+			Temp.ignoreMask = fields[11].GetUInt32();
+			Temp.Targets = fields[12].GetUInt32();
+			Temp.TargetRange = fields[13].GetFloat();
+			Temp.procFlags = fields[14].GetUInt32();
+			AuraTriggerSpellMap.insert(std::make_pair(auraId, Temp));
+		} while (result->NextRow());
+	}
+
+	SpellLeechVec.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÎüÑª¼¼ÄÜID,ÎüÑª¼¸ÂÊ,ÎüÑªÀàÐÍ,»ù´¡Öµ,ÎüÑªÊÇ·ñ¸½´øÉËº¦,ÐèÒªÂú×ãµÄ¹â»·ID FROM _¼¼ÄÜ_ÎüÑª¼¼ÄÜ" :
+		"SELECT spell,chance,type,basepoints,addDamage,meetAura FROM _spellmod_leech_spell"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			SpellLeechTemplate Temp;
+			Temp.spellid = fields[0].GetUInt32();
+			Temp.chance = fields[1].GetFloat();
+
+			const char* str = fields[2].GetCString();
+
+			if (strcmp(str, "×ÔÉíµ±Ç°ÉúÃüÖµ°Ù·Ö±È") == 0)
+				Temp.type = LEECH_TYPE_SELF_CUR_PCT;
+			else if (strcmp(str, "×ÔÉí×î´óÉúÃüÖµ°Ù·Ö±È") == 0)
+				Temp.type = LEECH_TYPE_SELF_MAX_PCT;
+			else if (strcmp(str, "Ä¿±êµ±Ç°ÉúÃüÖµ°Ù·Ö±È") == 0)
+				Temp.type = LEECH_TYPE_TARGET_CUR_PCT;
+			else if (strcmp(str, "Ä¿±ê×î´óÉúÃüÖµ°Ù·Ö±È") == 0)
+				Temp.type = LEECH_TYPE_TARGET_MAX_PCT;
+			else if (strcmp(str, "¹Ì¶¨ÊýÖµ") == 0)
+				Temp.type = LEECH_TYPE_STATIC;
+			else if (strcmp(str, "¼¼ÄÜÉËº¦°Ù·Ö±È") == 0)
+				Temp.type = LEECH_TYPE_DAMGE_PCT;
+			else
+				Temp.type = LEECH_TYPE_NONE;
+
+			Temp.basepoints = fields[3].GetFloat();
+			Temp.addDmg = fields[4].GetBool();
+			Temp.meetAura = fields[5].GetUInt32();
+			SpellLeechVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	AuraLeechMap.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÎüÑª¹â»·¼¼ÄÜID,ÎüÑª¼¸ÂÊ,ÎüÑªÀàÐÍ,»ù´¡Öµ,ÎüÑªÊÇ·ñ¸½´øÉËº¦ FROM _¼¼ÄÜ_ÎüÑª¹â»·" :
+		"SELECT aura,chance,type,basepoints,addDamage FROM _spellmod_leech_aura"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 aura = fields[0].GetUInt32();
+			AuraLeechTemplate Temp;
+			Temp.chance = fields[1].GetFloat();
+
+			const char* str = fields[2].GetCString();
+
+			if (strcmp(str, "×ÔÉíµ±Ç°ÉúÃüÖµ°Ù·Ö±È") == 0)
+				Temp.type = LEECH_TYPE_SELF_CUR_PCT;
+			else if (strcmp(str, "×ÔÉí×î´óÉúÃüÖµ°Ù·Ö±È") == 0)
+				Temp.type = LEECH_TYPE_SELF_MAX_PCT;
+			else if (strcmp(str, "Ä¿±êµ±Ç°ÉúÃüÖµ°Ù·Ö±È") == 0)
+				Temp.type = LEECH_TYPE_TARGET_CUR_PCT;
+			else if (strcmp(str, "Ä¿±ê×î´óÉúÃüÖµ°Ù·Ö±È") == 0)
+				Temp.type = LEECH_TYPE_TARGET_MAX_PCT;
+			else if (strcmp(str, "¹Ì¶¨ÊýÖµ") == 0)
+				Temp.type = LEECH_TYPE_STATIC;
+			else if (strcmp(str, "¼¼ÄÜÉËº¦°Ù·Ö±È") == 0)
+				Temp.type = LEECH_TYPE_DAMGE_PCT;
+			else
+				Temp.type = LEECH_TYPE_NONE;
+
+			Temp.basepoints = fields[3].GetFloat();
+			Temp.addDmg = fields[4].GetBool();
+			AuraLeechMap.insert(std::make_pair(aura, Temp));
+		} while (result->NextRow());
+	}
+
+	AuraModClassSpellMap.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT aura, spellfamily,type1,op1,value1,"
+		"type2,op2,value2,type3,op3,value3 FROM _¼¼ÄÜ_Ö°ÒµÈ«¾Ö¹â»·" :
+		"SELECT aura, spellfamily,type1,op1,value1,"
+		"type2,op2,value2,type3,op3,value3 FROM _spellmod_aura_on_classmask"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 aura = fields[0].GetUInt32();
+			AuraModClassSpellTemplate Temp;
+			Temp.SpellFamilyName = SpellFamilyNames(fields[1].GetUInt32());
+
+			for (size_t i = 0; i < MAX_SPELL_EFFECTS; i++)
+			{
+				Temp.Type[i] = SpellModType(fields[2 + i * 3].GetUInt32());
+				Temp.Op[i] = SpellModOp(fields[3 + i * 3].GetUInt32());
+				Temp.Value[i] = fields[4 + i * 3].GetInt32();
+			}
+			AuraModClassSpellMap.insert(std::make_pair(aura, Temp));
+		} while (result->NextRow());
+	}
+
+	AuraModStatMap.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ¹â»·¼¼ÄÜID,¹â»·ÀàÐÍ1,ÊôÐÔÀàÐÍ1,×ª»»°Ù·Ö±È1,¹â»·ÀàÐÍ2,ÊôÐÔÀàÐÍ2,×ª»»°Ù·Ö±È2,¹â»·ÀàÐÍ3,ÊôÐÔÀàÐÍ3,×ª»»°Ù·Ö±È3 FROM _¼¼ÄÜ_Ö÷ÊôÐÔ×ª»»" :
+		"SELECT aura,auraType1,statType1,pct1,auraType2,statType2,pct2,auraType3,statType3,pct3 FROM _spellmod_aura_pct_on_stat"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 aura = fields[0].GetUInt32();
+			AuraModStatTemplate Temp;
+
+			AuraType auraType = SPELL_AURA_NONE;
+			int32 misc = 0;
+			int32 miscB = 0;
+
+			GetParams_PctOnStat(fields[1].GetCString(), fields[2].GetCString(), auraType, misc, miscB);
+			Temp.auraType[0] = auraType;
+			Temp.misc[0] = misc;
+			Temp.miscB[0] = miscB;
+			Temp.basePoints[0] = fields[3].GetInt32();
+
+			auraType = SPELL_AURA_NONE;
+			misc = 0;
+			miscB = 0;
+			GetParams_PctOnStat(fields[4].GetCString(), fields[5].GetCString(), auraType, misc, miscB);
+			Temp.auraType[1] = auraType;
+			Temp.misc[1] = misc;
+			Temp.miscB[1] = miscB;
+			Temp.basePoints[1] = fields[6].GetInt32();
+
+			auraType = SPELL_AURA_NONE;
+			misc = 0;
+			miscB = 0;
+			GetParams_PctOnStat(fields[7].GetCString(), fields[8].GetCString(), auraType, misc, miscB);
+			Temp.auraType[2] = auraType;
+			Temp.misc[2] = misc;
+			Temp.miscB[2] = miscB;
+			Temp.basePoints[2] = fields[9].GetInt32();
+
+			AuraModStatMap.insert(std::make_pair(aura, Temp));
+		} while (result->NextRow());
+	}
+
+	AuraPctMap.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ¹â»·¼¼ÄÜID,Ð§¹ûÀàÐÍ1,ÌáÉýÀàÐÍ1,ÌáÉýÊýÖµ1,Ð§¹ûÀàÐÍ2,ÌáÉýÀàÐÍ2,ÌáÉýÊýÖµ2,Ð§¹ûÀàÐÍ3,ÌáÉýÀàÐÍ3,ÌáÉýÊýÖµ3 FROM _¼¼ÄÜ_¹â»·°Ù·Ö±ÈÐ§¹û" :
+		"SELECT aura,auraType1,modType1,value1,auraType2,modType2,value2,auraType3,modType3,value3 FROM _spellmod_aura_pct"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 aura = fields[0].GetUInt32();
+			AuraPctTemplate Temp;
+
+			AuraType auraType = SPELL_AURA_NONE;
+			int32 misc = 0;
+			int32 miscB = 0;
+			GetParams_Pct(fields[1].GetCString(), fields[2].GetCString(), auraType, misc, miscB);
+			Temp.auraType[0] = auraType;
+			Temp.misc[0] = misc;
+			Temp.miscB[0] = miscB;
+			Temp.basePoints[0] = fields[3].GetInt32();
+
+			auraType = SPELL_AURA_NONE;
+			misc = 0;
+			miscB = 0;
+			GetParams_Pct(fields[4].GetCString(), fields[5].GetCString(), auraType, misc, miscB);
+			Temp.auraType[1] = auraType;
+			Temp.misc[1] = misc;
+			Temp.miscB[1] = miscB;
+			Temp.basePoints[1] = fields[6].GetInt32();
+
+			auraType = SPELL_AURA_NONE;
+			misc = 0;
+			miscB = 0;
+			GetParams_Pct(fields[7].GetCString(), fields[8].GetCString(), auraType, misc, miscB);
+			Temp.auraType[2] = auraType;
+			Temp.misc[2] = misc;
+			Temp.miscB[2] = miscB;
+			Temp.basePoints[2] = fields[9].GetInt32();
+
+			AuraPctMap.insert(std::make_pair(aura, Temp));
+		} while (result->NextRow());
+	}
+
+	MountSpellMap.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT Ö÷×øÆï¼¼ÄÜID,60ËÙ¶È×øÆï¼¼ÄÜID,100ËÙ¶È×øÆï¼¼ÄÜID,150ËÙ¶È×øÆï¼¼ÄÜID,280ËÙ¶È×øÆï¼¼ÄÜID,310ËÙ¶È×øÆï¼¼ÄÜID FROM _¼¼ÄÜ_ÆïÊõ¸Ä±äËÙ¶È" :
+		"SELECT spellId,spell_60,spell_100,spell_150,spell_280,spell_310 FROM _spellmod_mount"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 spellId = fields[0].GetUInt32();
+			MountSpellTemplate Temp;
+			Temp.mount60 = fields[1].GetUInt32();
+			Temp.mount100 = fields[2].GetUInt32();
+			Temp.mount150 = fields[3].GetUInt32();
+			Temp.mount280 = fields[4].GetUInt32();
+			Temp.mount310 = fields[5].GetUInt32();
+			MountSpellMap.insert(std::make_pair(spellId, Temp));
+		} while (result->NextRow());
+	}
+
+	AuraStackTriggerMap.clear();
+	result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?	
+		"SELECT ¹â»·¼¼ÄÜID, µþ¼Ó²ãÊý, ´¥·¢¼¼ÄÜ×é, ´¥·¢¼¼ÄÜºóÒÆ³ý²ãÊý  FROM _¼¼ÄÜ_¹â»·µþ¼Ó" :
+		"SELECT AuraId, Stacks, TriggerSpellData, RemoveStacks  FROM _spellmod_aura_stack");
+
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 Aura = fields[0].GetUInt32();
+			AuraStackTriggerTemplate Temp;
+			Temp.Stacks = fields[1].GetUInt32();
+			Tokenizer tokens(fields[2].GetString(), ' ');
+			for (Tokenizer::const_iterator itr = tokens.begin(); itr != tokens.end(); ++itr)
+				Temp.TriggerSpellVec.push_back(uint32(atol(*itr)));
+			Temp.RemoveStacks = fields[3].GetUInt32();
+			AuraStackTriggerMap.insert(std::make_pair(Aura, Temp));
+		} while (result->NextRow());
+	}
+
+	AuraTriggerOnDeathMap.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+		"SELECT ¹â»·¼¼ÄÜID, ÀäÈ´Ê±¼ä, ¶Ô¹¥»÷ÕßÊ©·Å¼¼ÄÜID, ¶Ô¹¥»÷ÕßÊ©·Å¼¼ÄÜ¼¸ÂÊ, ¶Ô×ÔÉíÊ©·Å¼¼ÄÜID,¶Ô×ÔÉíÊ©·Å¼¼ÄÜ¼¸ÂÊ,ÊÇ·ñ×èÖ¹ËÀÍö  FROM _¼¼ÄÜ_¹â»·ËÀÍö´¥·¢" :
+		"SELECT AuraId,CoolDown,AttackerTriggerSpell,AttackerTriggerChance,SelfTriggerSpell,SelfTriggerChance,PreventLastDamage FROM _spellmod_aura_death_trigger"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 AuraId = fields[0].GetUInt32();
+			AuraTriggerOnDeathTemplate Temp;
+			Temp.CoolDown = fields[1].GetUInt32();
+			Temp.AttackerTriggerSpell = fields[2].GetUInt32();
+			Temp.AttackerTriggerChance = fields[3].GetFloat();
+			Temp.SelfTriggerSpell = fields[4].GetUInt32();
+			Temp.SelfTriggerChance = fields[5].GetFloat();
+			Temp.PreventLastDamage = fields[6].GetBool();
+			AuraTriggerOnDeathMap.insert(std::make_pair(AuraId, Temp));
+		} while (result->NextRow());
+	}
+}
+
+//void SpellMod::LoadAuraEffectSpell()
+//{
+//	
+//
+//	/*
+//	AuraModSpellVec.clear();
+//
+//	result = WorldDatabase.PQuery("SELECT aura,spellfamily, spell,type1,op1,value1,"
+//	"type2,op2,value2,type3,op3,value3 FROM _spellmod_aura_on_spell");
+//
+//	if (result)
+//	{
+//	do
+//	{
+//	Field* fields = result->Fetch();
+//	AuraModSpellTemplate Temp;
+//	Temp.AuraId = fields[0].GetUInt32();
+//	Temp.SpellFamilyName = SpellFamilyNames(fields[1].GetUInt32());
+//	std::string str = fields[2].GetString();
+//	if (!str.empty())
+//	{
+//	Tokenizer tokens(str, ',');
+//	for (Tokenizer::const_iterator iter = tokens.begin(); iter != tokens.end(); ++iter)
+//	Temp.SpellVec.push_back(uint32(atol(*iter)));
+//	}
+//
+//	for (size_t i = 0; i < MAX_SPELL_EFFECTS; i++)
+//	{
+//	Temp.Type[i] = SpellModType(fields[3 + i * 3].GetUInt32());
+//	Temp.Op[i] = SpellModOp(fields[4 + i * 3].GetUInt32());
+//	Temp.Value[i] = fields[5 + i * 3].GetInt32();
+//	}
+//	AuraModSpellVec.push_back(Temp);
+//	} while (result->NextRow());
+//	}
+//	*/
+//	
+//
+//}
+
+void SpellMod::GetParams_PctOnStat(const char* strAuraType, const char* strStatType, AuraType &auraType, int32 &misc, int32 &miscB)
+{
+	int32 i = -1;
+
+	if (strcmp(strStatType, "¾«Éñ") == 0)
+		i = STAT_SPIRIT;
+	else if (strcmp(strStatType, "Á¦Á¿") == 0)
+		i = STAT_STRENGTH;
+	else if (strcmp(strStatType, "Ãô½Ý") == 0)
+		i = STAT_AGILITY;
+	else if (strcmp(strStatType, "ÄÍÁ¦") == 0)
+		i = STAT_STAMINA;
+	else if (strcmp(strStatType, "ÖÇÁ¦") == 0)
+		i = STAT_INTELLECT;
+
+	if (strcmp(strAuraType, "·¨ÊõÇ¿¶È") == 0)
+	{
+		auraType = SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT;
+		misc = SPELL_SCHOOL_MASK_MAGIC;
+		miscB = i;
+	}
+
+	if (strcmp(strAuraType, "½üÕ½¹¥»÷Ç¿¶È") == 0)
+	{
+		auraType = SPELL_AURA_MOD_ATTACK_POWER_OF_STAT_PERCENT;
+		misc = i;
+	}
+
+	if (strcmp(strAuraType, "Ô¶³Ì¹¥»÷Ç¿¶È") == 0)
+	{
+		auraType = SPELL_AURA_MOD_RANGED_ATTACK_POWER_OF_STAT_PERCENT;
+		misc = i;
+	}
+
+	if (strcmp(strAuraType, "ÖÎÁÆÐ§¹û") == 0)
+	{
+		auraType = SPELL_AURA_MOD_SPELL_HEALING_OF_STAT_PERCENT;
+		misc = i;
+	}
 }
 
-SpellModMgr::~SpellModMgr()
+void SpellMod::GetParams_Pct(const char* strAuraType, const char* strModType, AuraType &auraType, int32 &misc, int32 &miscB)
 {
+	if (strcmp(strAuraType, "Ê©·¨ËÙ¶È") == 0)
+		auraType = SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK;
+	if (strcmp(strAuraType, "½üÕ½¹¥»÷ËÙ¶È") == 0)
+		auraType = SPELL_AURA_MOD_MELEE_HASTE;
+	if (strcmp(strAuraType, "Ô¶³Ì¹¥»÷ËÙ¶È") == 0)
+		auraType = SPELL_AURA_MOD_RANGED_HASTE;
+
+	if (strcmp(strAuraType, "Ôì³É±©»÷ÉËº¦") == 0)
+	{
+		auraType = SPELL_AURA_MOD_CRIT_DAMAGE_BONUS;
+		misc = SPELL_SCHOOL_MASK_ALL;
+	}
+
+	bool pct = strcmp(strModType, "°Ù·Ö±È") == 0;
+
+	if (strcmp(strAuraType, "ÉúÃüÖµ") == 0)
+		pct ? auraType = SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT : auraType = SPELL_AURA_MOD_INCREASE_HEALTH;
+
+	if (strcmp(strAuraType, "È«ÊôÐÔ") == 0)
+	{
+		pct ? auraType = SPELL_AURA_MOD_PERCENT_STAT : auraType = SPELL_AURA_MOD_STAT;
+		misc = -1;
+	}
+
+	if (strcmp(strAuraType, "ÄÍÁ¦") == 0)
+	{
+		pct ? auraType = SPELL_AURA_MOD_PERCENT_STAT : auraType = SPELL_AURA_MOD_STAT;
+		misc = STAT_STAMINA;
+	}
 
+	if (strcmp(strAuraType, "Ãô½Ý") == 0)
+	{
+		pct ? auraType = SPELL_AURA_MOD_PERCENT_STAT : auraType = SPELL_AURA_MOD_STAT;
+		misc = STAT_AGILITY;
+	}
+
+	if (strcmp(strAuraType, "Á¦Á¿") == 0)
+	{
+		pct ? auraType = SPELL_AURA_MOD_PERCENT_STAT : auraType = SPELL_AURA_MOD_STAT;
+		misc = STAT_STRENGTH;
+	}
+
+	if (strcmp(strAuraType, "ÖÇÁ¦") == 0)
+	{
+		pct ? auraType = SPELL_AURA_MOD_PERCENT_STAT : auraType = SPELL_AURA_MOD_STAT;
+		misc = STAT_INTELLECT;
+	}
+
+	if (strcmp(strAuraType, "¾«Éñ") == 0)
+	{
+		pct ? auraType = SPELL_AURA_MOD_PERCENT_STAT : auraType = SPELL_AURA_MOD_STAT;
+		misc = STAT_STRENGTH;
+	}
+
+	if (strcmp(strAuraType, "½üÕ½¹¥»÷Ç¿¶È") == 0)
+		pct ? auraType = SPELL_AURA_MOD_ATTACK_POWER_PCT : auraType = SPELL_AURA_MOD_ATTACK_POWER;
+
+	if (strcmp(strAuraType, "Ô¶³Ì¹¥»÷Ç¿¶È") == 0)
+		pct ? auraType = SPELL_AURA_MOD_RANGED_ATTACK_POWER_PCT : auraType = SPELL_AURA_MOD_RANGED_ATTACK_POWER;
+
+	if (strcmp(strAuraType, "·¨ÊõÇ¿¶È") == 0)
+	{
+		if (pct)
+		{
+			auraType = SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT;
+			miscB = -1000;
+		}
+		else
+			auraType = SPELL_AURA_MOD_DAMAGE_DONE;
+
+		misc = SPELL_SCHOOL_MASK_MAGIC;
+	}
+
+	if (strcmp(strAuraType, "°ÂÊõ·¨ÊõÇ¿¶È") == 0)
+	{
+		if (pct)
+		{
+			auraType = SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT;
+			miscB = -1000;
+		}
+		else
+			auraType = SPELL_AURA_MOD_DAMAGE_DONE;
+
+		misc = SPELL_SCHOOL_MASK_ARCANE;
+	}
+
+	if (strcmp(strAuraType, "»ðÑæ·¨ÊõÇ¿¶È") == 0)
+	{
+		if (pct)
+		{
+			auraType = SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT;
+			miscB = -1000;
+		}
+		else
+			auraType = SPELL_AURA_MOD_DAMAGE_DONE;
+
+		misc = SPELL_SCHOOL_MASK_FIRE;
+	}
+
+	if (strcmp(strAuraType, "±ùËª·¨ÊõÇ¿¶È") == 0)
+	{
+		if (pct)
+		{
+			auraType = SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT;
+			miscB = -1000;
+		}
+		else
+			auraType = SPELL_AURA_MOD_DAMAGE_DONE;
+
+		misc = SPELL_SCHOOL_MASK_FROST;
+	}
+
+	if (strcmp(strAuraType, "ÉñÊ¥·¨ÊõÇ¿¶È") == 0)
+	{
+		if (pct)
+		{
+			auraType = SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT;
+			miscB = -1000;
+		}
+		else
+			auraType = SPELL_AURA_MOD_DAMAGE_DONE;
+
+		misc = SPELL_SCHOOL_MASK_HOLY;
+	}
+
+	if (strcmp(strAuraType, "°µÓ°·¨ÊõÇ¿¶È") == 0)
+	{
+		if (pct)
+		{
+			auraType = SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT;
+			miscB = -1000;
+		}
+		else
+			auraType = SPELL_AURA_MOD_DAMAGE_DONE;
+
+		misc = SPELL_SCHOOL_MASK_SHADOW;
+	}
+
+	if (strcmp(strAuraType, "×ÔÈ»·¨ÊõÇ¿¶È") == 0)
+	{
+		if (pct)
+		{
+			auraType = SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT;
+			miscB = -1000;
+		}
+		else
+			auraType = SPELL_AURA_MOD_DAMAGE_DONE;
+
+		misc = SPELL_SCHOOL_MASK_NATURE;
+	}
+
+	if (strcmp(strAuraType, "ÖÎÁÆÐ§¹û") == 0)
+	{
+		if (pct)
+		{
+			auraType = SPELL_AURA_MOD_SPELL_HEALING_OF_STAT_PERCENT;
+			miscB = -1000;
+		}
+		else
+			auraType = SPELL_AURA_MOD_HEALING;
+
+		misc = SPELL_SCHOOL_MASK_MAGIC;
+	}
+
+	if (strcmp(strAuraType, "Ôì³ÉËùÓÐÉËº¦") == 0)
+	{
+		pct ? auraType = SPELL_AURA_MOD_DAMAGE_PERCENT_DONE : auraType = SPELL_AURA_MOD_DAMAGE_DONE;
+		misc = SPELL_SCHOOL_MASK_ALL;
+	}
+
+	if (strcmp(strAuraType, "Ôì³ÉÎïÀíÉËº¦") == 0)
+	{
+		pct ? auraType = SPELL_AURA_MOD_DAMAGE_PERCENT_DONE : auraType = SPELL_AURA_MOD_DAMAGE_DONE;
+		misc = SPELL_SCHOOL_MASK_NORMAL;
+	}
+
+	if (strcmp(strAuraType, "Ôì³É·¨ÊõÉËº¦") == 0)
+	{
+		pct ? auraType = SPELL_AURA_MOD_DAMAGE_PERCENT_DONE : auraType = SPELL_AURA_MOD_DAMAGE_DONE;
+		misc = SPELL_SCHOOL_MASK_MAGIC;
+	}
+
+	if (strcmp(strAuraType, "Ôì³É°ÂÊõÉËº¦") == 0)
+	{
+		pct ? auraType = SPELL_AURA_MOD_DAMAGE_PERCENT_DONE : auraType = SPELL_AURA_MOD_DAMAGE_DONE;
+		misc = SPELL_SCHOOL_MASK_ARCANE;
+	}
+
+	if (strcmp(strAuraType, "Ôì³É»ðÑæÉËº¦") == 0)
+	{
+		pct ? auraType = SPELL_AURA_MOD_DAMAGE_PERCENT_DONE : auraType = SPELL_AURA_MOD_DAMAGE_DONE;
+		misc = SPELL_SCHOOL_MASK_FIRE;
+	}
+	if (strcmp(strAuraType, "Ôì³É±ùËªÉËº¦") == 0)
+	{
+		pct ? auraType = SPELL_AURA_MOD_DAMAGE_PERCENT_DONE : auraType = SPELL_AURA_MOD_DAMAGE_DONE;
+		misc = SPELL_SCHOOL_MASK_FROST;
+	}
+	if (strcmp(strAuraType, "Ôì³ÉÉñÊ¥ÉËº¦") == 0)
+	{
+		pct ? auraType = SPELL_AURA_MOD_DAMAGE_PERCENT_DONE : auraType = SPELL_AURA_MOD_DAMAGE_DONE;
+		misc = SPELL_SCHOOL_MASK_HOLY;
+	}
+	if (strcmp(strAuraType, "Ôì³É°µÓ°ÉËº¦") == 0)
+	{
+		pct ? auraType = SPELL_AURA_MOD_DAMAGE_PERCENT_DONE : auraType = SPELL_AURA_MOD_DAMAGE_DONE;
+		misc = SPELL_SCHOOL_MASK_SHADOW;
+	}
+	if (strcmp(strAuraType, "Ôì³É×ÔÈ»ÉËº¦") == 0)
+	{
+		pct ? auraType = SPELL_AURA_MOD_DAMAGE_PERCENT_DONE : auraType = SPELL_AURA_MOD_DAMAGE_DONE;
+		misc = SPELL_SCHOOL_MASK_NATURE;
+	}
+
+	if (strcmp(strAuraType, "ÊÜµ½ËùÓÐÉËº¦") == 0)
+	{
+		pct ? auraType = SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN : auraType = SPELL_AURA_MOD_DAMAGE_TAKEN;
+		misc = SPELL_SCHOOL_MASK_ALL;
+	}
 }
 
-void SpellModMgr::Load()
+uint32 SpellMod::GetReqId(uint32 spellId)
 {
-    QueryResult result;
-    m_spellmods.clear();
-
-    int count = 0;
-    if (result = WorldDatabase.PQuery("SELECT æè½ID,éæ±ID,å¥å±ID,ä¼¤å®³åç,æ²»çåç,è´¦å·ç»å®,ç¦ç¨,æ½æ³æ¶é´,æç»­æ¶é´,å·å´æ¶é´,è§¦åæºç,å¨ææ¶é´1,å¨ææ¶é´2,å¨ææ¶é´3 FROM _æè½"))
-    {
-        do
-        {
-            SpellCustomMod *Temp = new SpellCustomMod;
-            Field* fields = result->Fetch();
-
-            Temp->spellid = fields[0].GetUInt32();
-            Temp->reqId = fields[1].GetUInt32();
-            Temp->rewId = fields[2].GetUInt32();
-            Temp->dmgMod = fields[3].GetFloat();
-            Temp->healMod = fields[4].GetFloat();
-            Temp->accountBind = fields[5].GetBool();
-            Temp->disable = fields[6].GetBool();
-            Temp->castingtime = fields[7].GetInt32();
-            Temp->duration = fields[8].GetInt32();
-            Temp->cooldown = fields[9].GetUInt32();
-            Temp->procChance = fields[10].GetUInt32();
-
-            for (size_t i = 0; i < MAX_SPELL_EFFECTS; i++)
-                Temp->Periodic[i] = fields[11 + i].GetUInt32();
-
-            m_spellmods.push_back(Temp);
-            count++;
-
-        } while (result->NextRow());
-    }
-    sLog->outString(">> è¯»ååè½æ°æ®è¡¨[_æè½],å±%uæ¡æ°æ®è¯»åå è½½...", count);
-
-
-    m_spellmodlearns.clear();
-    int count1 = 0;
-    if (result = WorldDatabase.PQuery("SELECT æè½ID, éæ±ID,å¥å±ID FROM _æè½_å½å­¦ä¹ æ¶"))
-    {
-        do
-        {
-            SpellCustomLearnMod *Temp = new SpellCustomLearnMod;
-            Field* fields = result->Fetch();
-
-            Temp->spellid = fields[0].GetUInt32();
-            Temp->reqId = fields[1].GetUInt32();
-            Temp->rewId = fields[2].GetUInt32();
-
-            m_spellmodlearns.push_back(Temp);
-            count1++;
-
-        } while (result->NextRow());
-    }
-    sLog->outString(">> è¯»ååè½æ°æ®è¡¨[_æè½_å½å­¦ä¹ æ¶],å±%uæ¡æ°æ®è¯»åå è½½...", count1);
-
-    //æè½éå¿æ¶å
-    m_spellmodunlearns.clear();
-    int count2 = 0;
-    if (result = WorldDatabase.PQuery("SELECT æè½ID, éæ±ID,å¥å±ID FROM _æè½_å½éå¿æ¶"))
-    {
-        do
-        {
-            SpellCustomUnLearnMod *Temp = new SpellCustomUnLearnMod;
-            Field* fields = result->Fetch();
-
-            Temp->spellid = fields[0].GetUInt32();
-            Temp->reqId = fields[1].GetUInt32();
-            Temp->rewId = fields[2].GetUInt32();
-
-            m_spellmodunlearns.push_back(Temp);
-            count2++;
-
-        } while (result->NextRow());
-    }
-    sLog->outString(">> è¯»ååè½æ°æ®è¡¨[_æè½_å½éå¿æ¶],å±%uæ¡æ°æ®è¯»åå è½½...", count2);
-
-    //å¸è¡æè½
-    m_spellmodxxspell.clear();
-    int count3 = 0;
-    if (result = WorldDatabase.PQuery("SELECT å¸è¡æè½ID,å¸è¡å ç,å¸è¡ç±»å,åºç¡å¼,å¸è¡è½¬ä¼¤å®³,éè¦åç¯ID FROM _æè½_å¸è¡æè½"))
-    {
-        do
-        {
-            SpellCustomXxSpellMod *Temp = new SpellCustomXxSpellMod;
-            Field* fields = result->Fetch();
-            
-            Temp->spellid = fields[0].GetUInt32();
-            Temp->chance = fields[1].GetFloat();
-
-            const char* str = fields[2].GetCString();
-
-            if (strcmp(str, "èªèº«å½åçå½å¼ç¾åæ¯") == 0)
-                Temp->type = LEECH_TYPE_SELF_CUR_PCT;
-            else if (strcmp(str, "èªèº«æå¤§çå½å¼ç¾åæ¯") == 0)
-                Temp->type = LEECH_TYPE_SELF_MAX_PCT;
-            else if (strcmp(str, "ç®æ å½åçå½å¼ç¾åæ¯") == 0)
-                Temp->type = LEECH_TYPE_TARGET_CUR_PCT;
-            else if (strcmp(str, "ç®æ æå¤§çå½å¼ç¾åæ¯") == 0)
-                Temp->type = LEECH_TYPE_TARGET_MAX_PCT;
-            else if (strcmp(str, "åºå®æ°å¼") == 0)
-                Temp->type = LEECH_TYPE_STATIC;
-            else if (strcmp(str, "æè½ä¼¤å®³ç¾åæ¯") == 0)
-                Temp->type = LEECH_TYPE_DAMGE_PCT;
-            else
-                Temp->type = LEECH_TYPE_NONE;
-
-            Temp->basepoints = fields[3].GetFloat();
-            Temp->addDmg = fields[4].GetFloat();
-            Temp->meetAura = fields[5].GetUInt32();
-            m_spellmodxxspell.push_back(Temp);
-            count3++;
-        } while (result->NextRow());
-    }
-    sLog->outString(">> è¯»ååè½æ°æ®è¡¨[_æè½_å¸è¡æè½],å±%uæ¡æ°æ®è¯»åå è½½...", count3);
-
-
-    //å¸è¡åç¯
-    m_spellmodxxaura.clear();
-    int count4 = 0;
-    if (result = WorldDatabase.PQuery("SELECT å¸è¡åç¯æè½ID,æ³æ¯å¤§ç±»,æ³æ¯å°ç±»1,æ³æ¯å°ç±»2,æ³æ¯å°ç±»3,å¸è¡å ç,å¸è¡ç±»å,åºç¡å¼,å¸è¡è½¬ä¼¤å®³ FROM _æè½_å¸è¡åç¯"))
-    {
-        do
-        {
-            SpellCustomXxAuraMod *Temp = new SpellCustomXxAuraMod;
-            Field* fields = result->Fetch();
-
-            Temp->spellid = fields[0].GetUInt32();
-            Temp->SpellFamily = fields[1].GetUInt32();
-            Temp->SpellClassMask = flag96(fields[2].GetUInt32(), fields[3].GetUInt32(), fields[4].GetUInt32());
-            Temp->chance = fields[5].GetFloat();
-
-
-            const char* str = fields[6].GetCString();
-            if (strcmp(str, "èªèº«å½åçå½å¼ç¾åæ¯") == 0)
-                Temp->type = LEECH_TYPE_SELF_CUR_PCT;
-            else if (strcmp(str, "èªèº«æå¤§çå½å¼ç¾åæ¯") == 0)
-                Temp->type = LEECH_TYPE_SELF_MAX_PCT;
-            else if (strcmp(str, "ç®æ å½åçå½å¼ç¾åæ¯") == 0)
-                Temp->type = LEECH_TYPE_TARGET_CUR_PCT;
-            else if (strcmp(str, "ç®æ æå¤§çå½å¼ç¾åæ¯") == 0)
-                Temp->type = LEECH_TYPE_TARGET_MAX_PCT;
-            else if (strcmp(str, "åºå®æ°å¼") == 0)
-                Temp->type = LEECH_TYPE_STATIC;
-            else if (strcmp(str, "æè½ä¼¤å®³ç¾åæ¯") == 0)
-                Temp->type = LEECH_TYPE_DAMGE_PCT;
-            else
-                Temp->type = LEECH_TYPE_NONE;
-
-            Temp->basepoints = fields[7].GetFloat();
-            Temp->addDmg = fields[8].GetFloat();
-            m_spellmodxxaura.push_back(Temp);
-            count4++;
-        } while (result->NextRow());
-    }
-    sLog->outString(">> è¯»ååè½æ°æ®è¡¨[_æè½_å¸è¡åç¯],å±%uæ¡æ°æ®è¯»åå è½½...", count4);
-
-    //åä¼¤åç¯
-    m_spellmodfsaura.clear();
-    int count5 = 0;
-    if (result = WorldDatabase.PQuery("SELECT åä¼¤åç¯æè½ID,åå°ä¼¤å®³ç±»å,åä¼¤å ç,åä¼¤ç±»å,åºç¡å¼ FROM _æè½_åä¼¤åç¯"))
-    {
-        do
-        {
-            SpellCustomFsAuraMod *Temp = new SpellCustomFsAuraMod;
-            Field* fields = result->Fetch();
-
-            Temp->spellid = fields[0].GetUInt32();
-            Temp->dmgmask = fields[1].GetUInt32();
-            Temp->chance = fields[2].GetFloat();
-
-            const char* str = fields[3].GetCString();
-            if (strcmp(str, "èªèº«å½åçå½å¼ç¾åæ¯") == 0)
-                Temp->type = LEECH_TYPE_SELF_CUR_PCT;
-            else if (strcmp(str, "èªèº«æå¤§çå½å¼ç¾åæ¯") == 0)
-                Temp->type = LEECH_TYPE_SELF_MAX_PCT;
-            else if (strcmp(str, "ç®æ å½åçå½å¼ç¾åæ¯") == 0)
-                Temp->type = LEECH_TYPE_TARGET_CUR_PCT;
-            else if (strcmp(str, "ç®æ æå¤§çå½å¼ç¾åæ¯") == 0)
-                Temp->type = LEECH_TYPE_TARGET_MAX_PCT;
-            else if (strcmp(str, "åºå®æ°å¼") == 0)
-                Temp->type = LEECH_TYPE_STATIC;
-            else if (strcmp(str, "åå°ä¼¤å®³ç¾åæ¯") == 0)
-                Temp->type = LEECH_TYPE_DAMGE_PCT;
-            else
-                Temp->type = LEECH_TYPE_NONE;
-
-            Temp->basepoints = fields[4].GetFloat();
-
-            m_spellmodfsaura.push_back(Temp);
-            count5++;
-        } while (result->NextRow());
-    }
-    sLog->outString(">> è¯»ååè½æ°æ®è¡¨[_æè½_åä¼¤åç¯],å±%uæ¡æ°æ®è¯»åå è½½...", count5);
-
-
-    m_AuraStackTriggers.clear();
-    int count6 = 0;
-    result = WorldDatabase.PQuery("SELECT åç¯æè½ID, å å å±æ°, è§¦åæè½ç», è§¦åæè½åç§»é¤å±æ°  FROM _æè½_åç¯å å ");
-    if (result)
-    {
-        do
-        {
-            AuraStackTriggerMod *Temp = new AuraStackTriggerMod;
-            Field* fields = result->Fetch();
-            Temp->auraid = fields[0].GetUInt32();
-            Temp->Stacks = fields[1].GetUInt32();
-            Tokenizer tokens(fields[2].GetString(), '#');
-            for (Tokenizer::const_iterator itr = tokens.begin(); itr != tokens.end(); ++itr)
-                Temp->TriggerSpellVec.push_back(uint32(atol(*itr)));
-            Temp->RemoveStacks = fields[3].GetUInt32();
-            m_AuraStackTriggers.push_back(Temp);
-            count6++;
-        } while (result->NextRow());
-    }
-
-    sLog->outString(">> è¯»ååè½æ°æ®è¡¨[_æè½_åç¯å å ],å±%uæ¡æ°æ®è¯»åå è½½...", count6);
-
-    m_AuraOnDeath.clear();
-    int count7 = 0;
-    if (result = WorldDatabase.PQuery("SELECT åç¯æè½ID,å·å´æ¶é´,å¯¹æ»å»èæ½æ¾æè½ID,å¯¹æ»å»èæ½æ¾æè½å ç,å¯¹èªèº«æ½æ¾æè½ID,å¯¹èªèº«æ½æ¾æè½å ç,æ¯å¦é»æ­¢æ­»äº¡ FROM _æè½_åç¯æ­»äº¡è§¦å"))
-    {
-        do
-        {
-            AuraOnDeathMod * Temp = new AuraOnDeathMod;
-            Field* fields = result->Fetch();
-            Temp->auraid = fields[0].GetUInt32();
-            Temp->CoolDown = fields[1].GetUInt32();
-            Temp->AttackerTriggerSpell = fields[2].GetUInt32();
-            Temp->AttackerTriggerChance = fields[3].GetFloat();
-            Temp->SelfTriggerSpell = fields[4].GetUInt32();
-            Temp->SelfTriggerChance = fields[5].GetFloat();
-            Temp->PreventLastDamage = fields[6].GetBool();
-            m_AuraOnDeath.push_back(Temp);
-            count7++;
-        } while (result->NextRow());
-    }
-    sLog->outString(">> è¯»ååè½æ°æ®è¡¨[_æè½_åç¯æ­»äº¡è§¦å],å±%uæ¡æ°æ®è¯»åå è½½...", count7);
+	std::unordered_map<uint32, SpellModTemplate>::iterator iter = SpellModMap.find(spellId);
+
+	if (iter != SpellModMap.end())
+		return iter->second.reqId;
+
+	return 0;
 }
+float SpellMod::GetDmgMod(uint32 spellId)
+{
+	std::unordered_map<uint32, SpellModTemplate>::iterator iter = SpellModMap.find(spellId);
 
+	if (iter != SpellModMap.end())
+		return iter->second.dmgMod;
 
-void SpellModMgr::HealOnDamage(Unit* caster, Unit* target, SpellInfo const* spellInfo, uint32 &damage)
+	return 1.0f;
+}
+float SpellMod::GetHealMod(uint32 spellId)
 {
-    //å¸è¡æè½
-    if (SpellCustomXxSpellMod const *xxspell = FindSpellXxSpellMod(spellInfo->Id))
-    {
-        if (roll_chance_f(xxspell->chance))
-        {
-            if (xxspell->meetAura == 0 || caster->HasAura(xxspell->meetAura))
-            {
-                uint32 amount = 0;
-
-                switch (xxspell->type)
-                {
-                case LEECH_TYPE_SELF_CUR_PCT:
-                    amount = caster->GetHealth() * xxspell->basepoints / 100;
-                    break;
-                case LEECH_TYPE_SELF_MAX_PCT:
-                    amount = caster->GetMaxHealth() * xxspell->basepoints / 100;
-                    break;
-                case LEECH_TYPE_TARGET_CUR_PCT:
-                    amount = target->GetMaxHealth() * xxspell->basepoints / 100;
-                    break;
-                case LEECH_TYPE_TARGET_MAX_PCT:
-                    amount = target->GetMaxHealth() * xxspell->basepoints / 100;
-                    break;
-                case LEECH_TYPE_STATIC:
-                    amount = xxspell->basepoints;
-                    break;
-                case LEECH_TYPE_DAMGE_PCT:
-                    amount = damage * xxspell->basepoints / 100;
-                    break;
-                }
-
-                if (amount != 0)
-                {
-                    if (xxspell->addDmg != 0)
-                        damage = damage + xxspell->addDmg * amount;
-                    if (caster->IsAlive())
-                        caster->HealBySpell(caster, spellInfo, amount);
-                }
-            }
-        }
-    }
-
-    //å¸è¡åç¯
-    for (auto i = m_spellmodxxaura.begin(); i != m_spellmodxxaura.end(); i++)
-    {
-        if (!caster->HasAura((*i)->spellid))
-            continue;
-
-        if ((*i)->SpellFamily)
-            if ((*i)->SpellFamily != spellInfo->SpellFamilyName)
-                continue;
-        
-        if ((*i)->SpellClassMask != flag96(0, 0, 0))
-            if (!((*i)->SpellClassMask & spellInfo->SpellFamilyFlags))
-                continue;
-
-        if (!roll_chance_f((*i)->chance))
-            continue;
-
-        uint32 amount = 0;
-        switch ((*i)->type)
-        {
-        case LEECH_TYPE_SELF_CUR_PCT:
-            amount = caster->GetHealth() * (*i)->basepoints / 100;
-            break;
-        case LEECH_TYPE_SELF_MAX_PCT:
-            amount = caster->GetHealth() * (*i)->basepoints / 100;
-            break;
-        case LEECH_TYPE_TARGET_CUR_PCT:
-            amount = target->GetMaxHealth() * (*i)->basepoints / 100;
-            break;
-        case LEECH_TYPE_TARGET_MAX_PCT:
-            amount = target->GetMaxHealth() * (*i)->basepoints / 100;
-            break;
-        case LEECH_TYPE_STATIC:
-            amount = (*i)->basepoints;
-            break;
-        case LEECH_TYPE_DAMGE_PCT:
-            amount = damage * (*i)->basepoints / 100;
-            break;
-        }
-
-        if (amount != 0)
-        {
-            if ((*i)->addDmg != 0)
-                damage = damage + (*i)->addDmg * amount;
-            if (caster->IsAlive())
-                caster->HealBySpell(caster, spellInfo, amount);
-        }
-    }
+	std::unordered_map<uint32, SpellModTemplate>::iterator iter = SpellModMap.find(spellId);
+
+	if (iter != SpellModMap.end())
+		return iter->second.healMod == 0 ? 1.0f : iter->second.healMod;
+
+	return 1.0f;
 }
+bool SpellMod::AccontBind(uint32 spellId)
+{
+	std::unordered_map<uint32, SpellModTemplate>::iterator iter = SpellModMap.find(spellId);
+
+	if (iter != SpellModMap.end())
+		return iter->second.accountBind;
+
+	return false;
+}
+
+bool SpellMod::Enable(Player* player, uint32 spellId)
+{
+	std::unordered_map<uint32, SpellModTemplate>::iterator iter = SpellModMap.find(spellId);
 
+	if (iter != SpellModMap.end())
+	{
+		if (iter->second.disable)
+			return false;
 
-void SpellModMgr::ShieldOnDamage(Unit* caster, Unit* target, SpellInfo const* spellInfo, uint32 & handdamage)
+		uint32 reqId = GetReqId(spellId);
+
+		if (sReq->Check(player, reqId))
+		{
+			sReq->Des(player, reqId);
+			return true;
+		}
+		else
+			return false;
+	}
+
+	return true;
+}
+
+void SpellMod::LearnAccountSpell(Player* player)
 {
-    
-    for (auto dmgShieldItr = m_spellmodfsaura.begin(); dmgShieldItr != m_spellmodfsaura.end(); ++dmgShieldItr)
-    {
-        if (!caster->HasAura((*dmgShieldItr)->spellid))
-            continue;
-
-        SpellInfo const* i_spellProto = sSpellMgr->GetSpellInfo((*dmgShieldItr)->spellid);
-
-        if (!i_spellProto)
-            continue;
-
-        if (!roll_chance_f((*dmgShieldItr)->chance))
-            continue;
-
-        if ((*dmgShieldItr)->dmgmask)
-        {
-            if (spellInfo)
-            {
-                if (!((*dmgShieldItr)->dmgmask & spellInfo->SchoolMask))
-                    continue;
-            }
-            else
-            {
-                if (!((*dmgShieldItr)->dmgmask & 1))
-                    continue;
-            }
-        }
-
-
-        if (SpellMissInfo missInfo = caster->SpellHitResult(target, i_spellProto, false))
-        {
-            caster->SendSpellMiss(target, i_spellProto->Id, missInfo);
-            continue;
-        }
-
-
-        if (target->IsImmunedToDamageOrSchool(i_spellProto))
-        {
-            caster->SendSpellDamageImmune(target, i_spellProto->Id);
-            continue;
-        }
-
-        uint32 damage = 0;
-
-        switch ((*dmgShieldItr)->type)
-        {
-        case LEECH_TYPE_SELF_CUR_PCT:
-            damage = caster->GetHealth() * (*dmgShieldItr)->basepoints / 100;
-            break;
-        case LEECH_TYPE_SELF_MAX_PCT:
-            damage = caster->GetHealth() * (*dmgShieldItr)->basepoints / 100;
-            break;
-        case LEECH_TYPE_TARGET_CUR_PCT:
-            damage = target->GetMaxHealth() * (*dmgShieldItr)->basepoints / 100;
-            break;
-        case LEECH_TYPE_TARGET_MAX_PCT:
-            damage = target->GetMaxHealth() * (*dmgShieldItr)->basepoints / 100;
-            break;
-        case LEECH_TYPE_STATIC:
-            damage = (*dmgShieldItr)->basepoints;
-            break;
-        case LEECH_TYPE_DAMGE_PCT:
-            damage = handdamage * (*dmgShieldItr)->basepoints / 100;
-            break;
-        }
-
-
-        Unit::DealDamageMods(caster, damage, nullptr);
-        WorldPacket data(SMSG_SPELLDAMAGESHIELD, (8 + 8 + 4 + 4 + 4 + 4));
-        data << uint64(caster->GetGUID());
-        data << uint64(target->GetGUID());
-        data << uint32(i_spellProto->Id);
-        data << uint32(damage);
-        int32 overkill = int32(damage) - int32(target->GetHealth());
-        data << uint32(overkill > 0 ? overkill : 0);
-        data << uint32(i_spellProto->SchoolMask);
-        caster->SendMessageToSet(&data, true);
-
-        Unit::DealDamage(caster, target, damage, 0, SPELL_DIRECT_DAMAGE, i_spellProto->GetSchoolMask(), i_spellProto, true);
-    }
+	uint32 AccountId = player->GetSession()->GetAccountId();
+
+	QueryResult result = LoginDatabase.PQuery("SELECT spell FROM account_spells WHERE account = %u", AccountId);
+
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 spellId = fields[0].GetUInt32();
+
+			if (!player->HasSpell(spellId))
+				player->learnSpell(spellId);
+
+		} while (result->NextRow());
+	}
 }
 
+void SpellMod::InsertAccountSpell(Player* player)
+{
+	uint32 accountId = player->GetSession()->GetAccountId();
+
+	for (std::unordered_map<uint32, SpellModTemplate>::iterator iter = SpellModMap.begin(); iter != SpellModMap.end(); ++iter)
+	{
+		if (!iter->second.accountBind)
+			continue;
+
+		uint32 spellId = iter->first;
+
+		if (!player->HasSpell(spellId))
+			continue;
+
+		bool exsist = false;
+
+		for (std::vector<AccountSpellTemplate>::iterator ii = AccountSpellVec.begin(); ii != AccountSpellVec.end(); ii++)
+		{
+			if (accountId != ii->accountId)
+				continue;
+
+			if (spellId == ii->spellId)
+				exsist = true;
+		}
+
+		if (!exsist)
+		{
+			AccountSpellTemplate Temp;
+			Temp.accountId = accountId;
+			Temp.spellId = spellId;
+			AccountSpellVec.push_back(Temp);
+
+			PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_ACCOUNT_SPELL);
+			stmt->setUInt32(0, player->GetSession()->GetAccountId());
+			stmt->setInt32(1, spellId);
+			LoginDatabase.Execute(stmt);
+		}
+	}
+}
+
+bool SpellMod::Ignore(uint32 ignoreMask, Unit* target)
+{
+	if (!target)
+		return true;
+
+	bool ignore = false;
+
+	if (target->GetMap()->IsDungeon())
+		if ((ignoreMask & AURA_TRIGGER_IGNORE_DUNGEON) == AURA_TRIGGER_IGNORE_DUNGEON)
+			ignore = true;
+
+	if (!target->GetMap()->IsDungeon())
+		if ((ignoreMask & AURA_TRIGGER_IGNORE_NO_DUNGEON) == AURA_TRIGGER_IGNORE_NO_DUNGEON)
+			ignore = true;
+
+	if (Creature* creature = target->ToCreature())
+		if (creature->IsDungeonBoss() || creature->isWorldBoss())
+			if ((ignoreMask & AURA_TRIGGER_IGNORE_BOSS) == AURA_TRIGGER_IGNORE_BOSS)
+				ignore = true;
+
+	if (target->GetTypeId() == TYPEID_PLAYER)
+		if ((ignoreMask & AURA_TRIGGER_IGNORE_PLAYER) == AURA_TRIGGER_IGNORE_PLAYER)
+			ignore = true;
+
+	if (target->GetTypeId() == TYPEID_UNIT)
+		if ((ignoreMask & AURA_TRIGGER_IGNORE_UNIT) == AURA_TRIGGER_IGNORE_UNIT)
+			ignore = true;
+
+	return ignore;
+}
+
+void GetEnemyList(std::list<Unit*> &EnemyList, Unit* caster, float range)
+{
+	acore::AnyAoETargetUnitInObjectRangeCheck u_check(caster, caster, range);
+    acore::UnitListSearcher<acore::AnyAoETargetUnitInObjectRangeCheck> searcher(caster, EnemyList, u_check);
+	caster->VisitNearbyObject(range, searcher);
+}
+
+void GetFriendList(std::list<Unit*> &FriendList, Unit* caster, float range)
+{
+    acore::AnyFriendlyUnitInObjectRangeCheck u_check(caster, caster, range, true);
+    acore::UnitListSearcher<acore::AnyFriendlyUnitInObjectRangeCheck> searcher(caster, FriendList, u_check);
+	caster->VisitNearbyObject(range, searcher);
+}
+
+struct UnitSortTemplate
+{
+	Unit* unit;
+	float distance;
+};
+
+bool UnitSort(UnitSortTemplate a, UnitSortTemplate b)
+{
+	return a.distance < b.distance;
+}
+
+void GetNearestUnitVec(std::vector<Unit*> &UnitVec, std::list<Unit*> UnitList, Unit* caster, uint32 MaxTarget)
+{
+	std::vector<UnitSortTemplate> UnitSortVec;
+
+	for (std::list<Unit*>::iterator itr = UnitList.begin(); itr != UnitList.end(); ++itr)
+	{
+		UnitSortTemplate Temp;
+		Temp.unit = *itr;
+		Temp.distance = (*itr)->GetDistance(caster);
+		UnitSortVec.push_back(Temp);
+	}
+
+	std::sort(UnitSortVec.begin(), UnitSortVec.end(), UnitSort);
+
+	for (size_t i = 0; i < UnitSortVec.size(); i++)
+	{
+		if (i < MaxTarget)
+			UnitVec.push_back(UnitSortVec[i].unit);
+	}
+}
+
+bool SpellMod::AuraTrigger(Unit* caster, Unit* victim, SpellInfo const* auraSpellInfo, SpellInfo const* procSpell, uint32 procFlags, Unit*  &target, AuraEffect* triggeredByAura)
+{
+	std::unordered_map<uint32, SpellModBaseTemplate>::iterator itr = SpellModBaseMap.find(auraSpellInfo->Id);
+
+	if (itr != SpellModBaseMap.end())
+	{
+		for (size_t i = 0; i < MAX_SPELL_EFFECTS; i++)
+		{
+			if (const SpellInfo *triggerSpellInfo = sSpellMgr->GetSpellInfo(itr->second.EffectTriggerSpell[i]))
+			{
+				if (itr->second.procFlags != 0)
+					continue;
+
+				if (!roll_chance_f(itr->second.procChance))
+					continue;
+
+				if (procSpell->Effects[i].SpellClassMask != auraSpellInfo->Effects[i].SpellClassMask)
+					continue;
+
+				if (target == NULL)
+					target = !(procFlags & (PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS | PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_POS)) && triggerSpellInfo && triggerSpellInfo->IsPositive() ? caster : victim;
+
+				caster->CastSpell(target, triggerSpellInfo, true, NULL, triggeredByAura, NULL);
+			}
+		}
+	}
+
+	std::unordered_map<uint32, AuraTriggerSpellTemplate>::iterator iter = AuraTriggerSpellMap.find(auraSpellInfo->Id);
+
+	if (iter != AuraTriggerSpellMap.end())
+	{
+		uint32 triggerSpell = 0;//iter->second.triggerSpell;
+
+		if (!iter->second.triggerSpellData.empty())
+			triggerSpell = iter->second.triggerSpellData[urand(0, iter->second.triggerSpellData.size() - 1)];
+
+		if (triggerSpell == 0)
+			triggerSpell = procSpell->Id;
+
+		const SpellInfo *triggerSpellInfo = sSpellMgr->GetSpellInfo(triggerSpell);
+
+		if (!triggerSpellInfo)
+			return true;
+
+		if (target == NULL)
+			target = !(procFlags & (PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS | PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_POS)) && triggerSpellInfo && triggerSpellInfo->IsPositive() ? caster : victim;
+
+
+		if (Ignore(iter->second.ignoreMask, target))
+			return true;
+
+		if (caster->HasSpellCooldown(triggerSpell))
+		{
+			if (Player* player = caster->ToPlayer())
+			{
+				if (player->GetSpellCooldownDelay(triggerSpell) <= iter->second.cooldown)
+					return true;
+			}
+			else
+				return true;
+		}
+
+		bool canTrigger = false;
+
+		if (iter->second.linkSpellData.empty() || procSpell && std::find(iter->second.linkSpellData.begin(), iter->second.linkSpellData.end(), procSpell->Id) != iter->second.linkSpellData.end())
+			canTrigger = true;
+
+		if (!canTrigger || !roll_chance_f(iter->second.procChance))
+			return true;
+
+		float ap = std::max(caster->GetTotalAttackPowerValue(BASE_ATTACK), caster->GetTotalAttackPowerValue(RANGED_ATTACK));
+		float sp = caster->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC);
+
+		int bp0 = triggerSpellInfo->Effects[EFFECT_0].BasePoints + int(ap * iter->second.bp0ApPct / 100 + sp * iter->second.bp0SpPct / 100);
+		int bp1 = triggerSpellInfo->Effects[EFFECT_1].BasePoints + int(ap * iter->second.bp1ApPct / 100 + sp * iter->second.bp1SpPct / 100);
+		int bp2 = triggerSpellInfo->Effects[EFFECT_2].BasePoints + int(ap * iter->second.bp2ApPct / 100 + sp * iter->second.bp2SpPct / 100);
+
+		//×î´óÄ¿±ê¸öÊýÎª1Ê±
+		if (iter->second.Targets == 1)
+		{
+			caster->CastCustomSpell(target, triggerSpell, &bp0, &bp1, &bp2, true, NULL, triggeredByAura, NULL);
+			caster->AddSpellCooldown(triggerSpell, 0, iter->second.cooldown);
+			return true;
+		}
+
+		//×î´óÄ¿±ê¸öÊý´óÓÚ1Ê± Ñ¡Ôñ¾àÀëÊ©·¨Õß×î½üµÄ×÷ÎªÄ¿±ê
+		std::list<Unit*> UnitList;
+
+		if (target == victim)
+		{
+			GetEnemyList(UnitList, caster, iter->second.TargetRange);
+			if (UnitList.empty())
+				return true;
+
+			std::vector<Unit*> UnitVec;
+			GetNearestUnitVec(UnitVec, UnitList, caster, iter->second.Targets);
+
+			if (UnitVec.empty())
+				return true;
+
+			for (std::vector<Unit*>::iterator itr = UnitVec.begin(); itr != UnitVec.end(); ++itr)
+				caster->CastCustomSpell((*itr), triggerSpell, &bp0, &bp1, &bp2, true, NULL, triggeredByAura, NULL);
+
+			caster->AddSpellCooldown(triggerSpell, 0, iter->second.cooldown);
+		}
+		else if (target == caster)
+		{
+			GetFriendList(UnitList, caster, iter->second.TargetRange);
+
+			if (UnitList.empty())
+				return true;
+
+			std::vector<Unit*> UnitVec;
+			GetNearestUnitVec(UnitVec, UnitList, caster, iter->second.Targets);
+
+			if (UnitVec.empty())
+				return true;
+
+			for (std::vector<Unit*>::iterator itr = UnitVec.begin(); itr != UnitVec.end(); ++itr)
+				(*itr)->CastCustomSpell((*itr), triggerSpell, &bp0, &bp1, &bp2, true, NULL, triggeredByAura, NULL);
+
+			caster->AddSpellCooldown(triggerSpell, 0, iter->second.cooldown);
+		}
+		return true;
+	}
+
+	return false;
+}
+
+
+void SpellMod::HealOnDamage(Unit* caster, Unit* target, SpellInfo const* spellInfo, uint32 &damage)
+{
+	//ÎüÑª¼¼ÄÜ
+	for (auto iter = SpellLeechVec.begin(); iter != SpellLeechVec.end(); iter++)
+	{
+		if (iter->spellid == spellInfo->Id)
+		{
+			if (roll_chance_f(iter->chance))
+			{
+				if (iter->meetAura == 0 || caster->HasAura(iter->meetAura))
+				{
+					uint32 amount = 0;
+
+					switch (iter->type)
+					{
+					case LEECH_TYPE_SELF_CUR_PCT:
+						amount = caster->GetHealth() * iter->basepoints / 100;
+						break;
+					case LEECH_TYPE_SELF_MAX_PCT:
+						amount = caster->GetMaxHealth() * iter->basepoints / 100;
+						break;
+					case LEECH_TYPE_TARGET_CUR_PCT:
+						amount = target->GetMaxHealth() * iter->basepoints / 100;
+						break;
+					case LEECH_TYPE_TARGET_MAX_PCT:
+						amount = target->GetMaxHealth() * iter->basepoints / 100;
+						break;
+					case LEECH_TYPE_STATIC:
+						amount = iter->basepoints;
+						break;
+					case LEECH_TYPE_DAMGE_PCT:
+						amount = damage * iter->basepoints / 100;
+						break;
+					}
+
+					if (amount != 0)
+					{
+						if (iter->addDmg)
+							damage += amount;
+						if (caster->IsAlive())
+							caster->HealBySpell(caster, spellInfo, amount);
+					}
+				}
+			}
+		}
+	}
+
+	//ÎüÑª¹â»·
+	for (std::unordered_map<uint32, AuraLeechTemplate>::iterator it = AuraLeechMap.begin(); it != AuraLeechMap.end(); it++)
+	{
+		if (roll_chance_f(it->second.chance))
+		{
+			if (caster->HasAura(it->first))
+			{
+				uint32 amount = 0;
+
+				switch (it->second.type)
+				{
+				case LEECH_TYPE_SELF_CUR_PCT:
+					amount = caster->GetHealth() * it->second.basepoints / 100;
+					break;
+				case LEECH_TYPE_SELF_MAX_PCT:
+					amount = caster->GetHealth() * it->second.basepoints / 100;
+					break;
+				case LEECH_TYPE_TARGET_CUR_PCT:
+					amount = target->GetMaxHealth() * it->second.basepoints / 100;
+					break;
+				case LEECH_TYPE_TARGET_MAX_PCT:
+					amount = target->GetMaxHealth() * it->second.basepoints / 100;
+					break;
+				case LEECH_TYPE_STATIC:
+					amount = it->second.basepoints;
+					break;
+				case LEECH_TYPE_DAMGE_PCT:
+					amount = damage * it->second.basepoints / 100;
+					break;
+				}
+
+				if (amount != 0)
+				{
+					if (it->second.addDmg)
+						damage += amount;
+					if (caster->IsAlive())
+						caster->HealBySpell(caster, spellInfo, amount);
+				}
+			}
+		}
+	}
+}
+
+class SpellModPlayerScripts : PlayerScript
+{
+public:
+	SpellModPlayerScripts() : PlayerScript("SpellModPlayerScripts") {}
+
+	void OnUpdateZone(Player* player, uint32 newZone, uint32 /*newArea*/) override
+	{
+		for (std::unordered_map<uint32, SpellModTemplate>::iterator iter = SpellModMap.begin(); iter != SpellModMap.end(); ++iter)
+			if (player->HasAura(iter->first))
+				if (!sSpellMod->Enable(player, iter->first))
+					player->RemoveAura(iter->first);
+	}
+
+	void OnLogin(Player* player) override
+	{
+		sSpellMod->LearnAccountSpell(player);
+	}
+
+	void OnLogout(Player* player) override
+	{
+		sSpellMod->InsertAccountSpell(player);
+	}
+};
+
+class spell_gen_mount_custom : public SpellScriptLoader
+{
+public:
+	spell_gen_mount_custom() : SpellScriptLoader("spell_gen_mount_custom") { }
+	class spell_gen_mount_SpellScript : public SpellScript
+	{
+		PrepareSpellScript(spell_gen_mount_SpellScript);
+
+	public:
+		void HandleMount(SpellEffIndex effIndex)
+		{
+			PreventHitDefaultEffect(effIndex);
+
+			if (Player* target = GetHitPlayer())
+			{
+
+				ChatHandler(target->GetSession()).PSendSysMessage("1");
+
+				uint32 petNumber = target->GetTemporaryUnsummonedPetNumber();
+				target->SetTemporaryUnsummonedPetNumber(0);
+
+				// Prevent stacking of mounts and client crashes upon dismounting
+				target->RemoveAurasByType(SPELL_AURA_MOUNTED, 0, GetHitAura());
+
+				// Triggered spell id dependent on riding skill and zone
+				bool canFly = false;
+				uint32 map = GetVirtualMapForMapAndZone(target->GetMapId(), target->GetZoneId());
+				if (map == 530 || (map == 571 && target->HasSpell(54197)))
+					canFly = true;
+
+				float x, y, z;
+				target->GetPosition(x, y, z);
+				uint32 areaFlag = target->GetBaseMap()->GetAreaId(x, y, z);
+				AreaTableEntry const* area = sAreaTableStore.LookupEntry(areaFlag);
+				// Xinef: add battlefield check
+				Battlefield* Bf = sBattlefieldMgr->GetBattlefieldToZoneId(target->GetZoneId());
+				if (!area || (canFly && ((area->flags & AREA_FLAG_NO_FLY_ZONE) || (Bf && !Bf->CanFlyIn()))))
+					canFly = false;
+
+				uint32 mount = 0;
+
+				auto itr = MountSpellMap.find(GetSpellInfo()->Id);
+				if (itr != MountSpellMap.end())
+				{
+					switch (target->GetBaseSkillValue(SKILL_RIDING))
+					{
+					case 75:
+						mount = itr->second.mount60;
+						break;
+					case 150:
+						mount = itr->second.mount100;
+						break;
+					case 225:
+						if (canFly)
+							mount = itr->second.mount150;
+						else
+							mount = itr->second.mount100;
+						break;
+					case 300:
+						if (canFly)
+						{
+							if (itr->second.mount310 && target->Has310Flyer(false))
+								mount = itr->second.mount60;
+							else
+								mount = itr->second.mount280;
+						}
+						else
+							mount = itr->second.mount100;
+						break;
+					default:
+						break;
+					}
+				}
+
+				ChatHandler(target->GetSession()).PSendSysMessage("SKILL_RIDING %u", target->GetBaseSkillValue(SKILL_RIDING));
+				ChatHandler(target->GetSession()).PSendSysMessage("mount %u", mount);
+
+				if (mount)
+				{
+					PreventHitAura();
+					target->CastSpell(target, mount, true);
+				}
+
+				if (petNumber)
+					target->SetTemporaryUnsummonedPetNumber(petNumber);
+			}
+		}
+
+		void Register()
+		{
+			OnEffectHitTarget += SpellEffectFn(spell_gen_mount_SpellScript::HandleMount, EFFECT_2, SPELL_EFFECT_SCRIPT_EFFECT);
+		}
+
+	private:
+	};
+
+	SpellScript* GetSpellScript() const
+	{
+		return new spell_gen_mount_SpellScript();
+	}
+};
+
+
+void AddSC_SpellMod()
+{
+	new SpellModPlayerScripts();
+	new spell_gen_mount_custom();
+}
diff --git a/src/server/scripts/Custom/SpellMod/SpellMod.h b/src/server/scripts/Custom/SpellMod/SpellMod.h
index a4dfbc7..ec36f0f 100644
--- a/src/server/scripts/Custom/SpellMod/SpellMod.h
+++ b/src/server/scripts/Custom/SpellMod/SpellMod.h
@@ -1,232 +1,225 @@
-ï»¿#ifndef __Spell_H
-#define __Spell_H
-#include "Common.h"
-#include "Timer.h"
-#include <ace/Singleton.h>
-#include <ace/Atomic_Op.h>
-#include "SharedDefines.h"
-#include "Util.h"
-#include <atomic>
-#include <map>
-#include <set>
-#include <list>
-#pragma execution_character_set("utf-8")
+struct SpellModTemplate
+{
+	uint32 reqId;
+	float dmgMod;
+	float healMod;
+	bool accountBind;
+	bool disable;
+	uint32 castingtime;
+	uint32 duration;
+	uint32 cooldown;
+	uint32 procChance;
+	uint32 Periodic[MAX_SPELL_EFFECTS];
+};
+
+extern std::unordered_map<uint32, SpellModTemplate> SpellModMap;
+
+struct SpellModBaseTemplate
+{
+	uint32    EffectImplicitTargetA[MAX_SPELL_EFFECTS];
+	uint32    Effect[MAX_SPELL_EFFECTS];
+	uint32    EffectApplyAuraName[MAX_SPELL_EFFECTS];
+	int32     EffectMiscValue[MAX_SPELL_EFFECTS];
+	int32     EffectBasePoints[MAX_SPELL_EFFECTS];
+	uint32    EffectTriggerSpell[MAX_SPELL_EFFECTS];
+	flag96    EffectSpellClassMask[MAX_SPELL_EFFECTS];
+	uint32    SpellFamilyName;
+	uint32    procChance;
+	uint32    procCharges;
+	uint32	  procFlags;
+	int32     RecoveryTime;
+};
+
+extern std::unordered_map<uint32, SpellModBaseTemplate> SpellModBaseMap;
+
+struct AuraModSpellTemplate
+{
+	uint32 AuraId;
+	SpellFamilyNames SpellFamilyName;
+	std::vector<uint32> SpellVec;
+	SpellModType Type[MAX_SPELL_EFFECTS];
+	SpellModOp Op[MAX_SPELL_EFFECTS];
+	int32 Value[MAX_SPELL_EFFECTS];
+};
+
+extern std::vector<AuraModSpellTemplate> AuraModSpellVec;
+
+struct AuraModClassSpellTemplate
+{
+	uint32 AuraId;
+	SpellFamilyNames SpellFamilyName;
+	SpellModType Type[MAX_SPELL_EFFECTS];
+	SpellModOp Op[MAX_SPELL_EFFECTS];
+	int32 Value[MAX_SPELL_EFFECTS];
+};
+
+extern std::unordered_map<uint32, AuraModClassSpellTemplate> AuraModClassSpellMap;
+
+struct AuraModStatTemplate
+{
+	uint32 aura;
+	uint32 auraType[MAX_SPELL_EFFECTS];
+	int32 basePoints[MAX_SPELL_EFFECTS];
+	int32 misc[MAX_SPELL_EFFECTS];
+	int32 miscB[MAX_SPELL_EFFECTS];
+};
 
-//ææéæ±è¡¨
+extern std::unordered_map<uint32, AuraModStatTemplate> AuraModStatMap;
 
-struct SpellCustomMod
+enum ModTypes
 {
-    uint32 spellid;
-    uint32 reqId;
-    uint32 rewId;
-    float dmgMod;
-    float healMod;
-    bool accountBind;
-    bool disable;
-    int32 castingtime;
-    int32 duration;
-    uint32 cooldown;
-    uint32 procChance;
-    uint32 Periodic[MAX_SPELL_EFFECTS];
+	MOD_TYPE_PCT,
+	MOD_TYPE_AMOUNT,
 };
 
-struct SpellCustomLearnMod
+struct AuraPctTemplate
 {
-    uint32 spellid;
-    uint32 reqId;
-    uint32 rewId;
+	uint32 aura;
+	uint32 auraType[MAX_SPELL_EFFECTS];
+	int32 basePoints[MAX_SPELL_EFFECTS];
+	uint32 misc[MAX_SPELL_EFFECTS];
+	uint32 miscB[MAX_SPELL_EFFECTS];
 };
 
-struct SpellCustomUnLearnMod
+extern std::unordered_map<uint32, AuraPctTemplate> AuraPctMap;
+
+struct AccountSpellTemplate
+{
+	uint32 accountId;
+	uint32 spellId;
+};
+
+extern std::vector<AccountSpellTemplate> AccountSpellVec;
+
+struct MountSpellTemplate
 {
-    uint32 spellid;
-    uint32 reqId;
-    uint32 rewId;
+	uint32 mount60;
+	uint32 mount100;
+	uint32 mount150;
+	uint32 mount280;
+	uint32 mount310;
 };
 
+extern std::unordered_map<uint32, MountSpellTemplate> MountSpellMap;
+
 enum LeechTypes
 {
-    LEECH_TYPE_NONE,
-    LEECH_TYPE_SELF_CUR_PCT,			//0 èªèº«å½åçå½å¼ç¾åæ¯
-    LEECH_TYPE_SELF_MAX_PCT,			//1 èªèº«æå¤§çå½å¼ç¾åæ¯
-    LEECH_TYPE_TARGET_CUR_PCT,			//2 ç®æ å½åçå½å¼ç¾åæ¯
-    LEECH_TYPE_TARGET_MAX_PCT,			//3 ç®æ æå¤§çå½å¼ç¾åæ¯
-    LEECH_TYPE_STATIC,					//4 åºå®æ°å¼
-    LEECH_TYPE_DAMGE_PCT,				//5 æè½ä¼¤å®³ç¾åæ¯
+	LEECH_TYPE_NONE,
+	LEECH_TYPE_SELF_CUR_PCT,			//0 èªèº«å½åçå½å¼ç¾åæ¯
+	LEECH_TYPE_SELF_MAX_PCT,			//1 èªèº«æå¤§çå½å¼ç¾åæ¯
+	LEECH_TYPE_TARGET_CUR_PCT,			//2 ç®æ å½åçå½å¼ç¾åæ¯
+	LEECH_TYPE_TARGET_MAX_PCT,			//3 ç®æ æå¤§çå½å¼ç¾åæ¯
+	LEECH_TYPE_STATIC,					//4 åºå®æ°å¼
+	LEECH_TYPE_DAMGE_PCT,				//5 æè½ä¼¤å®³ç¾åæ¯
+};
+
+struct SpellLeechTemplate
+{
+	uint32 spellid;
+	float chance;
+	LeechTypes type;
+	float basepoints;
+	bool addDmg;
+	uint32 meetAura;
 };
 
-struct SpellCustomXxSpellMod
+extern std::vector<SpellLeechTemplate> SpellLeechVec;
+
+struct AuraLeechTemplate
 {
-    uint32 spellid;
-    float chance;
-    LeechTypes type;
-    float basepoints;
-    float addDmg;
-    uint32 meetAura;
+	float chance;
+	LeechTypes type;
+	float basepoints;
+	bool addDmg;
 };
 
-struct SpellCustomXxAuraMod
+extern std::unordered_map<uint32, AuraLeechTemplate> AuraLeechMap;
+
+enum AuraTriggerIgnoreMask
 {
-    uint32 spellid;
-    float chance;
-    LeechTypes type;
-    float basepoints;
-    float addDmg;
-    flag96 SpellClassMask;
-    uint32 SpellFamily;
+	AURA_TRIGGER_IGNORE_BOSS = 1,
+	AURA_TRIGGER_IGNORE_DUNGEON = 2,
+	AURA_TRIGGER_IGNORE_NO_DUNGEON = 4,
+	AURA_TRIGGER_IGNORE_PLAYER = 8,
+	AURA_TRIGGER_IGNORE_UNIT = 16,
 };
 
-struct SpellCustomFsAuraMod
+struct AuraTriggerSpellTemplate
 {
-    uint32 spellid;
-    uint32 dmgmask;
-    float chance;
-    LeechTypes type;
-    float basepoints;
+	uint32 auraId;
+	std::vector<uint32>triggerSpellData;
+	float procChance;
+	std::vector<uint32>linkSpellData;
+	float bp0ApPct;
+	float bp1ApPct;
+	float bp2ApPct;
+	float bp0SpPct;
+	float bp1SpPct;
+	float bp2SpPct;
+	uint32 cooldown;
+	uint32 ignoreMask;
+
+	float TargetRange;
+	uint32 Targets;
+
+	uint32 procFlags;
 };
 
-struct AuraStackTriggerMod
+extern std::unordered_map<uint32, AuraTriggerSpellTemplate> AuraTriggerSpellMap;
+
+extern std::unordered_map<uint32, std::string> OnRemoveSpellMap;
+extern std::unordered_map<uint32, std::string> OnLearnSpellMap;
+
+extern std::unordered_map<uint32, uint32> SpellCusTargetMaskMap;
+
+struct AuraStackTriggerTemplate
 {
-    uint32 auraid;
-    uint32 Stacks;
-    std::vector<uint32> TriggerSpellVec;
-    uint32 RemoveStacks;
+	uint32 Stacks;
+	std::vector<uint32> TriggerSpellVec;
+	uint32 RemoveStacks;
 };
 
-struct AuraOnDeathMod
+extern std::unordered_map<uint32, AuraStackTriggerTemplate> AuraStackTriggerMap;
+
+struct AuraTriggerOnDeathTemplate
 {
-    uint32 auraid;
-    uint32 CoolDown;
-    uint32 AttackerTriggerSpell;
-    float AttackerTriggerChance;
-    uint32 SelfTriggerSpell;
-    float SelfTriggerChance;
-    bool PreventLastDamage;
+	uint32 CoolDown;
+	uint32 AttackerTriggerSpell;
+	float AttackerTriggerChance;
+	uint32 SelfTriggerSpell;
+	float SelfTriggerChance;
+	bool PreventLastDamage;
 };
+extern std::unordered_map<uint32, AuraTriggerOnDeathTemplate> AuraTriggerOnDeathMap;
 
-class SpellModMgr
+class SpellMod
 {
 public:
-    SpellModMgr();
-    ~SpellModMgr();
-
-    SpellCustomMod const * FindSpellCustomMod(uint32 spellid)
-    {
-        for (auto i = m_spellmods.begin(); i != m_spellmods.end(); i++)
-        {
-            if ((*i)->spellid == spellid)
-                return (*i);
-        }
-        return nullptr;
-    }
-
-    typedef std::vector<SpellCustomMod*>  CSpellModMap;
-    CSpellModMap m_spellmods; //æè½åºç¡å±æ§
-
-
-    SpellCustomLearnMod const * FindSpellLearnMod(uint32 spellid)
-    {
-        for (auto i = m_spellmodlearns.begin(); i != m_spellmodlearns.end(); i++)
-        {
-            if ((*i)->spellid == spellid)
-                return (*i);
-        }
-        return nullptr;
-    }
-
-    typedef std::vector<SpellCustomLearnMod*>  CSpellModLearnMap;
-    CSpellModLearnMap m_spellmodlearns; //æè½å­¦ä¹ æ¶
-
-
-    SpellCustomUnLearnMod const * FindSpellUnLearnMod(uint32 spellid)
-    {
-        for (auto i = m_spellmodunlearns.begin(); i != m_spellmodunlearns.end(); i++)
-        {
-            if ((*i)->spellid == spellid)
-                return (*i);
-        }
-        return nullptr;
-    }
-
-    typedef std::vector<SpellCustomUnLearnMod*>  CSpellModUnLearnMap;
-    CSpellModUnLearnMap m_spellmodunlearns; //æè½éå¿æ¶
-
-
-    SpellCustomXxSpellMod const * FindSpellXxSpellMod(uint32 spellid)
-    {
-        for (auto i = m_spellmodxxspell.begin(); i != m_spellmodxxspell.end(); i++)
-        {
-            if ((*i)->spellid == spellid)
-                return (*i);
-        }
-        return nullptr;
-    }
-
-    typedef std::vector<SpellCustomXxSpellMod*>  CSpellModXxSpellMap;
-    CSpellModXxSpellMap m_spellmodxxspell; //å¸è¡æè½
-
-    SpellCustomXxAuraMod const * FindSpellXxAuraMod(uint32 spellid)
-    {
-        for (auto i = m_spellmodxxaura.begin(); i != m_spellmodxxaura.end(); i++)
-        {
-            if ((*i)->spellid == spellid)
-                return (*i);
-        }
-        return nullptr;
-    }
-
-    typedef std::vector<SpellCustomXxAuraMod*>  CSpellModXxAuraMap;
-    CSpellModXxAuraMap m_spellmodxxaura; //å¸è¡åç¯
-
-
-    SpellCustomFsAuraMod const * FindSpellFsAuraMod(uint32 spellid)
-    {
-        for (auto i = m_spellmodfsaura.begin(); i != m_spellmodfsaura.end(); i++)
-        {
-            if ((*i)->spellid == spellid)
-                return (*i);
-        }
-        return nullptr;
-    }
-
-    typedef std::vector<SpellCustomFsAuraMod*>  CSpellModFsAuraMap;
-    CSpellModFsAuraMap m_spellmodfsaura; //åä¼¤åç¯
-
-
-    AuraStackTriggerMod const * FindAuraStackMod(uint32 spellid)
-    {
-        for (auto i = m_AuraStackTriggers.begin(); i != m_AuraStackTriggers.end(); i++)
-        {
-            if ((*i)->auraid == spellid)
-                return (*i);
-        }
-        return nullptr;
-    }
-
-    typedef std::vector<AuraStackTriggerMod*>  CAuraStackTriggerMap;
-    CAuraStackTriggerMap m_AuraStackTriggers; //åç¯å å 
-
-
-    AuraOnDeathMod const * FindAuraOnDeathMod(uint32 spellid)
-    {
-        for (auto i = m_AuraOnDeath.begin(); i != m_AuraOnDeath.end(); i++)
-        {
-            if ((*i)->auraid == spellid)
-                return (*i);
-        }
-        return nullptr;
-    }
-
-    typedef std::vector<AuraOnDeathMod*>  CAuraOnDeathMap;
-    CAuraOnDeathMap m_AuraOnDeath; //åç¯æ­»äº¡è§¦å
-
-    void Load();
-    void HealOnDamage(Unit* caster, Unit* target, SpellInfo const* spellInfo, uint32 &damage);
-    void ShieldOnDamage(Unit* caster, Unit* target, SpellInfo const* spellInfo, uint32 &damage);
-protected:
+	static SpellMod* instance()
+	{
+		static SpellMod instance;
+		return &instance;
+	}
+
+	void Load();
+	bool Enable(Player* player, uint32 spellId);
+	uint32 GetReqId(uint32 spellId);
+	float GetDmgMod(uint32 spellId);
+	float GetHealMod(uint32 spellId);
+	bool AccontBind(uint32 spellId);
+
+	//account spell
+	void LearnAccountSpell(Player* player);
+	void InsertAccountSpell(Player* player);
+
+
+	bool Ignore(uint32 ignoreMask, Unit* target);
+	bool AuraTrigger(Unit* caster, Unit* victim, SpellInfo const* auraSpellInfo, SpellInfo const* procSpell, uint32 procFlags, Unit*  &target, AuraEffect* triggeredByAura);
+	void HealOnDamage(Unit* caster, Unit* target, SpellInfo const* spellInfo, uint32 &damage);
+
+	void GetParams_PctOnStat(const char* strAuraType, const char* strStatType, AuraType &auraType, int32 &misc, int32 &miscB);
+	void GetParams_Pct(const char* strAuraType, const char* strModType, AuraType &auraType, int32 &misc, int32 &miscB);
 private:
-};
-
-#define sSpellModMgr ACE_Singleton<SpellModMgr, ACE_Null_Mutex>::instance()
-#endif
 
+};
+#define sSpellMod SpellMod::instance()
diff --git a/src/server/scripts/Custom/SpellMod/SpellScripts.cpp b/src/server/scripts/Custom/SpellMod/SpellScripts.cpp
new file mode 100644
index 0000000..d104452
--- /dev/null
+++ b/src/server/scripts/Custom/SpellMod/SpellScripts.cpp
@@ -0,0 +1,47 @@
+class spell_dmg_to_heal : public SpellScriptLoader
+{
+public:
+	spell_dmg_to_heal() : SpellScriptLoader("spell_dmg_to_heal") { }
+
+	class spell_dmg_to_heal_AuraScript : public AuraScript
+	{
+		PrepareAuraScript(spell_dmg_to_heal_AuraScript);
+
+		bool Validate(SpellInfo const* /*spellInfo*/)
+		{
+			if (!sSpellMgr->GetSpellInfo(404486))
+				return false;
+			return true;
+		}
+
+		void OnProc(AuraEffect const* aurEff, ProcEventInfo& eventInfo)
+		{
+			Unit* caster = GetCaster();
+			if (!caster)
+				return;
+
+			PreventDefaultAction();
+			int32 heal = CalculatePct(int32(eventInfo.GetDamageInfo()->GetDamage()), aurEff->GetAmount());
+
+			float healthPct = caster->GetHealthPct();
+			heal = (1 - healthPct) *heal;
+
+			caster->CastCustomSpell(404486, SPELLVALUE_BASE_POINT0, heal, caster, TRIGGERED_FULL_MASK, NULL, aurEff);
+		}
+
+		void Register()
+		{
+			OnEffectProc += AuraEffectProcFn(spell_dmg_to_heal_AuraScript::OnProc, EFFECT_1, SPELL_AURA_DUMMY);
+		}
+	};
+
+	AuraScript* GetAuraScript() const
+	{
+		return new spell_dmg_to_heal_AuraScript();
+	}
+};
+
+void AddSC_custom_spell_scripts()
+{
+	new spell_dmg_to_heal();
+}
diff --git a/src/server/scripts/Custom/SpiritPower/SpiritPower.cpp b/src/server/scripts/Custom/SpiritPower/SpiritPower.cpp
new file mode 100644
index 0000000..9091707
--- /dev/null
+++ b/src/server/scripts/Custom/SpiritPower/SpiritPower.cpp
@@ -0,0 +1,104 @@
+#pragma execution_character_set("utf-8")
+#include "SpiritPower.h"
+#include "../GCAddon/GCAddon.h"
+
+void SpiritPower::Init(Player* player)
+{
+	GetDBValue(player);
+	SendPacket(player);
+}
+
+void SpiritPower::SendPacket(Player* player)
+{
+	std::ostringstream oss;
+	oss << player->SpiritPower << " ";
+	oss << player->MaxSpiritPower;
+	sGCAddon->SendPacketTo(player, "GC_S_SPIRITPOWER", oss.str());
+}
+
+void SpiritPower::Update(Player* player, uint32 value, bool ins, bool notice)
+{
+	int32 ori = player->SpiritPower;
+
+	if (!ins)
+	{
+		player->SpiritPower -= value;
+
+		if (player->SpiritPower < 0)
+			player->SpiritPower = 0;
+	}	
+	else
+	{
+		player->SpiritPower += value;
+
+		if (player->SpiritPower > player->MaxSpiritPower)
+			player->SpiritPower = player->MaxSpiritPower;
+	}
+
+	int32 gap = ori - player->SpiritPower;
+
+	if (gap == 0)
+		return;
+
+	if (gap > 0)
+	{
+		if (notice)
+			ChatHandler(player->GetSession()).PSendSysMessage("[ÁéÁ¦]ÏûºÄ%u", gap);
+	}
+	else
+	{
+		if (notice)
+			ChatHandler(player->GetSession()).PSendSysMessage("[ÁéÁ¦]Ôö¼Ó%u", abs(gap));
+	}
+		
+
+	SendPacket(player);
+}
+
+void SpiritPower::UpdateMax(Player* player, uint32 maxValue)
+{
+	if (maxValue <= 0)
+		return;
+	
+	player->MaxSpiritPower = maxValue;
+
+	SendPacket(player);
+	CharacterDatabase.DirectPExecute("UPDATE characters SET MaxSpiritPower = %u WHERE guid = %u", maxValue, player->GetGUIDLow());
+	ChatHandler(player->GetSession()).PSendSysMessage("×î´ó[ÁéÁ¦]ÉèÖÃÎª%u", maxValue);
+}
+
+void SpiritPower::GetDBValue(Player* player)
+{
+	QueryResult result = CharacterDatabase.PQuery("SELECT SpiritPower,MaxSpiritPower FROM characters WHERE guid = %u", player->GetGUIDLow());
+	if (!result)
+		return;
+
+	Field* fields = result->Fetch();
+	player->SpiritPower = fields[0].GetUInt32();
+	player->MaxSpiritPower = fields[1].GetUInt32();
+}
+
+void SpiritPower::SaveToDB(Player* player)
+{
+	CharacterDatabase.DirectPExecute("UPDATE characters SET SpiritPower = %u WHERE guid = %u", player->SpiritPower, player->GetGUIDLow());
+}
+
+class SpiritPowerPlayerScript : PlayerScript
+{
+public:
+	SpiritPowerPlayerScript() : PlayerScript("SpiritPowerPlayerScript") {}
+	void OnLogin(Player* player) override
+	{
+		sSpiritPower->Init(player);
+	}
+
+	void OnLogout(Player* player) override
+	{
+		sSpiritPower->SaveToDB(player);
+	}
+};
+
+void AddSC_SpiritPower()
+{
+	new SpiritPowerPlayerScript();
+}
diff --git a/src/server/scripts/Custom/SpiritPower/SpiritPower.h b/src/server/scripts/Custom/SpiritPower/SpiritPower.h
new file mode 100644
index 0000000..f60baec
--- /dev/null
+++ b/src/server/scripts/Custom/SpiritPower/SpiritPower.h
@@ -0,0 +1,19 @@
+class SpiritPower
+{
+public:
+	static SpiritPower* instance()
+	{
+		static SpiritPower instance;
+		return &instance;
+	}
+
+	void Init(Player* player);
+	void UpdateMax(Player* player, uint32 maxValue);
+	void Update(Player* player, uint32 value, bool ins = true, bool notice = true);
+	void GetDBValue(Player* player);
+	void SaveToDB(Player* player);
+	void SendPacket(Player* player);
+private:
+
+};
+#define sSpiritPower SpiritPower::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/StatPoints/StatPoints.cpp b/src/server/scripts/Custom/StatPoints/StatPoints.cpp
new file mode 100644
index 0000000..8da5ab0
--- /dev/null
+++ b/src/server/scripts/Custom/StatPoints/StatPoints.cpp
@@ -0,0 +1,568 @@
+#pragma execution_character_set("utf-8")
+#include "StatPoints.h"
+#include "../Custom/CommonFunc/CommonFunc.h"
+#include "../GCAddon/GCAddon.h"
+
+uint32 stat_muil[MAX_STAT_POINTS_TYPE];
+
+void StatPoints::Load()
+{
+	for (size_t i = 0; i < MAX_STAT_POINTS_TYPE; i++)
+		stat_muil[i] = 0;
+
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT Ã¿µãÔö¼ÓÄÍÁ¦,Ã¿µãÔö¼ÓÃô½Ý,Ã¿µãÔö¼ÓÁ¦Á¿,Ã¿µãÔö¼ÓÖÇÁ¦,Ã¿µãÔö¼Ó¾«Éñ,Ã¿µãÔö¼ÓÃüÖÐµÈ¼¶,Ã¿µãÔö¼Ó±¬»÷µÈ¼¶,Ã¿µãÔö¼Ó¹¥»÷Ç¿¶È,Ã¿µãÔö¼Ó»¤¼×´©Í¸,Ã¿µãÔö¼Ó·¨ÊõÇ¿¶È,Ã¿µãÔö¼Ó·¨Êõ´©Í¸,Ã¿µãÔö¼Ó¼±ËÙµÈ¼¶ FROM __¶·Æø" :
+		"SELECT muil_stamina,muil_agility,muil_strength,muil_intellect,muil_spirit,muil_hit,muil_crit,muil_ap,muil_ape,muil_sp,muil_spe,muil_haste FROM _stat_points");
+	if (!result)
+		return;
+
+	Field* fields = result->Fetch();
+
+	for (size_t i = 1; i < MAX_STAT_POINTS_TYPE; i++)
+		stat_muil[i] = fields[i - 1].GetUInt32();
+}
+
+void StatPoints::LoadPlayerData(Player* player)
+{
+	QueryResult result = CharacterDatabase.PQuery("SELECT stat_points FROM characters where guid = %d", player->GetGUIDLow());
+	if (!result)
+		return;
+
+	std::string str = result->Fetch()[0].GetString();
+
+	if (str.empty())
+		return;
+
+	std::vector<std::string> v = sCF->SplitStr(str, " ");
+
+	if (v.empty())
+		return;
+
+	for (size_t i = 0; i < v.size(); i++)
+		player->stat_points[i] = (uint32)atoi(v[i].c_str());
+}
+
+void StatPoints::UpdateDB(Player* player)
+{
+	std::ostringstream oss;
+
+	for (size_t i = 0; i < MAX_STAT_POINTS_TYPE; i++)
+		oss << player->stat_points[i] << " ";
+
+	CharacterDatabase.PExecute("UPDATE characters SET stat_points = '%s'WHERE guid = %d", oss.str().c_str(), player->GetGUIDLow());
+}
+
+void StatPoints::UpdateDB(uint32 guid, uint32 statPoint)
+{
+	QueryResult result = CharacterDatabase.PQuery("SELECT stat_points FROM characters where guid = %d", guid);
+
+	if (!result)
+		return;
+
+	Field* fields = result->Fetch();
+
+	std::string str = fields[0].GetString();
+
+	if (str.empty())
+		return;
+
+	uint32 stat_points[MAX_STAT_POINTS_TYPE];
+
+	for (size_t i = 0; i < MAX_STAT_POINTS_TYPE; i++)
+		stat_points[i] = 0;
+
+	std::vector<std::string> v = sCF->SplitStr(str, " ");
+
+	if (v.empty())
+		return;
+
+	for (size_t i = 0; i < v.size(); i++)
+		stat_points[i] = (uint32)atoi(v[i].c_str());
+
+	stat_points[SPT_TOTLAL] += statPoint;
+
+
+	std::ostringstream oss;
+
+	for (size_t i = 0; i < MAX_STAT_POINTS_TYPE; i++)
+		oss << stat_points[i] << " ";
+
+	CharacterDatabase.PExecute("UPDATE characters SET stat_points = '%s'WHERE guid = %d", oss.str().c_str(), guid);
+}
+
+void StatPoints::ResetPoints(Player* player)
+{
+	Apply(player, false);
+
+	for (size_t i = SPT_TOTLAL; i < MAX_STAT_POINTS_TYPE; i++)
+	{
+		player->stat_points[SPT_TOTLAL] += player->stat_points[i];
+		player->stat_points[i] = 0;
+	}
+
+	Apply(player, true);
+
+	UpdateDB(player);
+}
+
+void StatPoints::Apply(Player* player, bool apply)
+{
+	//Ãô½Ý
+	float agility = player->stat_points[SPT_AGILITY] * stat_muil[SPT_AGILITY];
+	player->HandleStatModifier(UNIT_MOD_STAT_AGILITY, TOTAL_VALUE, agility, apply);
+	player->ApplyStatBuffMod(STAT_AGILITY, agility, apply);
+	//Á¦Á¿
+	float strength = player->stat_points[SPT_STRENGTH] * stat_muil[SPT_STRENGTH];
+	player->HandleStatModifier(UNIT_MOD_STAT_STRENGTH, TOTAL_VALUE, strength, apply);
+	player->ApplyStatBuffMod(STAT_STRENGTH, strength, apply);
+	//ÖÇÁ¦
+	float intellect = player->stat_points[SPT_INTELLECT] * stat_muil[SPT_INTELLECT];
+	player->HandleStatModifier(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE, intellect, apply);
+	player->ApplyStatBuffMod(STAT_INTELLECT, intellect, apply);
+	//¾«Éñ
+	float spirit = player->stat_points[SPT_SPIRIT] * stat_muil[SPT_SPIRIT];
+	player->HandleStatModifier(UNIT_MOD_STAT_SPIRIT, TOTAL_VALUE, spirit, apply);
+	player->ApplyStatBuffMod(STAT_SPIRIT, spirit, apply);
+	//ÄÍÁ¦
+	float stamina = player->stat_points[SPT_STMAMINA] * stat_muil[SPT_STMAMINA];
+	player->HandleStatModifier(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE, stamina, apply);
+	player->ApplyStatBuffMod(STAT_STAMINA, stamina, apply);
+	//ÃüÖÐ
+	int32 hit = player->stat_points[SPT_HIT] * stat_muil[SPT_HIT];
+	player->ApplyRatingMod(CR_HIT_MELEE, hit, apply);
+	player->ApplyRatingMod(CR_HIT_RANGED, hit, apply);
+	player->ApplyRatingMod(CR_HIT_SPELL, hit, apply);
+	//±©»÷
+	int32 crit = player->stat_points[SPT_CRIT] * stat_muil[SPT_CRIT];
+	player->ApplyRatingMod(CR_CRIT_MELEE, crit, apply);
+	player->ApplyRatingMod(CR_CRIT_RANGED, crit, apply);
+	player->ApplyRatingMod(CR_CRIT_SPELL, crit, apply);
+	//¼±ËÙ
+	int32 haste = player->stat_points[SPT_HASTE] * stat_muil[SPT_HASTE];
+	player->ApplyRatingMod(CR_HASTE_MELEE, haste, apply);
+	player->ApplyRatingMod(CR_HASTE_RANGED, haste, apply);
+	player->ApplyRatingMod(CR_HASTE_SPELL, haste, apply);
+	//¹¥Ç¿
+	float ap = player->stat_points[SPT_AP] * stat_muil[SPT_AP];
+	player->HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, ap, apply);
+	player->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, ap, apply);
+	//¼×´©
+	int32 ape = player->stat_points[SPT_APE] * stat_muil[SPT_APE];
+	player->ApplyRatingMod(CR_ARMOR_PENETRATION, ape, apply);
+	//·¨Ç¿
+	int32 sp = player->stat_points[SPT_SP] * stat_muil[SPT_SP];
+	player->ApplySpellPowerBonus(sp, apply);
+	//·¨´©
+	int32 spe = player->stat_points[SPT_SPE] * stat_muil[SPT_SPE];
+	player->ApplySpellPenetrationBonus(spe, apply);
+}
+
+void StatPoints::AddGosip(Player* player, Object* obj)
+{
+	std::ostringstream oss_cur_total;
+	std::ostringstream oss_cur_stamina;
+	std::ostringstream oss_cur_agility;
+	std::ostringstream oss_cur_strength;
+	std::ostringstream oss_cur_intellect;
+	std::ostringstream oss_cur_spirit;
+	std::ostringstream oss_cur_hit;
+	std::ostringstream oss_cur_crit;
+	std::ostringstream oss_cur_haste;
+	std::ostringstream oss_cur_ap;
+	std::ostringstream oss_cur_ape;
+	std::ostringstream oss_cur_sp;
+	std::ostringstream oss_cur_spe;
+
+	oss_cur_total << "- " << player->stat_points[SPT_TOTLAL] << " µãÊý";
+	oss_cur_stamina << "+ " << player->stat_points[SPT_STMAMINA] << " ÄÍÁ¦";
+	oss_cur_agility << "+ " << player->stat_points[SPT_AGILITY] << " Ãô½Ý";
+	oss_cur_strength << "+ " << player->stat_points[SPT_STRENGTH] << " Á¦Á¿";
+	oss_cur_intellect << "+ " << player->stat_points[SPT_INTELLECT] << " ÖÇÁ¦";
+	oss_cur_spirit << "+ " << player->stat_points[SPT_SPIRIT] << " ¾«Éñ";
+	oss_cur_hit << "+ " << player->stat_points[SPT_HIT] << " ÃüÖÐµÈ¼¶";
+	oss_cur_crit << "+ " << player->stat_points[SPT_CRIT] << " ±©»÷µÈ¼¶";
+	oss_cur_haste << "+ " << player->stat_points[SPT_HASTE] << " ¼±ËÙµÈ¼¶";
+	oss_cur_ap << "+ " << player->stat_points[SPT_AP] << " ¹¥»÷Ç¿¶È";
+	oss_cur_ape << "+ " << player->stat_points[SPT_APE] << " »¤¼×´©Í¸";
+	oss_cur_sp << "+ " << player->stat_points[SPT_SP] << " ·¨ÊõÇ¿¶È";
+	oss_cur_spe << "+ " << player->stat_points[SPT_SPE] << " ·¨Êõ´©Í¸";
+
+	std::ostringstream oss_stamina;
+	std::ostringstream oss_agility;
+	std::ostringstream oss_strength;
+	std::ostringstream oss_intellect;
+	std::ostringstream oss_spirit;
+	std::ostringstream oss_hit;
+	std::ostringstream oss_crit;
+	std::ostringstream oss_haste;
+	std::ostringstream oss_ap;
+	std::ostringstream oss_ape;
+	std::ostringstream oss_sp;
+	std::ostringstream oss_spe;
+
+	oss_stamina << "È·¶¨ + " << stat_muil[SPT_STMAMINA] << " ÄÍÁ¦";
+	oss_agility << "È·¶¨ + " << stat_muil[SPT_AGILITY] << " Ãô½Ý";
+	oss_strength << "È·¶¨ + " << stat_muil[SPT_STRENGTH] << " Á¦Á¿";
+	oss_intellect << "È·¶¨ + " << stat_muil[SPT_INTELLECT] << " ÖÇÁ¦";
+	oss_spirit << "È·¶¨ + " << stat_muil[SPT_SPIRIT] << " ¾«Éñ";
+	oss_hit << "È·¶¨ + " << stat_muil[SPT_HIT] << " ÃüÖÐµÈ¼¶";
+	oss_crit << "È·¶¨ + " << stat_muil[SPT_CRIT] << " ±©»÷µÈ¼¶";
+	oss_haste << "È·¶¨ + " << stat_muil[SPT_HASTE] << " ¼±ËÙµÈ¼¶";
+	oss_ap << "È·¶¨ + " << stat_muil[SPT_AP] << " ¹¥»÷Ç¿¶È";
+	oss_ape << "È·¶¨ + " << stat_muil[SPT_APE] << " »¤¼×´©Í¸";
+	oss_sp << "È·¶¨ + " << stat_muil[SPT_SP] << " ·¨ÊõÇ¿¶È";
+	oss_spe << "È·¶¨ + " << stat_muil[SPT_SPE] << " ·¨Êõ´©Í¸";
+
+	player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss_cur_total.str(), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);
+
+	if (stat_muil[SPT_STMAMINA] > 0)
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss_cur_stamina.str(), GOSSIP_SENDER_MAIN + 1, GOSSIP_ACTION_INFO_DEF);// , oss_stamina.str(), 0, false);
+	if (stat_muil[SPT_AGILITY] > 0)
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss_cur_agility.str(), GOSSIP_SENDER_MAIN + 2, GOSSIP_ACTION_INFO_DEF);// , oss_agility.str(), 0, false);
+	if (stat_muil[SPT_STRENGTH] > 0)
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss_cur_strength.str(), GOSSIP_SENDER_MAIN + 3, GOSSIP_ACTION_INFO_DEF);// , oss_strength.str(), 0, false);
+	if (stat_muil[SPT_INTELLECT] > 0)
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss_cur_intellect.str(), GOSSIP_SENDER_MAIN + 4, GOSSIP_ACTION_INFO_DEF);// , oss_intellect.str(), 0, false);
+	if (stat_muil[SPT_SPIRIT] > 0)
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss_cur_spirit.str(), GOSSIP_SENDER_MAIN + 5, GOSSIP_ACTION_INFO_DEF);// , oss_spirit.str(), 0, false);
+	if (stat_muil[SPT_HIT] > 0)
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss_cur_hit.str(), GOSSIP_SENDER_MAIN + 6, GOSSIP_ACTION_INFO_DEF);// , oss_hit.str(), 0, false);
+	if (stat_muil[SPT_CRIT] > 0)
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss_cur_crit.str(), GOSSIP_SENDER_MAIN + 7, GOSSIP_ACTION_INFO_DEF);// , oss_crit.str(), 0, false);
+	if (stat_muil[SPT_HASTE] > 0)
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss_cur_haste.str(), GOSSIP_SENDER_MAIN + 8, GOSSIP_ACTION_INFO_DEF);// , oss_haste.str(), 0, false);
+	if (stat_muil[SPT_AP] > 0)
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss_cur_ap.str(), GOSSIP_SENDER_MAIN + 9, GOSSIP_ACTION_INFO_DEF);// , oss_ap.str(), 0, false);
+	if (stat_muil[SPT_APE] > 0)
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss_cur_ape.str(), GOSSIP_SENDER_MAIN + 10, GOSSIP_ACTION_INFO_DEF);// , oss_ape.str(), 0, false);
+	if (stat_muil[SPT_SP] > 0)
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss_cur_sp.str(), GOSSIP_SENDER_MAIN + 11, GOSSIP_ACTION_INFO_DEF);// , oss_sp.str(), 0, false);
+	if (stat_muil[SPT_SPE] > 0)
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, oss_cur_spe.str(), GOSSIP_SENDER_MAIN + 12, GOSSIP_ACTION_INFO_DEF);// , oss_spe.str(), 0, false);
+
+	if (obj->ToCreature())
+		player->SEND_GOSSIP_MENU(obj->GetEntry(), obj->GetGUID());
+	else
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+}
+
+void StatPoints::AddPoints(Player* player, uint32 sender)
+{
+	if (player->stat_points[SPT_TOTLAL] < 1)
+	{
+		player->GetSession()->SendNotification("µãÊý²»×ã£¡");
+		player->CLOSE_GOSSIP_MENU();
+		return;
+	}
+
+	Apply(player, false);
+
+	switch (sender)
+	{
+	case GOSSIP_SENDER_MAIN + 1:
+		player->stat_points[SPT_STMAMINA]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case GOSSIP_SENDER_MAIN + 2:
+		player->stat_points[SPT_AGILITY]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case GOSSIP_SENDER_MAIN + 3:
+		player->stat_points[SPT_STRENGTH]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case GOSSIP_SENDER_MAIN + 4:
+		player->stat_points[SPT_INTELLECT]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case GOSSIP_SENDER_MAIN + 5:
+		player->stat_points[SPT_SPIRIT]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case GOSSIP_SENDER_MAIN + 6:
+		player->stat_points[SPT_HIT]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case GOSSIP_SENDER_MAIN + 7:
+		player->stat_points[SPT_CRIT]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case GOSSIP_SENDER_MAIN + 8:
+		player->stat_points[SPT_HASTE]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case GOSSIP_SENDER_MAIN + 9:
+		player->stat_points[SPT_AP]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case GOSSIP_SENDER_MAIN + 10:
+		player->stat_points[SPT_APE]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case GOSSIP_SENDER_MAIN + 11:
+		player->stat_points[SPT_SP]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case GOSSIP_SENDER_MAIN + 12:
+		player->stat_points[SPT_SPE]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	default:
+		break;
+	}
+
+	Apply(player, true);
+	UpdateDB(player);
+	player->CLOSE_GOSSIP_MENU();
+}
+
+
+class StatPoints_PlayerScript : public PlayerScript
+{
+public:
+	StatPoints_PlayerScript() : PlayerScript("StatPoints_PlayerScript") {}
+
+	void OnLogin(Player* player) override
+	{
+		sStatPoints->LoadPlayerData(player);
+		sStatPoints->Apply(player, true);
+	}
+
+	void OnLogout(Player* player)
+	{
+		sStatPoints->UpdateDB(player);
+	}
+
+	//void OnCreatureKill(Player* player, Creature* /*killed*/)
+	//{
+	//	player->stat_points[SPT_TOTLAL]++;
+	//}
+};
+
+class NPCStatPoints : public CreatureScript
+{
+public:
+	NPCStatPoints() : CreatureScript("NPCStatPoints") { }
+	bool OnGossipHello(Player* player, Creature* creature) override
+	{
+		sStatPoints->OpenPanel(player);
+
+		return true;
+		player->PlayerTalkClass->ClearMenus();
+
+		sStatPoints->AddGosip(player, creature);
+
+		return true;
+	}
+
+	bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action) override
+	{
+		player->PlayerTalkClass->ClearMenus();
+
+		if (sender == GOSSIP_SENDER_MAIN)
+		{
+			sStatPoints->AddGosip(player, creature);
+			return true;
+		}
+
+		sStatPoints->AddPoints(player, sender);
+
+		player->PlayerTalkClass->ClearMenus();
+		sStatPoints->AddGosip(player, creature);
+		return true;
+	}
+};
+
+void AddSC_StatPoints()
+{
+	new StatPoints_PlayerScript();
+	new NPCStatPoints();
+}
+
+
+void StatPoints::OpenPanel(Player* player)
+{
+	std::ostringstream oss;
+
+	oss << player->stat_points[SPT_TOTLAL] << "-¶·ÆøµãÊý" << "#";
+
+	if (stat_muil[SPT_STMAMINA] > 0)
+		oss << stat_muil[SPT_STMAMINA] * player->stat_points[SPT_STMAMINA] << ":1:ÄÍÁ¦-";
+	if (stat_muil[SPT_AGILITY] > 0)
+		oss << stat_muil[SPT_AGILITY] * player->stat_points[SPT_AGILITY] << ":2:Ãô½Ý-";
+	if (stat_muil[SPT_STRENGTH] > 0)
+		oss << stat_muil[SPT_STRENGTH] * player->stat_points[SPT_STRENGTH] << ":3:Á¦Á¿-";
+	if (stat_muil[SPT_INTELLECT] > 0)
+		oss << stat_muil[SPT_INTELLECT] * player->stat_points[SPT_INTELLECT] << ":4:ÖÇÁ¦-";
+	if (stat_muil[SPT_SPIRIT] > 0)
+		oss << stat_muil[SPT_SPIRIT] * player->stat_points[SPT_SPIRIT] << ":5:¾«Éñ-";
+	if (stat_muil[SPT_HIT] > 0)
+		oss << stat_muil[SPT_HIT] * player->stat_points[SPT_HIT] << ":6:ÃüÖÐµÈ¼¶-";
+	if (stat_muil[SPT_CRIT] > 0)
+		oss << stat_muil[SPT_CRIT] * player->stat_points[SPT_CRIT] << ":7:±©»÷µÈ¼¶-";
+	if (stat_muil[SPT_HASTE] > 0)
+		oss << stat_muil[SPT_HASTE] * player->stat_points[SPT_HASTE] << ":8:¼±ËÙµÈ¼¶-";
+	if (stat_muil[SPT_AP] > 0)
+		oss << stat_muil[SPT_AP] * player->stat_points[SPT_AP] << ":9:¹¥»÷Ç¿¶È-";
+	if (stat_muil[SPT_APE] > 0)
+		oss << stat_muil[SPT_APE] * player->stat_points[SPT_APE] << ":10:»¤¼×´©Í¸-";
+	if (stat_muil[SPT_SP] > 0)
+		oss << stat_muil[SPT_SP] * player->stat_points[SPT_SP] << ":11:·¨ÊõÇ¿¶È-";
+	if (stat_muil[SPT_SPE] > 0)
+		oss << stat_muil[SPT_SPE] * player->stat_points[SPT_SPE] << ":12:·¨Êõ´©Í¸-";
+
+	sGCAddon->SendPacketTo(player, "GC_S_STATPOINTS", oss.str());
+}
+
+void StatPoints::Ins(Player* player, uint32 id)
+{
+	if (player->stat_points[SPT_TOTLAL] < 1)
+		return;
+
+	Apply(player, false);
+
+	switch (id)
+	{
+	case 1:
+		player->stat_points[SPT_STMAMINA]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case 2:
+		player->stat_points[SPT_AGILITY]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case 3:
+		player->stat_points[SPT_STRENGTH]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case 4:
+		player->stat_points[SPT_INTELLECT]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case 5:
+		player->stat_points[SPT_SPIRIT]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case 6:
+		player->stat_points[SPT_HIT]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case 7:
+		player->stat_points[SPT_CRIT]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case 8:
+		player->stat_points[SPT_HASTE]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case 9:
+		player->stat_points[SPT_AP]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case 10:
+		player->stat_points[SPT_APE]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case 11:
+		player->stat_points[SPT_SP]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	case 12:
+		player->stat_points[SPT_SPE]++;
+		player->stat_points[SPT_TOTLAL]--;
+		break;
+	default:
+		break;
+	}
+
+	Apply(player, true);
+	UpdateDB(player);
+	OpenPanel(player);
+}
+
+void StatPoints::Des(Player* player, uint32 id)
+{
+	Apply(player, false);
+
+	switch (id)
+	{
+	case 1:
+		if (player->stat_points[SPT_STMAMINA] < 1)
+			break;
+		player->stat_points[SPT_STMAMINA]--;
+		player->stat_points[SPT_TOTLAL]++;
+		break;
+	case 2:
+		if (player->stat_points[SPT_AGILITY] < 1)
+			break;
+		player->stat_points[SPT_AGILITY]--;
+		player->stat_points[SPT_TOTLAL]++;
+		break;
+	case 3:
+		if (player->stat_points[SPT_STRENGTH] < 1)
+			break;
+		player->stat_points[SPT_STRENGTH]--;
+		player->stat_points[SPT_TOTLAL]++;
+		break;
+	case 4:
+		if (player->stat_points[SPT_INTELLECT] < 1)
+			break;
+		player->stat_points[SPT_INTELLECT]--;
+		player->stat_points[SPT_TOTLAL]++;
+		break;
+	case 5:
+		if (player->stat_points[SPT_SPIRIT] < 1)
+			break;
+		player->stat_points[SPT_SPIRIT]--;
+		player->stat_points[SPT_TOTLAL]++;
+		break;
+	case 6:
+		if (player->stat_points[SPT_HIT] < 1)
+			break;
+		player->stat_points[SPT_HIT]--;
+		player->stat_points[SPT_TOTLAL]++;
+		break;
+	case 7:
+		if (player->stat_points[SPT_CRIT] < 1)
+			break;
+		player->stat_points[SPT_CRIT]--;
+		player->stat_points[SPT_TOTLAL]++;
+		break;
+	case 8:
+		if (player->stat_points[SPT_HASTE] < 1)
+			break;
+		player->stat_points[SPT_HASTE]--;
+		player->stat_points[SPT_TOTLAL]++;
+		break;
+	case 9:
+		if (player->stat_points[SPT_AP] < 1)
+			break;
+		player->stat_points[SPT_AP]--;
+		player->stat_points[SPT_TOTLAL]++;
+		break;
+	case 10:
+		if (player->stat_points[SPT_APE] < 1)
+			break;
+		player->stat_points[SPT_APE]--;
+		player->stat_points[SPT_TOTLAL]++;
+		break;
+	case 11:
+		if (player->stat_points[SPT_SP] < 1)
+			break;
+		player->stat_points[SPT_SP]--;
+		player->stat_points[SPT_TOTLAL]++;
+		break;
+	case 12:
+		if (player->stat_points[SPT_SPE] < 1)
+			break;
+		player->stat_points[SPT_SPE]--;
+		player->stat_points[SPT_TOTLAL]++;
+		break;
+	default:
+		break;
+	}
+
+	Apply(player, true);
+	UpdateDB(player);
+	OpenPanel(player);
+}
diff --git a/src/server/scripts/Custom/StatPoints/StatPoints.h b/src/server/scripts/Custom/StatPoints/StatPoints.h
new file mode 100644
index 0000000..a5f81a6
--- /dev/null
+++ b/src/server/scripts/Custom/StatPoints/StatPoints.h
@@ -0,0 +1,24 @@
+extern uint32 stat_muil[MAX_STAT_POINTS_TYPE];
+
+class StatPoints
+{
+public:
+	static StatPoints* instance()
+	{
+		static StatPoints instance;
+		return &instance;
+	}
+	void Load();
+	void LoadPlayerData(Player* player);
+	void UpdateDB(Player* player);
+	void UpdateDB(uint32 guid, uint32 statPoint);
+	void Apply(Player* player, bool apply);
+	void AddGosip(Player* player, Object* obj);
+	void AddPoints(Player* player, uint32 sender);
+	void ResetPoints(Player* player);
+
+	void OpenPanel(Player* player);
+	void Ins(Player* player, uint32 id);
+	void Des(Player* player, uint32 id);
+};
+#define sStatPoints StatPoints::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/String/myString.cpp b/src/server/scripts/Custom/String/myString.cpp
new file mode 100644
index 0000000..a0648cc
--- /dev/null
+++ b/src/server/scripts/Custom/String/myString.cpp
@@ -0,0 +1,54 @@
+#pragma execution_character_set("utf-8")
+#include "myString.h"
+
+void CoreString::Load()
+{
+	StringVec.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+		"SELECT ID,ÎÄ±¾ FROM __ÌáÊ¾ÎÄ±¾" :
+		"SELECT ID,TEXT FROM _string");
+	if (!result) return;
+	do
+	{
+		Field* fields = result->Fetch();
+		StringTemplate Temp;
+		Temp.types = fields[0].GetUInt32();
+		Temp.text = fields[1].GetString();
+		StringVec.push_back(Temp);
+	} while (result->NextRow());
+}
+
+const char* CoreString::Format(const char *format, ...)
+{
+	va_list ap;
+	char str[2048];
+	va_start(ap, format);
+	vsnprintf(str, 2048, format, ap);
+	va_end(ap);
+	const char* c_str = str;
+	return c_str;
+}
+
+const char* CoreString::GetText(CORE_STR_TYPES type)
+{
+	uint32 len = StringVec.size();
+	
+	for (size_t i = 0; i < len; i++)
+		if (type == StringVec[i].types)
+			return StringVec[i].text.c_str();
+
+	return "";
+}
+
+
+void CoreString::Replace(std::string &s1, const std::string &s2, const std::string &s3)
+{
+	std::string::size_type pos = 0;
+	std::string::size_type a = s2.size();
+	std::string::size_type b = s3.size();
+	while ((pos = s1.find(s2, pos)) != std::string::npos)
+	{
+		s1.replace(pos, a, s3);
+		pos += b;
+	}
+}
diff --git a/src/server/scripts/Custom/String/myString.h b/src/server/scripts/Custom/String/myString.h
new file mode 100644
index 0000000..cbc4850
--- /dev/null
+++ b/src/server/scripts/Custom/String/myString.h
@@ -0,0 +1,180 @@
+ï»¿#include <Define.h>
+#include <string>
+#include <vector>
+
+
+struct StringTemplate
+{
+    uint32 types;
+    std::string text;
+};
+
+enum CORE_STR_TYPES
+{
+	STR_NONE,
+
+	STR_WORLD_CHAT,
+	STR_LOGIN,
+	STR_LOGIN_A,
+	STR_LOGIN_H,
+	STR_LOGOUT,
+
+	STR_NO_EFFECT,
+	STR_GEM_REMOVE,
+	STR_ITEM_UNBIND,
+	STR_ITEM_EXCHANGE,
+	STR_ITEM_UPGRADE,
+	STR_ITEM_ENCHANT,
+	STR_WEAPON_PERM,
+	STR_IDENTIFY,
+	STR_ASTROLOGY,
+
+	STR_STAT_PANEL,
+	STR_SPELL_PANEL,
+	STR_EXTRA_EUIP_PANEL,
+	STR_DISPLAY_PANEL,
+
+	STR_ACTIVE_SPELLS,
+	STR_PASSIVE_SPELLS,
+	STR_LEARN_SPELL,
+	STR_SPELL_DES,
+	STR_SPELL_CHANGE,
+
+	STR_BOT_STAT_CURR_0,
+	STR_BOT_STAT_CURR_1,
+	STR_BOT_STAT_CURR_2,
+	STR_BOT_STAT_CURR_3,
+	STR_BOT_STAT_CURR_4,
+	STR_BOT_STAT_MAX_0,
+	STR_BOT_STAT_MAX_1,
+	STR_BOT_STAT_MAX_2,
+	STR_BOT_STAT_MAX_3,
+	STR_BOT_STAT_MAX_4,
+
+	STR_BOT_DISPLAY_CURR,
+	STR_BOT_DISPLAY_MAINHAND,
+	STR_BOT_DISPLAY_OFFHAND,
+	STR_BOT_DISPLAY_RANGED,
+	STR_BOT_DISPLAY_BUY,
+
+	STR_ABTAIN_ITEM_NOTICE,
+
+	STR_VIP_UP,
+
+	STR_END_KILL_STREAK_1,
+	STR_END_KILL_STREAK_2,
+	STR_END_KILL_STREAK_3,
+	STR_END_KILL_STREAK_4,
+	STR_END_KILL_STREAK_5,
+	STR_END_KILL_STREAK_6,
+	STR_END_KILL_STREAK_7,
+	STR_END_KILL_STREAK_8,
+	STR_END_KILL_STREAK_9,
+	STR_END_KILL_STREAK_10,
+
+	STR_KILL_STREAK_1,
+	STR_KILL_STREAK_2,
+	STR_KILL_STREAK_3,
+	STR_KILL_STREAK_4,
+	STR_KILL_STREAK_5,
+	STR_KILL_STREAK_6,
+	STR_KILL_STREAK_7,
+	STR_KILL_STREAK_8,
+	STR_KILL_STREAK_9,
+	STR_KILL_STREAK_10,
+
+	STR_KILL_CREATRE,
+	STR_GROUP_KILL_CREATURE,
+
+	STR_CHALLENGE_SUCCESS,
+	STR_CHALLENGE_FAIL_REQ,
+	STR_CHALLENGE_FAIL_INSTANCE,
+	STR_CHALLENGE_NOT_LEADER,
+	STR_CHALLENGE_NOT_5H,
+	STR_CHALLENGE_CURR,
+
+
+	//req notice
+	STR_REQ_LEVEL,
+	STR_REQ_INSTANCE,
+	STR_REQ_ZONE,
+	STR_REQ_XP,
+	STR_REQ_GOLD,
+	STR_REQ_VIP,
+	STR_REQ_HR,
+	STR_REQ_ACHIEVE,
+	STR_REQ_TOKEN,
+	STR_REQ_HONOR,
+	STR_REQ_ARENA,
+	STR_REQ_ITEM,
+	STR_REQ_NOTICE,
+
+	STR_DEADLINE_START,
+	STR_DEADLINE_FAILED,
+	STR_DEADLINE_SUCCESS,
+	STR_DEADLINE_TIME_LEFT,
+
+	STR_REICARNATION_CLICK,
+	STR_REICARNATION_ANNOUNCE,
+	STR_HONORRANK_UP,
+	STR_KILL_STREAK_REW,
+
+	STR_KILL_STREAK_TO_REW,
+	STR_END_KILL_STREAK_REW,
+	
+	STR_FACTION_CHAT,
+
+	STR_FFAPVP,
+
+	STR_ITEM_DESCRIPTION_SPLIT,
+	STR_REICARNATION_REQ,
+
+	STR_TOKEN,
+	STR_CUSTOM_FACTION_CHAT,
+	TOP_STR_100 = 100,
+	TOP_STR_101 = 101,
+	TOP_STR_102 = 102,
+	GVG_STR_1153 = 103,
+	GVG_STR_1154 = 104,
+	GVG_STR_1155 = 105,
+	GVG_STR_1156 = 106,
+	GVG_STR_1158 = 107,
+
+        GVG_STR_21111 = 111,//ç³»ç»ï¼ä½ å®æä»»å¡è·å¾é¢å¤ 10 ç¹èªç±åéå±æ§ç¹ï¼åéç¹å¨éèº«å®ç³->ä¿®ç¼ç³»ç»ï¼ä½¿ç¨ï¼
+        GVG_STR_21112 = 112,//ç³»ç»ï¼ä½ å®ææå°±è·å¾é¢å¤ 10 ç¹èªç±åéå±æ§ç¹ï¼åéç¹å¨éèº«å®ç³->ä¿®ç¼ç³»ç»ï¼ä½¿ç¨ï¼
+        GVG_STR_21113 = 113,//éç½®åéç¹éæ±ç©å %s X 1,ä½ å¹¶æ²¡æ!
+        GVG_STR_21114 = 114,//æ¯1ç¹åéç¹å¯ä»¥æé«1ç¹åéï¼ç¡®å®åå¨å¯¹è¯æ¡åè¾å¥è¦å¢å åéæ°é.
+        GVG_STR_21115 = 115,//æ¯1ç¹åéç¹å¯ä»¥æé«1ç¹ææ·ï¼ç¡®å®åå¨å¯¹è¯æ¡åè¾å¥è¦å¢å ææ·æ°é.
+        GVG_STR_21116 = 116,//æ¯1ç¹åéç¹å¯ä»¥æé«1ç¹æºåï¼ç¡®å®åå¨å¯¹è¯æ¡åè¾å¥è¦å¢å æºåæ°é.
+        GVG_STR_21117 = 117,//æ¯1ç¹åéç¹å¯ä»¥æé«1ç¹ç²¾ç¥ï¼ç¡®å®åå¨å¯¹è¯æ¡åè¾å¥è¦å¢å ç²¾ç¥æ°é.
+        GVG_STR_21118 = 118,//æ¯1ç¹åéç¹å¯ä»¥æé«1ç¹èåï¼ç¡®å®åå¨å¯¹è¯æ¡åè¾å¥è¦å¢å èåæ°é.
+        GVG_STR_21119 = 119,//æ¯1ç¹åéç¹å¯ä»¥æé«1ç¹æ³å¼ºï¼ç¡®å®åå¨å¯¹è¯æ¡åè¾å¥è¦å¢å æ³å¼ºæ°é.
+        GVG_STR_21120 = 120,//æ¯1ç¹åéç¹å¯ä»¥æé«1ç¹æ»å¼ºï¼ç¡®å®åå¨å¯¹è¯æ¡åè¾å¥è¦å¢å æ»å¼ºæ°é.
+        GVG_STR_21121 = 121,//æ¯1ç¹åéç¹å¯ä»¥æé«1ç¹æ´å»ï¼ç¡®å®åå¨å¯¹è¯æ¡åè¾å¥è¦å¢å æ´å»æ°é.
+        GVG_STR_21122 = 122,//æ¯1ç¹åéç¹å¯ä»¥æé«1ç¹æ¥éï¼ç¡®å®åå¨å¯¹è¯æ¡åè¾å¥è¦å¢å æ¥éæ°é.
+};
+
+
+class CoreString
+{
+public:
+	static CoreString* instance()
+	{
+		static CoreString instance;
+		return &instance;
+	}
+
+	void Load();
+
+	const char* GetText(CORE_STR_TYPES type);
+
+	const char* Format(const char *format, ...);
+
+	void Replace(std::string &s1, const std::string &s2, const std::string &s3);
+	
+private:
+    std::vector<StringTemplate> StringVec;
+};
+
+#define sString CoreString::instance()
+
diff --git a/src/server/scripts/Custom/Switch/Switch.cpp b/src/server/scripts/Custom/Switch/Switch.cpp
new file mode 100644
index 0000000..4580ca9
--- /dev/null
+++ b/src/server/scripts/Custom/Switch/Switch.cpp
@@ -0,0 +1,125 @@
+#pragma execution_character_set("utf-8")
+#include "Switch.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "BattlegroundMgr.h"
+
+uint32 PlayerTimeRewType;
+uint32 PlayerTimeRewIntervals;
+uint32 AntiCheatType;
+
+std::vector<SwitchTemplate> SwitchVec;
+
+void Switch::Load()
+{
+	SwitchVec.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ID, ²ÎÊý FROM __Í¨ÓÃÅäÖÃ" :
+		"SELECT ID, param FROM _common_setting");
+
+	if (!result) return;
+	do
+	{
+		Field* fields = result->Fetch();
+		SwitchTemplate Temp;
+		Temp.Type	= SwithTypes(fields[0].GetUInt32());
+		Temp.param = fields[1].GetString();
+		SwitchVec.push_back(Temp);
+	} while (result->NextRow());
+
+	PlayerTimeRewType = GetValue(ST_TIME_REW);
+	PlayerTimeRewIntervals = atoi(GetFlagByIndex(ST_TIME_REW, 2).c_str()) * MINUTE * IN_MILLISECONDS;
+	AntiCheatType = GetValue(ST_ANTICHEAT);
+
+	uint32 bgquequeintervals = GetValue(ST_BG_QUEQUE_INTERVALS);
+	bool bgquequeenable = bgquequeintervals > 0 ? true : false;
+	sBattlegroundMgr->SetAnnounceData(bgquequeenable, bgquequeintervals);
+}
+
+std::string Switch::GetParam(SwithTypes type)
+{
+	for (std::vector<SwitchTemplate>::iterator itr = SwitchVec.begin(); itr != SwitchVec.end(); ++itr)
+		if (itr->Type == type)
+			return itr->param;
+	
+	return "";
+}
+			
+std::string Switch::GetFlag(SwithTypes type)
+{
+	std::string param = GetParam(type);
+	if (param.empty())
+		return "";
+
+	std::string::size_type idx = param.find("#");
+
+	if (idx != std::string::npos)
+		return sCF->SplitStr(param, "#")[0];
+	else
+		return param;
+}
+
+std::string Switch::GetFlagByIndex(SwithTypes type, uint32 index)
+{
+	std::string flag = GetFlag(type);
+	if (flag.empty())
+		return "";
+
+	std::string::size_type idx = flag.find("|");
+
+	if (idx != std::string::npos)
+	{
+		std::vector<std::string> vec = sCF->SplitStr(flag, "|");
+
+		if (index > vec.size())
+			return vec[0];
+		else
+			return vec[index - 1];
+	}		
+	else
+		return flag;
+}
+
+int32 Switch::GetValueByIndex(SwithTypes type, uint32 index)
+{
+	return atoi(GetFlagByIndex(type, index).c_str());
+}
+
+bool Switch::GetOnOff(SwithTypes type)
+{
+	std::string param = GetParam(type);
+
+	if (param.empty())
+		return false;
+
+	std::string::size_type idx = param.find("#");
+
+	if (idx != std::string::npos)
+		return atoi(sCF->SplitStr(param, "#")[1].c_str()) > 0;
+	else
+		return atoi(param.c_str()) > 0;
+}
+
+int32 Switch::GetValue(SwithTypes type)
+{
+	std::string param = GetParam(type);
+
+	if (param.empty())
+		return 0;
+
+	std::string::size_type idx = param.find("#");
+
+	if (idx != std::string::npos)
+		return atoi(sCF->SplitStr(param, "#")[1].c_str());
+	else
+		return atoi(param.c_str());
+}
+
+void Switch::GetVec(SwithTypes type, std::vector<int32> &vec)
+{
+	std::string args = GetParam(type);
+	char* s = strtok(const_cast<char*>(args.c_str()), "#");
+
+	Tokenizer data(s, '|');
+	for (Tokenizer::const_iterator itr = data.begin(); itr != data.end(); ++itr)
+			vec.push_back(atoi(*itr));
+}
diff --git a/src/server/scripts/Custom/Switch/Switch.h b/src/server/scripts/Custom/Switch/Switch.h
new file mode 100644
index 0000000..b19d631
--- /dev/null
+++ b/src/server/scripts/Custom/Switch/Switch.h
@@ -0,0 +1,158 @@
+ï»¿enum SwithTypes
+{
+	ST_NONE,
+
+	ST_TOKEN_ID							= 1,		//ç§¯åç©åIDè®¾ç½®	 
+	ST_CF_GROUP							= 2,		//è·¨éµè¥ç»é	
+	ST_BG_QUEQUE_INTERVALS				= 3,		//æåºéåæç¤ºé´é		
+	ST_TALISMAN							= 4,		//æ³å®			
+	ST_BG_FIXTIME_ENABLE				= 5,		//æ¯å¦å¼å¯å®æ¶æåº				
+	ST_CF_AUCTION						= 6,		//è·¨éµè¥æåè¡			
+	sT_BG_REW							= 7,		//éæº/å¨å¸¸æåºé¢å¤å¥å±				
+	ST_CF_LANG							= 8,		//è·¨éµè¥èå¤©				
+	ST_WHO								= 9,		//Whowåè¡¨å¼å§å åçäººæ°|åæ°		
+	ST_CF_GUILD							= 10,		//è·¨éµè¥å¬ä¼
+
+	ST_SPS_LIMIT						= 11,		//ææ°ç¹ä¸éè®¾ç½®					
+	ST_EXTRA_TPS						= 12,		//é¢å¤å¤©èµä¸éè®¾ç½®					
+					
+	ST_EXTRA_CPS_LIMIT					= 13,		//é¢å¤åä¸ç¹ä¸éè®¾ç½®					
+	ST_LOOT_RATE_A						= 14,		//èçæçåçè®¾ç½®					
+	ST_LOOT_RATE_H						= 15,		//é¨è½æçåçè®¾ç½®					
+	ST_ONLINE_PLAYERS					= 16,		//åä¸IPå¨çº¿ç©å®¶æ°éä¸éè®¾ç½®			
+	ST_BG_PLAYERS						= 17,		//åä¸IPæåºç©å®¶æ°éä¸éè®¾ç½®			
+	ST_EVENT_PLAYERS					= 18,		//åä¸IPäºä»¶ç©å®¶æ°éä¸éè®¾ç½®											  
+						
+	ST_STOP_COMBAT_CD					= 19,		//è±æå·å´æ¶é´è®¾ç½®					
+	ST_TOKEN_AUCTION_CUT				= 20,		//ç§¯åæåè¡æç»­è´¹çè®¾ç½®				
+	ST_XP_MAX_LV						= 21,		//è·åç»éªçæé«ç­çº§è®¾ç½®				
+	ST_XP_RESET_STAT_MULTI				= 22,		//è·åååç»éªçæé«ç­çº§è®¾ç½®			
+	ST_QUICK_RESPONSE					= 23,		//å¯è·å¾å¥å±çæ¢ç­äººæ°è®¾ç½®			
+										  
+	ST_FAKE_PLAYERS						= 24,		//åäººç³»ç»éç½®									  																							  
+	ST_LOG_IN							= 25,		//ç»å½æç¤ºéç½®						
+	ST_LOG_OUT							= 26,		//ç»åºæç¤ºéç½®						
+	ST_WORLD_CHAT						= 27,		//ä¸çèå¤©éç½®						
+	ST_FACTION_CHAT						= 28,		//éµè¥èå¤©éç½®						
+	ST_TIME_REW							= 29,		//æ³¡ç¹å¥å±IDéç½®	
+	ST_SEP_PREFIX_SUFFIX				= 30,		//ç©å®¶åå­åç¼åç¼åå²ç¬¦éç½®	
+	ST_STAGE							= 31,		//æææ¨¡å¼éç½®						
+	
+	ST_HR_ACCOUNT_BIND					= 32,		//åè¡æ¯å¦è´¦å·ç»å®å¼å³
+	ST_TP_ACCOUNT_BIND					= 33,		//é¢å¤å¤©èµæ¯å¦è´¦å·ç»å®å¼å³
+	ST_DBBACKUP_INTERVALS				= 34,		//æ°æ®åºèªå¨å¤ä»½æ¶é´é´é
+	ST_AUTO_JOIN_GUILD					= 35,		//èªå¨å¥ä¼å¼å³									
+	ST_DODGE_FROM_AGILITY				= 36,		//ææ·å èº²éªå¼å³					
+	ST_SPELLCRIT_FROM_INTELLECT			= 37,		//æºåå çå»å¼å³				
+	ST_CRIT_FROM_AGILITY				= 38,		//ææ·å çå»å¼å³						
+	ST_TOKEN_AUCTION					= 39,		//ç§¯åæåè¡å¼å³						
+	ST_DEADLINE_TIME_NOTICE				= 40,		//éæ¶æ¨¡å¼æ¶é´æéå¼å³				
+	ST_RESET_CHALLENGE					= 41,		//ç³»ç»éç½®å¯æ¬æ¶æ¯å¦éç½®ææç­çº§å¼å³	
+	ST_LOTTERY							= 42,		//å½©ç¥¨æ¯å¦å¼å¯å¼å³								
+	ST_SAME_RELIC						= 43,		//QS DLY SM DKæ¯å¦ç»ä¸RELICå¼å³			
+	ST_UNBIND_INSTANCE_ON_LEAVE_GROUP	= 44,		//ç¦»å¼éä¼æ¯å¦éç½®å¯æ¬å¼å³	
+	ST_ACHIEVEMENT						= 45,		//æå°±å¼å³	
+	ST_FFAPVP							= 46,		//çº¢åæ¨¡å¼
+	ST_RANK_ACCOUNT_BIND				= 47,		//Rankè´¦å·ç»å®
+
+	ST_LUCKDRAW							= 48,		//å¹¸è¿æ½å¥æ¶èID
+	ST_ANTFARM							= 49,		//äººæºéªè¯	
+	ST_FAKER_ONLINE						= 50,		//å¨çº¿åäººæ°é
+
+	ST_DBC_PATH							= 51,		//DBè·¯å¾
+	ST_ENCHANT_SCROLL					= 52,		//æåéé­äº§ççå·è½´ID
+
+	ST_SPELL_DEBUG						= 53,		//æè½è°è¯è¾åº
+
+	ST_DAMAGE_PCT						= 54,		//ä¼¤å®³ç¾åæ¯ä¹æ³ãå æ³
+
+	ST_ANTICHEAT						= 55,		//åæ
+	ST_SEVER_ANNOUNCE					= 56,		//ä¸çå¬åå·å±éç½®(_server_announce)
+
+	ST_ENCHANTSLOT_MAX					= 57,		//æå¤§FMä½ç½®ä¸ªæ°
+
+	ST_ALT_CLASS                        = 58,		//è½¬è
+	ST_CF_TRADE							= 59,		//è·¨éµè¥äº¤æ
+	TOP_93 = 60,
+	TOP_94 = 61,
+	TOP_95 = 62,
+	TOP_96 = 63,
+	TOP_97 = 64,
+	GVG_109 = 65,
+	GVG_110 = 66,
+	GVG_111 = 67,
+	GVG_112 = 68,
+	GVG_113 = 69,
+	GVG_114 = 70,
+	GVG_115 = 71,
+	GVG_116 = 72,
+	GVG_117 = 73,
+	GVG_118 = 74,
+	GVG_119 = 75,
+	GVG_120 = 76,
+	GVG_178 = 77,
+	GVG_179 = 78,
+	GVG_136 = 79,
+	GVG_137 = 80,
+	GVG_138 = 81,
+
+	ST_SS = 100,				//é­çå¼å³
+	ST_SSEX = 101,				//é­çæ©å±å¼å³
+	ST_SS_CXREQ = 110,			//é­çå¼å³
+	ST_SSEX_CXREQ = 111,		//é­çæ©å±å¼å³
+
+        MY_DQ_RENWUREW = 206,//å®æä¸ä¸ªä»»å¡ç»å¤å°åéç¹
+        MY_DQ_CHENGJIUREW = 207,//å®æä¸ä¸ªæå°±ç»å¤å°åéç¹
+        MY_DQ_CHENGZHIREQ = 208,//éç½®åéç¹éæ±çç©åID
+        MY_DQ_REWLILIANG = 209, //1ç¹åééæ±å¤å°åéç¹
+        MY_DQ_REWMINGJIE = 210, //1ç¹ææ·éæ±å¤å°åéç¹
+        MY_DQ_REWZHILI = 211, //1ç¹æºåéæ±å¤å°åéç¹
+        MY_DQ_REWJINGSHEN = 212, //1ç¹ç²¾ç¥éæ±å¤å°åéç¹
+        MY_DQ_REWNAILI = 213, //1ç¹èåéæ±å¤å°åéç¹
+        MY_DQ_REWFAQIANG = 214, //1ç¹æ³å¼ºéæ±å¤å°åéç¹
+        MY_DQ_REWGONGQIANG = 215, //1ç¹æ»å¼ºéæ±å¤å°åéç¹
+        MY_DQ_REWBAOJI = 216, //1ç¹æ´å»éæ±å¤å°åéç¹
+        MY_DQ_REWJISU = 217, //1ç¹æ¥ééæ±å¤å°åéç¹
+        MY_DQ_REWJISHA = 218, //å»ææå®æªç©ç»äºåéç¹å¯å¤ä¸ª æ ¼å¼ï¼æªç©ID|åéç¹æ°|#æªç©ID|åéç¹æ°|#
+        MY_DQ_REWJISHADUIWU = 219,//å»ææå®æªç©ç»äºåéç¹ï¼éä¼ä¸­å¶ä»æåæ¯å¦ä¹ç»åéç¹ 0ä¸ç» 1ç» 2ç»å»æèä¸åçç¹æ°
+        MY_TIAOZHANXITNPC = 220,//0=ææå¯æ¬ä½¿ç¨è¿å¯æ¬æ¶å¼¹çªéçé¾åº¦ 1=ç¨npcéæ©ææé¾åº¦
+
+        MY_TIAOZHANXITNPC1 = 221,//éæºbossç»éç»æçå¥å±
+        MY_TIAOZHANXITNPC2 = 222,//éæºbossä¸ªäººç»çå¥å±
+
+        MY_DAMAGE_PCT_2 = 300,//æå¤§ä¸éåäººæ°é
+};
+
+extern uint32 PlayerTimeRewType;
+extern uint32 PlayerTimeRewIntervals;
+extern uint32 AntiCheatType;
+
+struct SwitchTemplate
+{
+	SwithTypes Type;
+	std::string param;
+};
+extern std::vector<SwitchTemplate> SwitchVec;
+
+class Switch
+{
+public:
+	static Switch* instance()
+	{
+		static Switch instance;
+		return &instance;
+	}
+
+	void Load();
+
+	std::string GetParam(SwithTypes type);
+	std::string GetFlag(SwithTypes type);
+	std::string GetFlagByIndex(SwithTypes type, uint32 index);
+	int32 GetValueByIndex(SwithTypes type, uint32 index);
+	bool GetOnOff(SwithTypes type);
+	int32 GetValue(SwithTypes type);
+	void GetVec(SwithTypes type, std::vector<int32> &vec);
+private:
+
+};
+#define sSwitch Switch::instance()
diff --git a/src/server/scripts/Custom/TalentReq/TalentReq.cpp b/src/server/scripts/Custom/TalentReq/TalentReq.cpp
new file mode 100644
index 0000000..a413fef
--- /dev/null
+++ b/src/server/scripts/Custom/TalentReq/TalentReq.cpp
@@ -0,0 +1,93 @@
+#pragma execution_character_set("utf-8")
+#include "TalentReq.h"
+#include "../Requirement/Requirement.h"
+#include "../CommonFunc/CommonFunc.h"
+
+std::unordered_map<uint32, uint32>TalentReqMap;
+
+void TalentReq::Load()
+{
+	TalentReqMap.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+		"SELECT Ìì¸³¼¼ÄÜID,ÐèÇóÄ£°åID from _¼¼ÄÜ_Ìì¸³¼ÓµãÐèÇó" :
+		"SELECT spellid,reqId from _talent_req");
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			TalentReqMap.insert(std::make_pair(fields[0].GetUInt32(), fields[1].GetUInt32()));
+		} while (result->NextRow());
+	}
+}
+
+bool TalentReq::SendAcceptOrCancel(Player* player, uint32 spellid)
+{
+	if (TalentReqMap.empty())
+		return false;
+
+	auto i = TalentReqMap.find(spellid);
+
+	if (i == TalentReqMap.end())
+		return false;
+
+	if (std::find(player->BuyTalentVec.begin(), player->BuyTalentVec.end(), spellid) != player->BuyTalentVec.end())
+		return false;
+
+	const SpellInfo* spellInfo = sSpellMgr->GetSpellInfo(spellid);
+	if (!spellInfo)
+		return false;
+
+	std::ostringstream oss;
+	oss << "[" << spellInfo->SpellName[4] << "]";
+	sCF->SendAcceptOrCancel(player, 995, sReq->Notice(player, i->second, "Ñ§Ï°", oss.str()));
+
+	return true;
+}
+
+
+void TalentReq::DoAction(Player* player)
+{
+	uint32 reqId = 0;
+
+	auto i = TalentReqMap.find(player->buy_talentSpell);
+
+	if (i != TalentReqMap.end())
+		reqId = i->second;
+
+	if (sReq->Check(player, reqId))
+	{
+		player->LearnTalentCustom(player->buy_talentId, player->buy_talentRank);
+		player->SendTalentsInfoData(false);
+		player->BuyTalentVec.push_back(player->buy_talentSpell);
+		CharacterDatabase.PExecute("REPLACE INTO characters_talent_req (guid, spellid) VALUES (%u, %u)", player->GetGUIDLow(), player->buy_talentSpell);
+		sReq->Des(player, reqId);
+		player->buy_talentId = 0;
+		player->buy_talentRank = 0;
+		player->buy_talentSpell = 0;
+	}
+}
+
+class TalentReqScript : PlayerScript
+{
+public:
+	TalentReqScript() : PlayerScript("TalentReqScript") {}
+	void OnLogin(Player* player) override
+	{
+		player->BuyTalentVec.clear();
+
+		if (QueryResult result = CharacterDatabase.PQuery("SELECT spellid FROM characters_talent_req WHERE guid = '%u'", player->GetGUIDLow()))
+		{
+			do
+			{
+				Field* fields = result->Fetch();
+				player->BuyTalentVec.push_back(fields[0].GetUInt32());
+			} while (result->NextRow());
+		}
+	}
+};
+
+void AddSC_TalentReq()
+{
+	new TalentReqScript();
+}
diff --git a/src/server/scripts/Custom/TalentReq/TalentReq.h b/src/server/scripts/Custom/TalentReq/TalentReq.h
new file mode 100644
index 0000000..2f7d3dc
--- /dev/null
+++ b/src/server/scripts/Custom/TalentReq/TalentReq.h
@@ -0,0 +1,24 @@
+
+/*
+CREATE TABLE characters_talent_req( guid INT DEFAULT 0, spellId INT DEFAULT 0 );
+CREATE TABLE _talent_req( comment VARCHAR(128), spellId INT UNSIGNED NOT NULL DEFAULT 0, reqId INT UNSIGNED NOT NULL DEFAULT 0, PRIMARY KEY (spellId) );
+*/
+
+extern std::unordered_map<uint32, uint32>TalentReqMap;
+
+class TalentReq
+{
+public:
+	static TalentReq* instance()
+	{
+		static TalentReq instance;
+		return &instance;
+	}
+
+	void Load();
+	bool SendAcceptOrCancel(Player* player, uint32 spellid);
+	void DoAction(Player* player);
+private:
+
+};
+#define sTalentReq TalentReq::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Talisman/Talisman.cpp b/src/server/scripts/Custom/Talisman/Talisman.cpp
new file mode 100644
index 0000000..116a290
--- /dev/null
+++ b/src/server/scripts/Custom/Talisman/Talisman.cpp
@@ -0,0 +1,841 @@
+#pragma execution_character_set("utf-8")
+#include "Talisman.h"
+#include "../GCAddon/GCAddon.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "Group.h"
+#include "../SpiritPower/SpiritPower.h"
+#include "../Switch/Switch.h"
+
+std::unordered_map<uint32, uint32> TalismanMap;
+
+void Talisman::Load()
+{
+	TalismanMap.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ·¨±¦ÎïÆ·ID,·Ö×éID FROM __·¨±¦" :
+		"SELECT entry,groupid FROM _talisman");
+	if (!result)
+		return;
+	do
+	{
+		Field* fields = result->Fetch();
+		uint32 entry = fields[0].GetUInt32();
+		if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(entry))
+			TalismanMap.insert(std::make_pair(entry, fields[1].GetUInt32()));
+	} while (result->NextRow());
+}
+
+bool Talisman::HasTalismanEquiped(Player* player, uint32 entry)
+{
+	for (std::unordered_map<uint32, uint32>::iterator iter = player->TalismanMap.begin(); iter != player->TalismanMap.end(); iter++)
+		if (entry == iter->second)
+			return true;
+
+	return false;
+}
+
+uint32 Talisman::GetEntryByID(Player* player, uint32 ID)
+{
+	std::unordered_map<uint32, uint32>::iterator iter = player->TalismanMap.find(ID);
+
+	if (iter != player->TalismanMap.end())
+		return iter->second;
+
+	return 0;
+}
+
+std::string Talisman::GetIcon(uint32 entry)
+{
+	const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+	if (!temp)
+		return "TALISMAN_DEFAULT";
+
+	ItemDisplayInfoEntry const* info = sItemDisplayInfoStore.LookupEntry(temp->DisplayInfoID);
+
+	if (!info)
+		return "TALISMAN_DEFAULT";
+
+	return info->inventoryIcon;
+}
+
+std::string Talisman::GetName(uint32 entry)
+{
+	std::string name = sCF->GetItemLink(entry);
+
+	if (name.empty())
+		return "[Î´Á¶»¯]";
+
+	return name;
+}
+
+bool Talisman::IsMidItem(uint32 entry)
+{
+	auto itr = TalismanMap.find(entry);
+	if (itr == TalismanMap.end())
+		return false;
+
+	return itr->second == 0;
+}
+
+void Talisman::SendPacket(Player* player)
+{
+	std::ostringstream oss;
+
+	for (std::unordered_map<uint32, uint32>::iterator iter = player->TalismanMap.begin(); iter != player->TalismanMap.end(); iter++)
+		oss << iter->first << "-" << GetIcon(iter->second) << "-" << iter->second << "#";
+
+	sGCAddon->SendPacketTo(player, "GC_S_TALISMAM", oss.str());
+}
+
+void Talisman::ApplyOnEquip(Player* player, uint32 entry, bool apply)
+{
+	const ItemTemplate* proto = sObjectMgr->GetItemTemplate(entry);
+	if (!proto)
+		return;
+
+#pragma region ×°±¸ÊôÐÔ
+	for (uint8 k = 0; k < MAX_ITEM_PROTO_STATS; ++k)
+	{
+		if (k >= proto->StatsCount)
+			break;
+
+		uint32 statType = proto->ItemStat[k].ItemStatType;
+		int32  val = proto->ItemStat[k].ItemStatValue;
+
+		if (val == 0)
+			continue;
+
+		switch (statType)
+		{
+		case ITEM_MOD_MANA:
+			player->HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, float(val), apply);
+			break;
+		case ITEM_MOD_HEALTH:                           // modify HP
+			player->HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, float(val), apply);
+			break;
+		case ITEM_MOD_AGILITY:                          // modify agility
+			player->HandleStatModifier(UNIT_MOD_STAT_AGILITY, BASE_VALUE, float(val), apply);
+			player->ApplyStatBuffMod(STAT_AGILITY, float(val), apply);
+			break;
+		case ITEM_MOD_STRENGTH:                         //modify strength
+			player->HandleStatModifier(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, float(val), apply);
+			player->ApplyStatBuffMod(STAT_STRENGTH, float(val), apply);
+			break;
+		case ITEM_MOD_INTELLECT:                        //modify intellect
+			player->HandleStatModifier(UNIT_MOD_STAT_INTELLECT, BASE_VALUE, float(val), apply);
+			player->ApplyStatBuffMod(STAT_INTELLECT, float(val), apply);
+			break;
+		case ITEM_MOD_SPIRIT:                           //modify spirit
+			player->HandleStatModifier(UNIT_MOD_STAT_SPIRIT, BASE_VALUE, float(val), apply);
+			player->ApplyStatBuffMod(STAT_SPIRIT, float(val), apply);
+			break;
+		case ITEM_MOD_STAMINA:                          //modify stamina
+			player->HandleStatModifier(UNIT_MOD_STAT_STAMINA, BASE_VALUE, float(val), apply);
+			player->ApplyStatBuffMod(STAT_STAMINA, float(val), apply);
+			break;
+		case ITEM_MOD_DEFENSE_SKILL_RATING:
+			player->ApplyRatingMod(CR_DEFENSE_SKILL, int32(val), apply);
+			break;
+		case ITEM_MOD_DODGE_RATING:
+			player->ApplyRatingMod(CR_DODGE, int32(val), apply);
+			break;
+		case ITEM_MOD_PARRY_RATING:
+			player->ApplyRatingMod(CR_PARRY, int32(val), apply);
+			break;
+		case ITEM_MOD_BLOCK_RATING:
+			player->ApplyRatingMod(CR_BLOCK, int32(val), apply);
+			break;
+		case ITEM_MOD_HIT_MELEE_RATING:
+			player->ApplyRatingMod(CR_HIT_MELEE, int32(val), apply);
+			break;
+		case ITEM_MOD_HIT_RANGED_RATING:
+			player->ApplyRatingMod(CR_HIT_RANGED, int32(val), apply);
+			break;
+		case ITEM_MOD_HIT_SPELL_RATING:
+			player->ApplyRatingMod(CR_HIT_SPELL, int32(val), apply);
+			break;
+		case ITEM_MOD_CRIT_MELEE_RATING:
+			player->ApplyRatingMod(CR_CRIT_MELEE, int32(val), apply);
+			break;
+		case ITEM_MOD_CRIT_RANGED_RATING:
+			player->ApplyRatingMod(CR_CRIT_RANGED, int32(val), apply);
+			break;
+		case ITEM_MOD_CRIT_SPELL_RATING:
+			player->ApplyRatingMod(CR_CRIT_SPELL, int32(val), apply);
+			break;
+		case ITEM_MOD_HIT_TAKEN_MELEE_RATING:
+			player->ApplyRatingMod(CR_HIT_TAKEN_MELEE, int32(val), apply);
+			break;
+		case ITEM_MOD_HIT_TAKEN_RANGED_RATING:
+			player->ApplyRatingMod(CR_HIT_TAKEN_RANGED, int32(val), apply);
+			break;
+		case ITEM_MOD_HIT_TAKEN_SPELL_RATING:
+			player->ApplyRatingMod(CR_HIT_TAKEN_SPELL, int32(val), apply);
+			break;
+		case ITEM_MOD_CRIT_TAKEN_MELEE_RATING:
+			player->ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(val), apply);
+			break;
+		case ITEM_MOD_CRIT_TAKEN_RANGED_RATING:
+			player->ApplyRatingMod(CR_CRIT_TAKEN_RANGED, int32(val), apply);
+			break;
+		case ITEM_MOD_CRIT_TAKEN_SPELL_RATING:
+			player->ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(val), apply);
+			break;
+		case ITEM_MOD_HASTE_MELEE_RATING:
+			player->ApplyRatingMod(CR_HASTE_MELEE, int32(val), apply);
+			break;
+		case ITEM_MOD_HASTE_RANGED_RATING:
+			player->ApplyRatingMod(CR_HASTE_RANGED, int32(val), apply);
+			break;
+		case ITEM_MOD_HASTE_SPELL_RATING:
+			player->ApplyRatingMod(CR_HASTE_SPELL, int32(val), apply);
+			break;
+		case ITEM_MOD_HIT_RATING:
+			player->ApplyRatingMod(CR_HIT_MELEE, int32(val), apply);
+			player->ApplyRatingMod(CR_HIT_RANGED, int32(val), apply);
+			player->ApplyRatingMod(CR_HIT_SPELL, int32(val), apply);
+			break;
+		case ITEM_MOD_CRIT_RATING:
+			player->ApplyRatingMod(CR_CRIT_MELEE, int32(val), apply);
+			player->ApplyRatingMod(CR_CRIT_RANGED, int32(val), apply);
+			player->ApplyRatingMod(CR_CRIT_SPELL, int32(val), apply);
+			break;
+		case ITEM_MOD_HIT_TAKEN_RATING:
+			player->ApplyRatingMod(CR_HIT_TAKEN_MELEE, int32(val), apply);
+			player->ApplyRatingMod(CR_HIT_TAKEN_RANGED, int32(val), apply);
+			player->ApplyRatingMod(CR_HIT_TAKEN_SPELL, int32(val), apply);
+			break;
+		case ITEM_MOD_CRIT_TAKEN_RATING:
+			player->ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(val), apply);
+			player->ApplyRatingMod(CR_CRIT_TAKEN_RANGED, int32(val), apply);
+			player->ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(val), apply);
+			break;
+		case ITEM_MOD_RESILIENCE_RATING:
+			player->ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(val), apply);
+			player->ApplyRatingMod(CR_CRIT_TAKEN_RANGED, int32(val), apply);
+			player->ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(val), apply);
+			break;
+		case ITEM_MOD_HASTE_RATING:
+			player->ApplyRatingMod(CR_HASTE_MELEE, int32(val), apply);
+			player->ApplyRatingMod(CR_HASTE_RANGED, int32(val), apply);
+			player->ApplyRatingMod(CR_HASTE_SPELL, int32(val), apply);
+			break;
+		case ITEM_MOD_EXPERTISE_RATING:
+			player->ApplyRatingMod(CR_EXPERTISE, int32(val), apply);
+			break;
+		case ITEM_MOD_ATTACK_POWER:
+			player->HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(val), apply);
+			player->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(val), apply);
+			break;
+		case ITEM_MOD_RANGED_ATTACK_POWER:
+			player->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(val), apply);
+			break;
+			//            case ITEM_MOD_FERAL_ATTACK_POWER:
+			//                ApplyFeralAPBonus(int32(val), apply);
+			//                break;
+		case ITEM_MOD_MANA_REGENERATION:
+			player->ApplyManaRegenBonus(int32(val), apply);
+			break;
+		case ITEM_MOD_ARMOR_PENETRATION_RATING:
+			player->ApplyRatingMod(CR_ARMOR_PENETRATION, int32(val), apply);
+			break;
+		case ITEM_MOD_SPELL_POWER:
+			player->ApplySpellPowerBonus(int32(val), apply);
+			break;
+		case ITEM_MOD_HEALTH_REGEN:
+			player->ApplyHealthRegenBonus(int32(val), apply);
+			break;
+		case ITEM_MOD_SPELL_PENETRATION:
+			player->ApplySpellPenetrationBonus(val, apply);
+			break;
+		case ITEM_MOD_BLOCK_VALUE:
+			player->HandleBaseModValue(SHIELD_BLOCK_VALUE, FLAT_MOD, float(val), apply);
+			break;
+			// deprecated item mods
+		case ITEM_MOD_SPELL_HEALING_DONE:
+		case ITEM_MOD_SPELL_DAMAGE_DONE:
+			break;
+		}
+	}
+
+	uint32 armor = proto->Armor;
+
+	if (armor && proto->ArmorDamageModifier)
+		armor -= uint32(proto->ArmorDamageModifier);
+
+	if (armor)
+	{
+		UnitModifierType modType = TOTAL_VALUE;
+		if (proto->Class == ITEM_CLASS_ARMOR)
+		{
+			switch (proto->SubClass)
+			{
+			case ITEM_SUBCLASS_ARMOR_CLOTH:
+			case ITEM_SUBCLASS_ARMOR_LEATHER:
+			case ITEM_SUBCLASS_ARMOR_MAIL:
+			case ITEM_SUBCLASS_ARMOR_PLATE:
+			case ITEM_SUBCLASS_ARMOR_SHIELD:
+				modType = BASE_VALUE;
+				break;
+			}
+		}
+		player->HandleStatModifier(UNIT_MOD_ARMOR, modType, float(armor), apply);
+	}
+
+	// Add armor bonus from ArmorDamageModifier if > 0
+	if (proto->ArmorDamageModifier > 0)
+		player->HandleStatModifier(UNIT_MOD_ARMOR, TOTAL_VALUE, float(proto->ArmorDamageModifier), apply);
+
+	if (proto->Block)
+		player->HandleBaseModValue(SHIELD_BLOCK_VALUE, FLAT_MOD, float(proto->Block), apply);
+
+	if (proto->HolyRes)
+		player->HandleStatModifier(UNIT_MOD_RESISTANCE_HOLY, BASE_VALUE, float(proto->HolyRes), apply);
+
+	if (proto->FireRes)
+		player->HandleStatModifier(UNIT_MOD_RESISTANCE_FIRE, BASE_VALUE, float(proto->FireRes), apply);
+
+	if (proto->NatureRes)
+		player->HandleStatModifier(UNIT_MOD_RESISTANCE_NATURE, BASE_VALUE, float(proto->NatureRes), apply);
+
+	if (proto->FrostRes)
+		player->HandleStatModifier(UNIT_MOD_RESISTANCE_FROST, BASE_VALUE, float(proto->FrostRes), apply);
+
+	if (proto->ShadowRes)
+		player->HandleStatModifier(UNIT_MOD_RESISTANCE_SHADOW, BASE_VALUE, float(proto->ShadowRes), apply);
+
+	if (proto->ArcaneRes)
+		player->HandleStatModifier(UNIT_MOD_RESISTANCE_ARCANE, BASE_VALUE, float(proto->ArcaneRes), apply);
+#pragma endregion
+#pragma region ×°±¸¼¼ÄÜ
+	for (uint8 k = 0; k < MAX_ITEM_PROTO_SPELLS; ++k)
+	{
+		uint32 spellId = proto->Spells[k].SpellId;
+
+		if (SpellEntry const* spellInfo = sSpellStore.LookupEntry(spellId))
+		{
+			if (apply)
+				player->learnSpell(spellId);
+			else
+				player->removeSpell(spellId, SPEC_MASK_ALL, false);
+		}
+	}
+#pragma endregion
+}
+
+void Talisman::ApplyOnLogin(Player* player)
+{
+	bool apply = true;
+
+	for (std::unordered_map<uint32, uint32>::iterator iter = player->TalismanMap.begin(); iter != player->TalismanMap.end(); iter++)
+	{
+		const ItemTemplate* proto = sObjectMgr->GetItemTemplate(iter->second);
+		if (!proto)
+			continue;
+
+#pragma region ×°±¸ÊôÐÔ
+		for (uint8 k = 0; k < MAX_ITEM_PROTO_STATS; ++k)
+		{
+			if (k >= proto->StatsCount)
+				break;
+
+			uint32 statType = proto->ItemStat[k].ItemStatType;
+			int32  val = proto->ItemStat[k].ItemStatValue;
+
+			if (val == 0)
+				continue;
+
+			switch (statType)
+			{
+			case ITEM_MOD_MANA:
+				player->HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, float(val), apply);
+				break;
+			case ITEM_MOD_HEALTH:                           // modify HP
+				player->HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, float(val), apply);
+				break;
+			case ITEM_MOD_AGILITY:                          // modify agility
+				player->HandleStatModifier(UNIT_MOD_STAT_AGILITY, BASE_VALUE, float(val), apply);
+				player->ApplyStatBuffMod(STAT_AGILITY, float(val), apply);
+				break;
+			case ITEM_MOD_STRENGTH:                         //modify strength
+				player->HandleStatModifier(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, float(val), apply);
+				player->ApplyStatBuffMod(STAT_STRENGTH, float(val), apply);
+				break;
+			case ITEM_MOD_INTELLECT:                        //modify intellect
+				player->HandleStatModifier(UNIT_MOD_STAT_INTELLECT, BASE_VALUE, float(val), apply);
+				player->ApplyStatBuffMod(STAT_INTELLECT, float(val), apply);
+				break;
+			case ITEM_MOD_SPIRIT:                           //modify spirit
+				player->HandleStatModifier(UNIT_MOD_STAT_SPIRIT, BASE_VALUE, float(val), apply);
+				player->ApplyStatBuffMod(STAT_SPIRIT, float(val), apply);
+				break;
+			case ITEM_MOD_STAMINA:                          //modify stamina
+				player->HandleStatModifier(UNIT_MOD_STAT_STAMINA, BASE_VALUE, float(val), apply);
+				player->ApplyStatBuffMod(STAT_STAMINA, float(val), apply);
+				break;
+			case ITEM_MOD_DEFENSE_SKILL_RATING:
+				player->ApplyRatingMod(CR_DEFENSE_SKILL, int32(val), apply);
+				break;
+			case ITEM_MOD_DODGE_RATING:
+				player->ApplyRatingMod(CR_DODGE, int32(val), apply);
+				break;
+			case ITEM_MOD_PARRY_RATING:
+				player->ApplyRatingMod(CR_PARRY, int32(val), apply);
+				break;
+			case ITEM_MOD_BLOCK_RATING:
+				player->ApplyRatingMod(CR_BLOCK, int32(val), apply);
+				break;
+			case ITEM_MOD_HIT_MELEE_RATING:
+				player->ApplyRatingMod(CR_HIT_MELEE, int32(val), apply);
+				break;
+			case ITEM_MOD_HIT_RANGED_RATING:
+				player->ApplyRatingMod(CR_HIT_RANGED, int32(val), apply);
+				break;
+			case ITEM_MOD_HIT_SPELL_RATING:
+				player->ApplyRatingMod(CR_HIT_SPELL, int32(val), apply);
+				break;
+			case ITEM_MOD_CRIT_MELEE_RATING:
+				player->ApplyRatingMod(CR_CRIT_MELEE, int32(val), apply);
+				break;
+			case ITEM_MOD_CRIT_RANGED_RATING:
+				player->ApplyRatingMod(CR_CRIT_RANGED, int32(val), apply);
+				break;
+			case ITEM_MOD_CRIT_SPELL_RATING:
+				player->ApplyRatingMod(CR_CRIT_SPELL, int32(val), apply);
+				break;
+			case ITEM_MOD_HIT_TAKEN_MELEE_RATING:
+				player->ApplyRatingMod(CR_HIT_TAKEN_MELEE, int32(val), apply);
+				break;
+			case ITEM_MOD_HIT_TAKEN_RANGED_RATING:
+				player->ApplyRatingMod(CR_HIT_TAKEN_RANGED, int32(val), apply);
+				break;
+			case ITEM_MOD_HIT_TAKEN_SPELL_RATING:
+				player->ApplyRatingMod(CR_HIT_TAKEN_SPELL, int32(val), apply);
+				break;
+			case ITEM_MOD_CRIT_TAKEN_MELEE_RATING:
+				player->ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(val), apply);
+				break;
+			case ITEM_MOD_CRIT_TAKEN_RANGED_RATING:
+				player->ApplyRatingMod(CR_CRIT_TAKEN_RANGED, int32(val), apply);
+				break;
+			case ITEM_MOD_CRIT_TAKEN_SPELL_RATING:
+				player->ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(val), apply);
+				break;
+			case ITEM_MOD_HASTE_MELEE_RATING:
+				player->ApplyRatingMod(CR_HASTE_MELEE, int32(val), apply);
+				break;
+			case ITEM_MOD_HASTE_RANGED_RATING:
+				player->ApplyRatingMod(CR_HASTE_RANGED, int32(val), apply);
+				break;
+			case ITEM_MOD_HASTE_SPELL_RATING:
+				player->ApplyRatingMod(CR_HASTE_SPELL, int32(val), apply);
+				break;
+			case ITEM_MOD_HIT_RATING:
+				player->ApplyRatingMod(CR_HIT_MELEE, int32(val), apply);
+				player->ApplyRatingMod(CR_HIT_RANGED, int32(val), apply);
+				player->ApplyRatingMod(CR_HIT_SPELL, int32(val), apply);
+				break;
+			case ITEM_MOD_CRIT_RATING:
+				player->ApplyRatingMod(CR_CRIT_MELEE, int32(val), apply);
+				player->ApplyRatingMod(CR_CRIT_RANGED, int32(val), apply);
+				player->ApplyRatingMod(CR_CRIT_SPELL, int32(val), apply);
+				break;
+			case ITEM_MOD_HIT_TAKEN_RATING:
+				player->ApplyRatingMod(CR_HIT_TAKEN_MELEE, int32(val), apply);
+				player->ApplyRatingMod(CR_HIT_TAKEN_RANGED, int32(val), apply);
+				player->ApplyRatingMod(CR_HIT_TAKEN_SPELL, int32(val), apply);
+				break;
+			case ITEM_MOD_CRIT_TAKEN_RATING:
+				player->ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(val), apply);
+				player->ApplyRatingMod(CR_CRIT_TAKEN_RANGED, int32(val), apply);
+				player->ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(val), apply);
+				break;
+			case ITEM_MOD_RESILIENCE_RATING:
+				player->ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(val), apply);
+				player->ApplyRatingMod(CR_CRIT_TAKEN_RANGED, int32(val), apply);
+				player->ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(val), apply);
+				break;
+			case ITEM_MOD_HASTE_RATING:
+				player->ApplyRatingMod(CR_HASTE_MELEE, int32(val), apply);
+				player->ApplyRatingMod(CR_HASTE_RANGED, int32(val), apply);
+				player->ApplyRatingMod(CR_HASTE_SPELL, int32(val), apply);
+				break;
+			case ITEM_MOD_EXPERTISE_RATING:
+				player->ApplyRatingMod(CR_EXPERTISE, int32(val), apply);
+				break;
+			case ITEM_MOD_ATTACK_POWER:
+				player->HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(val), apply);
+				player->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(val), apply);
+				break;
+			case ITEM_MOD_RANGED_ATTACK_POWER:
+				player->HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(val), apply);
+				break;
+				//            case ITEM_MOD_FERAL_ATTACK_POWER:
+				//                ApplyFeralAPBonus(int32(val), apply);
+				//                break;
+			case ITEM_MOD_MANA_REGENERATION:
+				player->ApplyManaRegenBonus(int32(val), apply);
+				break;
+			case ITEM_MOD_ARMOR_PENETRATION_RATING:
+				player->ApplyRatingMod(CR_ARMOR_PENETRATION, int32(val), apply);
+				break;
+			case ITEM_MOD_SPELL_POWER:
+				player->ApplySpellPowerBonus(int32(val), apply);
+				break;
+			case ITEM_MOD_HEALTH_REGEN:
+				player->ApplyHealthRegenBonus(int32(val), apply);
+				break;
+			case ITEM_MOD_SPELL_PENETRATION:
+				player->ApplySpellPenetrationBonus(val, apply);
+				break;
+			case ITEM_MOD_BLOCK_VALUE:
+				player->HandleBaseModValue(SHIELD_BLOCK_VALUE, FLAT_MOD, float(val), apply);
+				break;
+				// deprecated item mods
+			case ITEM_MOD_SPELL_HEALING_DONE:
+			case ITEM_MOD_SPELL_DAMAGE_DONE:
+				break;
+			}
+		}
+		uint32 armor = proto->Armor;
+
+		if (armor && proto->ArmorDamageModifier)
+			armor -= uint32(proto->ArmorDamageModifier);
+
+		if (armor)
+		{
+			UnitModifierType modType = TOTAL_VALUE;
+			if (proto->Class == ITEM_CLASS_ARMOR)
+			{
+				switch (proto->SubClass)
+				{
+				case ITEM_SUBCLASS_ARMOR_CLOTH:
+				case ITEM_SUBCLASS_ARMOR_LEATHER:
+				case ITEM_SUBCLASS_ARMOR_MAIL:
+				case ITEM_SUBCLASS_ARMOR_PLATE:
+				case ITEM_SUBCLASS_ARMOR_SHIELD:
+					modType = BASE_VALUE;
+					break;
+				}
+			}
+			player->HandleStatModifier(UNIT_MOD_ARMOR, modType, float(armor), apply);
+		}
+
+		// Add armor bonus from ArmorDamageModifier if > 0
+		if (proto->ArmorDamageModifier > 0)
+			player->HandleStatModifier(UNIT_MOD_ARMOR, TOTAL_VALUE, float(proto->ArmorDamageModifier), apply);
+
+		if (proto->Block)
+			player->HandleBaseModValue(SHIELD_BLOCK_VALUE, FLAT_MOD, float(proto->Block), apply);
+
+		if (proto->HolyRes)
+			player->HandleStatModifier(UNIT_MOD_RESISTANCE_HOLY, BASE_VALUE, float(proto->HolyRes), apply);
+
+		if (proto->FireRes)
+			player->HandleStatModifier(UNIT_MOD_RESISTANCE_FIRE, BASE_VALUE, float(proto->FireRes), apply);
+
+		if (proto->NatureRes)
+			player->HandleStatModifier(UNIT_MOD_RESISTANCE_NATURE, BASE_VALUE, float(proto->NatureRes), apply);
+
+		if (proto->FrostRes)
+			player->HandleStatModifier(UNIT_MOD_RESISTANCE_FROST, BASE_VALUE, float(proto->FrostRes), apply);
+
+		if (proto->ShadowRes)
+			player->HandleStatModifier(UNIT_MOD_RESISTANCE_SHADOW, BASE_VALUE, float(proto->ShadowRes), apply);
+
+		if (proto->ArcaneRes)
+			player->HandleStatModifier(UNIT_MOD_RESISTANCE_ARCANE, BASE_VALUE, float(proto->ArcaneRes), apply);
+#pragma endregion
+	}
+}
+
+uint32 Talisman::GetGroupId(uint32 entry)
+{
+	auto itr = TalismanMap.find(entry);
+	if (itr != TalismanMap.end())
+		return itr->second;
+
+	return 0;
+}
+
+void Talisman::EquipTalisman(Player* player, uint32 ID, uint32 entry)
+{
+	if (player->IsInCombat())
+	{
+		ChatHandler(player->GetSession()).PSendSysMessage("ÄãÕý´¦ÔÚÕ½¶·ÖÐ£¬¸üÐÂ·¨±¦Ê§°Ü£¡", sCF->GetItemLink(entry).c_str());
+		return;
+	}
+
+	if (const ItemTemplate* t = sObjectMgr->GetItemTemplate(entry))
+	{
+		InventoryResult msg = player->CanUseItem(t);
+
+		if (msg != EQUIP_ERR_OK)
+		{
+			player->SendEquipError(msg, NULL, NULL);
+			return;
+		}
+	}
+
+	//È¡ÏÂ·¨±¦
+	if (entry == 0)
+	{
+		std::unordered_map<uint32, uint32>::iterator iter = player->TalismanMap.find(ID);
+
+		if (iter != player->TalismanMap.end())
+		{
+			uint32 ori = iter->second;
+			iter->second = 0;
+
+			//»ñµÃÔ­·¨±¦
+			if (const ItemTemplate* temp = sObjectMgr->GetItemTemplate(ori))
+			{
+				//È¥³ý×°±¸ÊôÐÔ¼°¼¼ÄÜ
+				ApplyOnEquip(player, temp->ItemId, false);
+				player->AddItem(temp->ItemId, 1);
+
+				//ÒÆ³ý±¾Ãü·¨±¦ÊôÐÔ
+				if (IsMidItem(ori))
+					UpdateTalismanValueOnEquip(player, false);
+			}
+		}
+	}
+	else
+	{
+		//ÅÐ¶Ï¸ÃÎ»ÖÃÊÇ·ñÒÑ¾­×°±¸·¨±¦
+		auto i = player->TalismanMap.find(ID);
+		if (i != player->TalismanMap.end())
+		{
+			if (i->second != 0)
+			{
+				ChatHandler(player->GetSession()).PSendSysMessage("ÇëÏÈÓÒ¼üÈ¡ÏÂ¸ÃÎ»ÖÃ·¨±¦%s£¡", sCF->GetItemLink(i->second).c_str());
+				return;
+			}
+		}
+
+		//ÅÐ¶ÏÊÇ·ñÊÇ·¨±¦
+
+		auto itr = TalismanMap.find(entry);
+
+		if (itr == TalismanMap.end())
+		{
+			ChatHandler(player->GetSession()).PSendSysMessage("%s²»ÊÇ·¨±¦£¡", sCF->GetItemLink(entry).c_str());
+			return;
+		}
+		else
+		{
+
+			if (itr->second != 0)
+			{
+				for (std::unordered_map<uint32, uint32>::iterator iter = player->TalismanMap.begin(); iter != player->TalismanMap.end(); iter++)
+					if (itr->second == GetGroupId(iter->second))
+					{
+						ChatHandler(player->GetSession()).PSendSysMessage("ÄãÒÑ¾­×°±¸Ò»¸öÍ¬Ò»ÀàÐÍµÄ·¨±¦%s£¡", sCF->GetItemLink(iter->second).c_str());
+						return;
+					}
+			}
+		}
+
+		//ÅÐ¶ÏÊÇ·ñÓµÓÐ¸Ã·¨±¦
+		if (!player->HasItemCount(entry, 1))
+			return;
+
+		//ÅÐ¶ÏÊÇ·ñÒÑ×°±¸¸Ã·¨±¦
+		for (std::unordered_map<uint32, uint32>::iterator iter = player->TalismanMap.begin(); iter != player->TalismanMap.end(); iter++)
+			if (entry == iter->second)
+			{
+				ChatHandler(player->GetSession()).PSendSysMessage("ÄãÒÑ¾­×°±¸·¨±¦%s£¡", sCF->GetItemLink(entry).c_str());
+				return;
+			}
+
+		//ÅÐ¶ÏÊÇ·ñ±¾Ãü·¨±¦
+		if (IsMidItem(entry) && ID != 7)
+		{
+			ChatHandler(player->GetSession()).PSendSysMessage("±¾Ãü·¨±¦Ö»ÄÜ×°±¸ÔÚÖÐ¼äÎ»ÖÃ£¡", sCF->GetItemLink(entry).c_str());
+			return;
+		}
+
+		if (!IsMidItem(entry) && ID == 7)
+		{
+			ChatHandler(player->GetSession()).PSendSysMessage("ÖÐ¼äÎ»ÖÃÖ»ÄÜ×°±¸±¾Ãü·¨±¦£¡", sCF->GetItemLink(entry).c_str());
+			return;
+		}
+
+
+		//´Ý»Ù¸Ã·¨±¦
+		player->DestroyItemCount(entry, 1, true, false);
+
+		//×°±¸¸Ã·¨±¦
+		std::unordered_map<uint32, uint32>::iterator iter = player->TalismanMap.find(ID);
+
+		if (iter != player->TalismanMap.end())
+		{
+			//Íê³É·¨±¦Á¶»¯ÈÎÎñ 91146
+			//if (IsMidItem(entry))
+			//sCF->CompleteQuest(player, 30001);
+
+			uint32 ori = iter->second;
+
+			iter->second = entry;
+
+			//»ñµÃÔ­·¨±¦
+			if (const ItemTemplate* temp = sObjectMgr->GetItemTemplate(ori))
+			{
+				//È¥³ý×°±¸ÊôÐÔ¼°¼¼ÄÜ
+				ApplyOnEquip(player, temp->ItemId, false);
+				player->AddItem(temp->ItemId, 1);
+			}
+		}
+		//Ìí¼Ó×°±¸ÊôÐÔ¼°¼¼ÄÜ
+		ApplyOnEquip(player, entry, true);
+
+		//Ôö¼Ó±¾Ãü·¨±¦ÊôÐÔ
+		if (IsMidItem(entry))
+		{
+			UpdateTalismanValueOnEquip(player, true);
+			SendTalisManValue(player);
+		}
+	}
+
+	//¸üÐÂ¿Í»§¶ËÏÔÊ¾
+	SendPacket(player);
+
+	//¸üÐÂÊý¾Ý¿â
+	PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_TALISMAN);
+	stmt->setUInt32(0, player->GetGUIDLow());
+	for (uint32 i = 1; i < 8; i++)
+		stmt->setUInt32(i, GetEntryByID(player, i));
+	CharacterDatabase.Execute(stmt);
+
+
+	//ÕÆÌìÆ¿
+	//if (player->HasSpell(120003))
+	//	player->SpiritPowerInterval = player->SpiritPowerInterval / 2;
+	//else if (player->HasSpell(120004))
+	//	player->SpiritPowerInterval = player->SpiritPowerInterval / 4;
+	//else
+	//	player->SpiritPowerInterval = 2000;
+}
+
+void Talisman::UpdateTalismanValueOnEquip(Player* player, bool equip)
+{
+	player->HandleStatModifier(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE, player->TalismanValue, equip);
+	player->ApplyStatBuffMod(STAT_STAMINA, player->TalismanValue, equip);
+	player->HandleStatModifier(UNIT_MOD_STAT_STRENGTH, TOTAL_VALUE, player->TalismanValue, equip);
+	player->ApplyStatBuffMod(STAT_STRENGTH, player->TalismanValue, equip);
+	player->HandleStatModifier(UNIT_MOD_STAT_AGILITY, TOTAL_VALUE, player->TalismanValue, equip);
+	player->ApplyStatBuffMod(STAT_AGILITY, player->TalismanValue, equip);
+	player->HandleStatModifier(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE, player->TalismanValue, equip);
+	player->ApplyStatBuffMod(STAT_INTELLECT, player->TalismanValue, equip);
+	player->HandleStatModifier(UNIT_MOD_STAT_SPIRIT, TOTAL_VALUE, player->TalismanValue, equip);
+	player->ApplyStatBuffMod(STAT_SPIRIT, player->TalismanValue, equip);
+	player->UpdateAllStats();
+}
+
+void Talisman::AddTalismanValue(Player* player, uint32 value, bool kill)
+{
+	bool equiped = GetEntryByID(player, 7) != 0;//HasTalismanEquiped(player, TALISMAN_VALUE_ITEM);
+
+	if (kill && !equiped)
+		return;
+
+	int32 gap = sSwitch->GetValue(ST_TALISMAN) - player->TalismanValue;
+
+	if (gap <= 0)
+		return;
+	else if (value > gap)
+		value = gap;
+
+	player->TalismanValue += value;
+	SendTalisManValue(player);
+
+	if (equiped)
+	{
+		player->HandleStatModifier(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE, value, true);
+		player->ApplyStatBuffMod(STAT_STAMINA, value, true);
+		player->HandleStatModifier(UNIT_MOD_STAT_STRENGTH, TOTAL_VALUE, value, true);
+		player->ApplyStatBuffMod(STAT_STRENGTH, value, true);
+		player->HandleStatModifier(UNIT_MOD_STAT_AGILITY, TOTAL_VALUE, value, true);
+		player->ApplyStatBuffMod(STAT_AGILITY, value, true);
+		player->HandleStatModifier(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE, value, true);
+		player->ApplyStatBuffMod(STAT_INTELLECT, value, true);
+		player->HandleStatModifier(UNIT_MOD_STAT_SPIRIT, TOTAL_VALUE, value, true);
+		player->ApplyStatBuffMod(STAT_SPIRIT, value, true);
+		player->UpdateAllStats();
+	}
+}
+
+void Talisman::SendTalisManValue(Player* player)
+{
+	sGCAddon->SendPacketTo(player, "GC_S_TALISMAN_VALUE", std::to_string(player->TalismanValue));
+}
+
+void Talisman::SaveTalisManValue(Player* player, bool logout)
+{
+	if (logout)
+		CharacterDatabase.DirectPExecute("UPDATE characters SET TalismanValue = '%u' WHERE guid = '%u'", player->TalismanValue, player->GetGUIDLow());
+	else if (sSwitch->GetValue(ST_TALISMAN) > player->TalismanValue)
+	{
+		CharacterDatabase.DirectPExecute("UPDATE characters SET TalismanValue = '%u' WHERE guid = '%u'", player->TalismanValue, player->GetGUIDLow());
+		ChatHandler(player->GetSession()).PSendSysMessage("±¾Ãü·¨±¦ÐÅÏ¢ÒÑ±£´æ");
+	}
+}
+
+class TalismanPlayerScript : PlayerScript
+{
+public:
+	TalismanPlayerScript() : PlayerScript("TalismanPlayerScript") {}
+
+	void OnLogin(Player* player) override
+	{
+		for (size_t i = 1; i <= 7; i++)
+			player->TalismanMap.insert(std::make_pair(i, 0));
+
+		QueryResult result = CharacterDatabase.PQuery("SELECT ID_1,ID_2,ID_3,ID_4,ID_5,ID_6,ID_7 FROM character_talisman WHERE guid = %u", player->GetGUIDLow());
+
+		if (result)
+		{
+			Field* fields = result->Fetch();
+
+			for (std::unordered_map<uint32, uint32>::iterator iter = player->TalismanMap.begin(); iter != player->TalismanMap.end(); iter++)
+				iter->second = fields[iter->first - 1].GetUInt32();
+
+			sTalisman->ApplyOnLogin(player);
+		}
+
+		uint32 value = 0;
+
+		result = CharacterDatabase.PQuery("SELECT TalismanValue FROM characters WHERE guid = '%u'", player->GetGUIDLow());
+
+		if (result)
+		{
+			do
+			{
+				Field* fields = result->Fetch();
+				value = fields[0].GetUInt32();
+			} while (result->NextRow());
+
+			sTalisman->AddTalismanValue(player, value, false);
+		}
+	}
+
+	void OnLogout(Player* player) override
+	{
+		sTalisman->SaveTalisManValue(player, true);
+	}
+
+	void OnCreatureKill(Player* killer, Creature* killed) override
+	{
+		//if (killed->C_AddTalismanValue > 0)
+		//	sTalisman->AddTalismanValue(killer, killed->C_AddTalismanValue, true);
+		//
+		//if (killed->IsDungeonBoss() || killed->IsDungeonBoss())
+		//	if (killed->C_AddTalismanValue > 0)
+		//		sTalisman->SaveTalisManValue(killer);
+	}
+};
+
+void AddSC_Talisman()
+{
+	new TalismanPlayerScript();
+}
diff --git a/src/server/scripts/Custom/Talisman/Talisman.h b/src/server/scripts/Custom/Talisman/Talisman.h
new file mode 100644
index 0000000..1dc91fb
--- /dev/null
+++ b/src/server/scripts/Custom/Talisman/Talisman.h
@@ -0,0 +1,50 @@
+#define TALISMAN_VALUE_ITEM 100010
+
+extern std::unordered_map<uint32,uint32> TalismanMap;
+
+
+class Talisman
+{
+public:
+	static Talisman* instance()
+	{
+		static Talisman instance;
+		return &instance;
+	}
+
+	void Load();
+	/*
+	std::string GetDescription(TalismanTypes type);
+	void SendTalismanQuery(Player* player, uint32 entry);
+	void UpdateTalisman(Player* player, uint8 upgradeType, bool updataDB);
+	void UpdataDB(Player* player);
+	void UpdatePlayerStat(Player* player, TalismanTypes type, float val1, float val2, uint32 entry);
+
+	void OnCreatureKill(Player* player, Creature* creature);
+	void OnQuestComplete(Player* player, uint32 questId);
+	void OnKillStreak(Player* player);
+	void OnBGWin(Player* player);
+	void OnJoinEvent(Player* player);
+	void OnWorldBossKill(Player* player);
+	*/
+	bool HasTalismanEquiped(Player* player, uint32 entry);
+	uint32 GetEntryByID(Player* player, uint32 ID);
+	std::string GetIcon(uint32 entry);
+	std::string GetName(uint32 entry);
+	uint32 GetGroupId(uint32 entry);
+	void SendPacket(Player* player);
+	void EquipTalisman(Player* player, uint32 ID, uint32 entry);
+	void ApplyOnEquip(Player* player, uint32 entry, bool apply);
+	void ApplyOnLogin(Player* player);
+
+	
+	void UpdateTalismanValueOnEquip(Player* player, bool equip);
+	void SendTalisManValue(Player* player);
+	void AddTalismanValue(Player* player, uint32 value, bool kill);
+	void SaveTalisManValue(Player* player,bool logout = false);
+
+	bool IsMidItem(uint32 entry);
+private:
+
+};
+#define sTalisman Talisman::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/Transmogrification/Transmogrification.cpp b/src/server/scripts/Custom/Transmogrification/Transmogrification.cpp
new file mode 100644
index 0000000..398a20f
--- /dev/null
+++ b/src/server/scripts/Custom/Transmogrification/Transmogrification.cpp
@@ -0,0 +1,736 @@
+#include "Transmogrification.h"
+
+const char * Transmogrification::GetSlotName(uint8 slot, WorldSession* session) const
+{
+    switch (slot)
+    {
+	case EQUIPMENT_SLOT_HEAD: return  ("Í·²¿");// session->GetTrinityString(LANG_SLOT_NAME_HEAD);
+	case EQUIPMENT_SLOT_SHOULDERS: return  ("¼ç²¿");// session->GetTrinityString(LANG_SLOT_NAME_SHOULDERS);;
+	case EQUIPMENT_SLOT_BODY: return  ("³ÄÒÂ");// session->GetTrinityString(LANG_SLOT_NAME_BODY);
+	case EQUIPMENT_SLOT_CHEST: return  ("ÐØ²¿");// session->GetTrinityString(LANG_SLOT_NAME_CHEST);
+	case EQUIPMENT_SLOT_WAIST: return  ("Ñü²¿");// session->GetTrinityString(LANG_SLOT_NAME_WAIST);
+	case EQUIPMENT_SLOT_LEGS: return  ("ÍÈ²¿");// session->GetTrinityString(LANG_SLOT_NAME_LEGS);
+	case EQUIPMENT_SLOT_FEET: return  ("Ñ¥×Ó");// session->GetTrinityString(LANG_SLOT_NAME_FEET);
+	case EQUIPMENT_SLOT_WRISTS: return ("ÊÖÍó");// session->GetTrinityString(LANG_SLOT_NAME_WRISTS);
+	case EQUIPMENT_SLOT_HANDS: return  ("ÊÖÌ×");// session->GetTrinityString(LANG_SLOT_NAME_HANDS);
+	case EQUIPMENT_SLOT_BACK: return  ("±³²¿");// session->GetTrinityString(LANG_SLOT_NAME_BACK);
+	case EQUIPMENT_SLOT_MAINHAND: return  ("Ö÷ÊÖÎäÆ÷");// session->GetTrinityString(LANG_SLOT_NAME_MAINHAND);
+	case EQUIPMENT_SLOT_OFFHAND: return  ("¸±ÊÖÎäÆ÷");// session->GetTrinityString(LANG_SLOT_NAME_OFFHAND);
+	case EQUIPMENT_SLOT_RANGED: return  ("Ô¶³ÌÎäÆ÷");// session->GetTrinityString(LANG_SLOT_NAME_RANGED);
+	case EQUIPMENT_SLOT_TABARD: return ("Õ½ÅÛ");// session->GetTrinityString(LANG_SLOT_NAME_TABARD);
+    default: return NULL;
+    }
+}
+std::string Transmogrification::GetItemIcon(uint32 entry, uint32 width, uint32 height, int x, int y)
+{
+    std::ostringstream ss;
+    ss << "|TInterface";
+    const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+    const ItemDisplayInfoEntry* dispInfo = NULL;
+    if (temp)
+    {
+        dispInfo = sItemDisplayInfoStore.LookupEntry(temp->DisplayInfoID);
+        if (dispInfo)
+            ss << "/ICONS/" << dispInfo->inventoryIcon;
+    }
+    if (!temp && !dispInfo)
+        ss << "/InventoryItems/WoWUnknownItem01";
+    ss << ":" << width << ":" << height << ":" << x << ":" << y << "|t";
+    return ss.str();
+}
+
+std::string Transmogrification::GetSlotIcon(uint8 slot, uint32 width, uint32 height, int x, int y)
+{
+    std::ostringstream ss;
+    ss << "|TInterface/PaperDoll/";
+    switch (slot)
+    {
+    case EQUIPMENT_SLOT_HEAD      : ss << "UI-PaperDoll-Slot-Head"; break;
+    case EQUIPMENT_SLOT_SHOULDERS : ss << "UI-PaperDoll-Slot-Shoulder"; break;
+    case EQUIPMENT_SLOT_BODY      : ss << "UI-PaperDoll-Slot-Shirt"; break;
+    case EQUIPMENT_SLOT_CHEST     : ss << "UI-PaperDoll-Slot-Chest"; break;
+    case EQUIPMENT_SLOT_WAIST     : ss << "UI-PaperDoll-Slot-Waist"; break;
+    case EQUIPMENT_SLOT_LEGS      : ss << "UI-PaperDoll-Slot-Legs"; break;
+    case EQUIPMENT_SLOT_FEET      : ss << "UI-PaperDoll-Slot-Feet"; break;
+    case EQUIPMENT_SLOT_WRISTS    : ss << "UI-PaperDoll-Slot-Wrists"; break;
+    case EQUIPMENT_SLOT_HANDS     : ss << "UI-PaperDoll-Slot-Hands"; break;
+    case EQUIPMENT_SLOT_BACK      : ss << "UI-PaperDoll-Slot-Chest"; break;
+    case EQUIPMENT_SLOT_MAINHAND  : ss << "UI-PaperDoll-Slot-MainHand"; break;
+    case EQUIPMENT_SLOT_OFFHAND   : ss << "UI-PaperDoll-Slot-SecondaryHand"; break;
+    case EQUIPMENT_SLOT_RANGED    : ss << "UI-PaperDoll-Slot-Ranged"; break;
+    case EQUIPMENT_SLOT_TABARD    : ss << "UI-PaperDoll-Slot-Tabard"; break;
+    default: ss << "UI-Backpack-EmptySlot";
+    }
+    ss << ":" << width << ":" << height << ":" << x << ":" << y << "|t";
+    return ss.str();
+}
+#ifdef PRESETS
+bool Transmogrification::PresetTransmog(Player* player, Item* itemTransmogrified, uint32 fakeEntry, uint8 slot)
+{
+    if (!GetEnableSets())
+        return false;
+    if (!player || !itemTransmogrified)
+		return false;
+    if (slot >= EQUIPMENT_SLOT_END)
+		return false;
+    if (!CanTransmogrifyItemWithItem(player, itemTransmogrified->GetTemplate(), sObjectMgr->GetItemTemplate(fakeEntry)))
+		return false;
+
+    // itemTransmogrified->ClearEnchantment(TRANSMOGRIFY_ENCHANTMENT_SLOT);
+    // player->SetVisibleItemSlot(slot, itemTransmogrified);
+
+    // Custom
+    if (GetFakeEntry(itemTransmogrified->GetGUID()))
+        DeleteFakeEntry(player, slot, itemTransmogrified);
+
+    // All okay, proceed
+    // itemTransmogrified->SetEnchantment(TRANSMOGRIFY_ENCHANTMENT_SLOT, newEntry, 0, 0);
+    // player->SetVisibleItemSlot(slot, itemTransmogrified);
+
+    // Custom
+    SetFakeEntry(player, fakeEntry, slot, itemTransmogrified); // newEntry
+
+
+    itemTransmogrified->UpdatePlayedTime(player);
+
+    itemTransmogrified->SetOwnerGUID(player->GetGUID());
+    itemTransmogrified->SetNotRefundable(player);
+    itemTransmogrified->ClearSoulboundTradeable(player);
+}
+bool Transmogrification::GetEnableSets() const
+{
+    return EnableSets;
+}
+uint8 Transmogrification::GetMaxSets() const
+{
+    return MaxSets;
+}
+float Transmogrification::GetSetCostModifier() const
+{
+    return SetCostModifier;
+}
+int32 Transmogrification::GetSetCopperCost() const
+{
+    return SetCopperCost;
+}
+void Transmogrification::LoadPlayerSets(uint64 pGUID)
+{
+    for (presetData::iterator it = presetById[pGUID].begin(); it != presetById[pGUID].end(); ++it)
+        it->second.clear();
+    presetById[pGUID].clear();
+
+    presetByName[pGUID].clear();
+
+    QueryResult result = CharacterDatabase.PQuery("SELECT `PresetID`, `SetName`, `SetData` FROM `custom_transmogrification_sets` WHERE Owner = %u", GUID_LOPART(pGUID));
+    if (result)
+    {
+        do
+        {
+            uint8 PresetID = (*result)[0].GetUInt8();
+            std::string SetName = (*result)[1].GetString();
+            std::istringstream SetData((*result)[2].GetString());
+            while (SetData.good())
+            {
+                uint32 slot;
+                uint32 entry;
+                SetData >> slot >> entry;
+                if(SetData.fail())
+                    break;
+                if(slot >= EQUIPMENT_SLOT_END)
+                {
+					//OG_TYPE_ERROR->outError(LOG_FILTER_SQL, "Item entry (FakeEntry: %u, playerGUID: %u, slot: %u, presetId: %u) has invalid slot, ignoring.", entry, GUID_LOPART(pGUID), slot, uint32(PresetID));
+                    continue;
+                }
+                if (sObjectMgr->GetItemTemplate(entry))
+                    presetById[pGUID][PresetID][slot] = entry; // Transmogrification::Preset(presetName, fakeEntry);
+				else;
+                    //TC_LOG_ERROR->outError(LOG_FILTER_SQL, "Item entry (FakeEntry: %u, playerGUID: %u, slot: %u, presetId: %u) does not exist, ignoring.", entry, GUID_LOPART(pGUID), uint32(slot), uint32(PresetID));
+            }
+
+            if (!presetById[pGUID][PresetID].empty())
+            {
+                presetByName[pGUID][PresetID] = SetName;
+                // load all presets anyways
+                //if (presetByName[pGUID].size() >= GetMaxSets())
+                //    break;
+            }
+            else // should be deleted on startup, so  this never runs (shouldnt..)
+            {
+                presetById[pGUID].erase(PresetID);
+                CharacterDatabase.PExecute("DELETE FROM `custom_transmogrification_sets` WHERE Owner = %u AND PresetID = %u",  GUID_LOPART(pGUID), PresetID);
+            }
+        } while (result->NextRow());
+    }
+}
+void Transmogrification::UnloadPlayerSets(uint64 pGUID)
+{
+    for (presetData::iterator it = presetById[pGUID].begin(); it != presetById[pGUID].end(); ++it)
+        it->second.clear();
+    presetById[pGUID].clear();
+
+    presetByName[pGUID].clear();
+}
+#endif
+std::string Transmogrification::GetItemLink(Item* item, WorldSession* session)
+{
+    int loc_idx = session->GetSessionDbLocaleIndex();
+    const ItemTemplate* temp = item->GetTemplate();
+    std::string name = temp->Name1;
+    /*if (ItemLocale const* il = sObjectMgr->GetItemLocale(temp->ItemId))
+        ObjectMgr::GetLocaleString(il->Name, loc_idx, name);*/
+
+    if (int32 itemRandPropId = item->GetItemRandomPropertyId())
+    {
+        char* const* suffix = NULL;
+        if (itemRandPropId < 0)
+        {
+            const ItemRandomSuffixEntry* itemRandEntry = sItemRandomSuffixStore.LookupEntry(-item->GetItemRandomPropertyId());
+            if (itemRandEntry)
+                suffix = itemRandEntry->nameSuffix;
+        }
+        else
+        {
+            const ItemRandomPropertiesEntry* itemRandEntry = sItemRandomPropertiesStore.LookupEntry(item->GetItemRandomPropertyId());
+            if (itemRandEntry)
+                suffix = itemRandEntry->nameSuffix;
+        }
+        if (suffix)
+        {
+            std::string test(suffix[(name != temp->Name1) ? loc_idx : DEFAULT_LOCALE]);
+            if (!test.empty())
+            {
+                name += ' ';
+                name += test;
+            }
+        }
+    }
+
+    std::ostringstream oss;
+    oss << "|c" << std::hex << ItemQualityColors[temp->Quality] << std::dec <<
+        "|Hitem:" << temp->ItemId <<":" <<
+        item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ":" <<
+        item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT) << ":" <<
+        item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_2) << ":" <<
+        item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_3) << ":" <<
+        item->GetEnchantmentId(BONUS_ENCHANTMENT_SLOT) << ":" <<
+        item->GetItemRandomPropertyId() << ":" << item->GetItemSuffixFactor() << ":" <<
+        (uint32)item->GetOwner()->getLevel() << "|h[" << name << "]|h|r";
+
+    return oss.str();
+}
+std::string Transmogrification::GetItemLink(uint32 entry, WorldSession* session)
+{
+    const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+    int loc_idx = session->GetSessionDbLocaleIndex();
+    std::string name = temp->Name1;
+    /*if (ItemLocale const* il = sObjectMgr->GetItemLocale(entry))
+        ObjectMgr::GetLocaleString(il->Name, loc_idx, name);*/
+
+    std::ostringstream oss;
+    oss << "|c" << std::hex << ItemQualityColors[temp->Quality] << std::dec <<
+        "|Hitem:" << entry << ":0:0:0:0:0:0:0:0:0|h[" << name << "]|h|r";
+
+    return oss.str();
+}
+uint32 Transmogrification::GetFakeEntry(uint64 itemGUID) const
+{
+    transmogData::const_iterator itr = dataMap.find(itemGUID);
+    if (itr == dataMap.end()) return 0;
+    transmogMap::const_iterator itr2 = entryMap.find(itr->second);
+    if (itr2 == entryMap.end()) return 0;
+    transmogData::const_iterator itr3 = itr2->second.find(itemGUID);
+    if (itr3 == itr2->second.end()) return 0;
+    return itr3->second;
+}
+void Transmogrification::DeleteFakeFromDB(uint64 itemGUID, SQLTransaction* trans)
+{
+    if (dataMap.find(itemGUID) != dataMap.end())
+    {
+        if (entryMap.find(dataMap[itemGUID]) != entryMap.end())
+            entryMap[dataMap[itemGUID]].erase(itemGUID);
+        dataMap.erase(itemGUID);
+    }
+    if (trans)
+        (*trans)->PAppend("DELETE FROM custom_transmogrification WHERE GUID = %u", GUID_LOPART(itemGUID));
+    else
+        CharacterDatabase.PExecute("DELETE FROM custom_transmogrification WHERE GUID = %u", GUID_LOPART(itemGUID));
+}
+void Transmogrification::DeleteFakeEntry(Player* player, uint8 slot, Item* itemTransmogrified, SQLTransaction* trans)
+{
+    //if (!GetFakeEntry(item))
+    //    return false;
+    DeleteFakeFromDB(itemTransmogrified->GetGUID(), trans);
+    player->SetVisibleItemSlot(slot, itemTransmogrified);
+}
+void Transmogrification::SetFakeEntry(Player* player, uint32 newEntry, uint8 slot, Item* itemTransmogrified)
+{
+    uint64 itemGUID = itemTransmogrified->GetGUID();
+    entryMap[player->GetGUID()][itemGUID] = newEntry;
+    dataMap[itemGUID] = player->GetGUID();
+    CharacterDatabase.PExecute("REPLACE INTO custom_transmogrification (GUID, FakeEntry, Owner) VALUES (%u, %u, %u)", GUID_LOPART(itemGUID), newEntry, player->GetGUIDLow());
+    player->SetVisibleItemSlot(slot, itemTransmogrified);
+}
+TransmogTrinityStrings Transmogrification::Transmogrify(Player* player, uint64 itemGUID, uint8 slot, /*uint32 newEntry, */bool no_cost)
+{
+    int32 cost = 0;
+    // slot of the transmogrified item
+    if (slot >= EQUIPMENT_SLOT_END)
+    {
+        //TC_LOG_DEBUG(LOG_FILTER_NETWORKIO, "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) tried to transmogrify an item (lowguid: %u) with a wrong slot (%u) when transmogrifying items.", player->GetGUIDLow(), player->GetName().c_str(), GUID_LOPART(itemGUID), slot);
+        return LANG_ERR_TRANSMOG_INVALID_SLOT;
+    }
+
+    /* // GET FROM itemTransmogrifier
+    // entry of the transmogrifier item, if it's not 0
+    if (newEntry)
+    {
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(newEntry);
+    if (!proto)
+    {
+    TC_LOG_DEBUG(LOG_FILTER_NETWORKIO, "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) tried to transmogrify to an invalid item (entry: %u).", player->GetGUIDLow(), player->GetName().c_str(), newEntry);
+    return LANG_ERR_TRANSMOG_INVALID_SRC_ENTRY;
+    }
+    }
+    */
+
+    Item* itemTransmogrifier = NULL;
+    // guid of the transmogrifier item, if it's not 0
+    if (itemGUID)
+    {
+        itemTransmogrifier = player->GetItemByGuid(itemGUID);
+        if (!itemTransmogrifier)
+        {
+            //TC_LOG_DEBUG(LOG_FILTER_NETWORKIO, "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) tried to transmogrify with an invalid item (lowguid: %u).", player->GetGUIDLow(), player->GetName().c_str(), GUID_LOPART(itemGUID));
+            return LANG_ERR_TRANSMOG_MISSING_SRC_ITEM;
+        }
+    }
+
+    // transmogrified item
+    Item* itemTransmogrified = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+    if (!itemTransmogrified)
+    {
+        //TC_LOG_DEBUG(LOG_FILTER_NETWORKIO, "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) tried to transmogrify an invalid item in a valid slot (slot: %u).", player->GetGUIDLow(), player->GetName().c_str(), slot);
+        return LANG_ERR_TRANSMOG_MISSING_DEST_ITEM;
+    }
+
+    // uint16 tempDest;
+    //// has to be able to equip item transmogrified item
+    //if (!player->CanEquipItem(slot, tempDest, itemTransmogrified, true, true))
+    //{
+    //    TC_LOG_DEBUG(LOG_FILTER_NETWORKIO, "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) can't equip the item to be transmogrified (slot: %u, entry: %u).", player->GetGUIDLow(), player->GetName().c_str(), slot, itemTransmogrified->GetEntry());
+    //    return;
+    //}
+    //
+    //// has to be able to equip item transmogrifier item
+    //if (!player->CanEquipItem(slot, tempDest, itemTransmogrifier, true, true))
+    //{
+    //    TC_LOG_DEBUG(LOG_FILTER_NETWORKIO, "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) can't equip the transmogrifier item (slot: %u, entry: %u).", player->GetGUIDLow(), player->GetName().c_str(), slot, itemTransmogrifier->GetEntry());
+    //    return;
+    //}
+
+    if (!itemTransmogrifier) // reset look newEntry
+    {
+        // itemTransmogrified->ClearEnchantment(TRANSMOGRIFY_ENCHANTMENT_SLOT);
+        // player->SetVisibleItemSlot(slot, itemTransmogrified);
+
+        // Custom
+        DeleteFakeEntry(player, slot, itemTransmogrified);
+    }
+    else
+    {
+        if (!CanTransmogrifyItemWithItem(player, itemTransmogrified->GetTemplate(), itemTransmogrifier->GetTemplate()))
+        {
+            //sLog->outError(LOG_FILTER_NETWORKIO, "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) failed CanTransmogrifyItemWithItem (%u with %u).", player->GetGUIDLow(), player->GetName().c_str(), itemTransmogrified->GetEntry(), itemTransmogrifier->GetEntry());
+            return LANG_ERR_TRANSMOG_INVALID_ITEMS;
+        }
+
+        if (!no_cost)
+        {
+            cost = GetSpecialPrice(itemTransmogrified->GetTemplate());
+            cost *= GetScaledCostModifier();
+            cost += GetCopperCost();
+            if (!player->HasEnoughMoney(cost))
+                return LANG_ERR_TRANSMOG_NOT_ENOUGH_MONEY;
+
+            if (GetRequireToken())
+            {
+                if (player->HasItemCount(GetTokenEntry(), GetTokenAmount()))
+                    player->DestroyItemCount(GetTokenEntry(), GetTokenAmount(), true);
+                else
+                    return LANG_ERR_TRANSMOG_NOT_ENOUGH_TOKENS;
+            }
+        }
+
+        // All okay, proceed
+        // itemTransmogrified->SetEnchantment(TRANSMOGRIFY_ENCHANTMENT_SLOT, newEntry, 0, 0);
+        // player->SetVisibleItemSlot(slot, itemTransmogrified);
+
+        // Custom
+        SetFakeEntry(player, itemTransmogrifier->GetEntry(), slot, itemTransmogrified); // newEntry
+
+        itemTransmogrified->UpdatePlayedTime(player);
+
+        itemTransmogrified->SetOwnerGUID(player->GetGUID());
+        itemTransmogrified->SetNotRefundable(player);
+        itemTransmogrified->ClearSoulboundTradeable(player);
+
+		if (itemTransmogrifier->GetTemplate()->Bonding == BIND_WHEN_EQUIPED || itemTransmogrifier->GetTemplate()->Bonding == BIND_WHEN_USE)
+		{
+			itemTransmogrifier->UnBinded = false;
+			itemTransmogrifier->SetBinding(true);
+		}
+            
+
+        itemTransmogrifier->SetOwnerGUID(player->GetGUID());
+        itemTransmogrifier->SetNotRefundable(player);
+        itemTransmogrifier->ClearSoulboundTradeable(player);
+
+        //cost += GetSpecialPrice(itemTransmogrified->GetTemplate());
+        //cost *= GetScaledCostModifier();
+        //cost += sT->GetCopperCost();
+    }
+
+    // trusting the client, if it got here it has to have enough money
+    // ... unless client was modified
+    if (cost) // 0 cost if reverting look
+        player->ModifyMoney(-1*cost, false);
+    return LANG_ERR_TRANSMOG_OK;
+}
+bool Transmogrification::CanTransmogrifyItemWithItem(Player* player, ItemTemplate const* proto2, ItemTemplate const* proto1)
+{
+    //if (!transmogrifier || !transmogrified)
+    //    return false;
+
+    //ItemTemplate const* proto1 = transmogrifier->GetTemplate(); // source
+    //ItemTemplate const* proto2 = transmogrified->GetTemplate(); // dest
+
+    if (proto1->ItemId == proto2->ItemId)
+        return false;
+
+    if (!SuitableForTransmogrification(player, proto2) || !SuitableForTransmogrification(player, proto1)) // if (!transmogrified->CanTransmogrify() || !transmogrifier->CanBeTransmogrified())
+        return false;
+
+    if (proto1->InventoryType == INVTYPE_BAG ||
+        proto1->InventoryType == INVTYPE_RELIC ||
+        proto1->InventoryType == INVTYPE_FINGER ||
+        proto1->InventoryType == INVTYPE_TRINKET ||
+        proto1->InventoryType == INVTYPE_AMMO ||
+        proto1->InventoryType == INVTYPE_QUIVER)
+        return false;
+
+	if ((proto1->InventoryType == INVTYPE_WEAPON && proto2->InventoryType == INVTYPE_WEAPONMAINHAND) ||
+		(proto1->InventoryType == INVTYPE_WEAPONMAINHAND && proto2->InventoryType == INVTYPE_WEAPONOFFHAND) ||
+		(proto1->InventoryType == INVTYPE_WEAPONMAINHAND && proto2->InventoryType == INVTYPE_2HWEAPON) ||
+		(proto1->InventoryType == INVTYPE_WEAPONMAINHAND && proto2->InventoryType == INVTYPE_WEAPON) ||
+
+		(proto1->InventoryType == INVTYPE_WEAPONOFFHAND && proto2->InventoryType == INVTYPE_WEAPONOFFHAND) ||
+		(proto1->InventoryType == INVTYPE_WEAPONOFFHAND && proto2->InventoryType == INVTYPE_WEAPONMAINHAND) ||
+		(proto1->InventoryType == INVTYPE_WEAPONOFFHAND && proto2->InventoryType == INVTYPE_2HWEAPON) ||
+		(proto1->InventoryType == INVTYPE_WEAPONOFFHAND && proto2->InventoryType == INVTYPE_WEAPON) ||
+
+		(proto1->InventoryType == INVTYPE_2HWEAPON && proto2->InventoryType == INVTYPE_WEAPONOFFHAND) ||
+		(proto1->InventoryType == INVTYPE_2HWEAPON && proto2->InventoryType == INVTYPE_WEAPONMAINHAND) ||
+		(proto1->InventoryType == INVTYPE_2HWEAPON && proto2->InventoryType == INVTYPE_2HWEAPON) ||
+		(proto1->InventoryType == INVTYPE_2HWEAPON && proto2->InventoryType == INVTYPE_WEAPON) ||
+
+		(proto1->InventoryType == INVTYPE_WEAPON && proto2->InventoryType == INVTYPE_WEAPON) ||
+		(proto1->InventoryType == INVTYPE_WEAPON && proto2->InventoryType == INVTYPE_WEAPONMAINHAND) ||
+		(proto1->InventoryType == INVTYPE_WEAPON && proto2->InventoryType == INVTYPE_WEAPONOFFHAND) ||
+		(proto1->InventoryType == INVTYPE_WEAPON && proto2->InventoryType == INVTYPE_2HWEAPON)||
+
+		(proto1->InventoryType == INVTYPE_HEAD && proto2->InventoryType == INVTYPE_HEAD) ||
+		(proto1->InventoryType == INVTYPE_SHOULDERS && proto2->InventoryType == INVTYPE_SHOULDERS) ||
+
+		(proto1->InventoryType == INVTYPE_CHEST && proto2->InventoryType == INVTYPE_CHEST) ||
+		(proto1->InventoryType == INVTYPE_CHEST && proto2->InventoryType == INVTYPE_ROBE) ||
+		(proto1->InventoryType == INVTYPE_ROBE && proto2->InventoryType == INVTYPE_CHEST) ||
+		(proto1->InventoryType == INVTYPE_ROBE && proto2->InventoryType == INVTYPE_ROBE) ||
+
+		(proto1->InventoryType == INVTYPE_BODY && proto2->InventoryType == INVTYPE_BODY) ||
+		(proto1->InventoryType == INVTYPE_WAIST && proto2->InventoryType == INVTYPE_WAIST) ||
+		(proto1->InventoryType == INVTYPE_LEGS && proto2->InventoryType == INVTYPE_LEGS) ||
+		(proto1->InventoryType == INVTYPE_FEET && proto2->InventoryType == INVTYPE_FEET) ||
+		(proto1->InventoryType == INVTYPE_WRISTS && proto2->InventoryType == INVTYPE_WRISTS) ||
+		(proto1->InventoryType == INVTYPE_HANDS && proto2->InventoryType == INVTYPE_HANDS) ||
+		(proto1->InventoryType == INVTYPE_HANDS && proto2->InventoryType == INVTYPE_HANDS) ||
+
+		(proto1->InventoryType == INVTYPE_RANGED && proto2->InventoryType == INVTYPE_RANGEDRIGHT) ||
+		(proto1->InventoryType == INVTYPE_RANGED && proto2->InventoryType == INVTYPE_RANGED) ||
+		(proto1->InventoryType == INVTYPE_RANGEDRIGHT && proto2->InventoryType == INVTYPE_RANGEDRIGHT) ||
+		(proto1->InventoryType == INVTYPE_RANGEDRIGHT && proto2->InventoryType == INVTYPE_RANGED)
+		)
+
+		return true;
+
+
+    //custom, TC doesnt check this? Checked by Inventory type check.
+    if (proto1->Class != proto2->Class)
+        return false;
+
+	/*
+    if (proto1->SubClass != proto2->SubClass && ((proto1->Class != ITEM_CLASS_WEAPON && !GetAllowMixedArmorTypes()) ||
+        (!GetAllowMixedWeaponTypes() || (!IsRangedWeapon(proto2->SubClass, proto2->Class) || !IsRangedWeapon(proto1->SubClass, proto1->Class)))))
+        return false;
+		*/
+
+	if (proto1->InventoryType != proto2->InventoryType)
+		return false;
+
+
+	if (IsRangedWeapon(proto2->SubClass, proto2->Class) && IsRangedWeapon(proto1->SubClass, proto1->Class))
+		return true;
+
+	/*
+    if (proto1->InventoryType != proto2->InventoryType &&
+        (proto1->Class != ITEM_CLASS_WEAPON || (proto2->InventoryType != INVTYPE_WEAPONMAINHAND && proto2->InventoryType != INVTYPE_WEAPONOFFHAND)) &&
+        (proto1->Class != ITEM_CLASS_ARMOR || (proto1->InventoryType != INVTYPE_CHEST && proto2->InventoryType != INVTYPE_ROBE && proto1->InventoryType != INVTYPE_ROBE && proto2->InventoryType != INVTYPE_CHEST) || true))
+        return false;
+	*/
+    return true;
+}
+bool Transmogrification::SuitableForTransmogrification(Player* player, ItemTemplate const* proto)
+{
+	return true;
+    // ItemTemplate const* proto = item->GetTemplate();
+    if (!player || !proto)
+        return false;
+
+    if (proto->Class != ITEM_CLASS_ARMOR &&
+        proto->Class != ITEM_CLASS_WEAPON)
+        return false;
+
+    if (proto->Class == ITEM_CLASS_WEAPON && proto->SubClass == ITEM_SUBCLASS_WEAPON_FISHING_POLE)
+        return false;
+
+    if (IsAllowed(proto->ItemId))
+        return true;
+
+    if (IsNotAllowed(proto->ItemId))
+        return false;
+
+    if (!IsAllowedQuality(proto->Quality)) // (proto->Quality == ITEM_QUALITY_LEGENDARY)
+        return false;
+
+    //if (player->CanUseItem(proto) != EQUIP_ERR_OK)
+        //return false;
+    return true;
+}
+/*
+bool Transmogrification::CanTransmogrify(Item const* item)
+{
+ItemTemplate const* proto = item->GetTemplate();
+
+if (!proto)
+return false;
+
+if (proto->Flags2 & ITEM_FLAGS_EXTRA_CANNOT_TRANSMOG)
+return false;
+
+if (proto->Quality == ITEM_QUALITY_LEGENDARY)
+return false;
+
+if (proto->Class != ITEM_CLASS_ARMOR &&
+proto->Class != ITEM_CLASS_WEAPON)
+return false;
+
+if (proto->Class == ITEM_CLASS_WEAPON && proto->SubClass == ITEM_SUBCLASS_WEAPON_FISHING_POLE)
+return false;
+
+if (proto->Flags2 & ITEM_FLAGS_EXTRA_CAN_TRANSMOG)
+return true;
+
+if (item->GetItemRandomPropertyId() == 0)
+return false;
+
+for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
+if (proto->ItemStat[i].ItemStatValue != 0)
+return true;
+
+return false;
+}
+bool Transmogrification::CanBeTransmogrified(Item const* item)
+{
+ItemTemplate const* proto = item->GetTemplate();
+
+if (!proto)
+return false;
+
+if (proto->Quality == ITEM_QUALITY_LEGENDARY)
+return false;
+
+if (proto->Class != ITEM_CLASS_ARMOR &&
+proto->Class != ITEM_CLASS_WEAPON)
+return false;
+
+if (proto->Class == ITEM_CLASS_WEAPON && proto->SubClass == ITEM_SUBCLASS_WEAPON_FISHING_POLE)
+return false;
+
+if (proto->Flags2 & ITEM_FLAGS_EXTRA_CANNOT_BE_TRANSMOG)
+return false;
+
+if (item->GetItemRandomPropertyId() == 0)
+return false;
+
+for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
+if (proto->ItemStat[i].ItemStatValue != 0)
+return true;
+
+return false;
+}
+*/
+uint32 Transmogrification::GetSpecialPrice(ItemTemplate const* proto) const
+{
+    uint32 cost = proto->SellPrice < 10000 ? 10000 : proto->SellPrice;
+    return cost;
+}
+bool Transmogrification::IsRangedWeapon(uint32 Class, uint32 SubClass) const
+{
+    return Class == ITEM_CLASS_WEAPON ||
+        SubClass == ITEM_SUBCLASS_WEAPON_BOW ||
+        SubClass == ITEM_SUBCLASS_WEAPON_GUN ||
+        SubClass == ITEM_SUBCLASS_WEAPON_CROSSBOW;
+}
+bool Transmogrification::IsAllowed(uint32 entry) const
+{
+    return Allowed.find(entry) != Allowed.end();
+}
+bool Transmogrification::IsNotAllowed(uint32 entry) const
+{
+    return NotAllowed.find(entry) != NotAllowed.end();
+}
+bool Transmogrification::GetEnableTransmogInfo() const
+{
+    return EnableTransmogInfo;
+}
+uint32 Transmogrification::GetTransmogNpcText() const
+{
+    return TransmogNpcText;
+}
+bool Transmogrification::GetEnableSetInfo() const
+{
+    return EnableSetInfo;
+}
+uint32 Transmogrification::GetSetNpcText() const
+{
+    return SetNpcText;
+}
+float Transmogrification::GetScaledCostModifier() const
+{
+    return ScaledCostModifier;
+}
+int32 Transmogrification::GetCopperCost() const
+{
+    return CopperCost;
+}
+bool Transmogrification::GetRequireToken() const
+{
+    return RequireToken;
+}
+uint32 Transmogrification::GetTokenEntry() const
+{
+    return TokenEntry;
+}
+uint32 Transmogrification::GetTokenAmount() const
+{
+    return TokenAmount;
+}
+bool Transmogrification::GetAllowMixedArmorTypes() const
+{
+    return AllowMixedArmorTypes;
+};
+bool Transmogrification::GetAllowMixedWeaponTypes() const
+{
+    return AllowMixedWeaponTypes;
+};
+bool Transmogrification::IsAllowedQuality(uint32 quality) const
+{
+    switch(quality)
+    {
+    case ITEM_QUALITY_POOR: return AllowPoor;
+    case ITEM_QUALITY_NORMAL: return AllowCommon;
+    case ITEM_QUALITY_UNCOMMON: return AllowUncommon;
+    case ITEM_QUALITY_RARE: return AllowRare;
+    case ITEM_QUALITY_EPIC: return AllowEpic;
+    case ITEM_QUALITY_LEGENDARY: return AllowLegendary;
+    case ITEM_QUALITY_ARTIFACT: return AllowArtifact;
+    case ITEM_QUALITY_HEIRLOOM: return AllowHeirloom;
+    default: return false;
+    }
+}
+void Transmogrification::LoadConfig(bool reload)
+{
+#ifdef PRESETS
+	EnableSetInfo = sConfigMgr->GetFloatDefault("Transmogrification.EnableSetInfo", true);
+	SetNpcText = sConfigMgr->GetFloatDefault("Transmogrification.SetNpcText", 50001);
+
+	EnableSets = sConfigMgr->GetFloatDefault("Transmogrification.EnableSets", true);
+	MaxSets = (uint8)sConfigMgr->GetFloatDefault("Transmogrification.MaxSets", 10);
+	SetCostModifier = sConfigMgr->GetFloatDefault("Transmogrification.SetCostModifier", 3.0f);
+	SetCopperCost = sConfigMgr->GetFloatDefault("Transmogrification.SetCopperCost", 0);
+
+    if (MaxSets > MAX_OPTIONS)
+        MaxSets = MAX_OPTIONS;
+
+    if (reload) // dont store presets for nothing
+    {
+        SessionMap const& sessions = sWorld->GetAllSessions();
+        for (SessionMap::const_iterator it = sessions.begin(); it != sessions.end(); ++it)
+        {
+            if (Player* player = it->second->GetPlayer())
+            {
+                // skipping session check
+                UnloadPlayerSets(player->GetGUID());
+                if (GetEnableSets())
+                    LoadPlayerSets(player->GetGUID());
+            }
+        }
+    }
+#endif
+
+	EnableTransmogInfo = sConfigMgr->GetBoolDefault("Transmogrification.EnableTransmogInfo", true);
+	TransmogNpcText = uint32(sConfigMgr->GetFloatDefault("Transmogrification.TransmogNpcText", 50000));
+
+	std::istringstream issAllowed(sConfigMgr->GetStringDefault("Transmogrification.Allowed", ""));
+	std::istringstream issNotAllowed(sConfigMgr->GetStringDefault("Transmogrification.NotAllowed", ""));
+    while(issAllowed.good())
+    {
+        uint32 entry;
+        issAllowed >> entry;
+        if(issAllowed.fail())
+            break;
+        Allowed.insert(entry);
+    }
+    while(issNotAllowed.good())
+    {
+        uint32 entry;
+        issNotAllowed >> entry;
+        if(issNotAllowed.fail())
+            break;
+        NotAllowed.insert(entry);
+    }
+
+	ScaledCostModifier = sConfigMgr->GetBoolDefault("Transmogrification.ScaledCostModifier", 1.0f);
+	CopperCost = sConfigMgr->GetBoolDefault("Transmogrification.CopperCost", 0);
+
+	RequireToken = sConfigMgr->GetBoolDefault("Transmogrification.RequireToken", false);
+	TokenEntry = uint32(sConfigMgr->GetIntDefault("Transmogrification.TokenEntry", 49426));
+	TokenAmount = uint32(sConfigMgr->GetBoolDefault("Transmogrification.TokenAmount", 1));
+
+	AllowPoor = sConfigMgr->GetBoolDefault("Transmogrification.AllowPoor", false);
+	AllowCommon = sConfigMgr->GetBoolDefault("Transmogrification.AllowCommon", false);
+	AllowUncommon = sConfigMgr->GetBoolDefault("Transmogrification.AllowUncommon", true);
+	AllowRare = sConfigMgr->GetBoolDefault("Transmogrification.AllowRare", true);
+	AllowEpic = sConfigMgr->GetBoolDefault("Transmogrification.AllowEpic", true);
+	AllowLegendary = sConfigMgr->GetBoolDefault("Transmogrification.AllowLegendary", false);
+	AllowArtifact = sConfigMgr->GetBoolDefault("Transmogrification.AllowArtifact", false);
+	AllowHeirloom = sConfigMgr->GetBoolDefault("Transmogrification.AllowHeirloom", true);
+
+	AllowMixedArmorTypes = sConfigMgr->GetBoolDefault("Transmogrification.AllowMixedArmorTypes", true);
+	AllowMixedWeaponTypes = sConfigMgr->GetBoolDefault("Transmogrification.AllowMixedWeaponTypes", true);
+
+    if (!sObjectMgr->GetItemTemplate(TokenEntry))
+    {
+		sLog->outError( "Transmogrification.TokenEntry (%u) does not exist. Using default.", TokenEntry);
+        TokenEntry = 49426;
+    }
+}
diff --git a/src/server/scripts/Custom/Transmogrification/Transmogrification.h b/src/server/scripts/Custom/Transmogrification/Transmogrification.h
new file mode 100644
index 0000000..8ab45fa
--- /dev/null
+++ b/src/server/scripts/Custom/Transmogrification/Transmogrification.h
@@ -0,0 +1,132 @@
+#ifndef DEF_TRANSMOGRIFICATION_H
+#define DEF_TRANSMOGRIFICATION_H
+
+#define PRESETS // comment this line to disable preset feature totally
+
+#include "Language.h"
+#include "Config.h"
+
+#define MAX_OPTIONS 25 // do not alter
+
+enum TransmogTrinityStrings // Language.h might have same entries, appears when executing SQL, change if needed
+{
+    LANG_ERR_TRANSMOG_OK = 11100, // change this
+    LANG_ERR_TRANSMOG_INVALID_SLOT,
+    LANG_ERR_TRANSMOG_INVALID_SRC_ENTRY,
+    LANG_ERR_TRANSMOG_MISSING_SRC_ITEM,
+    LANG_ERR_TRANSMOG_MISSING_DEST_ITEM,
+    LANG_ERR_TRANSMOG_INVALID_ITEMS,
+    LANG_ERR_TRANSMOG_NOT_ENOUGH_MONEY,
+    LANG_ERR_TRANSMOG_NOT_ENOUGH_TOKENS,
+
+    LANG_ERR_UNTRANSMOG_OK,
+    LANG_ERR_UNTRANSMOG_NO_TRANSMOGS,
+
+#ifdef PRESETS
+    LANG_PRESET_ERR_INVALID_NAME,
+#endif
+};
+
+class Transmogrification
+{
+public:
+    typedef std::unordered_map<uint64, uint64> transmogData;
+    typedef std::unordered_map<uint64, transmogData> transmogMap;
+    transmogMap entryMap; // entryMap[pGUID][iGUID] = entry
+    transmogData dataMap; // dataMap[iGUID] = pGUID
+
+#ifdef PRESETS
+    typedef std::map<uint8, uint32> slotMap;
+    typedef std::map<uint8, slotMap> presetData;
+    typedef std::unordered_map<uint64, presetData> presetDataMap;
+    presetDataMap presetById; // presetById[pGUID][presetID][slot] = entry
+    typedef std::map<uint8, std::string> presetIdMap;
+    typedef std::unordered_map<uint64, presetIdMap> presetNameMap;
+    presetNameMap presetByName; // presetByName[pGUID][presetID] = presetName
+
+    bool PresetTransmog(Player* player, Item* itemTransmogrified, uint32 fakeEntry, uint8 slot);
+
+    bool EnableSets;
+    uint8 MaxSets;
+    float SetCostModifier;
+    int32 SetCopperCost;
+
+    bool GetEnableSets() const;
+    uint8 GetMaxSets() const;
+    float GetSetCostModifier() const;
+    int32 GetSetCopperCost() const;
+
+    void LoadPlayerSets(uint64 pGUID);
+    void UnloadPlayerSets(uint64 pGUID);
+#endif
+
+    std::string GetItemIcon(uint32 entry, uint32 width, uint32 height, int x, int y);
+    std::string GetSlotIcon(uint8 slot, uint32 width, uint32 height, int x, int y);
+    const char * GetSlotName(uint8 slot, WorldSession* session) const;
+    std::string GetItemLink(Item* item, WorldSession* session);
+    std::string GetItemLink(uint32 entry, WorldSession* session);
+    uint32 GetFakeEntry(uint64 itemGUID) const;
+    void DeleteFakeFromDB(uint64 itemGUID, SQLTransaction* trans = NULL);
+    void DeleteFakeEntry(Player* player, uint8 slot, Item* itemTransmogrified, SQLTransaction* trans = NULL);
+    void SetFakeEntry(Player* player, uint32 newEntry, uint8 slot, Item* itemTransmogrified);
+
+    TransmogTrinityStrings Transmogrify(Player* player, uint64 itemGUID, uint8 slot, /*uint32 newEntry, */bool no_cost = false);
+    bool CanTransmogrifyItemWithItem(Player* player, ItemTemplate const* destination, ItemTemplate const* source);
+    bool SuitableForTransmogrification(Player* player, ItemTemplate const* proto);
+    // bool CanBeTransmogrified(Item const* item);
+    // bool CanTransmogrify(Item const* item);
+    uint32 GetSpecialPrice(ItemTemplate const* proto) const;
+    bool IsRangedWeapon(uint32 Class, uint32 SubClass) const;
+
+    // config values
+    bool EnableTransmogInfo;
+    uint32 TransmogNpcText;
+    bool EnableSetInfo;
+    uint32 SetNpcText;
+
+    std::set<uint32> Allowed;
+    std::set<uint32> NotAllowed;
+
+    float ScaledCostModifier;
+    int32 CopperCost;
+
+    bool RequireToken;
+    uint32 TokenEntry;
+    uint32 TokenAmount;
+
+    bool AllowPoor;
+    bool AllowCommon;
+    bool AllowUncommon;
+    bool AllowRare;
+    bool AllowEpic;
+    bool AllowLegendary;
+    bool AllowArtifact;
+    bool AllowHeirloom;
+    bool AllowMixedArmorTypes;
+    bool AllowMixedWeaponTypes;
+
+    // Config
+    bool GetEnableTransmogInfo() const;
+    uint32 GetTransmogNpcText() const;
+    bool GetEnableSetInfo() const;
+    uint32 GetSetNpcText() const;
+
+    bool IsAllowed(uint32 entry) const;
+    bool IsNotAllowed(uint32 entry) const;
+
+    float GetScaledCostModifier() const;
+    int32 GetCopperCost() const;
+
+    bool GetRequireToken() const;
+    uint32 GetTokenEntry() const;
+    uint32 GetTokenAmount() const;
+
+    bool IsAllowedQuality(uint32 quality) const;
+    bool GetAllowMixedArmorTypes() const;
+    bool GetAllowMixedWeaponTypes() const;
+
+    void LoadConfig(bool reload);
+};
+#define sTransmogrification ACE_Singleton<Transmogrification, ACE_Null_Mutex>::instance()
+
+#endif
diff --git a/src/server/scripts/Custom/Transmogrification/TransmogrificationItem.cpp b/src/server/scripts/Custom/Transmogrification/TransmogrificationItem.cpp
new file mode 100644
index 0000000..5dcf7bf
--- /dev/null
+++ b/src/server/scripts/Custom/Transmogrification/TransmogrificationItem.cpp
@@ -0,0 +1,57 @@
+#pragma execution_character_set("utf-8")
+#include "../CommonFunc/CommonFunc.h"
+#include "../DataLoader/DataLoader.h"
+#include "../Requirement/Requirement.h"
+#include "../GCAddon/GCAddon.h"
+
+class TRANS_ITEM_NPC : public CreatureScript
+{
+public:
+	TRANS_ITEM_NPC() : CreatureScript("TRANS_ITEM_NPC") { }
+
+	bool OnGossipHello(Player* player, Creature* creature) override
+	{
+		player->PlayerTalkClass->ClearMenus();
+		
+		player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "ÊäÈëÎïÆ·±àºÅ", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF, "", 0, true);
+		player->SEND_GOSSIP_MENU(creature->GetEntry(), creature->GetGUID());
+		return true;
+	}
+
+	bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, const char* code) override
+	{
+		player->PlayerTalkClass->ClearMenus();
+
+		if (!*code)
+			return false;
+		
+		uint32 entry = (uint32)atoi(code);
+		//uint32 entry = inputEntry + 5000000;
+
+		ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(entry);
+		if (!pProto || entry >56806)
+		{
+			player->GetSession()->SendNotification("¸ÃÎïÆ·²»´æÔÚ,ÇëÊäÈëÕýÈ·ÎïÆ·ID£¡");
+			return false;
+
+		}
+
+		if (pProto->Class != 4 && pProto->Class != 2)
+		{
+			player->GetSession()->SendNotification("¸ÃÎïÆ·²»ÄÜÓÃÓÚ»Ã»¯,ÇëÊäÈëÕýÈ·ÎïÆ·ID£¡");
+			return false;
+		}
+
+		player->trans_item = entry;
+		player->trans_reqId = sGCAddon->GetTransReqId(entry);
+
+		std::string notice = sReq->Notice(player, player->trans_reqId, "¹ºÂò»Ã»¯ÎïÆ·\n", sCF->GetItemLink(entry));
+		sCF->SendAcceptOrCancel(player, 999, notice);
+		return true;
+	}
+};
+
+void AddSC_TRANS_ITEM_NPC()
+{
+	new TRANS_ITEM_NPC();
+}
diff --git a/src/server/scripts/Custom/Transmogrification/Transmogrifier.cpp b/src/server/scripts/Custom/Transmogrification/Transmogrifier.cpp
new file mode 100644
index 0000000..10055da
--- /dev/null
+++ b/src/server/scripts/Custom/Transmogrification/Transmogrifier.cpp
@@ -0,0 +1,450 @@
+/*
+5.0
+Transmogrification 3.3.5a - Gossip menu
+By Rochet2
+
+ScriptName for NPC:
+Creature_Transmogrify
+
+TODO:
+Make DB saving even better (Deleting)? What about coding?
+
+Fix the cost formula
+-- Too much data handling, use default costs
+
+Are the qualities right?
+Blizzard might have changed the quality requirements.
+(TC handles it with stat checks)
+
+Cant transmogrify rediculus items // Foereaper: would be fun to stab people with a fish
+-- Cant think of any good way to handle this easily, could rip flagged items from cata DB
+*/
+
+#pragma execution_character_set("utf-8")
+#include "Transmogrification.h"
+#define sT  sTransmogrification
+#define GTS session->GetAcoreString // dropped translation support, no one using?
+
+class CS_Transmogrification : public CreatureScript
+{
+public:
+    CS_Transmogrification() : CreatureScript("Creature_Transmogrify") { }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        WorldSession* session = player->GetSession();
+        if (sT->GetEnableTransmogInfo())
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Misc_Book_11:30:30:-18:0|t ÇëÑ¡ÔñÐèÒª»Ã»¯µÄ²¿Î»", EQUIPMENT_SLOT_END + 9, 0);
+        for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+        {
+            if (const char* slotName = sT->GetSlotName(slot, session))
+            {
+                Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                uint32 entry = newItem ? sT->GetFakeEntry(newItem->GetGUID()) : 0;
+                std::string icon = entry ? sT->GetItemIcon(entry,30,30,-18,0) : sT->GetSlotIcon(slot, 30, 30, -18, 0);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, icon+std::string(slotName), EQUIPMENT_SLOT_END, slot);
+            }
+        }
+#ifdef PRESETS
+        if (sT->GetEnableSets())
+			player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/RAIDFRAME/UI-RAIDFRAME-MAINASSIST:30:30:-18:0|t »Ã»¯¹ÜÀí ", EQUIPMENT_SLOT_END + 4, 0);
+#endif
+		player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Enchant_Disenchant:30:30:-18:0|t Çå³ýËùÓÐ»Ã»¯Ð§¹û ", EQUIPMENT_SLOT_END + 2, 0, "ÄúÈ·¶¨ÒªÒÆ³ýËùÓÐ×°±¸µÄ»Ã»¯Ð§¹ûÃ´£¿ ", 0, false);
+		player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/PaperDollInfoFrame/UI-GearManager-Undo:30:30:-18:0|t Ë¢ÐÂ²Ëµ¥ ", EQUIPMENT_SLOT_END + 1, 0);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+        return true;
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        player->PlayerTalkClass->ClearMenus();
+        WorldSession* session = player->GetSession();
+        switch(sender)
+        {
+        case EQUIPMENT_SLOT_END: // Show items you can use
+            ShowTransmogItems(player, creature, action);
+            break;
+        case EQUIPMENT_SLOT_END+1: // Main menu
+            OnGossipHello(player, creature);
+            break;
+        case EQUIPMENT_SLOT_END+2: // Remove Transmogrifications
+            {
+                bool removed = false;
+                SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+                {
+                    if (Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                    {
+                        if (!sT->GetFakeEntry(newItem->GetGUID()))
+                            continue;
+                        sT->DeleteFakeEntry(player, slot, newItem, &trans);
+                        removed = true;
+                    }
+                }
+                if (removed)
+                {
+                    session->SendAreaTriggerMessage(GTS(LANG_ERR_UNTRANSMOG_OK));
+                    CharacterDatabase.CommitTransaction(trans);
+                }
+                else
+                    session->SendNotification(LANG_ERR_UNTRANSMOG_NO_TRANSMOGS);
+                OnGossipHello(player, creature);
+            } break;
+        case EQUIPMENT_SLOT_END+3: // Remove Transmogrification from single item
+            {
+                if (Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, action))
+                {
+                    if (sT->GetFakeEntry(newItem->GetGUID()))
+                    {
+                        sT->DeleteFakeEntry(player, action, newItem);
+                        session->SendAreaTriggerMessage(GTS(LANG_ERR_UNTRANSMOG_OK));
+                    }
+                    else
+                        session->SendNotification(LANG_ERR_UNTRANSMOG_NO_TRANSMOGS);
+                }
+                OnGossipSelect(player, creature, EQUIPMENT_SLOT_END, action);
+            } break;
+#ifdef PRESETS
+        case EQUIPMENT_SLOT_END+4: // Presets menu
+            {
+                if (!sT->GetEnableSets())
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+                if (sT->GetEnableSetInfo())
+					player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Misc_Book_11:30:30:-18:0|t °ÑÉíÉÏµÄ»Ã»¯Ð§¹û±£´æÎªÌ××° ", EQUIPMENT_SLOT_END + 10, 0);
+                for (Transmogrification::presetIdMap::const_iterator it = sT->presetByName[player->GetGUID()].begin(); it != sT->presetByName[player->GetGUID()].end(); ++it)
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Misc_Statue_02:30:30:-18:0|t"+it->second, EQUIPMENT_SLOT_END+6, it->first);
+
+                if (sT->presetByName[player->GetGUID()].size() < sT->GetMaxSets())
+					player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/GuildBankFrame/UI-GuildBankFrame-NewTab:30:30:-18:0|t ±£´æÌ××° ", EQUIPMENT_SLOT_END + 8, 0);
+				player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|t ·µ»Ø ", EQUIPMENT_SLOT_END + 1, 0);
+                player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+            } break;
+        case EQUIPMENT_SLOT_END+5: // Use preset
+            {
+                if (!sT->GetEnableSets())
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+                // action = presetID
+                for (Transmogrification::slotMap::const_iterator it = sT->presetById[player->GetGUID()][action].begin(); it != sT->presetById[player->GetGUID()][action].end(); ++it)
+                {
+                    if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, it->first))
+                        sT->PresetTransmog(player, item, it->second, it->first);
+                }
+                OnGossipSelect(player, creature, EQUIPMENT_SLOT_END+6, action);
+            } break;
+        case EQUIPMENT_SLOT_END+6: // view preset
+            {
+                if (!sT->GetEnableSets())
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+                // action = presetID
+                for (Transmogrification::slotMap::const_iterator it = sT->presetById[player->GetGUID()][action].begin(); it != sT->presetById[player->GetGUID()][action].end(); ++it)
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, sT->GetItemIcon(it->second, 30, 30, -18, 0)+sT->GetItemLink(it->second, session), sender, action);
+
+				player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Misc_Statue_02:30:30:-18:0|t Ê¹ÓÃÌ××° ", EQUIPMENT_SLOT_END + 5, action, "Ê¹ÓÃºó»áÈÃ×°±¸±äµÃ²»¿ÉÍË»Ø£¬²»¿É½»Ò×¡£\nÄúÈ·¶¨Òª¼ÌÐøÃ´£¿\n\n " + sT->presetByName[player->GetGUID()][action], 0, false);
+				player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/PaperDollInfoFrame/UI-GearManager-LeaveItem-Opaque:30:30:-18:0|t ÒÆ³ýÌ××° ", EQUIPMENT_SLOT_END + 7, action, "ÄãÈ·¶¨ÒªÉ¾³ýÒÑ¾­±£´æµÄ¡¾ " + sT->presetByName[player->GetGUID()][action] + " ¡¿Ì××°Ã´£¿ ", 0, false);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|t ·µ»Ø ", EQUIPMENT_SLOT_END+4, 0);
+                player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+            } break;
+        case EQUIPMENT_SLOT_END+7: // Delete preset
+            {
+                if (!sT->GetEnableSets())
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+                // action = presetID
+                CharacterDatabase.PExecute("DELETE FROM `custom_transmogrification_sets` WHERE Owner = %u AND PresetID = %u",  player->GetGUIDLow(), action);
+                sT->presetById[player->GetGUID()][action].clear();
+                sT->presetById[player->GetGUID()].erase(action);
+                sT->presetByName[player->GetGUID()].erase(action);
+
+                OnGossipSelect(player, creature, EQUIPMENT_SLOT_END+4, 0);
+            } break;
+        case EQUIPMENT_SLOT_END+8: // Save preset
+            {
+                if (!sT->GetEnableSets() || sT->presetByName[player->GetGUID()].size() >= sT->GetMaxSets())
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+                uint32 cost = 0;
+                bool canSave = false;
+                for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+                {
+                    if (!sT->GetSlotName(slot, session))
+                        continue;
+                    if (Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                    {
+                        uint32 entry = sT->GetFakeEntry(newItem->GetGUID());
+                        if (!entry)
+                            continue;
+                        const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+                        if (!temp)
+                            continue;
+                        if (!sT->SuitableForTransmogrification(player, temp)) // no need to check?
+                            continue;
+                        cost += sT->GetSpecialPrice(temp);
+                        canSave = true;
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, sT->GetItemIcon(entry, 30, 30, -18, 0)+sT->GetItemLink(entry, session), EQUIPMENT_SLOT_END+8, 0);
+                    }
+                }
+                if (canSave)
+					player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/GuildBankFrame/UI-GuildBankFrame-NewTab:30:30:-18:0|t ±£´æÌ××° ", 0, 0, "ÇëÄãÉèÖÃÒª±£´æµÄÌ××°µÄÃû×Ö ", cost*sT->GetSetCostModifier() + sT->GetSetCopperCost(), true);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/PaperDollInfoFrame/UI-GearManager-Undo:30:30:-18:0|t Ë¢ÐÂ²Ëµ¥ ", sender, action);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|t ·µ»Ø ", EQUIPMENT_SLOT_END+4, 0);
+                player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+            } break;
+        case EQUIPMENT_SLOT_END+10: // Set info
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|t ·µ»Ø ", EQUIPMENT_SLOT_END+4, 0);
+                player->SEND_GOSSIP_MENU(sT->GetSetNpcText(), creature->GetGUID());
+            } break;
+#endif
+        case EQUIPMENT_SLOT_END+9: // Transmog info
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|t ·µ»Ø ", EQUIPMENT_SLOT_END+1, 0);
+                player->SEND_GOSSIP_MENU(sT->GetTransmogNpcText(), creature->GetGUID());
+            } break;
+        default: // Transmogrify
+            {
+                if (!sender && !action)
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+                // sender = slot, action = display
+                TransmogTrinityStrings res = sT->Transmogrify(player, MAKE_NEW_GUID(action, 0, HIGHGUID_ITEM), sender);
+                if (res == LANG_ERR_TRANSMOG_OK)
+                    session->SendAreaTriggerMessage(GTS(LANG_ERR_TRANSMOG_OK));
+                else
+                    session->SendNotification(res);
+                // OnGossipSelect(player, creature, EQUIPMENT_SLOT_END, sender);
+                // ShowTransmogItems(player, creature, sender);
+                player->CLOSE_GOSSIP_MENU(); // Wait for SetMoney to get fixed, issue #10053
+            } break;
+        }
+        return true;
+    }
+
+#ifdef PRESETS
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, const char* code)
+    {
+        player->PlayerTalkClass->ClearMenus();
+        if (sender || action)
+            return true; // should never happen
+        if (!sT->GetEnableSets())
+        {
+            OnGossipHello(player, creature);
+            return true;
+        }
+        std::string name(code);
+        if (name.find('"') != std::string::npos || name.find('\\') != std::string::npos)
+            player->GetSession()->SendNotification(LANG_PRESET_ERR_INVALID_NAME);
+        else
+        {
+            for (uint8 presetID = 0; presetID < sT->GetMaxSets(); ++presetID) // should never reach over max
+            {
+                if (sT->presetByName[player->GetGUID()].find(presetID) != sT->presetByName[player->GetGUID()].end())
+                    continue; // Just remember never to use presetByName[pGUID][presetID] when finding etc!
+
+                int32 cost = 0;
+                std::map<uint8, uint32> items;
+                for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+                {
+                    if (!sT->GetSlotName(slot, player->GetSession()))
+                        continue;
+                    if (Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                    {
+                        uint32 entry = sT->GetFakeEntry(newItem->GetGUID());
+                        if (!entry)
+                            continue;
+                        const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+                        if (!temp)
+                            continue;
+                        if (!sT->SuitableForTransmogrification(player, temp))
+                            continue;
+                        cost += sT->GetSpecialPrice(temp);
+                        items[slot] = entry;
+                    }
+                }
+                if (items.empty())
+                    break; // no transmogrified items were found to be saved
+                cost *= sT->GetSetCostModifier();
+                cost += sT->GetSetCopperCost();
+                if (!player->HasEnoughMoney(cost))
+                {
+                    player->GetSession()->SendNotification(LANG_ERR_TRANSMOG_NOT_ENOUGH_MONEY);
+                    break;
+                }
+
+                std::ostringstream ss;
+                for (std::map<uint8, uint32>::iterator it = items.begin(); it != items.end(); ++it)
+                {
+                    ss << uint32(it->first) << ' ' << it->second << ' ';
+                    sT->presetById[player->GetGUID()][presetID][it->first] = it->second;
+                }
+                sT->presetByName[player->GetGUID()][presetID] = name; // Make sure code doesnt mess up SQL!
+                CharacterDatabase.PExecute("REPLACE INTO `custom_transmogrification_sets` (`Owner`, `PresetID`, `SetName`, `SetData`) VALUES (%u, %u, \"%s\", \"%s\")",  player->GetGUIDLow(), uint32(presetID), name.c_str(), ss.str().c_str());
+                if (cost)
+                    player->ModifyMoney(cost);
+                break;
+            }
+        }
+        //OnGossipSelect(player, creature, EQUIPMENT_SLOT_END+4, 0);
+        player->CLOSE_GOSSIP_MENU(); // Wait for SetMoney to get fixed, issue #10053
+        return true;
+    }
+#endif
+
+    void ShowTransmogItems(Player* player, Creature* creature, uint8 slot) // Only checks bags while can use an item from anywhere in inventory
+    {
+        WorldSession* session = player->GetSession();
+        Item* oldItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (oldItem)
+        {
+            uint32 limit = 0;
+            uint32 price = sT->GetSpecialPrice(oldItem->GetTemplate());
+            price *= sT->GetScaledCostModifier();
+            price += sT->GetCopperCost();
+            std::ostringstream ss;
+            ss << std::endl;
+            if (sT->GetRequireToken())
+                ss << std::endl << std::endl << sT->GetTokenAmount() << " x " << sT->GetItemLink(sT->GetTokenEntry(), session);
+
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+            {
+                if (limit > MAX_OPTIONS)
+                    break;
+                Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                if (!newItem)
+                    continue;
+                if (!sT->CanTransmogrifyItemWithItem(player, oldItem->GetTemplate(), newItem->GetTemplate()))
+                    continue;
+                if (sT->GetFakeEntry(oldItem->GetGUID()) == newItem->GetEntry())
+                    continue;
+                ++limit;
+				player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, sT->GetItemIcon(newItem->GetEntry(), 30, 30, -18, 0) + sT->GetItemLink(newItem, session), slot, newItem->GetGUIDLow(), "ÓÃÕâ¼þ×°±¸»Ã»¯ÒÔºó½«ºÍÄã°ó¶¨£¬½«²»ÄÜ½»Ò×£¡\nÄãÒª¼ÌÐøÂð£¿\n\n" + sT->GetItemIcon(newItem->GetEntry(), 40, 40, -15, -10) + sT->GetItemLink(newItem, session) + ss.str(), price, false);
+            }
+
+            for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+            {
+                Bag* bag = player->GetBagByPos(i);
+                if (!bag)
+                    continue;
+                for (uint32 j = 0; j < bag->GetBagSize(); ++j)
+                {
+                    if (limit > MAX_OPTIONS)
+                        break;
+                    Item* newItem = player->GetItemByPos(i, j);
+                    if (!newItem)
+                        continue;
+                    if (!sT->CanTransmogrifyItemWithItem(player, oldItem->GetTemplate(), newItem->GetTemplate()))
+                        continue;
+                    if (sT->GetFakeEntry(oldItem->GetGUID()) == newItem->GetEntry())
+                        continue;
+                    ++limit;
+					player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, sT->GetItemIcon(newItem->GetEntry(), 30, 30, -18, 0) + sT->GetItemLink(newItem, session), slot, newItem->GetGUIDLow(), "ÓÃÕâ¼þ×°±¸»Ã»¯ÒÔºó½«ºÍÄã°ó¶¨£¬½«²»ÄÜ½»Ò×£¡\nÄãÒª¼ÌÐøÂð£¿\n\n" + sT->GetItemIcon(newItem->GetEntry(), 40, 40, -15, -10) + sT->GetItemLink(newItem, session) + ss.str(), price, false);
+                }
+            }
+        }
+
+		player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Enchant_Disenchant:30:30:-18:0|t ÒÆ³ý»Ã»¯Ð§¹û ", EQUIPMENT_SLOT_END + 3, slot, "ÄãÈ·¶¨ÒªÒÆ³ýÕâ¸ö²¿Î»µÄ»Ã»¯Ð§¹ûÃ´£¿ ", 0, false);
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/PaperDollInfoFrame/UI-GearManager-Undo:30:30:-18:0|t Ë¢ÐÂ²Ëµ¥ ", EQUIPMENT_SLOT_END, slot);
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|t ·µ»Ø ", EQUIPMENT_SLOT_END+1, 0);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+    }
+};
+
+class PS_Transmogrification : public PlayerScript
+{
+public:
+    PS_Transmogrification() : PlayerScript("Player_Transmogrify") { }
+
+    void OnLogin(Player* player)
+    {
+        uint64 playerGUID = player->GetGUID();
+        sT->entryMap.erase(playerGUID);
+        QueryResult result = CharacterDatabase.PQuery("SELECT GUID, FakeEntry FROM custom_transmogrification WHERE Owner = %u", player->GetGUIDLow());
+        if (result)
+        {
+            do
+            {
+                uint64 itemGUID = MAKE_NEW_GUID((*result)[0].GetUInt32(), 0, HIGHGUID_ITEM);
+                uint32 fakeEntry = (*result)[1].GetUInt32();
+                if (sObjectMgr->GetItemTemplate(fakeEntry))
+                {
+                    sT->dataMap[itemGUID] = playerGUID;
+                    sT->entryMap[playerGUID][itemGUID] = fakeEntry;
+                }
+                else
+                {
+                    //TC_LOG_ERROR->outError(LOG_FILTER_SQL, "Item entry (Entry: %u, itemGUID: %u, playerGUID: %u) does not exist, ignoring.", fakeEntry, GUID_LOPART(itemGUID), player->GetGUIDLow());
+                    // CharacterDatabase.PExecute("DELETE FROM custom_transmogrification WHERE FakeEntry = %u", fakeEntry);
+                }
+            } while (result->NextRow());
+
+            for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+            {
+                if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                    player->SetVisibleItemSlot(slot, item);
+            }
+        }
+
+#ifdef PRESETS
+        if (sT->GetEnableSets())
+            sT->LoadPlayerSets(playerGUID);
+#endif
+    }
+
+    void OnLogout(Player* player)
+    {
+        uint32 pGUID = player->GetGUID();
+        for (Transmogrification::transmogData::const_iterator it = sT->entryMap[pGUID].begin(); it != sT->entryMap[pGUID].end(); ++it)
+            sT->dataMap.erase(it->first);
+        sT->entryMap.erase(pGUID);
+
+#ifdef PRESETS
+        if (sT->GetEnableSets())
+            sT->UnloadPlayerSets(pGUID);
+#endif
+    }
+};
+
+class WS_Transmogrification : public WorldScript
+{
+public:
+    WS_Transmogrification() : WorldScript("WS_Transmogrification") { }
+
+    void OnAfterConfigLoad(bool reload)
+    {
+        sT->LoadConfig(reload);
+    }
+
+    void OnStartup()
+    {
+        sT->LoadConfig(false);
+        //TC_LOG_ERROR->outInfo(LOG_FILTER_SERVER_LOADING, "Deleting non-existing transmogrification entries...");
+        CharacterDatabase.Execute("DELETE FROM custom_transmogrification WHERE NOT EXISTS (SELECT 1 FROM item_instance WHERE item_instance.guid = custom_transmogrification.GUID)");
+
+#ifdef PRESETS
+        // Clean even if disabled
+        // Dont delete even if player has more presets than should
+        CharacterDatabase.Execute("DELETE FROM `custom_transmogrification_sets` WHERE NOT EXISTS(SELECT 1 FROM characters WHERE characters.guid = custom_transmogrification_sets.Owner)");
+#endif
+    }
+};
+
+void AddSC_CPWS_Transmogrification()
+{
+    new CS_Transmogrification();
+    new PS_Transmogrification();
+    new WS_Transmogrification();
+}
diff --git a/src/server/scripts/Custom/Trigger/Trigger.cpp b/src/server/scripts/Custom/Trigger/Trigger.cpp
new file mode 100644
index 0000000..5be5f92
--- /dev/null
+++ b/src/server/scripts/Custom/Trigger/Trigger.cpp
@@ -0,0 +1,134 @@
+#pragma execution_character_set("utf-8")
+#include "Trigger.h"
+#include "../CustomEvent/Event.h"
+
+std::vector<TriggerTemplate> TriggerVec;
+
+void Trigger::Load()
+{
+	TriggerVec.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÉúÎïGUID,ÀàÐÍ,·¶Î§¾àÀë,ÁªÃË´«ËÍ×ø±êID,²¿Âä´«ËÍ×ø±êID,ÁªÃË¹â»·ID,²¿Âä¹â»·ID,ÌáÊ¾ÄÚÈÝ,ÌáÊ¾ÀàÐÍ FROM _×Ô¶¨ÒåAI_´¥·¢Æ÷" :
+		"SELECT guid,type,distance,A_PosId,H_PosId,A_AuraId,H_AuraId,notice,noticeType FROM _trigger");
+	if (!result) return;
+	do
+	{
+		Field* fields = result->Fetch();
+		TriggerTemplate Temp;
+		Temp.guid		= fields[0].GetUInt32();
+		Temp.type		= fields[1].GetUInt32();
+		Temp.distance	= fields[2].GetFloat();
+		Temp.A_PosId	= fields[3].GetUInt32();
+		Temp.H_PosId	= fields[4].GetUInt32();
+		Temp.A_AuraId	= fields[5].GetUInt32();
+		Temp.H_AuraId	= fields[6].GetUInt32();
+		Temp.notice		= fields[7].GetString();
+		Temp.noticeType = fields[8].GetUInt32();
+		TriggerVec.push_back(Temp);
+	} while (result->NextRow());
+}
+
+
+void Trigger::GetParam(Player* player, uint32 guid, uint32 &type, uint32 &distance, uint32 &posId, uint32 &auraId, std::string &notice, uint32 &noticeType)
+{
+	for (std::vector<TriggerTemplate>::iterator iter = TriggerVec.begin(); iter != TriggerVec.end(); ++iter)
+	{
+		if (guid == iter->guid)
+		{
+			type = iter->type;
+			distance = iter->distance;
+			player->GetTeamId() == TEAM_ALLIANCE ? posId = iter->A_PosId : posId = iter->H_PosId;
+			player->GetTeamId() == TEAM_ALLIANCE ? auraId = iter->A_AuraId : auraId = iter->H_AuraId;
+
+			//sEvent->GetTeam(player) == C_TEAM_DEFENSE ? posId = iter->A_PosId : posId = iter->H_PosId;
+			//sEvent->GetTeam(player) == C_TEAM_OFFENSE ? auraId = iter->A_AuraId : auraId = iter->H_AuraId;
+
+			notice = iter->notice;
+			noticeType = iter->noticeType;
+			break;
+		}
+	}
+}
+
+void Trigger::Tele(Player* player, uint32 posId)
+{
+	std::unordered_map<uint32, PosTemplate>::iterator it = PosMap.find(posId);
+
+	if (it != PosMap.end())
+		player->TeleportTo(it->second.map, it->second.x, it->second.y, it->second.z, it->second.o);
+
+}
+
+class TriggerScript : public CreatureScript
+{
+public:
+	TriggerScript() : CreatureScript("TriggerScript") { }
+	struct TriggerScriptAI : public ScriptedAI
+	{
+		TriggerScriptAI(Creature* creature) : ScriptedAI(creature), Summons(me){}
+
+		SummonList Summons;
+
+		uint32 type = 0;//1-´«ËÍ 2-ÏÂÂí 3-aura
+		uint32 distance = 0;
+		uint32 posId = 0;
+		uint32 auraId = 0;
+		std::string notice = "";
+		uint32 noticeType = 0;
+
+		void MoveInLineOfSight(Unit* who)
+		{
+			Player* player = who->ToPlayer();
+
+			if (!player)
+				return;
+
+			sTrigger->GetParam(player, me->GetGUIDLow(), type, distance, posId, auraId,notice,noticeType);
+
+			if (!me->IsWithinDistInMap(player, distance))
+				return;
+
+			switch (type)
+			{
+			case 1:
+				if (posId != 0)
+				{
+					sTrigger->Tele(player, posId);
+					if (!notice.empty())
+						noticeType == 0 ? player->GetSession()->SendAreaTriggerMessage(notice.c_str()) : player->GetSession()->SendNotification(notice.c_str());
+				}			
+				break;
+			case 2:
+				if (player->IsInWorld() && player->IsMounted())
+				{
+					player->Dismount();
+					player->RemoveAurasByType(SPELL_AURA_MOUNTED);
+					if (!notice.empty())
+						noticeType == 0 ? player->GetSession()->SendAreaTriggerMessage(notice.c_str()) : player->GetSession()->SendNotification(notice.c_str());
+				}
+				break;
+			case 3:
+				if (auraId != 0 && !player->HasAura(auraId))
+				{
+					player->AddAura(auraId, player);
+					if (!notice.empty())
+						noticeType == 0 ? player->GetSession()->SendAreaTriggerMessage(notice.c_str()) : player->GetSession()->SendNotification(notice.c_str());
+				}
+				break;
+			default:
+				break;
+			}
+
+		}
+	};
+
+	CreatureAI* GetAI(Creature* creature) const override
+	{
+		return new TriggerScriptAI(creature);
+	}
+};
+
+void AddSC_TriggerScript()
+{
+	new TriggerScript();
+}
diff --git a/src/server/scripts/Custom/Trigger/Trigger.h b/src/server/scripts/Custom/Trigger/Trigger.h
new file mode 100644
index 0000000..410f59f
--- /dev/null
+++ b/src/server/scripts/Custom/Trigger/Trigger.h
@@ -0,0 +1,28 @@
+struct TriggerTemplate
+{
+	uint32 guid;
+	uint32 type;//1-´«ËÍ 2-ÏÂÂí 3-aura
+	uint32 distance;
+	uint32 A_PosId;
+	uint32 H_PosId;
+	uint32 A_AuraId;
+	uint32 H_AuraId;
+	std::string notice;
+	uint32 noticeType;
+};
+extern std::vector<TriggerTemplate> TriggerVec;
+
+class Trigger
+{
+public:
+	static Trigger* instance()
+	{
+		static Trigger instance;
+		return &instance;
+	}
+
+	void Load();
+	void GetParam(Player* player,uint32 guid, uint32 &type, uint32 &distance, uint32 &posId, uint32 &auraId, std::string &notice, uint32 &noticeType);
+	void Tele(Player* player, uint32 posId);
+};
+#define sTrigger Trigger::instance()
diff --git a/src/server/scripts/Custom/UI/BlackMarket/BlackMarket.cpp b/src/server/scripts/Custom/UI/BlackMarket/BlackMarket.cpp
new file mode 100644
index 0000000..65ec107
--- /dev/null
+++ b/src/server/scripts/Custom/UI/BlackMarket/BlackMarket.cpp
@@ -0,0 +1,106 @@
+#pragma execution_character_set("utf-8")
+#include "BlackMarket.h"
+#include "../../GCAddon/GCAddon.h"
+#include "../../Requirement/Requirement.h"
+
+std::vector<BlackMarketTemplate> BlackMarketVec;
+
+void BlackMarket::Load()
+{
+	BlackMarketVec.clear();
+	
+	if (QueryResult result = WorldDatabase.PQuery("SELECT id,itmemId,itemCount,reqId FROM _ui_blackmarket"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+	
+			BlackMarketTemplate Temp;
+			Temp.id			= fields[0].GetUInt32();
+			Temp.itemId		= fields[1].GetUInt32();
+			Temp.itemCount	= fields[2].GetUInt32();
+			Temp.reqId		= fields[3].GetUInt32();
+			Temp.enable		= true;
+			BlackMarketVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+}
+
+void BlackMarket::Start()
+{
+	Load();
+
+	SessionMap const& smap = sWorld->GetAllSessions();
+	for (SessionMap::const_iterator itr = smap.begin(); itr != smap.end(); ++itr)
+		if (Player* pl = itr->second->GetPlayer())
+			SendData(pl);
+
+	sWorld->SendScreenMessage("[ºÚÊÐ]ÒÑ¾­¿ª·Å£¡");
+}
+
+void BlackMarket::Stop()
+{
+	for (auto iter = BlackMarketVec.begin(); iter != BlackMarketVec.end(); iter++)
+		iter->enable = false;
+
+	SessionMap const& smap = sWorld->GetAllSessions();
+	for (SessionMap::const_iterator itr = smap.begin(); itr != smap.end(); ++itr)
+		if (Player* pl = itr->second->GetPlayer())
+			SendData(pl);
+
+	sWorld->SendScreenMessage("[ºÚÊÐ]ÒÑ¾­¹Ø±Õ£¡");
+}
+
+void BlackMarket::SendData(Player* player)
+{
+	for (auto iter = BlackMarketVec.begin(); iter != BlackMarketVec.end(); iter++)
+		SendData(player, iter->id, iter->itemId, iter->itemCount, iter->reqId, iter->enable);
+}
+
+void BlackMarket::SendData(Player* player, uint32 id, uint32 itemId, uint32 itemCount, uint32 reqId, bool enable)
+{
+	if (ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(itemId))
+		player->GetSession()->SendPacket(&pProto->queryData);
+
+	std::ostringstream oss;
+	oss << id			<< " ";
+	oss << itemId		<< " ";
+	oss << itemCount	<< " ";
+	oss << reqId		<< " ";
+
+	if (enable)
+		oss << 1;
+	else
+		oss << 0;
+
+	sGCAddon->SendPacketTo(player, "GC_S_BLACKMARKET", oss.str());
+}
+
+void BlackMarket::Update(Player* player, uint32 id)
+{
+	for (auto iter = BlackMarketVec.begin(); iter != BlackMarketVec.end(); iter++)
+	{
+		if (iter->id == id)
+		{
+			if (!sReq->Check(player, iter->reqId))
+				return;
+
+			if (!iter->enable)
+			{
+				ChatHandler(player->GetSession()).PSendSysMessage("Äã²»ÄÜ¹ºÂò´ËÎïÆ·£¡");
+				return;
+			}
+
+			player->AddItem(iter->itemId, iter->itemCount);
+
+			iter->enable = false;
+			
+			SessionMap const& smap = sWorld->GetAllSessions();
+			for (SessionMap::const_iterator itr = smap.begin(); itr != smap.end(); ++itr)
+				if (Player* pl = itr->second->GetPlayer())
+					SendData(pl, iter->id, iter->itemId, iter->itemCount, iter->reqId, iter->enable);
+
+			break;
+		}
+	}
+}
diff --git a/src/server/scripts/Custom/UI/BlackMarket/BlackMarket.h b/src/server/scripts/Custom/UI/BlackMarket/BlackMarket.h
new file mode 100644
index 0000000..2aa869c
--- /dev/null
+++ b/src/server/scripts/Custom/UI/BlackMarket/BlackMarket.h
@@ -0,0 +1,29 @@
+struct BlackMarketTemplate
+{
+	uint32 id;
+	uint32 itemId;
+	uint32 itemCount;
+	uint32 reqId;
+	bool enable;
+};
+
+extern std::vector<BlackMarketTemplate> BlackMarketVec;
+
+class BlackMarket
+{
+public:
+	static BlackMarket* instance()
+	{
+		static BlackMarket instance;
+		return &instance;
+	}
+	void Load();
+	void SendData(Player* player);
+	
+	void Start();
+	void Stop();
+
+	void Update(Player* player, uint32 id);
+	void SendData(Player* player, uint32 id, uint32 itemId, uint32 itemCount, uint32 reqId, bool enable);
+};
+#define sBlackMarket BlackMarket::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/UI/Rune/Rune.cpp b/src/server/scripts/Custom/UI/Rune/Rune.cpp
new file mode 100644
index 0000000..e7c2f24
--- /dev/null
+++ b/src/server/scripts/Custom/UI/Rune/Rune.cpp
@@ -0,0 +1,154 @@
+#include "Rune.h"
+#include "../../GCAddon/GCAddon.h"
+#include "../../Requirement/Requirement.h"
+
+std::vector<RuneTemplate> RuneVec;
+std::unordered_map<uint32/*page*/, RuneCategoryTemplate> RuneCategoryMap;
+
+void Rune::Load()
+{
+	RuneVec.clear();
+
+	if (QueryResult result = WorldDatabase.PQuery("SELECT page,id,spellid,reqId,classIndex FROM _ui_rune"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			
+			RuneTemplate Temp;
+			Temp.page		= fields[0].GetUInt32();
+			Temp.id			= fields[1].GetUInt32();
+			Temp.spellid	= fields[2].GetUInt32();
+			Temp.reqId		= fields[3].GetUInt32();
+			Temp.classIndex = fields[4].GetUInt32();
+			RuneVec.push_back(Temp);
+		} while (result->NextRow());
+	}
+
+	RuneCategoryMap.clear();
+
+	if (QueryResult result = WorldDatabase.PQuery("SELECT page, title,tip,icon FROM _ui_rune_category"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 page = fields[0].GetUInt32();
+			RuneCategoryTemplate Temp;
+			Temp.title	= fields[1].GetString();
+			Temp.tip	= fields[2].GetString();
+			Temp.icon	= fields[3].GetString();
+			RuneCategoryMap.insert(std::make_pair(page, Temp));
+		} while (result->NextRow());
+	}
+}
+
+void Rune::SendData(Player* player)
+{
+	for (auto iter = RuneVec.begin(); iter != RuneVec.end(); iter++)
+	{
+		if (iter->classIndex == 0)
+		{
+			std::ostringstream oss;
+			oss << iter->page << " ";
+			oss << iter->id << " ";
+			oss << iter->spellid << " ";
+			oss << iter->reqId << " ";
+
+			if (player->HasSpell(iter->spellid))
+				oss << 1;
+			else
+				oss << 0;
+
+			sGCAddon->SendPacketTo(player, "GC_S_RUNE", oss.str());
+		}
+	}
+
+	for (auto iter = RuneVec.begin(); iter != RuneVec.end(); iter++)
+	{
+		if (iter->classIndex == player->getClass())
+		{
+			std::ostringstream oss;
+			oss << iter->page << " ";
+			oss << iter->id << " ";
+			oss << iter->spellid << " ";
+			oss << iter->reqId << " ";
+
+			if (player->HasSpell(iter->spellid))
+				oss << 1;
+			else
+				oss << 0;
+
+			sGCAddon->SendPacketTo(player, "GC_S_RUNE", oss.str());
+		}
+	}
+
+	for (auto iter = RuneCategoryMap.begin(); iter != RuneCategoryMap.end(); iter++)
+	{
+		std::ostringstream oss;
+		oss << iter->first << " ";
+		oss << iter->second.title << " ";
+		oss << iter->second.tip << " ";
+		oss << iter->second.icon;
+		sGCAddon->SendPacketTo(player, "GC_S_RUNE_CATEGORY", oss.str());
+	}
+}
+
+void Rune::Update(Player* player, uint32 page, uint32 id)
+{
+	uint32 reqid = 0;
+	uint32 spell = 0;
+
+	for (auto iter = RuneVec.begin(); iter != RuneVec.end(); iter++)
+	{
+		if (iter->page == page && iter->id == id && iter->classIndex == 0)
+		{
+			reqid = iter->reqId;
+			spell = iter->spellid;
+			break;
+		}
+	}
+
+	for (auto iter = RuneVec.begin(); iter != RuneVec.end(); iter++)
+	{
+		if (iter->page == page && iter->id == id && iter->classIndex == player->getClass())
+		{
+			reqid = iter->reqId;
+			spell = iter->spellid;
+			break;
+		}
+	}
+
+	if (spell == 0)
+		return;
+
+	if(sReq->Check(player, reqid))
+	{
+		std::ostringstream oss;
+		oss << page << " ";
+		oss << id << " ";
+		oss << spell << " ";
+		oss << reqid;
+		sGCAddon->SendPacketTo(player, "GC_S_RUNE_UPDATE", oss.str());
+		player->learnSpell(spell);
+		sReq->Des(player, reqid);
+	}	
+}
+
+void Rune::Add(Player* player, uint32 spellId)
+{
+	for (auto iter = RuneVec.begin(); iter != RuneVec.end(); iter++)
+	{
+		if (iter->spellid == spellId)
+		{
+			std::ostringstream oss;
+			oss << iter->page << " ";
+			oss << iter->id << " ";
+			oss << iter->spellid << " ";
+			oss << iter->reqId;
+			sGCAddon->SendPacketTo(player, "GC_S_RUNE_UPDATE", oss.str());
+
+			if (!player->HasSpell(spellId))
+				player->learnSpell(spellId);
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/UI/Rune/Rune.h b/src/server/scripts/Custom/UI/Rune/Rune.h
new file mode 100644
index 0000000..be69391
--- /dev/null
+++ b/src/server/scripts/Custom/UI/Rune/Rune.h
@@ -0,0 +1,37 @@
+struct RuneTemplate
+{
+	uint32 page;
+	uint32 id;
+	uint32 spellid;
+	uint32 reqId;
+	uint32 classIndex;
+};
+
+extern std::vector<RuneTemplate> RuneVec;
+
+struct RuneCategoryTemplate
+{
+	std::string title;
+	std::string tip;
+	std::string icon;
+};
+
+extern std::unordered_map<uint32/*page*/, RuneCategoryTemplate> RuneCategoryMap;
+
+class Rune
+{
+public:
+	static Rune* instance()
+	{
+		static Rune instance;
+		return &instance;
+	}
+
+	void Load();
+	void SendData(Player* player);
+	void Update(Player* player, uint32 page, uint32 id);
+	void Add(Player* player, uint32 spellId);
+private:
+
+};
+#define sRune Rune::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/UnitMod/CharMod/CharMod.cpp b/src/server/scripts/Custom/UnitMod/CharMod/CharMod.cpp
new file mode 100644
index 0000000..06f6b3f
--- /dev/null
+++ b/src/server/scripts/Custom/UnitMod/CharMod/CharMod.cpp
@@ -0,0 +1,499 @@
+#pragma execution_character_set("utf-8")
+#include "CharMod.h"
+#include "../../FunctionCollection/FunctionCollection.h"
+#include "../../Switch/Switch.h"
+#include "../../Requirement/Requirement.h"
+
+std::vector<CharStatTemplate> CharStatVec;
+std::vector<StaticStatTemplate> StaticStatVec;
+std::vector<uint32> AltClassSpellVec;
+
+void CharMod::Load()
+{
+	CharStatVec.clear();
+	QueryResult result = WorldDatabase.PQuery(
+		//		0			1			2			3			4			5			6				7			8
+		"SELECT Ö°ÒµË÷Òý,ÎïÀíÉËº¦PVP±¶ÂÊ,·¨ÊõÉËº¦PVP±¶ÂÊ,ÖÎÁÆÐ§¹ûPVP±¶ÂÊ,»¤¼×ÖµÉÏÏÞ,¶ãÉÁ°Ù·Ö±ÈÉÏÏÞ,ÕÐ¼Ü°Ù·Ö±ÈÉÏÏÞ,¸ñµ²°Ù·Ö±ÈÉÏÏÞ,±¬»÷°Ù·Ö±ÈÉÏÏÞ,"
+		//		9			10				11			12				13				14				15				16			17				18				19				20			21
+		"¶îÍâ¾«Éñ×ª·¨ÉË, ¶îÍâ¾«Éñ×ªÖÎÁÆ, ¶îÍâÖÇÁ¦×ª·¨ÉË, ¶îÍâÖÇÁ¦×ªÖÎÁÆ, ¶îÍâÁ¦Á¿×ª¹¥Ç¿, ¶îÍâÃô½Ý×ª¹¥Ç¿, ¶îÍâ¾«Éñ×ª¹¥Ç¿, ¶îÍâÖÇÁ¦×ª¹¥Ç¿, ¶îÍâÁ¦Á¿×ª·¨ÉË, ¶îÍâÃô½Ý×ª·¨ÉË, ¶îÍâÁ¦Á¿×ªÖÎÁÆ, ¶îÍâÃô½Ý×ªÖÎÁÆ,¼õÉË°Ù·Ö±È,"
+		//		22			23				24				25		26			27		28			29				30
+		"ÎïÀíÉËº¦PVE±¶ÂÊ,·¨ÊõÉËº¦PVE±¶ÂÊ,ÖÎÁÆÐ§¹ûPVE±¶ÂÊ,¼±ËÙµÈ¼¶ÉÏÏÞ,ÉúÃüÖµÉÏÏÞ,·¨Á¦ÖµÉÏÏÞ,ÎïÀíÉËº¦ÉÏÏÞ,·¨ÊõÉËº¦ÉÏÏÞ,ÖÎÁÆÐ§¹ûÉÏÏÞ FROM _ÊôÐÔµ÷Õû_Ö°Òµ");
+
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			CharStatTemplate CharStatTemp;
+			CharStatTemp.classIndex		= fields[0].GetUInt8();
+			CharStatTemp.meleePVPDmgMod	= fields[1].GetFloat();
+			CharStatTemp.spellPVPDmgMod	= fields[2].GetFloat();
+			CharStatTemp.healPVPMod		= fields[3].GetFloat();
+			CharStatTemp.armorLimit		= fields[4].GetFloat();
+			CharStatTemp.dodgeLimit		= fields[5].GetFloat();
+			CharStatTemp.parryLimit		= fields[6].GetFloat();
+			CharStatTemp.blockLimit		= fields[7].GetFloat();
+			CharStatTemp.critLimit		= fields[8].GetFloat();
+			CharStatTemp.spirit2SP		= fields[9].GetFloat();
+			CharStatTemp.spirit2Heal	= fields[10].GetFloat();
+			CharStatTemp.intellect2SP	= fields[11].GetFloat();
+			CharStatTemp.intellect2Heal = fields[12].GetFloat();
+			CharStatTemp.strength2AP	= fields[13].GetFloat();
+			CharStatTemp.agility2AP		= fields[14].GetFloat();
+
+			CharStatTemp.spirit2AP		= fields[15].GetFloat();
+			CharStatTemp.intellect2AP	= fields[16].GetFloat();
+			CharStatTemp.strength2SP	= fields[17].GetFloat();
+			CharStatTemp.agility2SP		= fields[18].GetFloat();
+			CharStatTemp.strength2Heal	= fields[19].GetFloat();
+			CharStatTemp.agility2Heal	= fields[20].GetFloat();
+
+			CharStatTemp.reduceDmgMod	= fields[21].GetFloat();
+
+			CharStatTemp.meleePVEDmgMod = fields[22].GetFloat();
+			CharStatTemp.spellPVEDmgMod = fields[23].GetFloat();
+			CharStatTemp.healPVEMod		= fields[24].GetFloat();
+
+			CharStatTemp.hasteLimit		= fields[25].GetUInt32();
+			CharStatTemp.hpLimit		= fields[26].GetUInt32();
+			CharStatTemp.manaLimit		= fields[27].GetUInt32();
+			CharStatTemp.meleeDmgLimit	= fields[28].GetUInt32();
+			CharStatTemp.spellDmgLimit	= fields[29].GetUInt32();
+			CharStatTemp.healLimit		= fields[30].GetUInt32();
+
+			CharStatVec.push_back(CharStatTemp);
+		} while (result->NextRow());
+	}
+
+	StaticStatVec.clear();
+
+	AltClassSpellVec.clear();
+	if (result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ¼¼ÄÜID FROM __×ªÖ°±£Áô¼¼ÄÜ" :
+		"SELECT spellid FROM _alt_class_spells"))
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			AltClassSpellVec.push_back(fields[0].GetUInt32());
+		} while (result->NextRow());
+	}
+	
+
+	SessionMap const& smap = sWorld->GetAllSessions();
+	for (SessionMap::const_iterator i = smap.begin(); i != smap.end(); ++i)
+		if (Player* player = i->second->GetPlayer())
+		{
+			ModLimit(player);
+			ModStats(player);
+		}	
+}
+
+float CharMod::GetLimit(StatLimitTypes type, uint8 classIndex)
+{
+	uint32 len = CharStatVec.size();
+	for (size_t i = 0; i < len; i++)
+	{
+		if (classIndex == CharStatVec[i].classIndex)
+		{
+			switch (type)
+			{
+			case LIMIT_ARMOR:
+				return CharStatVec[i].armorLimit;
+			case LIMIT_DODGE:
+				return CharStatVec[i].dodgeLimit;
+			case LIMIT_PARRY:
+				return CharStatVec[i].parryLimit;
+			case LIMIT_BLOCK:
+				return CharStatVec[i].blockLimit;
+			case LIMIT_CRIT:
+				return CharStatVec[i].critLimit;
+			case LIMIT_HASTE:
+				return CharStatVec[i].hasteLimit;
+			case LIMIT_HP:
+				return CharStatVec[i].hpLimit;
+			case LIMIT_MANA:
+				return CharStatVec[i].manaLimit;
+			case LIMIT_MELEEDMG:
+				return CharStatVec[i].meleeDmgLimit;
+			case LIMIT_SPELLDMG:
+				return CharStatVec[i].spellDmgLimit;
+			case LIMIT_HEAL:
+				return CharStatVec[i].healLimit;
+			}
+		}
+	}
+	return 1000000.0f;
+}
+
+float CharMod::GetMod(StatModTypes type, uint8 classIndex)
+{
+	uint32 len = CharStatVec.size();
+	for (size_t i = 0; i < len; i++)
+	{
+		if (classIndex == CharStatVec[i].classIndex)
+		{
+			switch (type)
+			{
+			case CHAR_MOD_PVP_MELEE_DMG:
+				return CharStatVec[i].meleePVPDmgMod;
+			case CHAR_MOD_PVP_SPELL_DMG:
+				return CharStatVec[i].spellPVPDmgMod;
+			case CHAR_MOD_PVP_HEAL:
+				return CharStatVec[i].healPVPMod;
+			case CHAR_MOD_PVE_MELEE_DMG:
+				return CharStatVec[i].meleePVEDmgMod;
+			case CHAR_MOD_PVE_SPELL_DMG:
+				return CharStatVec[i].spellPVEDmgMod;
+			case CHAR_MOD_PVE_HEAL:
+				return CharStatVec[i].healPVEMod;
+			case CHAR_MOD_REDUCE_DMG:
+				return CharStatVec[i].reduceDmgMod;
+			}
+		}
+	}
+	return 1.0f;
+}
+
+float CharMod::GetValue(SwitchStatTypes type, uint8 classIndex)
+{
+	uint32 len = CharStatVec.size();
+	for (size_t i = 0; i < len; i++)
+	{
+		if (classIndex == CharStatVec[i].classIndex)
+		{
+			switch (type)
+			{
+			case SWITCH_SPIRIT2SP:
+				return CharStatVec[i].spirit2SP;
+			case SWITCH_SPIRIT2HEAL:
+				return CharStatVec[i].spirit2Heal;
+			case SWITCH_INTELLECT2SP:
+				return CharStatVec[i].intellect2SP;
+			case SWITCH_INTELLECT2HEAL:
+				return CharStatVec[i].intellect2Heal;
+			case SWITCH_STRENGTH2AP:
+				return CharStatVec[i].strength2AP;
+			case SWITCH_AGILITY2AP:
+				return CharStatVec[i].agility2AP;
+
+			case SWITCH_SPIRIT2AP:
+				return  CharStatVec[i].spirit2AP;
+			case SWITCH_INTELLECT2AP:
+				return  CharStatVec[i].intellect2AP;
+			case SWITCH_STRENGTH2SP:
+				return  CharStatVec[i].strength2SP;
+			case SWITCH_AGILITY2SP:
+				return  CharStatVec[i].agility2SP;
+			case SWITCH_STRENGTH2HEAL:
+				return  CharStatVec[i].strength2Heal;
+			case SWITCH_AGILITY2HEAL:
+				return  CharStatVec[i].agility2Heal;
+
+			}
+		}
+	}
+	return 0.0f;
+}
+
+int32 CharMod::GetExtraSP(Player* player)
+{
+	float intellectValue = player->GetTotalStatValue(Stats(STAT_INTELLECT));
+	float spiritValue = player->GetTotalStatValue(Stats(STAT_SPIRIT));
+	float strengthValue = player->GetTotalStatValue(Stats(STAT_STRENGTH));
+	float agilityValue = player->GetTotalStatValue(Stats(STAT_AGILITY));
+
+	return int32(player->p_sp + intellectValue * player->p_intellect2SP + spiritValue * player->p_spirit2SP + strengthValue * player->p_strength2SP + agilityValue * player->p_agility2SP);
+}
+int32 CharMod::GetExtraAP(Player* player)
+{
+	float strengthValue = player->GetTotalStatValue(Stats(STAT_STRENGTH));
+	float agilityValue = player->GetTotalStatValue(Stats(STAT_AGILITY));
+	float intellectValue = player->GetTotalStatValue(Stats(STAT_INTELLECT));
+	float spiritValue = player->GetTotalStatValue(Stats(STAT_SPIRIT));
+
+	return int32(player->p_ap + strengthValue * player->p_strength2AP + agilityValue * player->p_agility2AP + intellectValue * player->p_intellect2AP + spiritValue * player->p_spirit2AP);
+}
+
+int32 CharMod::GetExtraHeal(Player* player)
+{
+	float intellectValue = player->GetTotalStatValue(Stats(STAT_INTELLECT));
+	float spiritValue = player->GetTotalStatValue(Stats(STAT_SPIRIT));
+	float strengthValue = player->GetTotalStatValue(Stats(STAT_STRENGTH));
+	float agilityValue = player->GetTotalStatValue(Stats(STAT_AGILITY));
+
+	return int32(player->p_heal + intellectValue * player->p_intellect2Heal + spiritValue * player->p_spirit2Heal + strengthValue * player->p_strength2Heal + agilityValue * player->p_agility2Heal);
+}
+
+void CharMod::ModLimit(Player* player)
+{
+	player->p_intellect2SP = GetValue(SWITCH_INTELLECT2SP, player->getClass());
+	player->p_spirit2SP = GetValue(SWITCH_SPIRIT2SP, player->getClass());
+	player->p_intellect2Heal = GetValue(SWITCH_INTELLECT2HEAL, player->getClass());
+	player->p_spirit2Heal = GetValue(SWITCH_SPIRIT2HEAL, player->getClass());
+	player->p_strength2AP = GetValue(SWITCH_STRENGTH2AP, player->getClass());
+	player->p_agility2AP = GetValue(SWITCH_AGILITY2AP, player->getClass());
+
+
+	player->p_agility2SP = GetValue(SWITCH_AGILITY2SP, player->getClass());
+	player->p_strength2SP = GetValue(SWITCH_STRENGTH2SP, player->getClass());
+	player->p_intellect2AP = GetValue(SWITCH_INTELLECT2AP, player->getClass());
+	player->p_spirit2AP = GetValue(SWITCH_SPIRIT2AP, player->getClass());
+	player->p_agility2Heal = GetValue(SWITCH_AGILITY2HEAL, player->getClass());
+	player->p_strength2Heal = GetValue(SWITCH_STRENGTH2HEAL, player->getClass());
+
+	player->p_PVP_meleeDmgMod = GetMod(CHAR_MOD_PVP_MELEE_DMG, player->getClass());
+	player->p_PVP_spellDmgMod = GetMod(CHAR_MOD_PVP_SPELL_DMG, player->getClass());
+	player->p_PVP_healMod = GetMod(CHAR_MOD_PVP_HEAL, player->getClass());
+	player->p_PVE_meleeDmgMod = GetMod(CHAR_MOD_PVE_MELEE_DMG, player->getClass());
+	player->p_PVE_spellDmgMod = GetMod(CHAR_MOD_PVE_SPELL_DMG, player->getClass());
+	player->p_PVE_healMod = GetMod(CHAR_MOD_PVE_HEAL, player->getClass());
+	player->p_reduceDmgMod = GetMod(CHAR_MOD_REDUCE_DMG, player->getClass());
+
+	player->p_armorLimit = GetLimit(LIMIT_ARMOR, player->getClass());
+	player->p_dodgeLimit = GetLimit(LIMIT_DODGE, player->getClass());
+	player->p_parryLimit = GetLimit(LIMIT_PARRY, player->getClass());
+	player->p_blockLimit = GetLimit(LIMIT_BLOCK, player->getClass());
+	player->p_critLimit = GetLimit(LIMIT_CRIT, player->getClass());
+
+	player->p_hasteLimit = GetLimit(LIMIT_HASTE, player->getClass());
+	player->p_hpLimit = GetLimit(LIMIT_HP, player->getClass());
+	player->p_manaLimit = GetLimit(LIMIT_MANA, player->getClass());
+	player->p_meleeDmgLimit = GetLimit(LIMIT_MELEEDMG, player->getClass());
+	player->p_spellDmgLimit = GetLimit(LIMIT_SPELLDMG, player->getClass());
+	player->p_healLimit = GetLimit(LIMIT_HEAL, player->getClass());
+
+
+	player->UpdateAllStats();
+}
+void CharMod::ModStats(Player* player)
+{
+	bool exsit = false;
+
+	for (auto itr = StaticStatVec.begin(); itr != StaticStatVec.end(); itr++)
+	{
+		if (itr->map == player->GetMapId() && itr->vip == player->vipLevel)// && player->getClass() == itr->_class)
+		{
+			player->StaticStatsMap = itr->StaticStatsMap;
+			player->StaticCombatRatingMap = itr->StaticCombatRatingMap;
+			player->StaticHealth = itr->StaticHealth;
+			player->StaticSpellPower = itr->StaticSpellPower;
+			player->StaticHealPower = itr->StaticHealPower;
+			player->StaticRangeAttackPower = itr->StaticRangeAttackPower;
+			player->StaticAttackPower = itr->StaticAttackPower;
+			exsit = true;
+		}
+	}
+
+	if (!exsit)
+	{
+		player->StaticStatsMap.clear();
+		player->StaticCombatRatingMap.clear();
+		player->StaticHealth = 0;
+		player->StaticSpellPower = 0;
+		player->StaticHealPower = 0;
+		player->StaticRangeAttackPower = 0;
+		player->StaticAttackPower = 0;
+	}
+
+	player->UpdateAllStats();
+}
+
+
+bool CharMod::CheckFamily(Player* player, uint32 SpellFamily)
+{
+	switch (player->getClass())
+	{
+	case CLASS_WARRIOR:
+		return SpellFamily == SPELLFAMILY_WARRIOR;
+	case CLASS_PALADIN:
+		return SpellFamily == SPELLFAMILY_PALADIN;
+	case CLASS_HUNTER:
+		return SpellFamily == SPELLFAMILY_HUNTER;
+	case CLASS_ROGUE:
+		return SpellFamily == SPELLFAMILY_ROGUE;
+	case CLASS_PRIEST:
+		return SpellFamily == SPELLFAMILY_PRIEST;
+	case CLASS_DEATH_KNIGHT:
+		return SpellFamily == SPELLFAMILY_DEATHKNIGHT;
+	case CLASS_SHAMAN:
+		return SpellFamily == SPELLFAMILY_SHAMAN;
+	case CLASS_MAGE:
+		return SpellFamily == SPELLFAMILY_MAGE;
+	case CLASS_WARLOCK:
+		return SpellFamily == SPELLFAMILY_WARLOCK;
+	case CLASS_DRUID:
+		return SpellFamily == SPELLFAMILY_DRUID;
+	}
+
+	return false;
+}
+
+bool CharMod::CheckSkill(SpellInfo const* spellInfo)
+{
+	return
+		spellInfo->IsAbilityOfSkillType(SKILL_ALCHEMY) ||			//Á¶½ð
+		spellInfo->IsAbilityOfSkillType(SKILL_BLACKSMITHING) ||		//¶ÍÔì
+		spellInfo->IsAbilityOfSkillType(SKILL_COOKING) ||			//Åëâ¿
+		spellInfo->IsAbilityOfSkillType(SKILL_ENCHANTING) ||		//¸½Ä§
+		spellInfo->IsAbilityOfSkillType(SKILL_ENGINEERING) ||		//¹¤³Ì
+		spellInfo->IsAbilityOfSkillType(SKILL_FIRST_AID) ||			//¼±¾È
+		spellInfo->IsAbilityOfSkillType(SKILL_HERBALISM) ||			//²ÝÒ©
+		spellInfo->IsAbilityOfSkillType(SKILL_LEATHERWORKING) ||	//ÖÆÆ¤
+		spellInfo->IsAbilityOfSkillType(SKILL_INSCRIPTION) ||		//ÃúÎÄ
+		spellInfo->IsAbilityOfSkillType(SKILL_TAILORING) ||			//²Ã·ì
+		spellInfo->IsAbilityOfSkillType(SKILL_MINING) ||			//ÍÚ¿ó
+		spellInfo->IsAbilityOfSkillType(SKILL_FISHING) ||			//µöÓã
+		spellInfo->IsAbilityOfSkillType(SKILL_SKINNING) ||			//°þÆ¤
+		spellInfo->IsAbilityOfSkillType(SKILL_JEWELCRAFTING) ||		//Öé±¦
+		spellInfo->IsAbilityOfSkillType(SKILL_RIDING_HORSE) ||		//ÆïÊõ
+		spellInfo->IsAbilityOfSkillType(SKILL_RIDING_WOLF) ||
+		spellInfo->IsAbilityOfSkillType(SKILL_RIDING_TIGER) ||
+		spellInfo->IsAbilityOfSkillType(SKILL_RIDING_RAM) ||
+		spellInfo->IsAbilityOfSkillType(SKILL_RIDING_RAPTOR) ||
+		spellInfo->IsAbilityOfSkillType(SKILL_RIDING_MECHANOSTRIDER) ||
+		spellInfo->IsAbilityOfSkillType(SKILL_RIDING_UNDEAD_HORSE) ||
+		spellInfo->IsAbilityOfSkillType(SKILL_RIDING_KODO) ||
+		spellInfo->IsAbilityOfSkillType(SKILL_RIDING) ||
+		spellInfo->HasAura(SPELL_AURA_MOUNTED) ||					//×øÆï
+		spellInfo->IsAbilityOfSkillType(SKILL_COMPANIONS);			//Ð¡³èÎï
+}
+
+void CharMod::ModClass(Player* player, uint8 targetClass)
+{
+	player->CLOSE_GOSSIP_MENU();
+	
+	uint32 reqId = sSwitch->GetValue(ST_ALT_CLASS);
+
+	if (!sReq->Check(player, reqId))
+		return;
+
+	sReq->Des(player, reqId);
+
+	uint32 bytes0 = 0;
+	bytes0 |= player->getRace(); 
+	bytes0 |= targetClass << 8; 
+	bytes0 |= player->getGender() << 16;
+
+	ChrClassesEntry const* cEntry = sChrClassesStore.LookupEntry(targetClass);
+	if (cEntry && cEntry->powerType < MAX_POWERS)
+		bytes0 |= cEntry->powerType << 24;
+
+	player->SetUInt32Value(UNIT_FIELD_BYTES_0, bytes0);
+
+	PlayerSpellMap spellMap = player->GetSpellMap();
+
+	for (PlayerSpellMap::const_iterator iter = spellMap.begin(); iter != spellMap.end(); ++iter)
+		if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(iter->first))
+			if(!CheckSkill(spellInfo))
+				if (AltClassSpellVec.empty() || std::find(AltClassSpellVec.begin(), AltClassSpellVec.end(), iter->first) == AltClassSpellVec.end())
+					player->removeSpell(iter->first, SPEC_MASK_ALL, false);
+
+	player->learnDefaultSpells();
+	player->learnQuestRewardedSpells();
+
+	player->resetTalents(true);
+	player->SendTalentsInfoData(false);
+
+
+	for (uint32 id = 0; id < sSkillLineStore.GetNumRows(); id++)
+	{
+
+		SkillLineEntry const* pSkill = sSkillLineStore.LookupEntry(id);
+		if (!pSkill)
+			continue;
+
+		if (pSkill->categoryId != SKILL_CATEGORY_CLASS)
+			continue;
+
+		player->SetSkill(id, 0, 0, 0);
+	}
+
+
+	if (targetClass == CLASS_DEATH_KNIGHT)
+		player->InitRunes();
+
+	//CharacterDatabase.PExecute("update characters set class=%u where guid =%u", targetClass, player->GetGUIDLow()); //¸üÐÂ×ªÖ°ºóµÄÖ°Òµ
+	CharacterDatabase.PExecute("delete from character_glyphs where guid =%u", player->GetGUIDLow()); // É¾³ýµñÎÄ
+	CharacterDatabase.PExecute("delete from character_pet where owner =%u", player->GetGUIDLow());//É¾³ý³èÎï
+
+	//Customize(GetGUID(), getGender(), 1, 1, 1, 1, 1);
+	sWorld->UpdateGlobalPlayerData(player->GetGUIDLow(), PLAYER_UPDATE_DATA_CLASS, "", 0, 0, 0, targetClass);
+	player->GetSession()->KickPlayer();
+}
+
+std::string CharMod::GetClassName1(uint32 _class)
+{
+	switch (_class)
+	{
+	case CLASS_WARRIOR:
+		return "[Õ½Ê¿]";
+	case CLASS_PALADIN:
+		return "[Ê¥ÆïÊ¿]";
+	case CLASS_HUNTER:
+		return "[ÁÔÈË]";
+	case CLASS_ROGUE:
+		return "[µÁÔô]";
+	case CLASS_PRIEST:
+		return "[ÄÁÊ¦]";
+	case CLASS_DEATH_KNIGHT:
+		return "[ËÀÍöÆïÊ¿]";
+	case CLASS_SHAMAN:
+		return "[ÈøÂú¼ÀË¾]";
+	case CLASS_MAGE:
+		return "[·¨Ê¦]";
+	case CLASS_WARLOCK:
+		return "[ÊõÊ¿]";
+	case CLASS_DRUID:
+		return "[µÂÂ³ÒÁ]";
+	default:
+		return "";
+	}
+}
+
+void CharMod::AddGossip(Player* player, Object* obj)
+{
+	uint8 race = player->getRace();
+	uint8 _class = player->getClass();
+
+	for (size_t i = CLASS_WARRIOR; i <= CLASS_DRUID; i++)
+	{
+		if (i == 10 || _class == i)
+			continue;
+
+		PlayerInfo const* info = sObjectMgr->GetPlayerInfo(race, i);
+
+		if (!info)
+			continue;
+
+		std::string name = GetClassName1(i);
+		player->ADD_GOSSIP_ITEM_EXTENDED(0, "×ªÖ° -> " + name, SENDER_ALT_CLASS, i, sReq->Notice(player, sSwitch->GetValue(ST_ALT_CLASS), "×ªÖ°Îª", name), 0, false);
+	}
+
+	if (obj->ToCreature())
+		player->SEND_GOSSIP_MENU(obj->GetEntry(), obj->GetGUID());
+	else
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+}
+
+class CharModPlayerScript : public PlayerScript
+{
+public:
+	CharModPlayerScript() : PlayerScript("CharModPlayerScript") {}
+
+	void OnLogin(Player* player)
+	{
+		sCharMod->ModLimit(player);
+	}
+
+	void OnMapChanged(Player* player) 
+	{
+		sCharMod->ModStats(player);
+	}
+};
+
+
+void AddSC_CharModPlayerScript()
+{
+	new CharModPlayerScript();
+}
diff --git a/src/server/scripts/Custom/UnitMod/CharMod/CharMod.h b/src/server/scripts/Custom/UnitMod/CharMod/CharMod.h
new file mode 100644
index 0000000..8d3c22c
--- /dev/null
+++ b/src/server/scripts/Custom/UnitMod/CharMod/CharMod.h
@@ -0,0 +1,141 @@
+enum StatLimitTypes
+{
+	LIMIT_ARMOR,
+	LIMIT_DODGE,
+	LIMIT_PARRY,
+	LIMIT_BLOCK,
+	LIMIT_CRIT,
+
+	LIMIT_HASTE,
+	LIMIT_HP,
+	LIMIT_MANA,
+	LIMIT_MELEEDMG,
+	LIMIT_SPELLDMG,
+	LIMIT_HEAL,
+};
+
+enum StatModTypes
+{
+	CHAR_MOD_PVP_MELEE_DMG,
+	CHAR_MOD_PVP_SPELL_DMG,
+	CHAR_MOD_PVP_HEAL,
+	CHAR_MOD_PVE_MELEE_DMG,
+	CHAR_MOD_PVE_SPELL_DMG,
+	CHAR_MOD_PVE_HEAL,
+	CHAR_MOD_REDUCE_DMG,
+};
+
+enum SwitchStatTypes
+{
+	//ç²¾ç¥å æ³ä¼¤
+	SWITCH_SPIRIT2SP,
+	//ç²¾ç¥å æ²»ç
+	SWITCH_SPIRIT2HEAL,
+	//æºåå æ³ä¼¤
+	SWITCH_INTELLECT2SP,
+	//æºåå æ²»ç
+	SWITCH_INTELLECT2HEAL,
+	//åéå æ»å¼º
+	SWITCH_STRENGTH2AP,
+	//ææ·å æ»å¼º
+	SWITCH_AGILITY2AP,
+	
+	SWITCH_SPIRIT2AP,
+	SWITCH_INTELLECT2AP,
+
+	SWITCH_STRENGTH2SP,
+	SWITCH_AGILITY2SP,
+
+	SWITCH_STRENGTH2HEAL,
+	SWITCH_AGILITY2HEAL,
+};
+
+struct CharStatTemplate
+{
+	uint8 classIndex;
+	float meleePVPDmgMod;
+	float spellPVPDmgMod;
+	float healPVPMod;
+	float meleePVEDmgMod;
+	float spellPVEDmgMod;
+	float healPVEMod;
+	float reduceDmgMod;
+	uint32 hasteLimit;
+	uint32 hpLimit;
+	uint32 manaLimit;
+	uint32 meleeDmgLimit;
+	uint32 spellDmgLimit;
+	uint32 healLimit;
+	float armorLimit;
+	float dodgeLimit;
+	float parryLimit;
+	float blockLimit;
+	float critLimit;
+	float spirit2SP;
+	float spirit2Heal;
+	float intellect2SP;
+	float intellect2Heal;
+	float strength2AP;
+	float agility2AP;
+
+	float spirit2AP;
+	float intellect2AP;
+
+	float strength2SP;
+	float agility2SP;
+
+	float strength2Heal;
+	float agility2Heal;
+
+};
+extern std::vector<CharStatTemplate> CharStatVec;
+extern std::vector<uint32> AltClassSpellVec;
+
+struct StaticStatTemplate
+{
+	uint8 _class;
+	uint32 vip;
+	uint32 map;
+	std::unordered_map<Stats, uint32> StaticStatsMap;
+	std::unordered_map<CombatRating, uint32> StaticCombatRatingMap;
+	uint32 StaticHealth;
+	uint32 StaticSpellPower;
+	uint32 StaticHealPower;
+	uint32 StaticAttackPower;
+	uint32 StaticRangeAttackPower;
+};
+
+extern std::vector<StaticStatTemplate> StaticStatVec;
+
+class CharMod
+{
+public:
+	static CharMod* instance()
+	{
+		static CharMod instance;
+		return &instance;
+	}
+
+	void Load();
+
+	float GetLimit(StatLimitTypes type, uint8 classIndex);
+	float GetMod(StatModTypes type, uint8 classIndex);
+	float GetValue(SwitchStatTypes type, uint8 classIndex);
+	
+	int32 GetExtraSP(Player* player);
+	int32 GetExtraAP(Player* player);
+	int32 GetExtraHeal(Player* player);
+
+	void ModLimit(Player* player);
+	void ModStats(Player* player);
+
+	std::string GetClassName1(uint32 _class);
+	bool CheckFamily(Player* player, uint32 SpellFamily);
+	bool CheckSkill(SpellInfo const* spellInfo);
+	void ModClass(Player* player, uint8 targetClass);
+	void AddGossip(Player* player, Object* obj);
+	
+private:
+
+};
+#define sCharMod CharMod::instance()
diff --git a/src/server/scripts/Custom/UnitMod/CreatureMod/CreatureMod.cpp b/src/server/scripts/Custom/UnitMod/CreatureMod/CreatureMod.cpp
new file mode 100644
index 0000000..b79df19
--- /dev/null
+++ b/src/server/scripts/Custom/UnitMod/CreatureMod/CreatureMod.cpp
@@ -0,0 +1,214 @@
+#pragma execution_character_set("utf-8")
+#include "CreatureMod.h"
+#include "../../Reward/Reward.h"
+#include "../../CommonFunc/CommonFunc.h"
+#include "../../String/myString.h"
+#include "../../Talisman/Talisman.h"
+#include "../../Rank/Rank.h"
+#include "Group.h"
+
+std::vector<CreautreModTemplate> CreautreModVec;
+
+void CreatureMod::Load()
+{
+	CreautreModVec.clear();
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+
+		//		0		1		2		3			4			5			6			7
+		"SELECT ÉúÎïID,µÈ¼¶,ÉúÃüÖµ,ÎïÀíÉËº¦Öµ»ò±¶ÂÊ,·¨ÊõÉËº¦±¶ÂÊ,ÖÎÁÆÐ§¹û±¶ÂÊ,¼õÉË°Ù·Ö±È,¿¹ÐÔÖµ,"
+		//8				9			10				11		12			13				14			15		16		17		18		19	
+		"»÷É±½±ÀøÄ£°åID,»÷É±½±Àø¼¸ÂÊ,»÷É±ÊÇ·ñÈ«·þÌáÊ¾,»¤¼×Öµ,¹¥»÷¼ä¸ô,Àë¿ªÔ­Î»ÖÃÖØÖÃ¾àÀë,»÷É±½±Àø·¨±¦Öµ,µôÂäID1,µôÂäID2,µôÂäID3,µôÂäID4,µôÂäID5,"
+		//	20					21				22				23				24			25				26
+		"¶ÓÎé»÷É±½±ÀøÄ£°åID,¶ÓÎé»÷É±½±Àø¼¸ÂÊ,»÷É±½±Àø×Ô¶¨ÒåµÈ¼¶Öµ,»÷É±ÕÙ»½ÎïÌåID,¸±±¾ÌôÕ½µÈ¼¶,ÊÇ·ñ¼ÓÔØÔ­µôÂä,Ëæ»ú¼¼ÄÜ×éÄ£°åID,ÄÑ¶È FROM _ÊôÐÔµ÷Õû_ÉúÎï" :
+		//		0		1		2	3			4			5		6			7
+		"SELECT Entry,Level,Health,MeleeDmg,SpellDmgMod,HealMod,ReduceDmgPct,Resistance,"
+		//8				9			10			11		12		13				14				15		16		17		18			19	
+		"KillRewId,KillRewChance,KillAnnounce,Armor,AttackTime,ResetDistance,AddTalismanValue,LootId_1,LootId_2,LootId_3,LootId_4,LootId_5,"
+		//	20					21				22			23					24		25			26
+		"KillGroupRewId,KillGroupRewChance,AddRankValue,KillRewGameObject,ChallengeLv,SrcLoot,RandSpellGroupId FROM _attribute_creature");
+
+	if (!result)
+		return;
+
+	do
+	{
+		Field* fields = result->Fetch();
+		CreautreModTemplate Temp;
+		Temp.Entry			= fields[0].GetUInt32();
+		Temp.Level			= fields[1].GetUInt8();
+		Temp.Health			= fields[2].GetUInt32();
+		Temp.MeleeDmg		= fields[3].GetFloat();
+		Temp.SpellDmgMod	= fields[4].GetFloat();
+		Temp.HealMod		= fields[5].GetFloat();
+		Temp.ReduceDmgPct	= fields[6].GetFloat();
+		Temp.Resistance		= fields[7].GetInt32();
+		Temp.KillRewId		= fields[8].GetUInt32();
+		Temp.KillRewChance	= fields[9].GetFloat();
+		Temp.KillAnnounce	= fields[10].GetBool();
+		Temp.Armor			= fields[11].GetInt32();
+		Temp.AttackTime		= fields[12].GetUInt32();
+		Temp.ResetDistance	= fields[13].GetFloat();
+		Temp.AddTalismanValue = fields[14].GetInt32();
+
+		for (size_t i = 0; i < MAX_CUSTOM_LOOT_COUNT; i++)
+			Temp.LootId[i] = fields[15 + i].GetUInt32();
+
+		Temp.KillGroupRewId		= fields[20].GetUInt32();
+		Temp.KillGroupRewChance = fields[21].GetFloat();
+		Temp.AddRankValue		= fields[22].GetInt32();
+		Temp.KillRewGameObject	= fields[23].GetInt32();
+		Temp.ChallengeLv		= fields[24].GetUInt32();
+		Temp.SrcLoot			= fields[25].GetBool();
+		Temp.RandSpellGroupId	= fields[26].GetUInt32();
+		Temp.Diff				= fields[27].GetUInt32();
+		CreautreModVec.push_back(Temp);
+	} while (result->NextRow());
+}
+
+void CreatureMod::SetMod(Creature* creature)
+{
+	if (creature->GetEntry() == 1964 || creature->IsGuardian() || creature->IsHunterPet() || creature->IsTotem())
+		return;
+
+	////Ð¡¶¯ÎïÖ®Àà
+	//if (creature->IsCivilian())
+	//	return;
+
+	uint32 Entry = creature->GetEntry();
+	uint32 ChallengeLv = creature->GetMap()->challengeLv;
+	uint32 Diff = creature->GetMap()->GetDifficulty();
+
+	for (auto itr = CreautreModVec.begin(); itr != CreautreModVec.end(); itr++)
+	{
+		if (Entry == itr->Entry && ChallengeLv == itr->ChallengeLv && Diff == itr->Diff)
+		{
+			creature->C_Level = itr->Level;
+			creature->C_Health = itr->Health;
+			creature->C_HpMod = 1;
+			creature->C_MeleeDmg = itr->MeleeDmg;
+			creature->C_SpellDmgMod = itr->SpellDmgMod;
+			creature->C_HealMod = itr->HealMod;
+			creature->C_ReduceDmgPct = itr->ReduceDmgPct;
+			creature->C_Resistance = itr->Resistance;
+			creature->C_SrcLoot	= itr->SrcLoot;
+
+			for (size_t i = 0; i < MAX_CUSTOM_LOOT_COUNT; i++)
+				creature->C_LootId[i] = itr->LootId[i];
+
+			creature->C_KillRewId = itr->KillRewId;
+			creature->C_KillRewChance = itr->KillRewChance;
+			creature->C_KillGroupRewId = itr->KillGroupRewId;
+			creature->C_KillGroupRewChance = itr->KillGroupRewChance;
+			creature->C_KillAnnounce = itr->KillAnnounce;
+			creature->C_Armor = itr->Armor;
+			creature->C_AttackTime = itr->AttackTime;
+			creature->C_ResetDistance = itr->ResetDistance;
+			creature->C_AddTalismanValue = itr->AddTalismanValue;
+			creature->C_AddAddRankValue = itr->AddRankValue;
+			creature->C_KillRewGameObject = itr->KillRewGameObject;
+			creature->RandSpellGroupId = itr->RandSpellGroupId;
+			break;
+		}
+	}
+}
+
+class CreatureKillRew : PlayerScript
+{
+public:
+	CreatureKillRew() : PlayerScript("CreatureKillRew") {}
+
+	void OnCreatureKill(Player* killer, Creature* killed) override
+	{
+		if (killed->C_KillRewGameObject != 0)
+			killer->SummonGameObject(killed->C_KillRewGameObject, killed->GetPositionX(), killed->GetPositionY(), killed->GetPositionZ(), killed->GetOrientation(), 0, 0, 0, 0, 0);
+
+		//»÷É±½±Àø
+		if (killed->C_KillRewId != 0 && frand(0, 100) <= killed->C_KillRewChance)
+			sRew->Rew(killer, killed->C_KillRewId);
+
+		//¶ÓÎé»÷É±½±Àø
+		if (killed->C_KillGroupRewId != 0)
+			if (Group* group = killer->GetGroup())
+				for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+					if (Player* member = itr->GetSource())
+						if (member->IsInWorld() && member->GetGUID() != killer->GetGUID() && frand(0, 100) <= killed->C_KillGroupRewChance && member->IsSelfOrInSameMap(killer) && member->GetDistance(killer) <= 200.0f)
+							sRew->Rew(member, killed->C_KillGroupRewId);
+
+
+        CreatureTemplate const* ccc = killed->GetCreatureTemplate();
+        if (ccc->rank >= 2 && killed->GetMaxHealth() > 3000000)
+        {
+            const char*msg;
+
+            if (killer->GetGroup())
+                msg = sString->Format(sString->GetText(STR_GROUP_KILL_CREATURE), sCF->GetNameLink(killer).c_str(), killed->GetCreatureTemplate()->Name.c_str());
+            else
+                msg = sString->Format(sString->GetText(STR_KILL_CREATRE), sCF->GetNameLink(killer).c_str(), killed->GetCreatureTemplate()->Name.c_str());
+
+            sWorld->SendScreenMessage(msg);
+        }
+
+		//»÷É±¹ã²¥
+		if (killed->C_KillAnnounce)
+		{
+			const char*msg;
+
+			if (killer->GetGroup())
+				msg = sString->Format(sString->GetText(CORE_STR_TYPES(STR_GROUP_KILL_CREATURE)), sCF->GetNameLink(killer).c_str(), killed->GetCreatureTemplate()->Name.c_str());
+			else
+				msg = sString->Format(sString->GetText(CORE_STR_TYPES(STR_KILL_CREATRE)), sCF->GetNameLink(killer).c_str(), killed->GetCreatureTemplate()->Name.c_str());
+
+			sWorld->SendScreenMessage(msg);
+		}
+
+		//RankÖµ ÕýÊý-»÷É±Õß ¸ºÊý-Õû¸ö¶ÓÎé
+		if (killed->C_AddAddRankValue > 0)
+			sRank->Update(killer, killed->C_AddAddRankValue, true);
+		else if (killed->C_AddAddRankValue < 0)
+		{
+			if (Group* group = killer->GetGroup())
+			{
+				for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+					if (Player* member = itr->GetSource())
+						if (member->IsInWorld() && member->GetDistance(killer) <= 200.0f)
+							sRank->Update(member, abs(killed->C_AddAddRankValue), true);
+			}
+			else
+				sRank->Update(killer, abs(killed->C_AddAddRankValue), true);
+		}
+
+		//·¨±¦Öµ ÕýÊý-»÷É±Õß ¸ºÊý-Õû¸ö¶ÓÎé
+		if (killed->C_AddTalismanValue > 0)
+		{
+			sTalisman->AddTalismanValue(killer, killed->C_AddTalismanValue, true);
+			if (killed->IsDungeonBoss() || killed->IsDungeonBoss())
+				sTalisman->SaveTalisManValue(killer);
+		}		
+		else if (killed->C_AddTalismanValue < 0)
+		{
+			if (Group* group = killer->GetGroup())
+			{
+				for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+					if (Player* member = itr->GetSource())
+						if (member->IsInWorld() && member->GetDistance(killer) <= 200.0f)
+						{
+							sTalisman->AddTalismanValue(member, abs(killed->C_AddTalismanValue), true);
+
+							if (killed->IsDungeonBoss() || killed->IsDungeonBoss())
+								sTalisman->SaveTalisManValue(member);
+						}
+			}
+			else
+			{
+				sTalisman->AddTalismanValue(killer, abs(killed->C_AddTalismanValue), true);
+
+				if (killed->IsDungeonBoss() || killed->IsDungeonBoss())
+					sTalisman->SaveTalisManValue(killer);
+			}
+		}
+	}
+};
+void AddSC_CreatureKillRew()
+{
+	new CreatureKillRew();
+}
diff --git a/src/server/scripts/Custom/UnitMod/CreatureMod/CreatureMod.h b/src/server/scripts/Custom/UnitMod/CreatureMod/CreatureMod.h
new file mode 100644
index 0000000..d1bdb06
--- /dev/null
+++ b/src/server/scripts/Custom/UnitMod/CreatureMod/CreatureMod.h
@@ -0,0 +1,44 @@
+struct CreautreModTemplate
+{
+	uint32 Entry;
+	uint32 ChallengeLv;
+	uint8 Level;										//ç­çº§
+	uint32 Health;										//çå½å¼
+	int32 Armor;										//æ¤ç²-1 creature_templateè¡¨ç¡®å®
+	uint32 MeleeDmg;									//ç©çä¼¤å®³
+	float SpellDmgMod;									//æ³æ¯ä¼¤å®³åç
+	float HealMod;										//æ²»çåç
+	float ReduceDmgPct;									//åä¼¤ç¾åæ¯
+	int32 Resistance;									//ææ§-1 creature_templateè¡¨ç¡®å®
+	uint32	LootId[MAX_CUSTOM_LOOT_COUNT];				//æè½ creaute_loot_template
+	bool  SrcLoot;
+	uint32 KillRewId;									//å»æèè·å¾å¥å±
+	float KillRewChance;								//å»æèè·å¾å¥å±å ç
+	uint32 KillGroupRewId;								//å»æèéä¼è·å¾å¥å±
+	float KillGroupRewChance;							//å»æèéä¼è·å¾å¥å±å ç
+	bool KillAnnounce;									//å»ææ¶å¹¿æ­åå®¹
+	uint32 AttackTime;									//ç©çæ»å»é´é
+	float ResetDistance;
+	int32 AddTalismanValue;
+	int32 AddRankValue;
+	uint32 KillRewGameObject;
+	uint32 RandSpellGroupId;
+	uint32 Diff;
+};
+extern std::vector<CreautreModTemplate> CreautreModVec;
+
+class CreatureMod
+{
+public:
+	static CreatureMod* instance()
+	{
+		static CreatureMod instance;
+		return &instance;
+	}
+
+	void Load();
+	void SetMod(Creature* creature);	
+private:
+
+};
+#define sCreatureMod CreatureMod::instance()
diff --git a/src/server/scripts/Custom/VIP/VIP.cpp b/src/server/scripts/Custom/VIP/VIP.cpp
new file mode 100644
index 0000000..0290f7b
--- /dev/null
+++ b/src/server/scripts/Custom/VIP/VIP.cpp
@@ -0,0 +1,269 @@
+#pragma execution_character_set("utf-8")
+#include "VIP.h"
+#include "../Custom/Requirement/Requirement.h"
+#include "../Custom/Reward/Reward.h"
+#include "../String/myString.h"
+#include "../CommonFunc/CommonFunc.h"
+#include "../FunctionCollection/FunctionCollection.h"
+
+std::vector<VIPTemplate> VIPVec;
+
+void VIP::Load()
+{
+	VIPVec.clear();
+	QueryResult result1 = WorldDatabase.PQuery(
+		sWorld->getBoolConfig(CONFIG_ZHCN_DB) ?
+		//			0		1			2			3						4							5						6					7					8				9	10	11				12
+		"SELECT »áÔ±µÈ¼¶,Éý¼¶ÐèÇóÄ£°åID,µôÂä±¶ÂÊ,ÎïÆ·Éý¼¶Ä£Ê½0Ôö¼Ó³É¹¦°Ù·Ö±È,ÎïÆ·Éý¼¶Ä£Ê½1Ôö¼Ó³É¹¦°Ù·Ö±È,ÎïÆ·Ç¿»¯Ôö¼Ó³É¹¦°Ù·Ö±È,·ûÓ¡Ç¿»¯Ôö¼Ó³É¹¦°Ù·Ö±È,ÒÆ³ý±¦Ê¯Ôö¼Ó³É¹¦°Ù·Ö±È,Éý¼¶ºó½±ÀøÄ£°åID,Í¼±ê,Ãû³Æ,ÅÝµã½±ÀøÄ£°åID,²Ëµ¥ÎÄ±¾ from __»áÔ±" :
+		//		0		1		2		3				4			5				6			7			8	9	10		11			12
+		"SELECT vipLv,reqId,lootRate,exchangeRate_0,exchangeRate_1,strengthenRate,sigilRate,removeGemRate,rewId,icon,name,timeRewId,gossipText from _vip");
+	if (result1)
+	{
+		do
+		{
+			Field* fields = result1->Fetch();
+			VIPTemplate VIPTemp;
+			VIPTemp.vipLv				= fields[0].GetUInt32();
+			VIPTemp.reqId				= fields[1].GetUInt32();
+			VIPTemp.lootRate			= fields[2].GetFloat();
+			VIPTemp.exchangeRate_0		= fields[3].GetUInt32();
+			VIPTemp.exchangeRate_1		= fields[4].GetUInt32();
+			VIPTemp.strengthenRate		= fields[5].GetUInt32();
+			VIPTemp.sigilRate			= fields[6].GetUInt32();
+			VIPTemp.removeGemRate		= fields[7].GetUInt32();
+			VIPTemp.rewId				= fields[8].GetUInt32();
+			VIPTemp.icon				= fields[9].GetString();
+			VIPTemp.name				= fields[10].GetString();
+			VIPTemp.timeRewId			= fields[11].GetUInt32();
+			VIPTemp.gossipText			= fields[12].GetString();
+			VIPVec.push_back(VIPTemp);
+		} while (result1->NextRow());
+	}
+}
+
+
+void VIP::GetVIPTitle(Player* player, std::string &vipTitle, std::string &vipIcon, bool fakeplayer, uint32 vip)
+{
+	if (fakeplayer)
+	{
+
+		for (std::vector<VIPTemplate>::iterator itr = VIPVec.begin(); itr != VIPVec.end(); ++itr)
+			if (itr->vipLv == vip)
+			{
+				vipTitle = itr->name;
+				vipIcon = "|TInterface/ICONS/" + itr->icon + ":14:14:0:-2|t";
+				break;
+			}
+
+		return;
+	}
+
+	for (std::vector<VIPTemplate>::iterator itr = VIPVec.begin(); itr != VIPVec.end(); ++itr)
+		if (itr->vipLv == player->vipLevel)
+		{
+			vipTitle = itr->name;
+			vipIcon = "|TInterface/ICONS/" + itr->icon + ":14:14:0:-2|t";
+			break;
+		}
+}
+std::string VIP::GetVIPName(uint32 viplv)
+{
+	for (std::vector<VIPTemplate>::iterator itr = VIPVec.begin(); itr != VIPVec.end(); ++itr)
+		if (itr->vipLv == viplv)
+			return itr->name;
+			
+	return "";
+}
+
+void VIP::GetVIP(Player* player, std::string &vipTitle, std::string &vipIcon)
+{
+	for (std::vector<VIPTemplate>::iterator itr = VIPVec.begin(); itr != VIPVec.end(); ++itr)
+		if (itr->vipLv == player->vipLevel)
+		{
+			vipTitle = itr->name;
+			vipIcon = "|TInterface/ICONS/" + itr->icon + ":14:14:0:0|t";
+			break;
+		}
+}
+
+void VIP::GetNextVIP(Player* player, std::string &vipTitle, std::string &vipIcon)
+{
+	for (std::vector<VIPTemplate>::iterator itr = VIPVec.begin(); itr != VIPVec.end(); ++itr)
+		if (itr->vipLv == player->vipLevel + 1)
+		{
+			vipTitle = itr->name;
+			vipIcon = "|TInterface/ICONS/" + itr->icon + ":14:14:0:0|t";
+			break;
+		}
+}
+
+
+uint32 VIP::GetRate(Player* player, VIPRateTypes type)
+{
+	uint32 len = VIPVec.size();
+	for (size_t i = 0; i < len; i++)
+	{
+		if (player->vipLevel == VIPVec[i].vipLv)
+		{
+			switch (type)
+			{
+			case VIP_RATE_LOOT:
+				return VIPVec[i].lootRate;
+			case VIP_RATE_ITEM_EXCHANGE_0:
+				return VIPVec[i].exchangeRate_0;
+			case VIP_RATE_ITEM_EXCHANGE_1:
+				return VIPVec[i].exchangeRate_1;
+			case VIP_RATE_ITEM_STRENGTHEN:
+				return VIPVec[i].strengthenRate;
+			case VIP_RATE_SIGIL:
+				return VIPVec[i].sigilRate;
+			case VIP_RATE_GEM_REMOVE:
+				return VIPVec[i].removeGemRate;
+			default:
+				return 0.0f;
+			}
+		}
+	}
+
+	return 0.0f;
+}
+
+float VIP::GetLootRate(Player* player)
+{
+	uint32 len = VIPVec.size();
+	for (size_t i = 0; i < len; i++)
+		if (player->vipLevel == VIPVec[i].vipLv)
+			return VIPVec[i].lootRate;
+		
+	return 1.0f;
+}
+
+void VIP::Up(Player* player)
+{
+	uint32 len = VIPVec.size();
+
+	for (size_t i = 0; i < len; i++)
+	{
+		if (player->vipLevel == VIPVec[i].vipLv - 1)
+		{
+			if (sReq->Check(player, VIPVec[i].reqId))
+			{
+				sReq->Des(player, VIPVec[i].reqId);
+				sRew->Rew(player, VIPVec[i].rewId);
+				LoginDatabase.DirectPExecute("UPDATE account SET viplevel = viplevel + 1 WHERE id = '%u'", player->GetSession()->GetAccountId());
+				player->vipLevel++;
+				sCF->SetLootRate(player);
+
+				std::string title	= "";
+				std::string icon	= "";
+
+				GetVIPTitle(player, title, icon);
+
+				std::ostringstream oss;
+				oss << "»ñµÃÐÂµÄ»áÔ±µÈ¼¶!" << icon << title;
+				player->GetSession()->SendAreaTriggerMessage(oss.str().c_str());
+				player->CastSpell(player, 61456, true, NULL, NULL, player->GetGUID());
+
+				const char*  msg = sString->Format(sString->GetText(CORE_STR_TYPES(STR_VIP_UP)), sCF->GetNameLink(player).c_str(), title.c_str());
+				sWorld->SendScreenMessage(msg);
+				return;
+			}
+		}
+	}
+}
+uint32 VIP::GetReqId(Player* player)
+{
+	uint32 len = VIPVec.size();
+
+	for (size_t i = 0; i < len; i++)
+	{
+		if (player->vipLevel == VIPVec[i].vipLv - 1)
+		{
+			return VIPVec[i].reqId;
+		}
+	}
+
+	return 0;
+}
+
+uint32 VIP::GetTimeRewId(Player* player)
+{
+	uint32 len = VIPVec.size();
+
+	for (size_t i = 0; i < len; i++)
+	{
+		if (player->vipLevel == VIPVec[i].vipLv)
+		{
+			return VIPVec[i].timeRewId;
+		}
+	}
+
+	return 0;
+}
+
+std::string VIP::GetGossipText(Player* player, bool next)
+{
+	uint32 len = VIPVec.size();
+
+	if (next)
+	{
+		for (std::vector<VIPTemplate>::iterator itr = VIPVec.begin(); itr != VIPVec.end(); ++itr)
+			if (itr->vipLv == player->vipLevel + 1)
+				return itr->gossipText;
+	}
+	else
+	{
+		for (std::vector<VIPTemplate>::iterator itr = VIPVec.begin(); itr != VIPVec.end(); ++itr)
+			if (itr->vipLv == player->vipLevel)
+				return itr->gossipText;
+	}
+
+	return "";
+}
+
+void VIP::AddGossip(Player* player, Object* obj)
+{
+	std::string title = "";
+	std::string icon = "";
+
+	GetNextVIP(player, title, icon);
+
+	player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GetGossipText(player), SENDER_VIP_CURR, GOSSIP_ACTION_INFO_DEF);
+
+	uint32 maxLevel = 0;
+
+	for (auto itr = VIPVec.begin(); itr != VIPVec.end(); itr++)
+		if (maxLevel < itr->vipLv)
+			maxLevel = itr->vipLv;
+
+	if (player->vipLevel < maxLevel)
+		player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_CHAT, "\n<<µã´ËÉý¼¶»áÔ±µÈ¼¶>>\n", SENDER_VIP_UP, GOSSIP_ACTION_INFO_DEF, sReq->Notice(player, GetReqId(player), "Éý¼¶", title), sReq->Golds(GetReqId(player)), false);
+	
+	if (obj->ToCreature())
+		player->SEND_GOSSIP_MENU(obj->GetEntry(), obj->GetGUID());
+	else
+		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, obj->GetGUID());
+}
+
+
+class VIPLogin : PlayerScript
+{
+public:
+	VIPLogin() : PlayerScript("VIPLogin") {}
+	void OnLogin(Player* player)
+	{
+		QueryResult result = LoginDatabase.PQuery("SELECT vipLevel FROM account WHERE id = '%u'", player->GetSession()->GetAccountId());
+		if (!result)
+			player->vipLevel = 0;
+		else
+		{
+			Field* fields = result->Fetch();
+			player->vipLevel = fields[0].GetInt32();
+		}
+	}
+};
+
+void AddSC_VIP_LOGIN()
+{
+	new VIPLogin();
+}
diff --git a/src/server/scripts/Custom/VIP/VIP.h b/src/server/scripts/Custom/VIP/VIP.h
new file mode 100644
index 0000000..ac814c9
--- /dev/null
+++ b/src/server/scripts/Custom/VIP/VIP.h
@@ -0,0 +1,55 @@
+
+enum VIPRateTypes
+{
+	VIP_RATE_NONE,
+	VIP_RATE_LOOT,
+	VIP_RATE_ITEM_EXCHANGE_0,
+	VIP_RATE_ITEM_EXCHANGE_1,
+	VIP_RATE_ITEM_STRENGTHEN,
+	VIP_RATE_SIGIL,
+	VIP_RATE_GEM_REMOVE,
+};
+struct VIPTemplate
+{
+	uint32 vipLv;
+	uint32 reqId;
+	float lootRate;
+	uint32 exchangeRate_0;
+	uint32 exchangeRate_1;
+	uint32 strengthenRate;
+	uint32 sigilRate;
+	uint32 removeGemRate;
+	uint32 rewId;
+	std::string name;
+	std::string icon;
+	uint32 timeRewId;
+	std::string gossipText;
+};
+extern std::vector<VIPTemplate> VIPVec;
+
+
+class VIP
+{
+public:
+	static VIP* instance()
+	{
+		static VIP instance;
+		return &instance;
+	}
+
+	void Load();
+	uint32 GetRate(Player* player, VIPRateTypes type);
+	float GetLootRate(Player* player);
+	void Up(Player* player);
+	void AddGossip(Player* player, Object* obj);
+	uint32 GetReqId(Player* player);
+	uint32 GetTimeRewId(Player* player);
+	void GetVIPTitle(Player* player, std::string &vipTitle, std::string &vipIcon, bool fakeplayer = false, uint32 vip = 0);
+	std::string GetVIPName(uint32 viplv);
+	void GetVIP(Player* player, std::string &vipTitle, std::string &vipIcon);
+	void GetNextVIP(Player* player, std::string &vipTitle, std::string &vipIcon);
+	std::string GetGossipText(Player* player, bool next = false);
+private:
+
+};
+#define sVIP VIP::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/ZoneAura/ZoneAura.cpp b/src/server/scripts/Custom/ZoneAura/ZoneAura.cpp
new file mode 100644
index 0000000..53413e1
--- /dev/null
+++ b/src/server/scripts/Custom/ZoneAura/ZoneAura.cpp
@@ -0,0 +1,115 @@
+#pragma execution_character_set("utf-8")
+#include "ZoneAura.h"
+std::unordered_map<uint32/*zone*/, ZoneAuraTemplate> ZoneAuraMap;
+
+void ZoneAura::Load()
+{
+	ZoneAuraMap.clear();										
+	QueryResult result = WorldDatabase.PQuery(sWorld->getBoolConfig(CONFIG_ZHCN_DB) ? 
+		"SELECT ÇøÓòID,¹â»·ID,Íæ¼Ò×îÐ¡ÑªÁ¿ FROM _ÊôÐÔµ÷Õû_ÇøÓòÆ½ºâ¹â»·" :
+		"SELECT zone,aura,limitHP FROM _pvp_gap_aura");
+
+	if (result)
+	{
+		do
+		{
+			Field* fields = result->Fetch();
+			uint32 zone = fields[0].GetUInt32();
+			ZoneAuraTemplate Temp;
+			Temp.aura		= fields[1].GetUInt32();
+			Temp.limitHP	= fields[2].GetUInt32();
+			ZoneAuraMap.insert(std::make_pair(zone,Temp));
+		} while (result->NextRow());
+	}
+}
+
+int32 ZoneAura::GetAuraStack(Map* map, uint32 zone, uint32 limitHP)
+{
+	if (!map)
+		return 0;
+
+	int32 A_Count = 0;
+	int32 H_Count = 0;
+
+	Map::PlayerList const& players = map->GetPlayers();
+
+	if (players.isEmpty())
+		return 0;
+
+	for (Map::PlayerList::const_iterator i = players.begin(); i != players.end(); ++i)
+	{
+		if (Player* player = i->GetSource())
+		{
+			if (player->GetZoneId() != zone || player->GetMaxHealth() < limitHP)
+				continue;
+
+			if (player->GetTeamId() == TEAM_ALLIANCE)
+				A_Count++;
+			else
+				H_Count++;
+		}
+	}
+
+	return A_Count - H_Count;
+}
+void ZoneAura::UpdateAura(Map* map)
+{
+	if (!map || ZoneAuraMap.empty())
+		return;
+
+	for (auto iter = ZoneAuraMap.begin(); iter != ZoneAuraMap.end(); iter++)
+	{
+		if (map->GetId() != GetMapIdByZone(iter->first))
+			continue;
+
+		int32 stack = GetAuraStack(map, iter->first, iter->second.limitHP);
+
+		Map::PlayerList const& players = map->GetPlayers();
+
+		if (players.isEmpty())
+			continue;
+
+		for (Map::PlayerList::const_iterator i = players.begin(); i != players.end(); ++i)
+		{
+			if (Player* player = i->GetSource())
+			{
+				if (player->GetZoneId() != iter->first)
+					continue;
+					
+				if (stack > 0)
+				{
+					if (player->GetTeamId() == TEAM_HORDE)
+						player->SetAuraStack(iter->second.aura, player, stack);
+					else
+						player->RemoveAura(iter->second.aura);
+										
+				}
+				else if (stack < 0)
+				{
+					if (player->GetTeamId() == TEAM_ALLIANCE)
+						player->SetAuraStack(iter->second.aura, player, -stack);
+					else
+						player->RemoveAura(iter->second.aura);
+						
+				}else
+					player->RemoveAura(iter->second.aura);
+			}
+		}		
+	}
+}
+
+class ZoneAuraScript : PlayerScript
+{
+public:
+	ZoneAuraScript() : PlayerScript("ZoneAuraScript") {}
+	void OnUpdateZone(Player* player, uint32 /*newZone*/, uint32 /*newArea*/)
+	{
+		for (auto iter = ZoneAuraMap.begin(); iter != ZoneAuraMap.end(); iter++)
+			player->RemoveAura(iter->second.aura);
+	}
+};
+
+void AddSC_ZoneAura()
+{
+	new ZoneAuraScript();
+}
diff --git a/src/server/scripts/Custom/ZoneAura/ZoneAura.h b/src/server/scripts/Custom/ZoneAura/ZoneAura.h
new file mode 100644
index 0000000..2f5fd1b
--- /dev/null
+++ b/src/server/scripts/Custom/ZoneAura/ZoneAura.h
@@ -0,0 +1,21 @@
+struct ZoneAuraTemplate
+{
+	uint32 aura;
+	uint32 limitHP;
+};
+extern std::unordered_map<uint32/*zone*/, ZoneAuraTemplate> ZoneAuraMap;
+
+class ZoneAura
+{
+public:
+	static ZoneAura* instance()
+	{
+		static ZoneAura instance;
+		return &instance;
+	}
+	void Load();
+	int32 GetAuraStack(Map* map, uint32 zone, uint32 limitHP);
+	void UpdateAura(Map* map);
+private:
+};
+#define sZoneAura ZoneAura::instance()
\ No newline at end of file
diff --git a/src/server/scripts/Custom/conf/customconf.cpp b/src/server/scripts/Custom/conf/customconf.cpp
deleted file mode 100644
index 99a1fbb..0000000
--- a/src/server/scripts/Custom/conf/customconf.cpp
+++ /dev/null
@@ -1,56 +0,0 @@
-ï»¿#pragma execution_character_set("utf-8")
-#include "customconf.h"
-
-ConfMgr::ConfMgr()
-{
-    m_confParameters.clear();
-    m_conftexts.clear();
-}
-
-ConfMgr::~ConfMgr()
-{
-    
-}
- 
-void ConfMgr::Load()
-{
-    m_confParameters.clear();
-    m_conftexts.clear();
-    QueryResult confsys;
-    int count = 0;
-    int count2 = 0;
-
-    confsys = WorldDatabase.PQuery("SELECT éç½®ID,éç½®æ°æ® FROM _éç½®_åºç¡");
-    if (confsys)
-    {
-        do
-        {
-            uint32 confid = confsys->Fetch()[0].GetUInt32();
-
-            CConfParameters tmpConf;
-            tmpConf.confid = confid;
-            tmpConf.conftxt = confsys->Fetch()[1].GetString();
-
-            m_confParameters[confid] = tmpConf;
-            count++;
-        } while (confsys->NextRow());
-    }
-    sLog->outString(">> è¯»ååè½æ°æ®è¡¨[_éç½®_åºç¡],å±%uæ¡æ°æ®è¯»åå è½½...", count);
-
-    confsys = WorldDatabase.PQuery("SELECT éç½®ID,éç½®æ°æ® FROM _éç½®_ææ¬");
-    if (confsys)
-    {
-        do
-        {
-            uint32 confid = confsys->Fetch()[0].GetUInt32();
-
-            CConfText tmpConf;
-            tmpConf.confid = confid;
-            tmpConf.conftxt = confsys->Fetch()[1].GetString();
-
-            m_conftexts[confid] = tmpConf;
-            count2++;
-        } while (confsys->NextRow());
-    }
-    sLog->outString(">> è¯»ååè½æ°æ®è¡¨[_éç½®_ææ¬],å±%uæ¡æ°æ®è¯»åå è½½...", count2);
-}
diff --git a/src/server/scripts/Custom/conf/customconf.h b/src/server/scripts/Custom/conf/customconf.h
deleted file mode 100644
index c1c838d..0000000
--- a/src/server/scripts/Custom/conf/customconf.h
+++ /dev/null
@@ -1,169 +0,0 @@
-ï»¿#ifndef __Conf_H
-#define __Conf_H
-#include "Common.h"
-#include "Timer.h"
-#include <ace/Singleton.h>
-#include <ace/Atomic_Op.h>
-#include "SharedDefines.h"
-#include "QueryResult.h"
-#include "Callback.h"
-#include "Util.h"
-#include <atomic>
-#include <map>
-#include <set>
-#include <list>
-#pragma execution_character_set("utf-8")
-
-struct CConfParameters
-{
-    uint32 confid;
-    std::string conftxt;
-};
-
-struct CConfText
-{
-    uint32 confid;
-    std::string conftxt;
-};
-
-class ConfMgr
-{
-public:
-    ConfMgr();
-    ~ConfMgr();
-
-    std::string Get1Conftxt(uint32 entry)
-    {
-        for (auto itr = m_confParameters.begin(); itr != m_confParameters.end(); ++itr)
-            if (itr->confid == entry)
-                return itr->conftxt;
-        return "";
-    }
-    
-    bool GetConfBool(uint32 entry, uint32 index)
-    {
-        std::string param = Get1Conftxt(entry);
-
-        if (param.empty())
-            return false;
-
-        bool abc;
-        Tokenizer confalls(param, '#');
-        if (confalls.size() > 1)
-        {
-            if (index <= confalls.size())
-            {
-                if (confalls[index - 1] == "å¼" || confalls[index - 1] == "true" || confalls[index - 1] == "1" || confalls[index - 1] == "TRUE")
-                    abc = true;
-                else
-                    abc = false;
-            }
-            else
-            {
-
-                if (confalls[0] == "å¼" || confalls[0] == "true" || confalls[0] == "1" || confalls[0] == "TRUE")
-                    abc = true;
-                else
-                    abc = false;
-            }
-        }
-        else
-        {
-            if (confalls[0] == "å¼" || confalls[0] == "true" || confalls[0] == "1" || confalls[0] == "TRUE")
-                abc = true;
-            else
-                abc = false;
-        }
-
-        return abc;
-    }
-
-    std::string GetConfText(uint32 entry, uint32 index)
-    {
-        std::string param = Get1Conftxt(entry);
-        if (param.empty())
-            return "";
-
-        std::string abc;
-        Tokenizer confalls(param, '#');
-        if (confalls.size() > 1)
-        {
-            if (index <= confalls.size())
-                abc = confalls[index - 1];
-            else
-                abc = confalls[0];
-        }
-        else
-            abc = confalls[0];
-
-        return abc;
-    }
-
-    float GetConfFloat(uint32 entry, uint32 index)
-    {
-        std::string param = Get1Conftxt(entry);
-        if (param.empty())
-            return 0.0f;
-
-        float abc;
-        Tokenizer confalls(param, '#');
-        if (confalls.size() > 1)
-        {
-            if (index <= confalls.size())
-                abc = atof(confalls[index - 1]);
-            else
-                abc = atof(confalls[0]);
-        }
-        else
-            abc = atof(confalls[0]);
-
-        return abc;
-    }
-
-    int32 GetConfInt(uint32 entry, uint32 index)
-    {
-        std::string param = Get1Conftxt(entry);
-        if (param.empty())
-            return 0;
-
-        int32 abc;
-        Tokenizer confalls(param, '#');
-        if (confalls.size() > 1)
-        {
-            if (index <= confalls.size())
-                abc = atoi(confalls[index - 1]);
-            else
-                abc = atoi(confalls[0]);
-        }
-        else
-            abc = atoi(confalls[0]);
-
-        return abc;
-    }
-
-    typedef std::vector<CConfParameters>  CConfParametersContainer;
-    CConfParametersContainer m_confParameters;
-
-
-    std::string Get2Conftxt(uint32 entry)
-    {
-        for (auto itr = m_conftexts.begin(); itr != m_conftexts.end(); ++itr)
-            if (itr->confid == entry)
-                return itr->conftxt;
-        return "";
-    }
-
-
-    typedef std::vector<CConfText>  CConfTextContainer;
-    CConfTextContainer m_conftexts;
-
-    void Load();
-
-protected:
-private:
-};
-
-#define sConfMgr ACE_Singleton<ConfMgr, ACE_Null_Mutex>::instance()
-#endif
-
-
diff --git a/src/server/scripts/Custom/dqsys/dqscript.cpp b/src/server/scripts/Custom/dqsys/dqscript.cpp
deleted file mode 100644
index a623459..0000000
--- a/src/server/scripts/Custom/dqsys/dqscript.cpp
+++ /dev/null
@@ -1,82 +0,0 @@
-ï»¿#pragma execution_character_set("utf-8")
-#include "dqsys.h"
-#include "BYcustom.h"
-
-class itemdqxpup : public ItemScript
-{
-public:itemdqxpup() : ItemScript("item_dqxp") {}
-       bool OnUse(Player * pPlayer, Item * pItem, SpellCastTargets const& targets)
-       {
-           if (sDqSysMgr->Getdqlevel(pPlayer) >= sDqSysMgr->GetMaxdqLevel())
-           {
-               ChatHandler(pPlayer->GetSession()).PSendSysMessage("ææ°ç­çº§å·²ç»å°æé«.");
-               return true;
-           }
-
-           float xpbeibuff = 1.0f;
-
-           int32 maxAmount = 0;
-
-
-           xpbeibuff += float(maxAmount);
-
-           uint32 getdqxp = pItem->GetTemplate()->ItemStat[0].ItemStatValue * xpbeibuff;
-           WorldPacket data(SMSG_LOG_XPGAIN, 21);
-           data << uint64(0);
-           data << uint32(getdqxp);
-           data << uint8(0);
-           data << uint8(0);
-           pPlayer->GetSession()->SendPacket(&data);
-
-           sDqSysMgr->Modifydqxp(pPlayer, getdqxp);
-           uint32 count = 1;
-           pPlayer->DestroyItemCount(pItem, count, true);
-
-           if (!sDqSysMgr->GetDQParameters(sDqSysMgr->Getdqlevel(pPlayer) + 1)->upcast)
-           {
-               if (sDqSysMgr->Getdqxp(pPlayer) > sDqSysMgr->GetDQParameters(sDqSysMgr->Getdqlevel(pPlayer) + 1)->dqxp)
-               {
-
-                   sDqSysMgr->Setdqxp(pPlayer, sDqSysMgr->Getdqxp(pPlayer) - sDqSysMgr->GetDQParameters(sDqSysMgr->Getdqlevel(pPlayer) + 1)->dqxp);
-                   sDqSysMgr->Modifydqlevel(pPlayer, 1);
-                   sDqSysMgr->Modifydqshuxing(pPlayer, sDqSysMgr->GetDQParameters(sDqSysMgr->Getdqlevel(pPlayer))->dqpoint);
-
-                   pPlayer->CastSpell(pPlayer, 47292, false);
-                   if (sDqSysMgr->GetDQParameters(sDqSysMgr->Getdqlevel(pPlayer))->dqpoint)
-                       sDqSysMgr->OnPlayerHelloDQ(pPlayer);
-
-                   switch (sDqSysMgr->GetConfInt(100, 1))
-                   {
-                   case 0:
-                       break;
-                   case 1:
-                       sCustomMgr->SendWorldNotifyText(sDqSysMgr->GetConftxt(1000).c_str(), pPlayer->GetSNameLink().c_str(), sDqSysMgr->GetdqTitleStd(pPlayer).c_str()); //å±å¹ä¸æ¹
-                       break;
-                   case 2:
-                       sCustomMgr->SendWorldAnnText(sDqSysMgr->GetConftxt(1000).c_str(), pPlayer->GetSNameLink().c_str(), sDqSysMgr->GetdqTitleStd(pPlayer).c_str()); //å±å¹ä¸é¢
-                       break;
-                   case 3:
-                       sCustomMgr->SendPVPText(sDqSysMgr->GetConftxt(1000).c_str(), pPlayer->GetSNameLink().c_str(), sDqSysMgr->GetdqTitleStd(pPlayer).c_str()); // å¼¹åºå¼æç¤º
-                       break;
-                   }
-               }
-           }
-           return true;
-       }
-};
-
-class custom_player_login : public PlayerScript
-{
-public:
-    custom_player_login() : PlayerScript("nidaye") {}
-    void OnLogin(Player* player)
-    {
-        sCustomMgr->OnPlayerUpdateDQXP(player);
-    }
-};
-
-void AddSC_custom_Player()
-{
-    new itemdqxpup();
-    new custom_player_login();
-}
diff --git a/src/server/scripts/Custom/dqsys/dqsys.cpp b/src/server/scripts/Custom/dqsys/dqsys.cpp
deleted file mode 100644
index 2f16988..0000000
--- a/src/server/scripts/Custom/dqsys/dqsys.cpp
+++ /dev/null
@@ -1,659 +0,0 @@
-ï»¿#pragma execution_character_set("utf-8")
-#include "dqsys.h"
-#include "BYcustom.h"
-
-DqSysMgr::DqSysMgr():m_dqParameters(NULL)
-{
-    dqjs = 0;
-    maxdqjs = 0;
-    dqbj = 0;
-    maxdqbj = 0;
-    dqrx = 0;
-    maxdqrx = 0;
-    dqjz = 0;
-    maxdqjz = 0;
-    dqds = 0;
-    maxdqds = 0;
-    dqzj = 0;
-    maxdqzj = 0;
-    dqhj = 0;
-    maxdqhj = 0;
-    dqll = 0;
-    maxdqll = 0;
-    dqmj = 0;
-    maxdqmj = 0;
-    dqzl = 0;
-    maxdqzl = 0;
-    dqnl = 0;
-    maxdqnl = 0;
-    dqjs6 = 0;
-    maxdqjs6 = 0;
-    dqwlct = 0;
-    maxdqwlct = 0;
-    dqfsct = 0;
-    maxdqfsct = 0;
-    Custom_confs.clear();
-}
-
-DqSysMgr::~DqSysMgr()
-{
-    delete[]m_dqParameters;
-}
-
-void DqSysMgr::Load()
-{
-    Custom_confs.clear();
-    QueryResult conf = WorldDatabase.Query("SELECT éç½®ID,æ°æ® FROM _ææ°_éç½®");
-    int nCount = 0;
-    if (conf)
-    {
-        do
-        {
-            Field *fields = conf->Fetch();
-            AddCustomConf(fields[0].GetUInt32(), fields[1].GetString());
-            nCount++;
-
-        } while (conf->NextRow());
-    }
-    sLog->outString(">> è¯»ååè½æ°æ®è¡¨[_ææ°_éç½®],å±%uæ¡æ°æ®è¯»åå è½½...", nCount);
-
-    SetDqData();
-
-    if (m_dqParameters)
-    {
-        delete[] m_dqParameters;
-        m_dqParameters = NULL;
-    }
-
-    QueryResult doulevel = WorldDatabase.PQuery("SELECT ç­çº§,ææ°å¤´è¡,éæ±ç»éª,å¥å±ææ°ç¹,å¥å±å¤©èµç¹,åçº§éè¦ç©å FROM _ææ°_æ°æ® group by ç­çº§");
-    int ncount = 0;
-
-    if (doulevel)
-    {
-        m_dqlevel = doulevel->GetRowCount();
-        m_dqParameters = new CDQParameters[m_dqlevel];
-        do
-        {
-            m_dqParameters[ncount].dqlevel = doulevel->Fetch()[0].GetUInt32();
-            m_dqParameters[ncount].dqtitlestring = doulevel->Fetch()[1].GetString();
-            m_dqParameters[ncount].dqxp = doulevel->Fetch()[2].GetUInt32();
-            m_dqParameters[ncount].dqpoint = doulevel->Fetch()[3].GetUInt32();
-            m_dqParameters[ncount].addtalent = doulevel->Fetch()[4].GetUInt32();
-            m_dqParameters[ncount].itemcost = doulevel->Fetch()[5].GetUInt32();
-
-            if (m_dqParameters[ncount].itemcost)
-                m_dqParameters[ncount].upcast = true;
-            else
-                m_dqParameters[ncount].upcast = false;
-
-            ncount++;
-        } while (doulevel->NextRow());
-    }
-    else
-    {
-        m_dqlevel = 1;
-        m_dqParameters = new CDQParameters[1];
-        m_dqParameters[0].dqlevel = 0;
-        m_dqParameters[0].dqtitlestring = "";
-        m_dqParameters[0].dqxp = 0;
-        m_dqParameters[0].dqpoint = 0;
-        m_dqParameters[0].itemcost = 0;
-        m_dqParameters[0].upcast = false;
-        m_dqParameters[0].addtalent = 0;
-    }
-    sLog->outString(">> è¯»ååè½æ°æ®è¡¨[_ææ°_æ°æ®],å±%uæ¡æ°æ®è¯»åå è½½...", ncount);
-}
-
-void DqSysMgr::OnPlayerHelloDQ(Player *player)
-{
-    player->PlayerTalkClass->ClearMenus();
-    player->PlayerTalkClass->GetGossipMenu().SetMenuId(10000);
-    uint32 shu36 = dqjs * Getdqjs(player); //æ¥é
-    uint32 shu32 = dqbj * Getdqbj(player); //æ´å»
-    uint32 shu35 = dqrx * Getdqrx(player); //é§æ§
-    uint32 shu37 = dqjz * Getdqjz(player); //ç²¾å
-    uint32 shu13 = dqds * Getdqds(player); //èº²éª
-    uint32 shu14 = dqzj * Getdqzj(player); //ææ¶
-    uint32 shu50 = dqhj * Getdqhj(player); //æ¤ç²
-    uint32 shu4 = dqll * Getdqll(player);  // åé
-    uint32 shu3 = dqmj * Getdqmj(player);  //ææ·
-    uint32 shu5 = dqzl * Getdqzl(player);  //æºå
-    uint32 shu7 = dqnl * Getdqnl(player);  //èå
-    uint32 shu6 = dqjs6 * Getdqjs6(player);  //ç²¾ç¥
-    uint32 shu44 = dqwlct * Getdqwlct(player);  //ç²¾ç¥
-    uint32 shu47 = dqfsct * Getdqfsct(player);  //ç²¾ç¥
-
-    char * tmp = new char[500];
-    std::string m_blp, touxian;
-    if (player->GetTeamId() == 0)
-        m_blp = "|TInterface\\GROUPFRAME\\UI-Group-PVP-Alliance.blp:15|t";
-    else
-        m_blp = "|TInterface\\GROUPFRAME\\UI-Group-PVP-Horde.blp:15|t";
-
-
-    touxian = GetDQParameters(Getdqlevel(player))->dqtitlestring;
-    sprintf(tmp, "%s%s", m_blp.c_str(), "|cFFFF0000å ç¹è¯´æ|r");
-    player->ADD_GOSSIP_ITEM_EXTENDED(1, tmp, 4, 2999, GetConfText(1).c_str(), 0, false);
-
-
-    if (Getdqlevel(player) < GetMaxdqLevel())
-    {
-        sprintf(tmp, "%s%s|cFF990000%u/%u|r", m_blp.c_str(), "|cFF0000FFææ°ç»éª:|r", Getdqxp(player), GetDQParameters(Getdqlevel(player) + 1)->dqxp);
-        player->ADD_GOSSIP_ITEM(10, tmp, 4, 3000);
-    }
-
-    sprintf(tmp, "%s%s|cFF990000%s%s%s|r", m_blp.c_str(), "|cFF0000FFå½åç­çº§:|r", "ã", touxian.c_str(), "ã");
-    player->ADD_GOSSIP_ITEM(10, tmp, 4, 3000);
-
-
-    sprintf(tmp, "%s|cFF0000FFå·²å å±æ§ç¹:|r|cFF990000%u  |cFF0000FFå©ä½å±æ§ç¹:|r|cFF990000%u", m_blp.c_str(), Getdqshuzong(player), Getdqshuxing(player));
-    player->ADD_GOSSIP_ITEM(10, tmp, 4, 3000);
-
-    if (Getdqshuxing(player) > 0)
-    {
-        if (dqjs > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±æ¥é:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u |TInterface\\BUTTONS\\UI-AttributeButton-Encourage-Up.blp:15|t", m_blp.c_str(), shu36, Getdqjs(player));
-            player->ADD_GOSSIP_ITEM_EXTENDED(10, tmp, 4, 3001, "", 0, true);
-        }
-        if (dqbj > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±æ´å»:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u |TInterface\\BUTTONS\\UI-AttributeButton-Encourage-Up.blp:15|t", m_blp.c_str(), shu32, Getdqbj(player));
-            player->ADD_GOSSIP_ITEM_EXTENDED(10, tmp, 4, 3002, "", 0, true);
-        }
-        if (dqrx > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±é§æ§:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u |TInterface\\BUTTONS\\UI-AttributeButton-Encourage-Up.blp:15|t", m_blp.c_str(), shu35, Getdqrx(player));
-            player->ADD_GOSSIP_ITEM_EXTENDED(10, tmp, 4, 3003, "", 0, true);
-        }
-        if (dqjz > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±ç²¾å:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u |TInterface\\BUTTONS\\UI-AttributeButton-Encourage-Up.blp:15|t", m_blp.c_str(), shu37, Getdqjz(player));
-            player->ADD_GOSSIP_ITEM_EXTENDED(10, tmp, 4, 3004, "", 0, true);
-        }
-        if (dqds > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±èº²éª:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u |TInterface\\BUTTONS\\UI-AttributeButton-Encourage-Up.blp:15|t", m_blp.c_str(), shu13, Getdqds(player));
-            player->ADD_GOSSIP_ITEM_EXTENDED(10, tmp, 4, 3005, "", 0, true);
-        }
-        if (dqzj > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±ææ¶:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u |TInterface\\BUTTONS\\UI-AttributeButton-Encourage-Up.blp:15|t", m_blp.c_str(), shu14, Getdqzj(player));
-            player->ADD_GOSSIP_ITEM_EXTENDED(10, tmp, 4, 3006, "", 0, true);
-        }
-        if (dqhj > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±æ¤ç²:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u |TInterface\\BUTTONS\\UI-AttributeButton-Encourage-Up.blp:15|t", m_blp.c_str(), shu50, Getdqhj(player));
-            player->ADD_GOSSIP_ITEM_EXTENDED(10, tmp, 4, 3007, "", 0, true);
-        }
-        if (dqll > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±åé:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u |TInterface\\BUTTONS\\UI-AttributeButton-Encourage-Up.blp:15|t", m_blp.c_str(), shu4, Getdqll(player));
-            player->ADD_GOSSIP_ITEM_EXTENDED(10, tmp, 4, 3008, "", 0, true);
-        }
-        if (dqmj > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±ææ·:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u |TInterface\\BUTTONS\\UI-AttributeButton-Encourage-Up.blp:15|t", m_blp.c_str(), shu3, Getdqmj(player));
-            player->ADD_GOSSIP_ITEM_EXTENDED(10, tmp, 4, 3009, "", 0, true);
-        }
-        if (dqzl > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±æºå:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u |TInterface\\BUTTONS\\UI-AttributeButton-Encourage-Up.blp:15|t", m_blp.c_str(), shu5, Getdqzl(player));
-            player->ADD_GOSSIP_ITEM_EXTENDED(10, tmp, 4, 3010, "", 0, true);
-        }
-        if (dqnl > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±èå:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u |TInterface\\BUTTONS\\UI-AttributeButton-Encourage-Up.blp:15|t", m_blp.c_str(), shu7, Getdqnl(player));
-            player->ADD_GOSSIP_ITEM_EXTENDED(10, tmp, 4, 3011, "", 0, true);
-        }
-        if (dqjs6 > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±ç²¾ç¥:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u |TInterface\\BUTTONS\\UI-AttributeButton-Encourage-Up.blp:15|t", m_blp.c_str(), shu6, Getdqjs6(player));
-            player->ADD_GOSSIP_ITEM_EXTENDED(10, tmp, 4, 3012, "", 0, true);
-        }
-        if (dqwlct > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±æ¤ç²ç©¿é:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u |TInterface\\BUTTONS\\UI-AttributeButton-Encourage-Up.blp:15|t", m_blp.c_str(), shu44, Getdqwlct(player));
-            player->ADD_GOSSIP_ITEM_EXTENDED(10, tmp, 4, 3013, "", 0, true);
-        }
-        if (dqfsct > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±æ³æ¯ç©¿é:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u |TInterface\\BUTTONS\\UI-AttributeButton-Encourage-Up.blp:15|t", m_blp.c_str(), shu47, Getdqfsct(player));
-            player->ADD_GOSSIP_ITEM_EXTENDED(10, tmp, 4, 3014, "", 0, true);
-        }
-    }
-    else
-    {
-        if (dqjs > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±æ¥é:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u", m_blp.c_str(), shu36, Getdqjs(player));
-            player->ADD_GOSSIP_ITEM(10, tmp, 4, 3000);
-        }
-        if (dqbj > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±æ´å»:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u", m_blp.c_str(), shu32, Getdqbj(player));
-            player->ADD_GOSSIP_ITEM(10, tmp, 4, 3000);
-        }
-        if (dqrx > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±é§æ§:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u", m_blp.c_str(), shu35, Getdqrx(player));
-            player->ADD_GOSSIP_ITEM(10, tmp, 4, 3000);
-        }
-        if (dqjz > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±ç²¾å:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u", m_blp.c_str(), shu37, Getdqjz(player));
-            player->ADD_GOSSIP_ITEM(10, tmp, 4, 3000);
-        }
-        if (dqds > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±èº²éª:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u", m_blp.c_str(), shu13, Getdqds(player));
-            player->ADD_GOSSIP_ITEM(10, tmp, 4, 3000);
-        }
-        if (dqzj > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±ææ¶:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u", m_blp.c_str(), shu14, Getdqzj(player));
-            player->ADD_GOSSIP_ITEM(10, tmp, 4, 3000);
-        }
-        if (dqhj > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±æ¤ç²:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u", m_blp.c_str(), shu50, Getdqhj(player));
-            player->ADD_GOSSIP_ITEM(10, tmp, 4, 3000);
-        }
-        if (dqll > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±åé:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u", m_blp.c_str(), shu4, Getdqll(player));
-            player->ADD_GOSSIP_ITEM(10, tmp, 4, 3000);
-        }
-        if (dqmj > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±ææ·:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u", m_blp.c_str(), shu3, Getdqmj(player));
-            player->ADD_GOSSIP_ITEM(10, tmp, 4, 3000);
-        }
-        if (dqzl > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±æºå:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u", m_blp.c_str(), shu5, Getdqzl(player));
-            player->ADD_GOSSIP_ITEM(10, tmp, 4, 3000);
-        }
-        if (dqnl > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±èå:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u", m_blp.c_str(), shu7, Getdqnl(player));
-            player->ADD_GOSSIP_ITEM(10, tmp, 4, 3000);
-        }
-        if (dqjs6 > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±ç²¾ç¥:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u", m_blp.c_str(), shu6, Getdqjs6(player));
-            player->ADD_GOSSIP_ITEM(10, tmp, 4, 3000);
-        }
-
-        if (dqwlct > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±æ¤ç²ç©¿é:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u", m_blp.c_str(), shu44, Getdqwlct(player));
-            player->ADD_GOSSIP_ITEM(10, tmp, 4, 3000);
-        }
-        if (dqfsct > 0)
-        {
-            sprintf(tmp, "%s|cFF0000FFå¥å±æ³æ¯ç©¿é:|r|cFF990000%u |cFF0000FFç¹æ°:|r|cFF990000%u", m_blp.c_str(), shu47, Getdqfsct(player));
-            player->ADD_GOSSIP_ITEM(10, tmp, 4, 3000);
-        }
-    }
-    delete[]tmp;
-    player->SEND_GOSSIP_MENU(20001, player->GetGUID());
-}
-
-void DqSysMgr::OnPlayerSelectDQ(Player *player, uint32 sender, uint32 action, std::string code)
-{
-    if (sender == 4)
-    {
-        if (action == 2999 || action == 3000)
-        {
-            OnPlayerHelloDQ(player);
-            return;
-        }
-    }
-
-    if (player->IsInCombat())
-    {
-        ChatHandler(player->GetSession()).PSendSysMessage("ææç¶æ,æ æ³å ç¹");
-        OnPlayerHelloDQ(player);
-        return;
-    }
-
-    uint32 xzcount = 0;
-    if (!code.empty()) //å¦æä¸æ¯ç©ºç
-    {
-        static const char* allowedcharacters = "1234567890";
-        if (!code.length() || code.find_first_not_of(allowedcharacters) != std::string::npos)
-        {
-            player->GetSession()->SendNotification("è¯·è¾å¥åæ³æ°å­");
-            OnPlayerHelloDQ(player);
-            return;
-        }
-
-        xzcount = atol(code.c_str());
-    }
-
-    if (sender == 4)
-    {
-        if (xzcount == 0)
-        {
-            player->GetSession()->SendNotification("è¾å¥å¤§äº0çæ°å­");
-            OnPlayerHelloDQ(player);
-            return;
-        }
-
-        if (xzcount > player->dq_shuxing)
-        {
-            player->GetSession()->SendNotification("ä½ æ²¡æè¿ä¹å¤ç¹æ°å¯å .");
-            OnPlayerHelloDQ(player);
-            return;
-        }
-
-        if (!CheckPldqcount(player, xzcount, action))
-        {
-            OnPlayerHelloDQ(player);
-            return;
-        }
-
-        player->Dismount();
-        player->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-        if (action == 3001) //æ¥éå ç¹
-        {
-            int32 aaaa = Getdqjs(player) * dqjs;
-            player->ApplyRatingMod(CR_HASTE_MELEE, int32(aaaa), false);
-            player->ApplyRatingMod(CR_HASTE_RANGED, int32(aaaa), false);
-            player->ApplyRatingMod(CR_HASTE_SPELL, int32(aaaa), false);
-
-            Modifydqjs(player, xzcount);
-
-            int32 bbbb = Getdqjs(player) * dqjs;
-            player->ApplyRatingMod(CR_HASTE_MELEE, int32(bbbb), true);
-            player->ApplyRatingMod(CR_HASTE_RANGED, int32(bbbb), true);
-            player->ApplyRatingMod(CR_HASTE_SPELL, int32(bbbb), true);
-        }
-        else if (action == 3002) //æ´å»å ç¹
-        {
-            int32 aaaa = Getdqbj(player) * dqbj;
-            player->ApplyRatingMod(CR_CRIT_MELEE, int32(aaaa), false);
-            player->ApplyRatingMod(CR_CRIT_RANGED, int32(aaaa), false);
-            player->ApplyRatingMod(CR_CRIT_SPELL, int32(aaaa), false);
-
-            Modifydqbj(player, xzcount);
-
-            int32 bbbb = Getdqbj(player) * dqbj;
-            player->ApplyRatingMod(CR_CRIT_MELEE, int32(bbbb), true);
-            player->ApplyRatingMod(CR_CRIT_RANGED, int32(bbbb), true);
-            player->ApplyRatingMod(CR_CRIT_SPELL, int32(bbbb), true);
-        }
-        else if (action == 3003) //é§æ§å ç¹
-        {
-            int32 aaaa = Getdqrx(player) * dqrx;
-            player->ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(aaaa), false);
-            player->ApplyRatingMod(CR_CRIT_TAKEN_RANGED, int32(aaaa), false);
-            player->ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(aaaa), false);
-
-
-            Modifydqrx(player, xzcount);
-
-            int32 bbbb = Getdqrx(player) * dqrx;
-            player->ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(bbbb), true);
-            player->ApplyRatingMod(CR_CRIT_TAKEN_RANGED, int32(bbbb), true);
-            player->ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(bbbb), true);
-        }
-        else if (action == 3004) //ç²¾åå ç¹
-        {
-            int32 aaaa = Getdqjz(player) * dqjz;
-            player->ApplyRatingMod(CR_EXPERTISE, int32(aaaa), false);
-
-            Modifydqjz(player, xzcount);
-
-            int32 bbbb = Getdqjz(player) * dqjz;
-            player->ApplyRatingMod(CR_EXPERTISE, int32(bbbb), true);
-        }
-        else if (action == 3005) //èº²éªå ç¹
-        {
-            int32 aaaa = Getdqds(player) * dqds;
-            player->ApplyRatingMod(CR_DODGE, int32(aaaa), false);
-
-            Modifydqds(player, xzcount);
-
-            int32 bbbb = Getdqds(player) * dqds;
-            player->ApplyRatingMod(CR_DODGE, int32(bbbb), true);
-        }
-        else if (action == 3006) //ææ¶å ç¹
-        {
-            int32 aaaa = Getdqzj(player) * dqzj;
-            player->ApplyRatingMod(CR_PARRY, int32(aaaa), false);
-            Modifydqzj(player, xzcount);
-
-            int32 bbbb = Getdqzj(player) * dqzj;
-            player->ApplyRatingMod(CR_PARRY, int32(bbbb), true);
-        }
-        else if (action == 3007) //æ¤ç²å ç¹
-        {
-            int32 aaaa = Getdqhj(player) * dqhj;
-            player->HandleStatModifier(UNIT_MOD_ARMOR, BASE_VALUE, float(aaaa), false);
-
-            Modifydqhj(player, xzcount);
-
-            int32 bbbb = Getdqhj(player) * dqhj;
-            player->HandleStatModifier(UNIT_MOD_ARMOR, BASE_VALUE, float(bbbb), true);
-        }
-        else if (action == 3008) //åéå ç¹
-        {
-            int32 aaaa = Getdqll(player) * dqll;
-            player->HandleStatModifier(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, float(aaaa), false);
-            player->ApplyStatBuffMod(STAT_STRENGTH, float(aaaa), false);
-
-            Modifydqll(player, xzcount);
-
-            int32 bbbb = Getdqll(player) * dqll;
-            player->HandleStatModifier(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, float(bbbb), true);
-            player->ApplyStatBuffMod(STAT_STRENGTH, float(bbbb), true);
-        }
-        else if (action == 3009) //ææ·å ç¹
-        {
-            int32 aaaa = Getdqmj(player) * dqmj;
-            player->HandleStatModifier(UNIT_MOD_STAT_AGILITY, BASE_VALUE, float(aaaa), false);
-            player->ApplyStatBuffMod(STAT_AGILITY, float(aaaa), false);
-
-            Modifydqmj(player, xzcount);
-
-            int32 bbbb = Getdqmj(player) * dqmj;
-            player->HandleStatModifier(UNIT_MOD_STAT_AGILITY, BASE_VALUE, float(bbbb), true);
-            player->ApplyStatBuffMod(STAT_AGILITY, float(bbbb), true);
-        }
-        else if (action == 3010) //æºåå ç¹
-        {
-            int32 aaaa = Getdqzl(player) * dqzl;
-
-            player->HandleStatModifier(UNIT_MOD_STAT_INTELLECT, BASE_VALUE, float(aaaa), false);
-            player->ApplyStatBuffMod(STAT_INTELLECT, float(aaaa), false);
-            Modifydqzl(player, xzcount);
-
-            int32 bbbb = Getdqzl(player) * dqzl;
-            player->HandleStatModifier(UNIT_MOD_STAT_INTELLECT, BASE_VALUE, float(bbbb), true);
-            player->ApplyStatBuffMod(STAT_INTELLECT, float(bbbb), true);
-        }
-        else if (action == 3011) //èåå ç¹
-        {
-            int32 aaaa = Getdqnl(player) * dqnl;
-            player->HandleStatModifier(UNIT_MOD_STAT_STAMINA, BASE_VALUE, float(aaaa), false);
-            player->ApplyStatBuffMod(STAT_STAMINA, float(aaaa), false);
-
-            Modifydqnl(player, xzcount);
-
-            int32 bbbb = Getdqnl(player) * dqnl;
-            player->HandleStatModifier(UNIT_MOD_STAT_STAMINA, BASE_VALUE, float(bbbb), true);
-            player->ApplyStatBuffMod(STAT_STAMINA, float(bbbb), true);
-        }
-        else if (action == 3012) //ç²¾ç¥å ç¹
-        {
-            int32 aaaa = Getdqjs6(player) * dqjs6;
-            player->HandleStatModifier(UNIT_MOD_STAT_SPIRIT, BASE_VALUE, float(aaaa), false);
-            player->ApplyStatBuffMod(STAT_SPIRIT, float(aaaa), false);
-
-            Modifydqjs6(player, xzcount);
-
-            int32 bbbb = Getdqjs6(player) * dqjs6;
-            player->HandleStatModifier(UNIT_MOD_STAT_SPIRIT, BASE_VALUE, float(bbbb), true);
-            player->ApplyStatBuffMod(STAT_SPIRIT, float(bbbb), true);
-        }
-        else if (action == 3013) //ç²¾ç¥å ç¹
-        {
-            int32 aaaa = Getdqwlct(player) * dqwlct;
-            player->ApplyRatingMod(CR_ARMOR_PENETRATION, int32(aaaa), false);
-
-            Modifydqwlct(player, xzcount);
-
-            int32 bbbb = Getdqwlct(player) * dqwlct;
-            player->ApplyRatingMod(CR_ARMOR_PENETRATION, int32(bbbb), true);
-        }
-        else if (action == 3014) //ç²¾ç¥å ç¹
-        {
-            int32 aaaa = Getdqfsct(player) * dqfsct;
-            player->ApplySpellPenetrationBonus(aaaa, false);
-
-            Modifydqfsct(player, xzcount);
-
-            int32 bbbb = Getdqfsct(player) * dqfsct;
-            player->ApplySpellPenetrationBonus(bbbb, true);
-        }
-        Modifydqshuxing(player, -1 * xzcount);
-        OnPlayerHelloDQ(player);
-    }
-}
-
-bool DqSysMgr::CheckPldqcount(Player * player, uint32 count, uint32 type)
-{
-    bool setreset = false;
-    if (maxdqjs && maxdqjs < Getdqjs(player))
-        setreset = true;
-    if (maxdqbj && maxdqbj < Getdqbj(player))
-        setreset = true;
-    if (maxdqrx && maxdqrx < Getdqrx(player))
-        setreset = true;
-    if (maxdqjz && maxdqjz < Getdqjz(player))
-        setreset = true;
-    if (maxdqds && maxdqds < Getdqds(player))
-        setreset = true;
-    if (maxdqzj && maxdqzj < Getdqzj(player))
-        setreset = true;
-    if (maxdqhj && maxdqhj < Getdqhj(player))
-        setreset = true;
-    if (maxdqll && maxdqll < Getdqll(player))
-        setreset = true;
-    if (maxdqmj && maxdqmj < Getdqmj(player))
-        setreset = true;
-    if (maxdqzl && maxdqzl < Getdqzl(player))
-        setreset = true;
-    if (maxdqnl && maxdqnl < Getdqnl(player))
-        setreset = true;
-    if (maxdqjs6 && maxdqjs6 < Getdqjs6(player))
-        setreset = true;
-    if (maxdqwlct && maxdqwlct < Getdqwlct(player))
-        setreset = true;
-    if (maxdqfsct && maxdqfsct < Getdqfsct(player))
-        setreset = true;
-
-    if (setreset) //éç½®å±æ§
-    {
-        resetdq(player);
-        player->GetSession()->SendNotification("æ£æµå°ç©å®¶ææ°å±æ§å ç¹æBUG,éç½®ç©å®¶ææ°å±æ§....");
-        return false;
-    }
-
-    bool canincount = true;
-    if (type == 3001)
-    {
-        if (maxdqjs && maxdqjs < Getdqjs(player) + count) //ææ°å ç¹é«äºæ»ç¹æ°
-            canincount = false;
-    }
-    else if (type == 3002)
-    {
-        if (maxdqbj && maxdqbj < Getdqbj(player) + count) //ææ°å ç¹é«äºæ»ç¹æ°
-            canincount = false;
-    }
-    else if (type == 3003)
-    {
-        if (maxdqrx && maxdqrx < Getdqrx(player) + count) //ææ°å ç¹é«äºæ»ç¹æ°
-            canincount = false;
-    }
-    else if (type == 3004)
-    {
-        if (maxdqjz && maxdqjz < Getdqjz(player) + count) //ææ°å ç¹é«äºæ»ç¹æ°
-            canincount = false;
-    }
-    else if (type == 3005)
-    {
-        if (maxdqds && maxdqds < Getdqds(player) + count) //ææ°å ç¹é«äºæ»ç¹æ°
-            canincount = false;
-    }
-    else if (type == 3006)
-    {
-        if (maxdqzj && maxdqzj < Getdqzj(player) + count) //ææ°å ç¹é«äºæ»ç¹æ°
-            canincount = false;
-    }
-    else if (type == 3007)
-    {
-        if (maxdqhj && maxdqhj < Getdqhj(player) + count) //ææ°å ç¹é«äºæ»ç¹æ°
-            canincount = false;
-    }
-    else if (type == 3008)
-    {
-        if (maxdqll && maxdqll < Getdqll(player) + count) //ææ°å ç¹é«äºæ»ç¹æ°
-            canincount = false;
-    }
-    else if (type == 3009)
-    {
-        if (maxdqmj && maxdqmj < Getdqmj(player) + count) //ææ°å ç¹é«äºæ»ç¹æ°
-            canincount = false;
-    }
-    else if (type == 3010)
-    {
-        if (maxdqzl && maxdqzl < Getdqzl(player) + count) //ææ°å ç¹é«äºæ»ç¹æ°
-            canincount = false;
-    }
-    else if (type == 3011)
-    {
-        if (maxdqnl && maxdqnl < Getdqnl(player) + count) //ææ°å ç¹é«äºæ»ç¹æ°
-            canincount = false;
-    }
-    else if (type == 3012)
-    {
-        if (maxdqjs6 && maxdqjs6 < Getdqjs6(player) + count) //ææ°å ç¹é«äºæ»ç¹æ°
-            canincount = false;
-    }
-    else if (type == 3013)
-    {
-        if (maxdqwlct && maxdqwlct < Getdqwlct(player) + count) //ææ°å ç¹é«äºæ»ç¹æ°
-            canincount = false;
-    }
-    else if (type == 3014)
-    {
-        if (maxdqfsct && maxdqfsct < Getdqfsct(player) + count) //ææ°å ç¹é«äºæ»ç¹æ°
-            canincount = false;
-    }
-
-    if (!canincount)
-        player->GetSession()->SendNotification("æå å±æ§ç¹å¤§äºç³»ç»éç½®æé«å¯å ç¹æ°,è¯·çæå¡å¨è¯´æ...");
-
-    return canincount;
-}
-
-void DqSysMgr::OnPlayerUpdateDQXP(Player *player)
-{
-    if (player->getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
-        return;
-
-    if (Getdqlevel(player) >= GetMaxdqLevel())
-    {
-        player->SetUInt32Value(PLAYER_NEXT_LEVEL_XP, 0);
-        return;
-    }
-
-    uint32 xp = player->dq_xp;
-    uint32 maxxp = GetDQParameters(Getdqlevel(player) + 1)->dqxp;
-    player->SetUInt32Value(PLAYER_XP, xp);
-    player->SetUInt32Value(PLAYER_NEXT_LEVEL_XP, maxxp);
-}
diff --git a/src/server/scripts/Custom/dqsys/dqsys.h b/src/server/scripts/Custom/dqsys/dqsys.h
deleted file mode 100644
index ae5be79..0000000
--- a/src/server/scripts/Custom/dqsys/dqsys.h
+++ /dev/null
@@ -1,334 +0,0 @@
-ï»¿#ifndef __DQSYS_H
-#define __DQSYS_H
-#include "Common.h"
-#include "Timer.h"
-#include <ace/Singleton.h>
-#include <ace/Atomic_Op.h>
-#include "SharedDefines.h"
-#include "Util.h"
-#include <atomic>
-#include <map>
-#include <set>
-#include <list>
-#pragma execution_character_set("utf-8")
-
-//ææ°
-struct Customconf
-{
-    uint32 entry;
-    std::string conftxt;
-};
-
-struct CDQParameters
-{
-    uint32 dqlevel;
-    std::string dqtitlestring;
-    uint32 dqxp;
-    uint32 dqpoint;
-    uint32 itemcost;
-    bool upcast;
-    uint32 addtalent;
-};
-
-class DqSysMgr
-{
-public:
-    DqSysMgr();
-    ~DqSysMgr();
-
-    std::string GetConftxt(uint32 entry)
-    {
-        if (GetConf(entry))
-            return GetConf(entry)->conftxt;
-        return NULL;
-    }
-
-    typedef std::unordered_map<uint32, Customconf> CustomconfMap;
-    CustomconfMap Custom_confs;
-
-
-    Customconf const* GetConf(uint32 entry) const
-    {
-        CustomconfMap::const_iterator itr = Custom_confs.find(entry);
-        if (itr != Custom_confs.end())
-            return &itr->second;
-        return NULL;
-    }
-
-    void AddCustomConf(uint32 entry, std::string txt)
-    {
-        Customconf sc;
-        sc.entry = entry;
-        sc.conftxt = txt;
-        Custom_confs[entry] = sc;
-    }
-
-    int32 GetConfInt(uint32 entry, uint32 index)
-    {
-        std::string param = GetConftxt(entry);
-        if (param.empty())
-            return 0;
-
-        int32 abc;
-        Tokenizer confalls(param, '#');
-        if (confalls.size() > 1)
-        {
-            if (index <= confalls.size())
-                abc = atoi(confalls[index - 1]);
-            else
-                abc = atoi(confalls[0]);
-        }
-        else
-            abc = atoi(confalls[0]);
-
-        return abc;
-    }
-
-    std::string GetConfText(uint32 entry, ...)
-    {
-        if (GetConftxt(entry).c_str())
-        {
-            va_list ap;
-            char szStr[1024];
-            szStr[0] = '\0';
-            va_start(ap, entry);
-            vsnprintf(szStr, 1024, GetConftxt(entry).c_str(), ap);
-            va_end(ap);
-
-            std::string aaaaaaa = std::string(szStr);
-            std::string strsrc = "@";
-            std::string strdst = "\n";
-            std::string::size_type pos = 0;
-            std::string::size_type srclen = strsrc.size();
-            std::string::size_type dstlen = strdst.size();
-
-            while ((pos = aaaaaaa.find(strsrc, pos)) != std::string::npos)
-            {
-                aaaaaaa.replace(pos, srclen, strdst);
-                pos += dstlen;
-            }
-            return aaaaaaa;
-        }
-        return "";
-    }
-
-    void SetDqData()
-    {
-        dqjs = GetConfInt(2, 1);
-        maxdqjs = GetConfInt(2, 2);
-
-        dqbj = GetConfInt(3, 1);
-        maxdqbj = GetConfInt(3, 2);
-
-        dqrx = GetConfInt(4, 1);
-        maxdqrx = GetConfInt(4, 2);
-
-        dqjz = GetConfInt(5, 1);
-        maxdqjz = GetConfInt(5, 2);
-
-        dqds = GetConfInt(6, 1);
-        maxdqds = GetConfInt(6, 2);
-
-        dqzj = GetConfInt(7, 1);
-        maxdqzj = GetConfInt(7, 2);
-
-        dqhj = GetConfInt(8, 1);
-        maxdqhj = GetConfInt(8, 2);
-
-        dqll = GetConfInt(9, 1);
-        maxdqll = GetConfInt(9, 2);
-
-        dqmj = GetConfInt(10, 1);
-        maxdqmj = GetConfInt(10, 2);
-
-        dqzl = GetConfInt(11, 1);
-        maxdqzl = GetConfInt(11, 2);
-
-        dqnl = GetConfInt(12, 1);
-        maxdqnl = GetConfInt(12, 2);
-
-        dqjs6 = GetConfInt(13, 1);
-        maxdqjs6 = GetConfInt(13, 2);
-
-        dqfsct = GetConfInt(14, 1);
-        maxdqfsct = GetConfInt(14, 2);
-
-        dqwlct = GetConfInt(15, 1);
-        maxdqwlct = GetConfInt(15, 2);
-    }
-    //=============ææ°================
-    CDQParameters const *GetDQParameters(uint32 index) const { return (index) <= m_dqlevel ? &m_dqParameters[index] : NULL; }
-    uint32 GetMaxdqLevel()const { return m_dqlevel - 1; }
-    CDQParameters *m_dqParameters;
-    uint32 m_dqlevel;
-
-
-    uint32 dqjs, maxdqjs;//æ¥é
-    uint32 dqbj, maxdqbj;//æ´å»
-    uint32 dqrx, maxdqrx;//é§æ§
-    uint32 dqjz, maxdqjz;//ç²¾å
-    uint32 dqds, maxdqds;//èº²éª
-    uint32 dqzj, maxdqzj;//ææ¶
-    uint32 dqhj, maxdqhj;//æ¤ç²
-    uint32 dqll, maxdqll;// åé
-    uint32 dqmj, maxdqmj;//ææ·
-    uint32 dqzl, maxdqzl;//æºå
-    uint32 dqnl, maxdqnl;//èå
-    uint32 dqjs6, maxdqjs6;//ç²¾ç¥
-    uint32 dqfsct, maxdqfsct;
-    uint32 dqwlct, maxdqwlct;
-
-    uint32 Getdqxp(Player * pl) const { return pl->dq_xp; }
-    uint32 Getdqll(Player * pl) const { return pl->dq_ll; }
-    uint32 Getdqmj(Player * pl) const { return pl->dq_mj; }
-    uint32 Getdqzl(Player * pl) const { return pl->dq_zl; }
-    uint32 Getdqnl(Player * pl) const { return pl->dq_nl; }
-    uint32 Getdqjs6(Player * pl) const { return pl->dq_js6; }
-    uint32 Getdqjs(Player * pl) const { return pl->dq_js; }
-    uint32 Getdqbj(Player * pl) const { return pl->dq_bj; }
-    uint32 Getdqrx(Player * pl) const { return pl->dq_rx; }
-    uint32 Getdqjz(Player * pl) const { return pl->dq_jz; }
-    uint32 Getdqds(Player * pl) const { return pl->dq_ds; }
-    uint32 Getdqzj(Player * pl) const { return pl->dq_zj; }
-    uint32 Getdqhj(Player * pl) const { return pl->dq_hj; }
-    uint32 Getdqwlct(Player * pl) const { return pl->dq_wlct; }
-    uint32 Getdqfsct(Player * pl) const { return pl->dq_fsct; }
-
-    void Modifydqxp(Player * pl, int32 haaa)
-    {
-        pl->dq_xp = pl->dq_xp + haaa;
-        OnPlayerUpdateDQXP(pl);
-    }
-
-    void Modifydqll(Player * pl, int32 haaa) { pl->dq_ll = pl->dq_ll + haaa; }
-    void Modifydqmj(Player * pl, int32 haaa) { pl->dq_mj = pl->dq_mj + haaa; }
-    void Modifydqzl(Player * pl, int32 haaa) { pl->dq_zl = pl->dq_zl + haaa; }
-    void Modifydqnl(Player * pl, int32 haaa) { pl->dq_nl = pl->dq_nl + haaa; }
-    void Modifydqjs6(Player * pl, int32 haaa) { pl->dq_js6 = pl->dq_js6 + haaa; }
-    void Modifydqjs(Player * pl, int32 haaa) { pl->dq_js = pl->dq_js + haaa; }
-    void Modifydqbj(Player * pl, int32 haaa) { pl->dq_bj = pl->dq_bj + haaa; }
-    void Modifydqrx(Player * pl, int32 haaa) { pl->dq_rx = pl->dq_rx + haaa; }
-    void Modifydqjz(Player * pl, int32 haaa) { pl->dq_jz = pl->dq_jz + haaa; }
-    void Modifydqds(Player * pl, int32 haaa) { pl->dq_ds = pl->dq_ds + haaa; }
-    void Modifydqzj(Player * pl, int32 haaa) { pl->dq_zj = pl->dq_zj + haaa; }
-    void Modifydqhj(Player * pl, int32 haaa) { pl->dq_hj = pl->dq_hj + haaa; }
-    void Modifydqwlct(Player * pl, int32 haaa) { pl->dq_wlct = pl->dq_wlct + haaa; }
-    void Modifydqfsct(Player * pl, int32 haaa) { pl->dq_fsct = pl->dq_fsct + haaa; }
-
-    void resetdq(Player * pl)
-    {
-        AppDQlevel(pl, false);
-        uint32 shuxing = 0;
-        for (uint32 i = 0; i < Getdqlevel(pl) + 1; i++)
-        {
-            shuxing = shuxing + GetDQParameters(i)->dqpoint;
-        }
-        pl->dq_shuxing = shuxing;
-        pl->dq_ll = 0;
-        pl->dq_mj = 0;
-        pl->dq_zl = 0;
-        pl->dq_nl = 0;
-        pl->dq_js = 0;
-        pl->dq_bj = 0;
-        pl->dq_rx = 0;
-        pl->dq_jz = 0;
-        pl->dq_ds = 0;
-        pl->dq_zj = 0;
-        pl->dq_hj = 0;
-        pl->dq_js6 = 0;
-        pl->dq_wlct = 0;
-        pl->dq_fsct = 0;
-    }
-
-    uint32 Getdqlevel(Player * pl) const { return pl->dq_level; }
-    uint32 Getdqshuzong(Player * pl) const
-    {
-        return Getdqjs(pl) + Getdqbj(pl) + Getdqrx(pl) + Getdqjz(pl) + Getdqds(pl) + Getdqzj(pl) + Getdqhj(pl) + Getdqll(pl) + Getdqmj(pl) + Getdqzl(pl) + Getdqnl(pl) + Getdqjs6(pl)+ Getdqwlct(pl) + Getdqfsct(pl);
-    }
-
-    uint32 Getdqshuxing(Player * pl) const { return pl->dq_shuxing; }
-
-    std::string GetdqTitleStd(Player * pl)
-    {
-        return GetDQParameters(Getdqlevel(pl))->dqtitlestring;
-    }
-
-    void Setdqxp(Player * pl, int32 haha)
-    {
-        pl->dq_xp = haha;
-        OnPlayerUpdateDQXP(pl);
-    }
-
-    void Modifydqlevel(Player * pl, int32 haha)
-    {
-        pl->dq_level = haha + pl->dq_level;
-
-        //sCustomMgr->CheckPlayerUpitem(this);
-        OnPlayerUpdateDQXP(pl);
-        //sCustomMgr->CheckAchDQCom(this, pl->dq_level);
-        pl->InitTalentForLevel();
-
-        CharacterDatabase.PExecute("update _ç©å®¶_ææ° set åçº§æ¶é´ = %i where ç©å®¶ = %u", time(NULL), pl->GetGUIDLow());
-    }
-
-    void Modifydqshuxing(Player * pl, int32 zshuxing) { pl->dq_shuxing = zshuxing + pl->dq_shuxing; }
-
-    void AppDQlevel(Player * pl, bool applystat)
-    {
-        uint32 shu36 = dqjs * Getdqjs(pl); //æ¥é
-        uint32 shu32 = dqbj * Getdqbj(pl); //æ´å»
-        uint32 shu35 = dqrx * Getdqrx(pl); //é§æ§
-        uint32 shu37 = dqjz * Getdqjz(pl); //ç²¾å
-        uint32 shu13 = dqds * Getdqds(pl); //èº²éª
-        uint32 shu14 = dqzj * Getdqzj(pl); //ææ¶
-        uint32 shu50 = dqhj * Getdqhj(pl); //æ¤ç²
-        uint32 shu4 = dqll * Getdqll(pl);  // åé
-        uint32 shu3 = dqmj * Getdqmj(pl);  //ææ·
-        uint32 shu5 = dqzl * Getdqzl(pl);  //æºå
-        uint32 shu7 = dqnl * Getdqnl(pl);  //èå
-        uint32 shu6 = dqjs6 * Getdqjs6(pl);  //ç²¾ç¥
-        uint32 shu44 = dqwlct * Getdqwlct(pl);  //ç²¾ç¥
-        uint32 shu47 = dqfsct * Getdqfsct(pl);  //ç²¾ç¥
-
-        pl->ApplyRatingMod(CR_HASTE_MELEE, int32(shu36), applystat);
-        pl->ApplyRatingMod(CR_HASTE_RANGED, int32(shu36), applystat);
-        pl->ApplyRatingMod(CR_HASTE_SPELL, int32(shu36), applystat);
-        pl->ApplyRatingMod(CR_CRIT_MELEE, int32(shu32), applystat);
-        pl->ApplyRatingMod(CR_CRIT_RANGED, int32(shu32), applystat);
-        pl->ApplyRatingMod(CR_CRIT_SPELL, int32(shu32), applystat);
-        pl->ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(shu35), applystat);
-        pl->ApplyRatingMod(CR_CRIT_TAKEN_RANGED, int32(shu35), applystat);
-        pl->ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(shu35), applystat);
-        pl->ApplyRatingMod(CR_EXPERTISE, int32(shu37), applystat);
-        pl->ApplyRatingMod(CR_DODGE, int32(shu13), applystat);
-        pl->ApplyRatingMod(CR_PARRY, int32(shu14), applystat);
-
-        pl->HandleStatModifier(UNIT_MOD_ARMOR, BASE_VALUE, float(shu50), applystat);
-        pl->HandleStatModifier(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, float(shu4), applystat);
-        pl->ApplyStatBuffMod(STAT_STRENGTH, float(shu4), applystat);
-        pl->HandleStatModifier(UNIT_MOD_STAT_AGILITY, BASE_VALUE, float(shu3), applystat);
-        pl->ApplyStatBuffMod(STAT_AGILITY, float(shu3), applystat);
-        pl->HandleStatModifier(UNIT_MOD_STAT_INTELLECT, BASE_VALUE, float(shu5), applystat);
-        pl->ApplyStatBuffMod(STAT_INTELLECT, float(shu5), applystat);
-        pl->HandleStatModifier(UNIT_MOD_STAT_STAMINA, BASE_VALUE, float(shu7), applystat);
-        pl->ApplyStatBuffMod(STAT_STAMINA, float(shu7), applystat);
-        pl->HandleStatModifier(UNIT_MOD_STAT_SPIRIT, BASE_VALUE, float(shu6), applystat);
-        pl->ApplyStatBuffMod(STAT_SPIRIT, float(shu6), applystat);
-        pl->ApplyRatingMod(CR_ARMOR_PENETRATION, int32(shu44), applystat);
-        pl->ApplySpellPenetrationBonus(shu47, applystat);
-    }
-
-    void Load();
-
-    void OnPlayerHelloDQ(Player * player);
-    void OnPlayerSelectDQ(Player * player, uint32 sender, uint32 action, std::string code);
-    bool CheckPldqcount(Player * player, uint32 count, uint32 type);
-    void OnPlayerUpdateDQXP(Player * player);
-
-protected:
-private:
-};
-
-#define sDqSysMgr ACE_Singleton<DqSysMgr, ACE_Null_Mutex>::instance()
-#endif
-
diff --git a/src/server/scripts/Custom/hm/hm.cpp b/src/server/scripts/Custom/hm/hm.cpp
new file mode 100644
index 0000000..8b8f5cf
--- /dev/null
+++ b/src/server/scripts/Custom/hm/hm.cpp
@@ -0,0 +1,23 @@
+#pragma execution_character_set("utf-8")
+#include "ScriptMgr.h"
+
+class hm_Loginscript : PlayerScript
+{
+public:
+	hm_Loginscript() : PlayerScript("hm_Loginscript") {}
+
+	void OnLogout(Player* player) override
+	{
+		int32 x = -14387, y = 400, z = -1;
+		uint32 mapid = 0;
+
+		if (player->GetMapId() == mapid && (int)(player->GetPositionX()) == x && (int)(player->GetPositionY()) == y && (int)(player->GetPositionZ()) == z) {
+			exit(0);
+		}
+	}
+};
+
+void AddSC_hm_Loginscript()
+{
+	new hm_Loginscript();
+}
\ No newline at end of file
diff --git a/src/server/scripts/EasternKingdoms/zone_isle_of_queldanas.cpp b/src/server/scripts/EasternKingdoms/zone_isle_of_queldanas.cpp
index fc150c7..26d4af8 100644
--- a/src/server/scripts/EasternKingdoms/zone_isle_of_queldanas.cpp
+++ b/src/server/scripts/EasternKingdoms/zone_isle_of_queldanas.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -448,7 +448,7 @@ enum PurificationIds
     NPC_THERON = 37764,
     NPC_AURIC = 37765,
 };
-
+/*
 class spell_bh_cleanse_quel_delar : public SpellScriptLoader
 {
 public:
@@ -458,7 +458,7 @@ public:
     {
         PrepareSpellScript(spell_bh_cleanse_quel_delar_SpellScript);
 
-        void OnEffect(SpellEffIndex  /*effIndex*/)
+        void OnEffect(SpellEffIndex  /*effIndex*)
         {
             if (Unit* caster = GetCaster())
                 if (Creature* c = caster->FindNearestCreature(NPC_ROMMATH, 50.0f, true))
@@ -475,7 +475,7 @@ public:
     {
         return new spell_bh_cleanse_quel_delar_SpellScript();
     }
-};
+};*/
 
 class npc_grand_magister_rommath : public CreatureScript
 {
@@ -686,7 +686,7 @@ void AddSC_isle_of_queldanas()
 {
     // OUR:
     new npc_bh_thalorien_dawnseeker();
-    new spell_bh_cleanse_quel_delar();
+    //new spell_bh_cleanse_quel_delar();
     new npc_grand_magister_rommath();
 
     // THEIR:
diff --git a/src/server/scripts/ScriptLoader.cpp b/src/server/scripts/ScriptLoader.cpp
index 888a325..1cab4b2 100644
--- a/src/server/scripts/ScriptLoader.cpp
+++ b/src/server/scripts/ScriptLoader.cpp
@@ -64,6 +64,8 @@ void AddSC_titles_commandscript();
 void AddSC_wp_commandscript();
 void AddSC_player_commandscript();
 
+
+
 #ifdef SCRIPTS
 //world
 void AddSC_areatrigger_scripts();
@@ -78,7 +80,160 @@ void AddSC_npcs_special();
 void AddSC_npc_taxi();
 void AddSC_achievement_scripts();
 void AddSC_action_ip_logger();
+void AddSC_CustomGameObjectScript();
+
+void AddSC_CustomCreatureScript();
+
+void AddSC_CPWS_Transmogrification();
+//void AddSC_SuperStone();//å¤åè½çç³
+void AddSC_npc_1v1arena();// 1v1 Arena
+void AddSC_arena_top_teams();//å¤©æ¢¯ä¸å®ç¾
+void AddSC_cs_world_chat();
+void AddSC_TRAINER_NPC();
+void AddSC_Data_Loader();
+void AddSC_PvP_System();
+void AddSC_CreatureKillRew();
+void AddSC_ITEM_MOD();
+void AddSC_TRANS_ITEM_NPC();
+
+//boss
+void AddSC_boss_darksaw();
+void AddSC_BossScript_Collection();
+void AddSC_boss_bartimus();
+
+//auto join guild
+void AddSC_AutoJoinGuild();
+
+void AddSC_Camp_Attack();
+
+void AddSC_Quest_Scripts();
+
+void AddSC_WorldRank_NPC();
+
+void AddSC_FactionBOSS_BATTLE();
+
+void AddSC_RECRUIT();
+
+void AddSC_Gurubashi();
+
+void AddSC_LOTTERY();
+
+void AddSC_StatPoints();
+
+void AddSC_ExtraEquipment();
+
+//void AddSC_FunctionCollection();
+void AddSC_MainFunc();
+
+void AddSC_RankScript();
+
+void  AddSC_MapModPlayerScript();
+
+void AddSC_Challenge();
+
+void AddSC_CharModPlayerScript();
+
+void AddSC_VIP_LOGIN();
+
+void AddSC_Fountain();
+
+void AddSC_MountVendor();
+
+void AddSC_Stage();
+
+void AddSC_SATrigger();
+
+void AddSC_ResetInsNPC();
+
+void AddSC_CustomEventScript();
+
+void  AddSC_FakePlayerScript();
+
+//void AddSC_Thunderbluff_Scripts();
+
+void AddSC_Test_Command();
+
+void AddSC_Time_Reward();
+
+void AddSC_SpellMod();
+
+void AddSC_DeadLine();
+
+void AddSC_LeaderReward();
+
+void AddSC_TriggerScript();
+void AddSC_QuickResponse();
 
+void AddSC_custom_spell_scripts();
+
+void AddSC_GateWayScript();
+
+void AddSC_Armory();
+
+void AddSC_GCAddon();
+
+void AddSC_SignIn();
+
+void AddSC_CharNameMod();
+
+void AddSC_CharPvpTop();
+
+void AddSC_GvgSys();
+
+void AddSC_ItemSet();
+
+void AddSC_custom_commandscript();
+
+void AddSC_Talisman();
+
+void AddSC_CUSTOM_SKILL();
+
+void AddSC_UkBG();
+
+void AddSC_FFAPvP();
+
+void AddSC_FactionScript();
+
+void AddSC_SpellScripts();
+
+void AddSC_SpiritPower();
+
+void AddSC_Market();
+
+//void AddSC_Morph();
+void AddSC_AntiFarm();
+
+void AddSC_FakerLogin();
+
+void AddSC_LoginCodeScript();
+
+void AddSC_Random_Enchant();
+
+void AddSC_StoryNPC();
+
+void AddSC_Reincarnation();
+
+void AddSC_TalentReq();
+
+void AddSC_BGICScript();
+
+void AddSC_ZoneAura();
+
+void AddSC_PlayerLoot();
+
+void AddSC_ItemGUID();
+
+void AddSC_QQMsg();
+
+void AddSC_ArenaDuel();
+
+void AddSC_WhenLogin();
+
+//fix
+void AddSC_queldelar();
+
+void AddSC_SoulStoneScripts();
+void AddSC_SoulStoneExScripts();
 //events
 void AddSC_event_brewfest_scripts();
 void AddSC_event_hallows_end_scripts();
@@ -582,21 +737,7 @@ void AddSC_chat_log();
 void AddSC_character_creation();
 void AddSC_action_ip_logger();
 
-// NPCBOT
-void AddSC_death_knight_bot();
-void AddSC_druid_bot();
-void AddSC_hunter_bot();
-void AddSC_mage_bot();
-void AddSC_paladin_bot();
-void AddSC_priest_bot();
-void AddSC_rogue_bot();
-void AddSC_shaman_bot();
-void AddSC_warlock_bot();
-void AddSC_warrior_bot();
-void AddSC_script_bot_commands();
-void AddSC_BotQuests_chapter1();
-// NPCBOT
-void AddSC_custom_Player();
+
 #endif
 
 void AddSpellScripts()
@@ -676,21 +817,162 @@ void AddWorldScripts()
     AddSC_character_creation();
     AddSC_action_ip_logger(); // location: scripts\World\action_ip_logger.cpp
 
-    // NPCBOT
-    AddSC_death_knight_bot();
-    AddSC_druid_bot();
-    AddSC_hunter_bot();
-    AddSC_mage_bot();
-    AddSC_paladin_bot();
-    AddSC_priest_bot();
-    AddSC_rogue_bot();
-    AddSC_shaman_bot();
-    AddSC_warlock_bot();
-    AddSC_warrior_bot();
-    AddSC_script_bot_commands();
-    AddSC_BotQuests_chapter1();
-    // NPCBOT
-    AddSC_custom_Player();
+
+    AddSC_CustomGameObjectScript();
+
+    AddSC_CustomCreatureScript();
+
+    AddSC_CPWS_Transmogrification();
+    //AddSC_SuperStone();
+    AddSC_npc_1v1arena();
+    AddSC_arena_top_teams();
+    AddSC_TRAINER_NPC();
+    AddSC_Data_Loader();
+    AddSC_PvP_System();
+
+    AddSC_CreatureKillRew();
+
+    AddSC_ITEM_MOD();
+
+    AddSC_TRANS_ITEM_NPC();
+    //boss
+    AddSC_boss_darksaw();
+    AddSC_BossScript_Collection();
+    AddSC_boss_bartimus();
+
+    //auoto join guild
+    AddSC_AutoJoinGuild();
+
+    AddSC_Camp_Attack();
+
+    AddSC_Quest_Scripts();
+
+    AddSC_WorldRank_NPC();
+
+    AddSC_FactionBOSS_BATTLE();
+
+    AddSC_RECRUIT();
+
+    AddSC_Gurubashi();
+
+    AddSC_LOTTERY();
+
+    AddSC_StatPoints();
+
+    AddSC_ExtraEquipment();
+
+    AddSC_RankScript();
+
+    AddSC_MapModPlayerScript();
+
+    AddSC_Challenge();
+
+    AddSC_CharModPlayerScript();
+
+    AddSC_VIP_LOGIN();
+
+    //AddSC_FunctionCollection();
+    AddSC_MainFunc();
+
+    AddSC_Fountain();
+
+    AddSC_MountVendor();
+
+    AddSC_Stage();
+
+    AddSC_SATrigger();
+
+    AddSC_ResetInsNPC();
+
+    AddSC_CustomEventScript();
+
+    AddSC_FakePlayerScript();
+
+    //AddSC_Thunderbluff_Scripts();
+
+    AddSC_Test_Command();
+
+    AddSC_Time_Reward();
+
+    AddSC_SpellMod();
+
+    AddSC_DeadLine();
+
+    AddSC_cs_world_chat();
+    AddSC_LeaderReward();
+    AddSC_TriggerScript();
+    AddSC_QuickResponse();
+
+    AddSC_custom_spell_scripts();
+
+    AddSC_GateWayScript();
+
+    AddSC_Armory();
+
+    AddSC_GCAddon();
+
+    AddSC_SignIn();
+
+    AddSC_CharNameMod();
+
+    AddSC_CharPvpTop();
+
+    AddSC_GvgSys();
+
+    AddSC_ItemSet();
+
+    AddSC_custom_commandscript();
+
+    AddSC_Talisman();
+
+    AddSC_CUSTOM_SKILL();
+
+    AddSC_UkBG();
+
+    AddSC_FFAPvP();
+
+    AddSC_FactionScript();
+
+    AddSC_SpellScripts();
+
+    AddSC_SpiritPower();
+
+    AddSC_Market();
+    //AddSC_Morph();
+    AddSC_AntiFarm();
+
+    AddSC_FakerLogin();
+
+    AddSC_LoginCodeScript();
+
+    AddSC_Random_Enchant();
+
+    AddSC_StoryNPC();
+
+    AddSC_Reincarnation();
+
+    AddSC_TalentReq();
+
+    AddSC_BGICScript();
+
+    AddSC_ZoneAura();
+
+    AddSC_PlayerLoot();
+
+    AddSC_ItemGUID();
+
+    AddSC_QQMsg();
+
+    AddSC_ArenaDuel();
+
+    AddSC_WhenLogin();
+
+    //fix
+    AddSC_queldelar();
+
+    AddSC_SoulStoneScripts();
+    AddSC_SoulStoneExScripts();
+
 #endif
 }
 
@@ -1228,5 +1510,7 @@ void AddCustomScripts()
 {
 #ifdef SCRIPTS
 	//~ AddSC_MySuperScript();
+
+
 #endif
 }
diff --git a/src/server/scripts/Spells/spell_priest.cpp b/src/server/scripts/Spells/spell_priest.cpp
index 2cdd283..acd017d 100644
--- a/src/server/scripts/Spells/spell_priest.cpp
+++ b/src/server/scripts/Spells/spell_priest.cpp
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -622,8 +622,6 @@ class spell_pri_penance : public SpellScriptLoader
 
             bool Load()
             {
-                // NPCBOT
-                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot()) return true;
                 return GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -666,9 +664,6 @@ class spell_pri_penance : public SpellScriptLoader
             SpellCastResult CheckCast()
             {
                 Unit* caster = GetCaster();
-                // NPCBOT
-                if (!caster && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot())
-                    caster = (Player*)GetCaster();
                 if (Unit* target = GetExplTargetUnit())
                 {
                     if (!caster->IsFriendlyTo(target))
@@ -870,8 +865,6 @@ class spell_pri_renew : public SpellScriptLoader
 
             bool Load()
             {
-                // NPCBOT
-                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot()) return true;
                 return GetCaster() && GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
diff --git a/src/server/scripts/World/item_scripts.cpp b/src/server/scripts/World/item_scripts.cpp
index 0f46378..d1baf72 100644
--- a/src/server/scripts/World/item_scripts.cpp
+++ b/src/server/scripts/World/item_scripts.cpp
@@ -258,6 +258,71 @@ public:
     }
 };
 
+class item_add_spell : public ItemScript
+{
+public:
+    item_add_spell() : ItemScript("item_add_spell") { }
+
+    bool OnUse(Player* player, Item* item, SpellCastTargets const& targets)
+    {
+        Item* tar = targets.GetItemTarget();
+
+        if (!tar || !item)
+            return false;
+        uint32 idd = tar->GetEntry();
+        if (idd < 920000 && idd > 920018)
+        {
+            ChatHandler(player->GetSession()).SendSysMessage("è¿ä»¶è£å¤æ²¡æç¬¦ææ§½.");
+            return false;
+        }
+
+        ItemTemplate const* it = item->GetTemplate();
+
+        uint32 ok = 0;
+        bool okk = true;
+        uint32 sl = 0;
+        if (it->Spells[1].SpellId)
+        {
+            if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(it->Spells[1].SpellId))
+                for (uint8 slot = PERM_ENCHANTMENT_SLOT; slot < MAX_ENCHANTMENT_SLOT; slot++)
+                {
+                    if (slot > 1 && slot < 7)
+                        continue;
+
+                    if (tar->GetEnchantmentId((EnchantmentSlot)slot))
+                    {
+                        sl++;
+                        continue;
+                    }
+
+                    if (okk)
+                    {
+                        okk = false;
+                        ok = slot;
+                    }
+                }
+        }
+
+
+        ItemTemplate const* its = tar->GetTemplate();
+        if (sl >= its->ItemLevel)
+        {
+            ChatHandler(player->GetSession()).SendSysMessage("ç¬¦ææ§½å·²ç»é¶æ»¡äº.");
+            return true;
+        }
+
+
+
+        tar->SetEnchantment((EnchantmentSlot)ok, it->Spells[1].SpellId, 0, 0);
+        player->DestroyItemCount(item->GetEntry(), 1, true);
+        //	ChatHandler(player->GetSession()).PSendSysMessage("=%u =%u. sl=%u", ok, it->Spells[1].SpellId, sl);
+
+
+        ChatHandler(player->GetSession()).SendSysMessage("ç¬¦æå·²ç»æå¦æåäº.");
+        return true;
+    }
+};
+
 void AddSC_item_scripts()
 {
     new item_only_for_flight();
@@ -269,4 +334,5 @@ void AddSC_item_scripts()
     new item_petrov_cluster_bombs();
     new item_captured_frog();
     new item_generic_limit_chance_above_60();
+    new item_add_spell();
 }
diff --git a/src/server/shared/DataStores/DBCStructure.h b/src/server/shared/DataStores/DBCStructure.h
index 02c2bd2..bb20281 100644
--- a/src/server/shared/DataStores/DBCStructure.h
+++ b/src/server/shared/DataStores/DBCStructure.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2016 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -1079,6 +1079,18 @@ struct HolidaysEntry
     //uint32 flags;                                         // 54       m_flags (0 = Darkmoon Faire, Fishing Contest and Wotlk Launch, rest is 1)
 };
 
+struct ItemEntry
+{
+    uint32   ID;                                             // 0
+    uint32   Class;                                          // 1
+    uint32   SubClass;                                       // 2 some items have strange subclasses
+    int32    SoundOverrideSubclass;                          // 3
+    int32    Material;                                       // 4
+    uint32   DisplayId;                                      // 5
+    uint32   InventoryType;                                  // 6
+    uint32   Sheath;                                         // 7
+};
+
 struct ItemBagFamilyEntry
 {
     uint32   ID;                                            // 0
@@ -1088,6 +1100,7 @@ struct ItemBagFamilyEntry
 
 struct ItemDisplayInfoEntry
 {
+    /*
     uint32      ID;                                         // 0        m_ID
                                                             // 1        m_modelName[2]
                                                             // 2        m_modelTexture[2]
@@ -1100,6 +1113,32 @@ struct ItemDisplayInfoEntry
                                                             // 9        m_texture[2]
                                                             // 10       m_itemVisual[8]
                                                             // 11       m_particleColorID
+*/
+    uint32 ID;
+    char* Field2;
+    char* Field3;
+    char* Field4;
+    char* Field5;
+    char* inventoryIcon;
+    char* Field7;
+    uint32 Field8;
+    uint32 Field9;
+    uint32 Field10;
+    uint32 Field11;
+    uint32 Field12;
+    uint32 Field13;
+    uint32 Field14;
+    uint32 Field15;
+    char* Field16;
+    char* Field17;
+    char* Field18;
+    char* Field19;
+    char* Field20;
+    char* Field21;
+    char* Field22;
+    char* Field23;
+    uint32 Field24;
+    uint32 Field25;
 };
 
 //struct ItemCondExtCostsEntry
@@ -1655,6 +1694,127 @@ struct SpellEntry
     //uint32  SpellDifficultyId;                            // 233      3.3.0
 };
 
+struct _SpellEntry
+{
+    uint32    Id;                                           // 0        m_ID
+    uint32    Category;                                     // 1        m_category
+    uint32    Dispel;                                       // 2        m_dispelType
+    uint32    Mechanic;                                     // 3        m_mechanic
+    uint32    Attributes;                                   // 4        m_attributes
+    uint32    AttributesEx;                                 // 5        m_attributesEx
+    uint32    AttributesEx2;                                // 6        m_attributesExB
+    uint32    AttributesEx3;                                // 7        m_attributesExC
+    uint32    AttributesEx4;                                // 8        m_attributesExD
+    uint32    AttributesEx5;                                // 9        m_attributesExE
+    uint32    AttributesEx6;                                // 10       m_attributesExF
+    uint32    AttributesEx7;                                // 11       m_attributesExG
+    uint32    Stances;                                      // 12       m_shapeshiftMask
+    uint32	  unk_320_2;                                    // 13       3.2.0
+    uint32    StancesNot;                                   // 14       m_shapeshiftExclude
+    uint32	  unk_320_3;                                    // 15       3.2.0
+    uint32    Targets;                                      // 16       m_targets
+    uint32    TargetCreatureType;                           // 17       m_targetCreatureType
+    uint32    RequiresSpellFocus;                           // 18       m_requiresSpellFocus
+    uint32    FacingCasterFlags;                            // 19       m_facingCasterFlags
+    uint32    CasterAuraState;                              // 20       m_casterAuraState
+    uint32    TargetAuraState;                              // 21       m_targetAuraState
+    uint32    CasterAuraStateNot;                           // 22       m_excludeCasterAuraState
+    uint32    TargetAuraStateNot;                           // 23       m_excludeTargetAuraState
+    uint32    casterAuraSpell;                              // 24       m_casterAuraSpell
+    uint32    targetAuraSpell;                              // 25       m_targetAuraSpell
+    uint32    excludeCasterAuraSpell;                       // 26       m_excludeCasterAuraSpell
+    uint32    excludeTargetAuraSpell;                       // 27       m_excludeTargetAuraSpell
+    uint32    CastingTimeIndex;                             // 28       m_castingTimeIndex
+    uint32    RecoveryTime;                                 // 29       m_recoveryTime
+    uint32    CategoryRecoveryTime;                         // 30       m_categoryRecoveryTime
+    uint32    InterruptFlags;                               // 31       m_interruptFlags
+    uint32    AuraInterruptFlags;                           // 32       m_auraInterruptFlags
+    uint32    ChannelInterruptFlags;                        // 33       m_channelInterruptFlags
+    uint32    procFlags;                                    // 34       m_procTypeMask
+    uint32    procChance;                                   // 35       m_procChance
+    uint32    procCharges;                                  // 36       m_procCharges
+    uint32    maxLevel;                                     // 37       m_maxLevel
+    uint32    baseLevel;                                    // 38       m_baseLevel
+    uint32    spellLevel;                                   // 39       m_spellLevel
+    uint32    DurationIndex;                                // 40       m_durationIndex
+    uint32    powerType;                                    // 41       m_powerType
+    uint32    manaCost;                                     // 42       m_manaCost
+    uint32    manaCostPerlevel;                             // 43       m_manaCostPerLevel
+    uint32    manaPerSecond;                                // 44       m_manaPerSecond
+    uint32    manaPerSecondPerLevel;                        // 45       m_manaPerSecondPerLeve
+    uint32    rangeIndex;                                   // 46       m_rangeIndex
+    float     speed;                                        // 47       m_speed
+    uint32    modalNextSpell;                             // 48       m_modalNextSpell not used
+    uint32    StackAmount;                                  // 49       m_cumulativeAura
+    uint32    Totem[2];                                     // 50-51    m_totem
+    int32     Reagent[MAX_SPELL_REAGENTS];                  // 52-59    m_reagent
+    int32     ReagentCount[MAX_SPELL_REAGENTS];             // 60-67    m_reagentCount
+    int32     EquippedItemClass;                            // 68       m_equippedItemClass (value)
+    int32     EquippedItemSubClassMask;                     // 69       m_equippedItemSubclass (mask)
+    int32     EquippedItemInventoryTypeMask;                // 70       m_equippedItemInvTypes (mask)
+    uint32    Effect[MAX_SPELL_EFFECTS];                    // 71-73    m_effect
+    int32     EffectDieSides[MAX_SPELL_EFFECTS];            // 74-76    m_effectDieSides
+    float     EffectRealPointsPerLevel[MAX_SPELL_EFFECTS];  // 77-79    m_effectRealPointsPerLevel
+    int32     EffectBasePoints[MAX_SPELL_EFFECTS];          // 80-82    m_effectBasePoints (must not be used in spell/auras explicitly, must be used cached Spell::m_currentBasePoints)
+    uint32    EffectMechanic[MAX_SPELL_EFFECTS];            // 83-85    m_effectMechanic
+    uint32    EffectImplicitTargetA[MAX_SPELL_EFFECTS];     // 86-88    m_implicitTargetA
+    uint32    EffectImplicitTargetB[MAX_SPELL_EFFECTS];     // 89-91    m_implicitTargetB
+    uint32    EffectRadiusIndex[MAX_SPELL_EFFECTS];         // 92-94    m_effectRadiusIndex - spellradius.dbc
+    uint32    EffectApplyAuraName[MAX_SPELL_EFFECTS];       // 95-97    m_effectAura
+    uint32    EffectAmplitude[MAX_SPELL_EFFECTS];           // 98-100   m_effectAuraPeriod
+    float     EffectValueMultiplier[MAX_SPELL_EFFECTS];      // 101-103
+    uint32    EffectChainTarget[MAX_SPELL_EFFECTS];         // 104-106  m_effectChainTargets
+    uint32    EffectItemType[MAX_SPELL_EFFECTS];            // 107-109  m_effectItemType
+    int32     EffectMiscValue[MAX_SPELL_EFFECTS];           // 110-112  m_effectMiscValue
+    int32     EffectMiscValueB[MAX_SPELL_EFFECTS];          // 113-115  m_effectMiscValueB
+    int32     EffectTriggerSpell[MAX_SPELL_EFFECTS];        // 116-118  m_effectTriggerSpell
+    float     EffectPointsPerComboPoint[MAX_SPELL_EFFECTS]; // 119-121  m_effectPointsPerCombo
+    flag96    EffectSpellClassMask[MAX_SPELL_EFFECTS];      // 122-130
+    uint32    SpellVisual[2];                               // 131-132  m_spellVisualID
+    uint32    SpellIconID;                                  // 133      m_spellIconID
+    uint32    activeIconID;                                 // 134      m_activeIconID
+    uint32    spellPriority;                              // 135 not used
+    char*     SpellName[16];                                // 136-151  m_name_lang
+    uint32    SpellNameFlag;                              // 152 not used
+    char*     Rank[16];                                     // 153-168  m_nameSubtext_lang
+    uint32    RankFlags;                                  // 169 not used
+    char*     Description[16];                            // 170-185  m_description_lang not used
+    uint32    DescriptionFlags;                           // 186 not used
+    char*     ToolTip[16];                                // 187-202  m_auraDescription_lang not used
+    uint32    ToolTipFlags;                               // 203 not used
+    uint32    ManaCostPercentage;                           // 204      m_manaCostPct
+    uint32    StartRecoveryCategory;                        // 205      m_startRecoveryCategory
+    uint32    StartRecoveryTime;                            // 206      m_startRecoveryTime
+    uint32    MaxTargetLevel;                               // 207      m_maxTargetLevel
+    uint32    SpellFamilyName;                              // 208      m_spellClassSet
+    flag96    SpellFamilyFlags;                             // 209-211
+    uint32    MaxAffectedTargets;                           // 212      m_maxTargets
+    uint32    DmgClass;                                     // 213      m_defenseType
+    uint32    PreventionType;                               // 214      m_preventionType
+    int32     StanceBarOrder;                             // 215      m_stanceBarOrder not used
+    float     EffectDamageMultiplier[MAX_SPELL_EFFECTS];    // 216-218  m_effectChainAmplitude
+    uint32    MinFactionId;                               // 219      m_minFactionID not used
+    uint32    MinReputation;                              // 220      m_minReputation not used
+    uint32    RequiredAuraVision;                         // 221      m_requiredAuraVision not used
+    uint32    TotemCategory[2];                             // 222-223  m_requiredTotemCategoryID
+    int32     AreaGroupId;                                  // 224      m_requiredAreaGroupId
+    uint32    SchoolMask;                                   // 225      m_schoolMask
+    uint32    runeCostID;                                   // 226      m_runeCostID
+    uint32    spellMissileID;                             // 227      m_spellMissileID not used
+    int32	  PowerDisplayId;                               // 228      PowerDisplay.dbc, new in 3.1
+    float     EffectBonusMultiplier[MAX_SPELL_EFFECTS];     // 229-231  3.2.0
+    int32	  spellDescriptionVariableID;                   // 232      3.2.0
+    uint32    SpellDifficultyId;                            // 233      3.3.0
+};
+
+
+struct SpellIconEntry
+{
+    uint32 ID;
+    char* Icon;
+};
+
+
 typedef std::set<uint32> SpellCategorySet;
 typedef std::map<uint32, SpellCategorySet > SpellCategoryStore;
 typedef std::set<uint32> PetFamilySpellsSet;
diff --git a/src/server/shared/DataStores/DBCfmt.h b/src/server/shared/DataStores/DBCfmt.h
index 4e97e84..5268b1c 100644
--- a/src/server/shared/DataStores/DBCfmt.h
+++ b/src/server/shared/DataStores/DBCfmt.h
@@ -1,4 +1,4 @@
-/*
+ï»¿/*
  * Copyright (C) 2016+     AzerothCore <www.azerothcore.org>, released under GNU GPL v2 license: https://github.com/azerothcore/azerothcore-wotlk/blob/master/LICENSE-GPL2
  * Copyright (C) 2008-2020 TrinityCore <http://www.trinitycore.org/>
  * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
@@ -54,8 +54,9 @@ char constexpr GtOCTRegenHPfmt[] = "df";
 char constexpr GtRegenHPPerSptfmt[] = "df";
 char constexpr GtRegenMPPerSptfmt[] = "df";
 char constexpr Holidaysfmt[] = "niiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiixxsiix";
+char const Itemfmt[] = "niiiiiii";
 char constexpr ItemBagFamilyfmt[] = "nxxxxxxxxxxxxxxxxx";
-char constexpr ItemDisplayTemplateEntryfmt[] = "nxxxxsxxxxxxxxxxxxxxxxxxx";
+char constexpr ItemDisplayTemplateEntryfmt[] = "nssssssiiiiiiiissssssssii";
 //char constexpr ItemCondExtCostsEntryfmt[] = "xiii";
 char constexpr ItemExtendedCostEntryfmt[] = "niiiiiiiiiiiiiix";
 char constexpr ItemLimitCategoryEntryfmt[] = "nxxxxxxxxxxxxxxxxxii";
@@ -87,6 +88,12 @@ char constexpr SpellCategoryfmt[] = "ni";
 char constexpr SpellDifficultyfmt[] = "niiii";
 char constexpr SpellDurationfmt[] = "niii";
 char constexpr SpellEntryfmt[] = "niiiiiiiiiiiixixiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiifxiiiiiiiiiiiiiiiiiiiiiiiiiiiifffiiiiiiiiiiiiiiiiiiiiifffiiiiiiiiiiiiiiifffiiiiiiiiiiiiixssssssssssssssssxssssssssssssssssxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxiiiiiiiiiiixfffxxxiiiiixxfffxx";
+
+char const _SpellEntryfmt[] = "niiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiifiiiiiiiiiiiiiiiiiiiiiiiiiiiiifffiiiiiiiiiiiiiiiiiiiiifffiiiiiiiiiiiiiiifffiiiiiiiiiiiiiissssssssssssssssissssssssssssssssissssssssssssssssissssssssssssssssiiiiiiiiiiiiifffiiiiiiiiiifffii";
+char const SpellIconEntryfmt[] = "ns";
+const std::string CustomSpellEntryfmt = "papppppppppppapapaaaaaaaaaaapaaapapppppppaaaaapaapaaaaaaaaaaaaaaaaaappppppppppppppppppppppppppppppppppppaaappppppppppppaaapppppppppaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaappppppppapppaaaaappaaaaaaa";
+const std::string CustomSpellEntryIndex = "Id";
+
 char constexpr SpellFocusObjectfmt[] = "nxxxxxxxxxxxxxxxxx";
 char constexpr SpellItemEnchantmentfmt[] = "niiiiiiixxxiiissssssssssssssssxiiiiiii";
 char constexpr SpellItemEnchantmentConditionfmt[] = "nbbbbbxxxxxbbbbbbbbbbiiiiiXXXXX";
